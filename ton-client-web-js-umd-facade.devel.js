(function webpackUniversalModuleDefinition(root, factory) {
	//This is UMD facade library over https://www.npmjs.com/package/ton-client-web-js to be used inside Dart Web/Flutter Web applications.
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	//This is UMD facade library over https://www.npmjs.com/package/ton-client-web-js to be used inside Dart Web/Flutter Web applications.
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	//This is UMD facade library over https://www.npmjs.com/package/ton-client-web-js to be used inside Dart Web/Flutter Web applications.
	else if(typeof exports === 'object')
		exports["TON Client"] = factory();
	//This is UMD facade library over https://www.npmjs.com/package/ton-client-web-js to be used inside Dart Web/Flutter Web applications.
	else
		root["TON Client"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@wry/context/lib/context.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@wry/context/lib/context.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Slot": () => (/* binding */ Slot),
/* harmony export */   "asyncFromGen": () => (/* binding */ asyncFromGen),
/* harmony export */   "bind": () => (/* binding */ bind),
/* harmony export */   "noContext": () => (/* binding */ noContext),
/* harmony export */   "setTimeout": () => (/* binding */ setTimeoutWithContext),
/* harmony export */   "wrapYieldingFiberMethods": () => (/* binding */ wrapYieldingFiberMethods)
/* harmony export */ });
// This currentContext variable will only be used if the makeSlotClass
// function is called, which happens only if this is the first copy of the
// @wry/context package to be imported.
var currentContext = null;
// This unique internal object is used to denote the absence of a value
// for a given Slot, and is never exposed to outside code.
var MISSING_VALUE = {};
var idCounter = 1;
// Although we can't do anything about the cost of duplicated code from
// accidentally bundling multiple copies of the @wry/context package, we can
// avoid creating the Slot class more than once using makeSlotClass.
var makeSlotClass = function () { return /** @class */ (function () {
    function Slot() {
        // If you have a Slot object, you can find out its slot.id, but you cannot
        // guess the slot.id of a Slot you don't have access to, thanks to the
        // randomized suffix.
        this.id = [
            "slot",
            idCounter++,
            Date.now(),
            Math.random().toString(36).slice(2),
        ].join(":");
    }
    Slot.prototype.hasValue = function () {
        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
            // We use the Slot object iself as a key to its value, which means the
            // value cannot be obtained without a reference to the Slot object.
            if (this.id in context_1.slots) {
                var value = context_1.slots[this.id];
                if (value === MISSING_VALUE)
                    break;
                if (context_1 !== currentContext) {
                    // Cache the value in currentContext.slots so the next lookup will
                    // be faster. This caching is safe because the tree of contexts and
                    // the values of the slots are logically immutable.
                    currentContext.slots[this.id] = value;
                }
                return true;
            }
        }
        if (currentContext) {
            // If a value was not found for this Slot, it's never going to be found
            // no matter how many times we look it up, so we might as well cache
            // the absence of the value, too.
            currentContext.slots[this.id] = MISSING_VALUE;
        }
        return false;
    };
    Slot.prototype.getValue = function () {
        if (this.hasValue()) {
            return currentContext.slots[this.id];
        }
    };
    Slot.prototype.withValue = function (value, callback, 
    // Given the prevalence of arrow functions, specifying arguments is likely
    // to be much more common than specifying `this`, hence this ordering:
    args, thisArg) {
        var _a;
        var slots = (_a = {
                __proto__: null
            },
            _a[this.id] = value,
            _a);
        var parent = currentContext;
        currentContext = { parent: parent, slots: slots };
        try {
            // Function.prototype.apply allows the arguments array argument to be
            // omitted or undefined, so args! is fine here.
            return callback.apply(thisArg, args);
        }
        finally {
            currentContext = parent;
        }
    };
    // Capture the current context and wrap a callback function so that it
    // reestablishes the captured context when called.
    Slot.bind = function (callback) {
        var context = currentContext;
        return function () {
            var saved = currentContext;
            try {
                currentContext = context;
                return callback.apply(this, arguments);
            }
            finally {
                currentContext = saved;
            }
        };
    };
    // Immediately run a callback function without any captured context.
    Slot.noContext = function (callback, 
    // Given the prevalence of arrow functions, specifying arguments is likely
    // to be much more common than specifying `this`, hence this ordering:
    args, thisArg) {
        if (currentContext) {
            var saved = currentContext;
            try {
                currentContext = null;
                // Function.prototype.apply allows the arguments array argument to be
                // omitted or undefined, so args! is fine here.
                return callback.apply(thisArg, args);
            }
            finally {
                currentContext = saved;
            }
        }
        else {
            return callback.apply(thisArg, args);
        }
    };
    return Slot;
}()); };
// We store a single global implementation of the Slot class as a permanent
// non-enumerable symbol property of the Array constructor. This obfuscation
// does nothing to prevent access to the Slot class, but at least it ensures
// the implementation (i.e. currentContext) cannot be tampered with, and all
// copies of the @wry/context package (hopefully just one) will share the
// same Slot implementation. Since the first copy of the @wry/context package
// to be imported wins, this technique imposes a very high cost for any
// future breaking changes to the Slot class.
var globalKey = "@wry/context:Slot";
var host = Array;
var Slot = host[globalKey] || function () {
    var Slot = makeSlotClass();
    try {
        Object.defineProperty(host, globalKey, {
            value: host[globalKey] = Slot,
            enumerable: false,
            writable: false,
            configurable: false,
        });
    }
    finally {
        return Slot;
    }
}();

var bind = Slot.bind, noContext = Slot.noContext;
function setTimeoutWithContext(callback, delay) {
    return setTimeout(bind(callback), delay);
}
// Turn any generator function into an async function (using yield instead
// of await), with context automatically preserved across yields.
function asyncFromGen(genFn) {
    return function () {
        var gen = genFn.apply(this, arguments);
        var boundNext = bind(gen.next);
        var boundThrow = bind(gen.throw);
        return new Promise(function (resolve, reject) {
            function invoke(method, argument) {
                try {
                    var result = method.call(gen, argument);
                }
                catch (error) {
                    return reject(error);
                }
                var next = result.done ? resolve : invokeNext;
                if (isPromiseLike(result.value)) {
                    result.value.then(next, result.done ? reject : invokeThrow);
                }
                else {
                    next(result.value);
                }
            }
            var invokeNext = function (value) { return invoke(boundNext, value); };
            var invokeThrow = function (error) { return invoke(boundThrow, error); };
            invokeNext();
        });
    };
}
function isPromiseLike(value) {
    return value && typeof value.then === "function";
}
// If you use the fibers npm package to implement coroutines in Node.js,
// you should call this function at least once to ensure context management
// remains coherent across any yields.
var wrappedFibers = [];
function wrapYieldingFiberMethods(Fiber) {
    // There can be only one implementation of Fiber per process, so this array
    // should never grow longer than one element.
    if (wrappedFibers.indexOf(Fiber) < 0) {
        var wrap = function (obj, method) {
            var fn = obj[method];
            obj[method] = function () {
                return noContext(fn, arguments, this);
            };
        };
        // These methods can yield, according to
        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100
        wrap(Fiber, "yield");
        wrap(Fiber.prototype, "run");
        wrap(Fiber.prototype, "throwInto");
        wrappedFibers.push(Fiber);
    }
    return Fiber;
}


//# sourceMappingURL=context.esm.js.map


/***/ }),

/***/ "./node_modules/@wry/equality/lib/equality.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@wry/equality/lib/equality.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "equal": () => (/* binding */ equal)
/* harmony export */ });
var _a = Object.prototype, toString = _a.toString, hasOwnProperty = _a.hasOwnProperty;
var previousComparisons = new Map();
/**
 * Performs a deep equality check on two JavaScript values, tolerating cycles.
 */
function equal(a, b) {
    try {
        return check(a, b);
    }
    finally {
        previousComparisons.clear();
    }
}
function check(a, b) {
    // If the two values are strictly equal, our job is easy.
    if (a === b) {
        return true;
    }
    // Object.prototype.toString returns a representation of the runtime type of
    // the given value that is considerably more precise than typeof.
    var aTag = toString.call(a);
    var bTag = toString.call(b);
    // If the runtime types of a and b are different, they could maybe be equal
    // under some interpretation of equality, but for simplicity and performance
    // we just return false instead.
    if (aTag !== bTag) {
        return false;
    }
    switch (aTag) {
        case '[object Array]':
            // Arrays are a lot like other objects, but we can cheaply compare their
            // lengths as a short-cut before comparing their elements.
            if (a.length !== b.length)
                return false;
        // Fall through to object case...
        case '[object Object]': {
            if (previouslyCompared(a, b))
                return true;
            var aKeys = Object.keys(a);
            var bKeys = Object.keys(b);
            // If `a` and `b` have a different number of enumerable keys, they
            // must be different.
            var keyCount = aKeys.length;
            if (keyCount !== bKeys.length)
                return false;
            // Now make sure they have the same keys.
            for (var k = 0; k < keyCount; ++k) {
                if (!hasOwnProperty.call(b, aKeys[k])) {
                    return false;
                }
            }
            // Finally, check deep equality of all child properties.
            for (var k = 0; k < keyCount; ++k) {
                var key = aKeys[k];
                if (!check(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
        case '[object Error]':
            return a.name === b.name && a.message === b.message;
        case '[object Number]':
            // Handle NaN, which is !== itself.
            if (a !== a)
                return b !== b;
        // Fall through to shared +a === +b case...
        case '[object Boolean]':
        case '[object Date]':
            return +a === +b;
        case '[object RegExp]':
        case '[object String]':
            return a == "" + b;
        case '[object Map]':
        case '[object Set]': {
            if (a.size !== b.size)
                return false;
            if (previouslyCompared(a, b))
                return true;
            var aIterator = a.entries();
            var isMap = aTag === '[object Map]';
            while (true) {
                var info = aIterator.next();
                if (info.done)
                    break;
                // If a instanceof Set, aValue === aKey.
                var _a = info.value, aKey = _a[0], aValue = _a[1];
                // So this works the same way for both Set and Map.
                if (!b.has(aKey)) {
                    return false;
                }
                // However, we care about deep equality of values only when dealing
                // with Map structures.
                if (isMap && !check(aValue, b.get(aKey))) {
                    return false;
                }
            }
            return true;
        }
    }
    // Otherwise the values are not equal.
    return false;
}
function previouslyCompared(a, b) {
    // Though cyclic references can make an object graph appear infinite from the
    // perspective of a depth-first traversal, the graph still contains a finite
    // number of distinct object references. We use the previousComparisons cache
    // to avoid comparing the same pair of object references more than once, which
    // guarantees termination (even if we end up comparing every object in one
    // graph to every object in the other graph, which is extremely unlikely),
    // while still allowing weird isomorphic structures (like rings with different
    // lengths) a chance to pass the equality test.
    var bSet = previousComparisons.get(a);
    if (bSet) {
        // Return true here because we can be sure false will be returned somewhere
        // else if the objects are not equivalent.
        if (bSet.has(b))
            return true;
    }
    else {
        previousComparisons.set(a, bSet = new Set);
    }
    bSet.add(b);
    return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (equal);

//# sourceMappingURL=equality.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/bundle.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/bundle.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HeuristicFragmentMatcher": () => (/* binding */ HeuristicFragmentMatcher),
/* harmony export */   "InMemoryCache": () => (/* binding */ InMemoryCache),
/* harmony export */   "IntrospectionFragmentMatcher": () => (/* binding */ IntrospectionFragmentMatcher),
/* harmony export */   "ObjectCache": () => (/* binding */ ObjectCache),
/* harmony export */   "StoreReader": () => (/* binding */ StoreReader),
/* harmony export */   "StoreWriter": () => (/* binding */ StoreWriter),
/* harmony export */   "WriteError": () => (/* binding */ WriteError),
/* harmony export */   "assertIdValue": () => (/* binding */ assertIdValue),
/* harmony export */   "defaultDataIdFromObject": () => (/* binding */ defaultDataIdFromObject),
/* harmony export */   "defaultNormalizedCacheFactory": () => (/* binding */ defaultNormalizedCacheFactory$1),
/* harmony export */   "enhanceErrorWithDocument": () => (/* binding */ enhanceErrorWithDocument)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var apollo_cache__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! apollo-cache */ "./node_modules/apollo-cache/lib/bundle.esm.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/bundle.esm.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/@wry/equality/lib/equality.esm.js");
/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! optimism */ "./node_modules/optimism/lib/bundle.esm.js");
/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ts-invariant */ "./node_modules/ts-invariant/lib/invariant.esm.js");






var haveWarned = false;
function shouldWarn() {
    var answer = !haveWarned;
    if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isTest)()) {
        haveWarned = true;
    }
    return answer;
}
var HeuristicFragmentMatcher = (function () {
    function HeuristicFragmentMatcher() {
    }
    HeuristicFragmentMatcher.prototype.ensureReady = function () {
        return Promise.resolve();
    };
    HeuristicFragmentMatcher.prototype.canBypassInit = function () {
        return true;
    };
    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
        var obj = context.store.get(idValue.id);
        var isRootQuery = idValue.id === 'ROOT_QUERY';
        if (!obj) {
            return isRootQuery;
        }
        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;
        if (!__typename) {
            if (shouldWarn()) {
                 false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
                 false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);
                 false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " +
                    "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
            }
            return 'heuristic';
        }
        if (__typename === typeCondition) {
            return true;
        }
        if (shouldWarn()) {
             false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.error('You are using the simple (heuristic) fragment matcher, but your ' +
                'queries contain union or interface types. Apollo Client will not be ' +
                'able to accurately map fragments. To make this error go away, use ' +
                'the `IntrospectionFragmentMatcher` as described in the docs: ' +
                'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');
        }
        return 'heuristic';
    };
    return HeuristicFragmentMatcher;
}());
var IntrospectionFragmentMatcher = (function () {
    function IntrospectionFragmentMatcher(options) {
        if (options && options.introspectionQueryResultData) {
            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
            this.isReady = true;
        }
        else {
            this.isReady = false;
        }
        this.match = this.match.bind(this);
    }
    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(this.isReady, 'FragmentMatcher.match() was called before FragmentMatcher.init()');
        var obj = context.store.get(idValue.id);
        var isRootQuery = idValue.id === 'ROOT_QUERY';
        if (!obj) {
            return isRootQuery;
        }
        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(__typename, "Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));
        if (__typename === typeCondition) {
            return true;
        }
        var implementingTypes = this.possibleTypesMap[typeCondition];
        if (__typename &&
            implementingTypes &&
            implementingTypes.indexOf(__typename) > -1) {
            return true;
        }
        return false;
    };
    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {
        var typeMap = {};
        introspectionResultData.__schema.types.forEach(function (type) {
            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {
                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });
            }
        });
        return typeMap;
    };
    return IntrospectionFragmentMatcher;
}());

var hasOwn = Object.prototype.hasOwnProperty;
var DepTrackingCache = (function () {
    function DepTrackingCache(data) {
        var _this = this;
        if (data === void 0) { data = Object.create(null); }
        this.data = data;
        this.depend = (0,optimism__WEBPACK_IMPORTED_MODULE_0__.wrap)(function (dataId) { return _this.data[dataId]; }, {
            disposable: true,
            makeCacheKey: function (dataId) {
                return dataId;
            },
        });
    }
    DepTrackingCache.prototype.toObject = function () {
        return this.data;
    };
    DepTrackingCache.prototype.get = function (dataId) {
        this.depend(dataId);
        return this.data[dataId];
    };
    DepTrackingCache.prototype.set = function (dataId, value) {
        var oldValue = this.data[dataId];
        if (value !== oldValue) {
            this.data[dataId] = value;
            this.depend.dirty(dataId);
        }
    };
    DepTrackingCache.prototype.delete = function (dataId) {
        if (hasOwn.call(this.data, dataId)) {
            delete this.data[dataId];
            this.depend.dirty(dataId);
        }
    };
    DepTrackingCache.prototype.clear = function () {
        this.replace(null);
    };
    DepTrackingCache.prototype.replace = function (newData) {
        var _this = this;
        if (newData) {
            Object.keys(newData).forEach(function (dataId) {
                _this.set(dataId, newData[dataId]);
            });
            Object.keys(this.data).forEach(function (dataId) {
                if (!hasOwn.call(newData, dataId)) {
                    _this.delete(dataId);
                }
            });
        }
        else {
            Object.keys(this.data).forEach(function (dataId) {
                _this.delete(dataId);
            });
        }
    };
    return DepTrackingCache;
}());
function defaultNormalizedCacheFactory(seed) {
    return new DepTrackingCache(seed);
}

var StoreReader = (function () {
    function StoreReader(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new optimism__WEBPACK_IMPORTED_MODULE_0__.KeyTrie(apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseWeakMap) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;
        var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;
        this.freezeResults = freezeResults;
        this.executeStoreQuery = (0,optimism__WEBPACK_IMPORTED_MODULE_0__.wrap)(function (options) {
            return executeStoreQuery.call(_this, options);
        }, {
            makeCacheKey: function (_a) {
                var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;
                if (contextValue.store instanceof DepTrackingCache) {
                    return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
                }
            }
        });
        this.executeSelectionSet = (0,optimism__WEBPACK_IMPORTED_MODULE_0__.wrap)(function (options) {
            return executeSelectionSet.call(_this, options);
        }, {
            makeCacheKey: function (_a) {
                var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
                if (execContext.contextValue.store instanceof DepTrackingCache) {
                    return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
                }
            }
        });
        this.executeSubSelectedArray = (0,optimism__WEBPACK_IMPORTED_MODULE_0__.wrap)(function (options) {
            return executeSubSelectedArray.call(_this, options);
        }, {
            makeCacheKey: function (_a) {
                var field = _a.field, array = _a.array, execContext = _a.execContext;
                if (execContext.contextValue.store instanceof DepTrackingCache) {
                    return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));
                }
            }
        });
    }
    StoreReader.prototype.readQueryFromStore = function (options) {
        return this.diffQueryAgainstStore((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), { returnPartialData: false })).result;
    };
    StoreReader.prototype.diffQueryAgainstStore = function (_a) {
        var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;
        var queryDefinition = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getQueryDefinition)(query);
        variables = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.assign)({}, (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getDefaultValues)(queryDefinition), variables);
        var context = {
            store: store,
            dataIdFromObject: config && config.dataIdFromObject,
            cacheRedirects: (config && config.cacheRedirects) || {},
        };
        var execResult = this.executeStoreQuery({
            query: query,
            rootValue: {
                type: 'id',
                id: rootId,
                generated: true,
                typename: 'Query',
            },
            contextValue: context,
            variableValues: variables,
            fragmentMatcher: fragmentMatcherFunction,
        });
        var hasMissingFields = execResult.missing && execResult.missing.length > 0;
        if (hasMissingFields && !returnPartialData) {
            execResult.missing.forEach(function (info) {
                if (info.tolerable)
                    return;
                throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
            });
        }
        if (previousResult) {
            if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.equal)(previousResult, execResult.result)) {
                execResult.result = previousResult;
            }
        }
        return {
            result: execResult.result,
            complete: !hasMissingFields,
        };
    };
    StoreReader.prototype.executeStoreQuery = function (_a) {
        var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
        var mainDefinition = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getMainDefinition)(query);
        var fragments = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getFragmentDefinitions)(query);
        var fragmentMap = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.createFragmentMap)(fragments);
        var execContext = {
            query: query,
            fragmentMap: fragmentMap,
            contextValue: contextValue,
            variableValues: variableValues,
            fragmentMatcher: fragmentMatcher,
        };
        return this.executeSelectionSet({
            selectionSet: mainDefinition.selectionSet,
            rootValue: rootValue,
            execContext: execContext,
        });
    };
    StoreReader.prototype.executeSelectionSet = function (_a) {
        var _this = this;
        var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
        var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;
        var finalResult = { result: null };
        var objectsToMerge = [];
        var object = contextValue.store.get(rootValue.id);
        var typename = (object && object.__typename) ||
            (rootValue.id === 'ROOT_QUERY' && 'Query') ||
            void 0;
        function handleMissing(result) {
            var _a;
            if (result.missing) {
                finalResult.missing = finalResult.missing || [];
                (_a = finalResult.missing).push.apply(_a, result.missing);
            }
            return result.result;
        }
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.shouldInclude)(selection, variables)) {
                return;
            }
            if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isField)(selection)) {
                var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));
                if (typeof fieldResult !== 'undefined') {
                    objectsToMerge.push((_a = {},
                        _a[(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.resultKeyNameFromField)(selection)] = fieldResult,
                        _a));
                }
            }
            else {
                var fragment = void 0;
                if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isInlineFragment)(selection)) {
                    fragment = selection;
                }
                else {
                    fragment = fragmentMap[selection.name.value];
                    if (!fragment) {
                        throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError("No fragment named " + selection.name.value);
                    }
                }
                var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;
                var match = !typeCondition ||
                    execContext.fragmentMatcher(rootValue, typeCondition, contextValue);
                if (match) {
                    var fragmentExecResult = _this.executeSelectionSet({
                        selectionSet: fragment.selectionSet,
                        rootValue: rootValue,
                        execContext: execContext,
                    });
                    if (match === 'heuristic' && fragmentExecResult.missing) {
                        fragmentExecResult = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, fragmentExecResult), { missing: fragmentExecResult.missing.map(function (info) {
                                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, info), { tolerable: true });
                            }) });
                    }
                    objectsToMerge.push(handleMissing(fragmentExecResult));
                }
            }
        });
        finalResult.result = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.mergeDeepArray)(objectsToMerge);
        if (this.freezeResults && "development" !== 'production') {
            Object.freeze(finalResult.result);
        }
        return finalResult;
    };
    StoreReader.prototype.executeField = function (object, typename, field, execContext) {
        var variables = execContext.variableValues, contextValue = execContext.contextValue;
        var fieldName = field.name.value;
        var args = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.argumentsObjectFromField)(field, variables);
        var info = {
            resultKey: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.resultKeyNameFromField)(field),
            directives: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getDirectiveInfoFromField)(field, variables),
        };
        var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);
        if (Array.isArray(readStoreResult.result)) {
            return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({
                field: field,
                array: readStoreResult.result,
                execContext: execContext,
            }));
        }
        if (!field.selectionSet) {
            assertSelectionSetForIdValue(field, readStoreResult.result);
            if (this.freezeResults && "development" !== 'production') {
                (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.maybeDeepFreeze)(readStoreResult);
            }
            return readStoreResult;
        }
        if (readStoreResult.result == null) {
            return readStoreResult;
        }
        return this.combineExecResults(readStoreResult, this.executeSelectionSet({
            selectionSet: field.selectionSet,
            rootValue: readStoreResult.result,
            execContext: execContext,
        }));
    };
    StoreReader.prototype.combineExecResults = function () {
        var execResults = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            execResults[_i] = arguments[_i];
        }
        var missing;
        execResults.forEach(function (execResult) {
            if (execResult.missing) {
                missing = missing || [];
                missing.push.apply(missing, execResult.missing);
            }
        });
        return {
            result: execResults.pop().result,
            missing: missing,
        };
    };
    StoreReader.prototype.executeSubSelectedArray = function (_a) {
        var _this = this;
        var field = _a.field, array = _a.array, execContext = _a.execContext;
        var missing;
        function handleMissing(childResult) {
            if (childResult.missing) {
                missing = missing || [];
                missing.push.apply(missing, childResult.missing);
            }
            return childResult.result;
        }
        array = array.map(function (item) {
            if (item === null) {
                return null;
            }
            if (Array.isArray(item)) {
                return handleMissing(_this.executeSubSelectedArray({
                    field: field,
                    array: item,
                    execContext: execContext,
                }));
            }
            if (field.selectionSet) {
                return handleMissing(_this.executeSelectionSet({
                    selectionSet: field.selectionSet,
                    rootValue: item,
                    execContext: execContext,
                }));
            }
            assertSelectionSetForIdValue(field, item);
            return item;
        });
        if (this.freezeResults && "development" !== 'production') {
            Object.freeze(array);
        }
        return { result: array, missing: missing };
    };
    return StoreReader;
}());
function assertSelectionSetForIdValue(field, value) {
    if (!field.selectionSet && (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isIdValue)(value)) {
        throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError("Missing selection set for object of type " + value.typename + " returned for query field " + field.name.value);
    }
}
function defaultFragmentMatcher() {
    return true;
}
function assertIdValue(idValue) {
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isIdValue)(idValue), "Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.");
}
function readStoreResolver(object, typename, fieldName, args, context, _a) {
    var resultKey = _a.resultKey, directives = _a.directives;
    var storeKeyName = fieldName;
    if (args || directives) {
        storeKeyName = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getStoreKeyName)(storeKeyName, args, directives);
    }
    var fieldValue = void 0;
    if (object) {
        fieldValue = object[storeKeyName];
        if (typeof fieldValue === 'undefined' &&
            context.cacheRedirects &&
            typeof typename === 'string') {
            var type = context.cacheRedirects[typename];
            if (type) {
                var resolver = type[fieldName];
                if (resolver) {
                    fieldValue = resolver(object, args, {
                        getCacheKey: function (storeObj) {
                            var id = context.dataIdFromObject(storeObj);
                            return id && (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.toIdValue)({
                                id: id,
                                typename: storeObj.__typename,
                            });
                        },
                    });
                }
            }
        }
    }
    if (typeof fieldValue === 'undefined') {
        return {
            result: fieldValue,
            missing: [{
                    object: object,
                    fieldName: storeKeyName,
                    tolerable: false,
                }],
        };
    }
    if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isJsonValue)(fieldValue)) {
        fieldValue = fieldValue.json;
    }
    return {
        result: fieldValue,
    };
}

var ObjectCache = (function () {
    function ObjectCache(data) {
        if (data === void 0) { data = Object.create(null); }
        this.data = data;
    }
    ObjectCache.prototype.toObject = function () {
        return this.data;
    };
    ObjectCache.prototype.get = function (dataId) {
        return this.data[dataId];
    };
    ObjectCache.prototype.set = function (dataId, value) {
        this.data[dataId] = value;
    };
    ObjectCache.prototype.delete = function (dataId) {
        this.data[dataId] = void 0;
    };
    ObjectCache.prototype.clear = function () {
        this.data = Object.create(null);
    };
    ObjectCache.prototype.replace = function (newData) {
        this.data = newData || Object.create(null);
    };
    return ObjectCache;
}());
function defaultNormalizedCacheFactory$1(seed) {
    return new ObjectCache(seed);
}

var WriteError = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(WriteError, _super);
    function WriteError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'WriteError';
        return _this;
    }
    return WriteError;
}(Error));
function enhanceErrorWithDocument(error, document) {
    var enhancedError = new WriteError("Error writing result to store for query:\n " + JSON.stringify(document));
    enhancedError.message += '\n' + error.message;
    enhancedError.stack = error.stack;
    return enhancedError;
}
var StoreWriter = (function () {
    function StoreWriter() {
    }
    StoreWriter.prototype.writeQueryToStore = function (_a) {
        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
        return this.writeResultToStore({
            dataId: 'ROOT_QUERY',
            result: result,
            document: query,
            store: store,
            variables: variables,
            dataIdFromObject: dataIdFromObject,
            fragmentMatcherFunction: fragmentMatcherFunction,
        });
    };
    StoreWriter.prototype.writeResultToStore = function (_a) {
        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
        var operationDefinition = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinition)(document);
        try {
            return this.writeSelectionSetToStore({
                result: result,
                dataId: dataId,
                selectionSet: operationDefinition.selectionSet,
                context: {
                    store: store,
                    processedData: {},
                    variables: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.assign)({}, (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getDefaultValues)(operationDefinition), variables),
                    dataIdFromObject: dataIdFromObject,
                    fragmentMap: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.createFragmentMap)((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getFragmentDefinitions)(document)),
                    fragmentMatcherFunction: fragmentMatcherFunction,
                },
            });
        }
        catch (e) {
            throw enhanceErrorWithDocument(e, document);
        }
    };
    StoreWriter.prototype.writeSelectionSetToStore = function (_a) {
        var _this = this;
        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;
        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.shouldInclude)(selection, variables)) {
                return;
            }
            if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isField)(selection)) {
                var resultFieldKey = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.resultKeyNameFromField)(selection);
                var value = result[resultFieldKey];
                if (typeof value !== 'undefined') {
                    _this.writeFieldToStore({
                        dataId: dataId,
                        value: value,
                        field: selection,
                        context: context,
                    });
                }
                else {
                    var isDefered = false;
                    var isClient = false;
                    if (selection.directives && selection.directives.length) {
                        isDefered = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });
                        isClient = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'client'; });
                    }
                    if (!isDefered && !isClient && context.fragmentMatcherFunction) {
                         false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
                    }
                }
            }
            else {
                var fragment = void 0;
                if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isInlineFragment)(selection)) {
                    fragment = selection;
                }
                else {
                    fragment = (fragmentMap || {})[selection.name.value];
                     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(fragment, "No fragment named " + selection.name.value + ".");
                }
                var matches = true;
                if (context.fragmentMatcherFunction && fragment.typeCondition) {
                    var id = dataId || 'self';
                    var idValue = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.toIdValue)({ id: id, typename: undefined });
                    var fakeContext = {
                        store: new ObjectCache((_a = {}, _a[id] = result, _a)),
                        cacheRedirects: {},
                    };
                    var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);
                    if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isProduction)() && match === 'heuristic') {
                         false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.error('WARNING: heuristic fragment matching going on!');
                    }
                    matches = !!match;
                }
                if (matches) {
                    _this.writeSelectionSetToStore({
                        result: result,
                        selectionSet: fragment.selectionSet,
                        dataId: dataId,
                        context: context,
                    });
                }
            }
        });
        return store;
    };
    StoreWriter.prototype.writeFieldToStore = function (_a) {
        var _b;
        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;
        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;
        var storeValue;
        var storeObject;
        var storeFieldName = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.storeKeyNameFromField)(field, variables);
        if (!field.selectionSet || value === null) {
            storeValue =
                value != null && typeof value === 'object'
                    ?
                        { type: 'json', json: value }
                    :
                        value;
        }
        else if (Array.isArray(value)) {
            var generatedId = dataId + "." + storeFieldName;
            storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
        }
        else {
            var valueDataId = dataId + "." + storeFieldName;
            var generated = true;
            if (!isGeneratedId(valueDataId)) {
                valueDataId = '$' + valueDataId;
            }
            if (dataIdFromObject) {
                var semanticId = dataIdFromObject(value);
                 false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the "$" character.');
                if (semanticId ||
                    (typeof semanticId === 'number' && semanticId === 0)) {
                    valueDataId = semanticId;
                    generated = false;
                }
            }
            if (!isDataProcessed(valueDataId, field, context.processedData)) {
                this.writeSelectionSetToStore({
                    dataId: valueDataId,
                    result: value,
                    selectionSet: field.selectionSet,
                    context: context,
                });
            }
            var typename = value.__typename;
            storeValue = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.toIdValue)({ id: valueDataId, typename: typename }, generated);
            storeObject = store.get(dataId);
            var escapedId = storeObject && storeObject[storeFieldName];
            if (escapedId !== storeValue && (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isIdValue)(escapedId)) {
                var hadTypename = escapedId.typename !== undefined;
                var hasTypename = typename !== undefined;
                var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
                 false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!generated || escapedId.generated || typenameChanged, "Store error: the application attempted to write an object with no provided id but the store already contains an id of " + escapedId.id + " for this object. The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
                 false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!hadTypename || hasTypename, "Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
                if (escapedId.generated) {
                    if (typenameChanged) {
                        if (!generated) {
                            store.delete(escapedId.id);
                        }
                    }
                    else {
                        mergeWithGenerated(escapedId.id, storeValue.id, store);
                    }
                }
            }
        }
        storeObject = store.get(dataId);
        if (!storeObject || !(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.equal)(storeValue, storeObject[storeFieldName])) {
            store.set(dataId, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));
        }
    };
    StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {
        var _this = this;
        return value.map(function (item, index) {
            if (item === null) {
                return null;
            }
            var itemDataId = generatedId + "." + index;
            if (Array.isArray(item)) {
                return _this.processArrayValue(item, itemDataId, selectionSet, context);
            }
            var generated = true;
            if (context.dataIdFromObject) {
                var semanticId = context.dataIdFromObject(item);
                if (semanticId) {
                    itemDataId = semanticId;
                    generated = false;
                }
            }
            if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
                _this.writeSelectionSetToStore({
                    dataId: itemDataId,
                    result: item,
                    selectionSet: selectionSet,
                    context: context,
                });
            }
            return (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.toIdValue)({ id: itemDataId, typename: item.__typename }, generated);
        });
    };
    return StoreWriter;
}());
function isGeneratedId(id) {
    return id[0] === '$';
}
function mergeWithGenerated(generatedKey, realKey, cache) {
    if (generatedKey === realKey) {
        return false;
    }
    var generated = cache.get(generatedKey);
    var real = cache.get(realKey);
    var madeChanges = false;
    Object.keys(generated).forEach(function (key) {
        var value = generated[key];
        var realValue = real[key];
        if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isIdValue)(value) &&
            isGeneratedId(value.id) &&
            (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.isIdValue)(realValue) &&
            !(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.equal)(value, realValue) &&
            mergeWithGenerated(value.id, realValue.id, cache)) {
            madeChanges = true;
        }
    });
    cache.delete(generatedKey);
    var newRealValue = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, generated), real);
    if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.equal)(newRealValue, real)) {
        return madeChanges;
    }
    cache.set(realKey, newRealValue);
    return true;
}
function isDataProcessed(dataId, field, processedData) {
    if (!processedData) {
        return false;
    }
    if (processedData[dataId]) {
        if (processedData[dataId].indexOf(field) >= 0) {
            return true;
        }
        else {
            processedData[dataId].push(field);
        }
    }
    else {
        processedData[dataId] = [field];
    }
    return false;
}

var defaultConfig = {
    fragmentMatcher: new HeuristicFragmentMatcher(),
    dataIdFromObject: defaultDataIdFromObject,
    addTypename: true,
    resultCaching: true,
    freezeResults: false,
};
function defaultDataIdFromObject(result) {
    if (result.__typename) {
        if (result.id !== undefined) {
            return result.__typename + ":" + result.id;
        }
        if (result._id !== undefined) {
            return result.__typename + ":" + result._id;
        }
    }
    return null;
}
var hasOwn$1 = Object.prototype.hasOwnProperty;
var OptimisticCacheLayer = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(OptimisticCacheLayer, _super);
    function OptimisticCacheLayer(optimisticId, parent, transaction) {
        var _this = _super.call(this, Object.create(null)) || this;
        _this.optimisticId = optimisticId;
        _this.parent = parent;
        _this.transaction = transaction;
        return _this;
    }
    OptimisticCacheLayer.prototype.toObject = function () {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this.parent.toObject()), this.data);
    };
    OptimisticCacheLayer.prototype.get = function (dataId) {
        return hasOwn$1.call(this.data, dataId)
            ? this.data[dataId]
            : this.parent.get(dataId);
    };
    return OptimisticCacheLayer;
}(ObjectCache));
var InMemoryCache = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(InMemoryCache, _super);
    function InMemoryCache(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this) || this;
        _this.watches = new Set();
        _this.typenameDocumentCache = new Map();
        _this.cacheKeyRoot = new optimism__WEBPACK_IMPORTED_MODULE_0__.KeyTrie(apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseWeakMap);
        _this.silenceBroadcast = false;
        _this.config = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, defaultConfig), config);
        if (_this.config.customResolvers) {
             false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');
            _this.config.cacheRedirects = _this.config.customResolvers;
        }
        if (_this.config.cacheResolvers) {
             false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');
            _this.config.cacheRedirects = _this.config.cacheResolvers;
        }
        _this.addTypename = !!_this.config.addTypename;
        _this.data = _this.config.resultCaching
            ? new DepTrackingCache()
            : new ObjectCache();
        _this.optimisticData = _this.data;
        _this.storeWriter = new StoreWriter();
        _this.storeReader = new StoreReader({
            cacheKeyRoot: _this.cacheKeyRoot,
            freezeResults: config.freezeResults,
        });
        var cache = _this;
        var maybeBroadcastWatch = cache.maybeBroadcastWatch;
        _this.maybeBroadcastWatch = (0,optimism__WEBPACK_IMPORTED_MODULE_0__.wrap)(function (c) {
            return maybeBroadcastWatch.call(_this, c);
        }, {
            makeCacheKey: function (c) {
                if (c.optimistic) {
                    return;
                }
                if (c.previousResult) {
                    return;
                }
                if (cache.data instanceof DepTrackingCache) {
                    return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
                }
            }
        });
        return _this;
    }
    InMemoryCache.prototype.restore = function (data) {
        if (data)
            this.data.replace(data);
        return this;
    };
    InMemoryCache.prototype.extract = function (optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return (optimistic ? this.optimisticData : this.data).toObject();
    };
    InMemoryCache.prototype.read = function (options) {
        if (typeof options.rootId === 'string' &&
            typeof this.data.get(options.rootId) === 'undefined') {
            return null;
        }
        var fragmentMatcher = this.config.fragmentMatcher;
        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
        return this.storeReader.readQueryFromStore({
            store: options.optimistic ? this.optimisticData : this.data,
            query: this.transformDocument(options.query),
            variables: options.variables,
            rootId: options.rootId,
            fragmentMatcherFunction: fragmentMatcherFunction,
            previousResult: options.previousResult,
            config: this.config,
        }) || null;
    };
    InMemoryCache.prototype.write = function (write) {
        var fragmentMatcher = this.config.fragmentMatcher;
        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
        this.storeWriter.writeResultToStore({
            dataId: write.dataId,
            result: write.result,
            variables: write.variables,
            document: this.transformDocument(write.query),
            store: this.data,
            dataIdFromObject: this.config.dataIdFromObject,
            fragmentMatcherFunction: fragmentMatcherFunction,
        });
        this.broadcastWatches();
    };
    InMemoryCache.prototype.diff = function (query) {
        var fragmentMatcher = this.config.fragmentMatcher;
        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
        return this.storeReader.diffQueryAgainstStore({
            store: query.optimistic ? this.optimisticData : this.data,
            query: this.transformDocument(query.query),
            variables: query.variables,
            returnPartialData: query.returnPartialData,
            previousResult: query.previousResult,
            fragmentMatcherFunction: fragmentMatcherFunction,
            config: this.config,
        });
    };
    InMemoryCache.prototype.watch = function (watch) {
        var _this = this;
        this.watches.add(watch);
        return function () {
            _this.watches.delete(watch);
        };
    };
    InMemoryCache.prototype.evict = function (query) {
        throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError("eviction is not implemented on InMemory Cache");
    };
    InMemoryCache.prototype.reset = function () {
        this.data.clear();
        this.broadcastWatches();
        return Promise.resolve();
    };
    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
        var toReapply = [];
        var removedCount = 0;
        var layer = this.optimisticData;
        while (layer instanceof OptimisticCacheLayer) {
            if (layer.optimisticId === idToRemove) {
                ++removedCount;
            }
            else {
                toReapply.push(layer);
            }
            layer = layer.parent;
        }
        if (removedCount > 0) {
            this.optimisticData = layer;
            while (toReapply.length > 0) {
                var layer_1 = toReapply.pop();
                this.performTransaction(layer_1.transaction, layer_1.optimisticId);
            }
            this.broadcastWatches();
        }
    };
    InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {
        var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;
        this.silenceBroadcast = true;
        if (typeof optimisticId === 'string') {
            this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);
        }
        try {
            transaction(this);
        }
        finally {
            this.silenceBroadcast = silenceBroadcast;
            this.data = data;
        }
        this.broadcastWatches();
    };
    InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {
        return this.performTransaction(transaction, id);
    };
    InMemoryCache.prototype.transformDocument = function (document) {
        if (this.addTypename) {
            var result = this.typenameDocumentCache.get(document);
            if (!result) {
                result = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.addTypenameToDocument)(document);
                this.typenameDocumentCache.set(document, result);
                this.typenameDocumentCache.set(result, result);
            }
            return result;
        }
        return document;
    };
    InMemoryCache.prototype.broadcastWatches = function () {
        var _this = this;
        if (!this.silenceBroadcast) {
            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c); });
        }
    };
    InMemoryCache.prototype.maybeBroadcastWatch = function (c) {
        c.callback(this.diff({
            query: c.query,
            variables: c.variables,
            previousResult: c.previousResult && c.previousResult(),
            optimistic: c.optimistic,
        }));
    };
    return InMemoryCache;
}(apollo_cache__WEBPACK_IMPORTED_MODULE_5__.ApolloCache));


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-cache/lib/bundle.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/apollo-cache/lib/bundle.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApolloCache": () => (/* binding */ ApolloCache),
/* harmony export */   "Cache": () => (/* binding */ Cache)
/* harmony export */ });
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/bundle.esm.js");


function queryFromPojo(obj) {
    var op = {
        kind: 'OperationDefinition',
        operation: 'query',
        name: {
            kind: 'Name',
            value: 'GeneratedClientQuery',
        },
        selectionSet: selectionSetFromObj(obj),
    };
    var out = {
        kind: 'Document',
        definitions: [op],
    };
    return out;
}
function fragmentFromPojo(obj, typename) {
    var frag = {
        kind: 'FragmentDefinition',
        typeCondition: {
            kind: 'NamedType',
            name: {
                kind: 'Name',
                value: typename || '__FakeType',
            },
        },
        name: {
            kind: 'Name',
            value: 'GeneratedClientQuery',
        },
        selectionSet: selectionSetFromObj(obj),
    };
    var out = {
        kind: 'Document',
        definitions: [frag],
    };
    return out;
}
function selectionSetFromObj(obj) {
    if (typeof obj === 'number' ||
        typeof obj === 'boolean' ||
        typeof obj === 'string' ||
        typeof obj === 'undefined' ||
        obj === null) {
        return null;
    }
    if (Array.isArray(obj)) {
        return selectionSetFromObj(obj[0]);
    }
    var selections = [];
    Object.keys(obj).forEach(function (key) {
        var nestedSelSet = selectionSetFromObj(obj[key]);
        var field = {
            kind: 'Field',
            name: {
                kind: 'Name',
                value: key,
            },
            selectionSet: nestedSelSet || undefined,
        };
        selections.push(field);
    });
    var selectionSet = {
        kind: 'SelectionSet',
        selections: selections,
    };
    return selectionSet;
}
var justTypenameQuery = {
    kind: 'Document',
    definitions: [
        {
            kind: 'OperationDefinition',
            operation: 'query',
            name: null,
            variableDefinitions: null,
            directives: [],
            selectionSet: {
                kind: 'SelectionSet',
                selections: [
                    {
                        kind: 'Field',
                        alias: null,
                        name: {
                            kind: 'Name',
                            value: '__typename',
                        },
                        arguments: [],
                        directives: [],
                        selectionSet: null,
                    },
                ],
            },
        },
    ],
};

var ApolloCache = (function () {
    function ApolloCache() {
    }
    ApolloCache.prototype.transformDocument = function (document) {
        return document;
    };
    ApolloCache.prototype.transformForLink = function (document) {
        return document;
    };
    ApolloCache.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.read({
            query: options.query,
            variables: options.variables,
            optimistic: optimistic,
        });
    };
    ApolloCache.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.read({
            query: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_0__.getFragmentQueryDocument)(options.fragment, options.fragmentName),
            variables: options.variables,
            rootId: options.id,
            optimistic: optimistic,
        });
    };
    ApolloCache.prototype.writeQuery = function (options) {
        this.write({
            dataId: 'ROOT_QUERY',
            result: options.data,
            query: options.query,
            variables: options.variables,
        });
    };
    ApolloCache.prototype.writeFragment = function (options) {
        this.write({
            dataId: options.id,
            result: options.data,
            variables: options.variables,
            query: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_0__.getFragmentQueryDocument)(options.fragment, options.fragmentName),
        });
    };
    ApolloCache.prototype.writeData = function (_a) {
        var id = _a.id, data = _a.data;
        if (typeof id !== 'undefined') {
            var typenameResult = null;
            try {
                typenameResult = this.read({
                    rootId: id,
                    optimistic: false,
                    query: justTypenameQuery,
                });
            }
            catch (e) {
            }
            var __typename = (typenameResult && typenameResult.__typename) || '__ClientData';
            var dataToWrite = Object.assign({ __typename: __typename }, data);
            this.writeFragment({
                id: id,
                fragment: fragmentFromPojo(dataToWrite, __typename),
                data: dataToWrite,
            });
        }
        else {
            this.writeQuery({ query: queryFromPojo(data), data: data });
        }
    };
    return ApolloCache;
}());

var Cache;
(function (Cache) {
})(Cache || (Cache = {}));


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-client/bundle.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/apollo-client/bundle.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "ApolloClient": () => (/* binding */ ApolloClient),
/* harmony export */   "ApolloError": () => (/* binding */ ApolloError),
/* harmony export */   "FetchType": () => (/* binding */ FetchType),
/* harmony export */   "NetworkStatus": () => (/* binding */ NetworkStatus),
/* harmony export */   "ObservableQuery": () => (/* binding */ ObservableQuery),
/* harmony export */   "isApolloError": () => (/* binding */ isApolloError)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/bundle.esm.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/@wry/equality/lib/equality.esm.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! apollo-link */ "./node_modules/zen-observable-ts/lib/bundle.esm.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/bundle.esm.js");
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");
/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ts-invariant */ "./node_modules/ts-invariant/lib/invariant.esm.js");
/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! graphql/language/visitor */ "./node_modules/graphql/language/visitor.js");







var NetworkStatus;
(function (NetworkStatus) {
    NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
    NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
    NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
    NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
    NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
    NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
    NetworkStatus[NetworkStatus["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
    return networkStatus < 7;
}

var Observable = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Observable, _super);
    function Observable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Observable.prototype[symbol_observable__WEBPACK_IMPORTED_MODULE_0__.default] = function () {
        return this;
    };
    Observable.prototype['@@observable'] = function () {
        return this;
    };
    return Observable;
}(apollo_link__WEBPACK_IMPORTED_MODULE_3__.default));

function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}

function isApolloError(err) {
    return err.hasOwnProperty('graphQLErrors');
}
var generateErrorMessage = function (err) {
    var message = '';
    if (isNonEmptyArray(err.graphQLErrors)) {
        err.graphQLErrors.forEach(function (graphQLError) {
            var errorMessage = graphQLError
                ? graphQLError.message
                : 'Error message not found.';
            message += "GraphQL error: " + errorMessage + "\n";
        });
    }
    if (err.networkError) {
        message += 'Network error: ' + err.networkError.message + '\n';
    }
    message = message.replace(/\n$/, '');
    return message;
};
var ApolloError = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ApolloError, _super);
    function ApolloError(_a) {
        var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.graphQLErrors = graphQLErrors || [];
        _this.networkError = networkError || null;
        if (!errorMessage) {
            _this.message = generateErrorMessage(_this);
        }
        else {
            _this.message = errorMessage;
        }
        _this.extraInfo = extraInfo;
        _this.__proto__ = ApolloError.prototype;
        return _this;
    }
    return ApolloError;
}(Error));

var FetchType;
(function (FetchType) {
    FetchType[FetchType["normal"] = 1] = "normal";
    FetchType[FetchType["refetch"] = 2] = "refetch";
    FetchType[FetchType["poll"] = 3] = "poll";
})(FetchType || (FetchType = {}));

var hasError = function (storeValue, policy) {
    if (policy === void 0) { policy = 'none'; }
    return storeValue && (storeValue.networkError ||
        (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors)));
};
var ObservableQuery = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ObservableQuery, _super);
    function ObservableQuery(_a) {
        var queryManager = _a.queryManager, options = _a.options, _b = _a.shouldSubscribe, shouldSubscribe = _b === void 0 ? true : _b;
        var _this = _super.call(this, function (observer) {
            return _this.onSubscribe(observer);
        }) || this;
        _this.observers = new Set();
        _this.subscriptions = new Set();
        _this.isTornDown = false;
        _this.options = options;
        _this.variables = options.variables || {};
        _this.queryId = queryManager.generateQueryId();
        _this.shouldSubscribe = shouldSubscribe;
        var opDef = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.getOperationDefinition)(options.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        _this.queryManager = queryManager;
        return _this;
    }
    ObservableQuery.prototype.result = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var observer = {
                next: function (result) {
                    resolve(result);
                    _this.observers.delete(observer);
                    if (!_this.observers.size) {
                        _this.queryManager.removeQuery(_this.queryId);
                    }
                    setTimeout(function () {
                        subscription.unsubscribe();
                    }, 0);
                },
                error: reject,
            };
            var subscription = _this.subscribe(observer);
        });
    };
    ObservableQuery.prototype.currentResult = function () {
        var result = this.getCurrentResult();
        if (result.data === undefined) {
            result.data = {};
        }
        return result;
    };
    ObservableQuery.prototype.getCurrentResult = function () {
        if (this.isTornDown) {
            var lastResult = this.lastResult;
            return {
                data: !this.lastError && lastResult && lastResult.data || void 0,
                error: this.lastError,
                loading: false,
                networkStatus: NetworkStatus.error,
            };
        }
        var _a = this.queryManager.getCurrentQueryResult(this), data = _a.data, partial = _a.partial;
        var queryStoreValue = this.queryManager.queryStore.get(this.queryId);
        var result;
        var fetchPolicy = this.options.fetchPolicy;
        var isNetworkFetchPolicy = fetchPolicy === 'network-only' ||
            fetchPolicy === 'no-cache';
        if (queryStoreValue) {
            var networkStatus = queryStoreValue.networkStatus;
            if (hasError(queryStoreValue, this.options.errorPolicy)) {
                return {
                    data: void 0,
                    loading: false,
                    networkStatus: networkStatus,
                    error: new ApolloError({
                        graphQLErrors: queryStoreValue.graphQLErrors,
                        networkError: queryStoreValue.networkError,
                    }),
                };
            }
            if (queryStoreValue.variables) {
                this.options.variables = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options.variables), queryStoreValue.variables);
                this.variables = this.options.variables;
            }
            result = {
                data: data,
                loading: isNetworkRequestInFlight(networkStatus),
                networkStatus: networkStatus,
            };
            if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {
                result.errors = queryStoreValue.graphQLErrors;
            }
        }
        else {
            var loading = isNetworkFetchPolicy ||
                (partial && fetchPolicy !== 'cache-only');
            result = {
                data: data,
                loading: loading,
                networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,
            };
        }
        if (!partial) {
            this.updateLastResult((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, result), { stale: false }));
        }
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, result), { partial: partial });
    };
    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {
        var snapshot = this.lastResultSnapshot;
        return !(snapshot &&
            newResult &&
            snapshot.networkStatus === newResult.networkStatus &&
            snapshot.stale === newResult.stale &&
            (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_5__.equal)(snapshot.data, newResult.data));
    };
    ObservableQuery.prototype.getLastResult = function () {
        return this.lastResult;
    };
    ObservableQuery.prototype.getLastError = function () {
        return this.lastError;
    };
    ObservableQuery.prototype.resetLastResults = function () {
        delete this.lastResult;
        delete this.lastResultSnapshot;
        delete this.lastError;
        this.isTornDown = false;
    };
    ObservableQuery.prototype.resetQueryStoreErrors = function () {
        var queryStore = this.queryManager.queryStore.get(this.queryId);
        if (queryStore) {
            queryStore.networkError = null;
            queryStore.graphQLErrors = [];
        }
    };
    ObservableQuery.prototype.refetch = function (variables) {
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === 'cache-only') {
            return Promise.reject( false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError('cache-only fetchPolicy option should not be used together with query refetch.'));
        }
        if (fetchPolicy !== 'no-cache' &&
            fetchPolicy !== 'cache-and-network') {
            fetchPolicy = 'network-only';
        }
        if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_5__.equal)(this.variables, variables)) {
            this.variables = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.variables), variables);
        }
        if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_5__.equal)(this.options.variables, this.variables)) {
            this.options.variables = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options.variables), this.variables);
        }
        return this.queryManager.fetchQuery(this.queryId, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options), { fetchPolicy: fetchPolicy }), FetchType.refetch);
    };
    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
        var _this = this;
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(fetchMoreOptions.updateQuery, 'updateQuery option is required. This function defines how to update the query data with the new results.');
        var combinedOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, (fetchMoreOptions.query ? fetchMoreOptions : (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options), fetchMoreOptions), { variables: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.variables), fetchMoreOptions.variables) }))), { fetchPolicy: 'network-only' });
        var qid = this.queryManager.generateQueryId();
        return this.queryManager
            .fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId)
            .then(function (fetchMoreResult) {
            _this.updateQuery(function (previousResult) {
                return fetchMoreOptions.updateQuery(previousResult, {
                    fetchMoreResult: fetchMoreResult.data,
                    variables: combinedOptions.variables,
                });
            });
            _this.queryManager.stopQuery(qid);
            return fetchMoreResult;
        }, function (error) {
            _this.queryManager.stopQuery(qid);
            throw error;
        });
    };
    ObservableQuery.prototype.subscribeToMore = function (options) {
        var _this = this;
        var subscription = this.queryManager
            .startGraphQLSubscription({
            query: options.document,
            variables: options.variables,
        })
            .subscribe({
            next: function (subscriptionData) {
                var updateQuery = options.updateQuery;
                if (updateQuery) {
                    _this.updateQuery(function (previous, _a) {
                        var variables = _a.variables;
                        return updateQuery(previous, {
                            subscriptionData: subscriptionData,
                            variables: variables,
                        });
                    });
                }
            },
            error: function (err) {
                if (options.onError) {
                    options.onError(err);
                    return;
                }
                 false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.error('Unhandled GraphQL subscription error', err);
            },
        });
        this.subscriptions.add(subscription);
        return function () {
            if (_this.subscriptions.delete(subscription)) {
                subscription.unsubscribe();
            }
        };
    };
    ObservableQuery.prototype.setOptions = function (opts) {
        var oldFetchPolicy = this.options.fetchPolicy;
        this.options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.options), opts);
        if (opts.pollInterval) {
            this.startPolling(opts.pollInterval);
        }
        else if (opts.pollInterval === 0) {
            this.stopPolling();
        }
        var fetchPolicy = opts.fetchPolicy;
        return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === 'cache-only' ||
            oldFetchPolicy === 'standby' ||
            fetchPolicy === 'network-only'), opts.fetchResults);
    };
    ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {
        if (tryFetch === void 0) { tryFetch = false; }
        if (fetchResults === void 0) { fetchResults = true; }
        this.isTornDown = false;
        variables = variables || this.variables;
        if (!tryFetch && (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_5__.equal)(variables, this.variables)) {
            return this.observers.size && fetchResults
                ? this.result()
                : Promise.resolve();
        }
        this.variables = this.options.variables = variables;
        if (!this.observers.size) {
            return Promise.resolve();
        }
        return this.queryManager.fetchQuery(this.queryId, this.options);
    };
    ObservableQuery.prototype.updateQuery = function (mapFn) {
        var queryManager = this.queryManager;
        var _a = queryManager.getQueryWithPreviousResult(this.queryId), previousResult = _a.previousResult, variables = _a.variables, document = _a.document;
        var newResult = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.tryFunctionOrLogError)(function () {
            return mapFn(previousResult, { variables: variables });
        });
        if (newResult) {
            queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
            queryManager.broadcastQueries();
        }
    };
    ObservableQuery.prototype.stopPolling = function () {
        this.queryManager.stopPollingQuery(this.queryId);
        this.options.pollInterval = undefined;
    };
    ObservableQuery.prototype.startPolling = function (pollInterval) {
        assertNotCacheFirstOrOnly(this);
        this.options.pollInterval = pollInterval;
        this.queryManager.startPollingQuery(this.options, this.queryId);
    };
    ObservableQuery.prototype.updateLastResult = function (newResult) {
        var previousResult = this.lastResult;
        this.lastResult = newResult;
        this.lastResultSnapshot = this.queryManager.assumeImmutableResults
            ? newResult
            : (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.cloneDeep)(newResult);
        return previousResult;
    };
    ObservableQuery.prototype.onSubscribe = function (observer) {
        var _this = this;
        try {
            var subObserver = observer._subscription._observer;
            if (subObserver && !subObserver.error) {
                subObserver.error = defaultSubscriptionObserverErrorCallback;
            }
        }
        catch (_a) { }
        var first = !this.observers.size;
        this.observers.add(observer);
        if (observer.next && this.lastResult)
            observer.next(this.lastResult);
        if (observer.error && this.lastError)
            observer.error(this.lastError);
        if (first) {
            this.setUpQuery();
        }
        return function () {
            if (_this.observers.delete(observer) && !_this.observers.size) {
                _this.tearDownQuery();
            }
        };
    };
    ObservableQuery.prototype.setUpQuery = function () {
        var _this = this;
        var _a = this, queryManager = _a.queryManager, queryId = _a.queryId;
        if (this.shouldSubscribe) {
            queryManager.addObservableQuery(queryId, this);
        }
        if (this.options.pollInterval) {
            assertNotCacheFirstOrOnly(this);
            queryManager.startPollingQuery(this.options, queryId);
        }
        var onError = function (error) {
            _this.updateLastResult((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _this.lastResult), { errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false }));
            iterateObserversSafely(_this.observers, 'error', _this.lastError = error);
        };
        queryManager.observeQuery(queryId, this.options, {
            next: function (result) {
                if (_this.lastError || _this.isDifferentFromLastResult(result)) {
                    var previousResult_1 = _this.updateLastResult(result);
                    var _a = _this.options, query_1 = _a.query, variables = _a.variables, fetchPolicy_1 = _a.fetchPolicy;
                    if (queryManager.transform(query_1).hasClientExports) {
                        queryManager.getLocalState().addExportedVariables(query_1, variables).then(function (variables) {
                            var previousVariables = _this.variables;
                            _this.variables = _this.options.variables = variables;
                            if (!result.loading &&
                                previousResult_1 &&
                                fetchPolicy_1 !== 'cache-only' &&
                                queryManager.transform(query_1).serverQuery &&
                                !(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_5__.equal)(previousVariables, variables)) {
                                _this.refetch();
                            }
                            else {
                                iterateObserversSafely(_this.observers, 'next', result);
                            }
                        });
                    }
                    else {
                        iterateObserversSafely(_this.observers, 'next', result);
                    }
                }
            },
            error: onError,
        }).catch(onError);
    };
    ObservableQuery.prototype.tearDownQuery = function () {
        var queryManager = this.queryManager;
        this.isTornDown = true;
        queryManager.stopPollingQuery(this.queryId);
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        this.subscriptions.clear();
        queryManager.removeObservableQuery(this.queryId);
        queryManager.stopQuery(this.queryId);
        this.observers.clear();
    };
    return ObservableQuery;
}(Observable));
function defaultSubscriptionObserverErrorCallback(error) {
     false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.error('Unhandled error', error.message, error.stack);
}
function iterateObserversSafely(observers, method, argument) {
    var observersWithMethod = [];
    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });
    observersWithMethod.forEach(function (obs) { return obs[method](argument); });
}
function assertNotCacheFirstOrOnly(obsQuery) {
    var fetchPolicy = obsQuery.options.fetchPolicy;
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
}

var MutationStore = (function () {
    function MutationStore() {
        this.store = {};
    }
    MutationStore.prototype.getStore = function () {
        return this.store;
    };
    MutationStore.prototype.get = function (mutationId) {
        return this.store[mutationId];
    };
    MutationStore.prototype.initMutation = function (mutationId, mutation, variables) {
        this.store[mutationId] = {
            mutation: mutation,
            variables: variables || {},
            loading: true,
            error: null,
        };
    };
    MutationStore.prototype.markMutationError = function (mutationId, error) {
        var mutation = this.store[mutationId];
        if (mutation) {
            mutation.loading = false;
            mutation.error = error;
        }
    };
    MutationStore.prototype.markMutationResult = function (mutationId) {
        var mutation = this.store[mutationId];
        if (mutation) {
            mutation.loading = false;
            mutation.error = null;
        }
    };
    MutationStore.prototype.reset = function () {
        this.store = {};
    };
    return MutationStore;
}());

var QueryStore = (function () {
    function QueryStore() {
        this.store = {};
    }
    QueryStore.prototype.getStore = function () {
        return this.store;
    };
    QueryStore.prototype.get = function (queryId) {
        return this.store[queryId];
    };
    QueryStore.prototype.initQuery = function (query) {
        var previousQuery = this.store[query.queryId];
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!previousQuery ||
            previousQuery.document === query.document ||
            (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_5__.equal)(previousQuery.document, query.document), 'Internal Error: may not update existing query string in store');
        var isSetVariables = false;
        var previousVariables = null;
        if (query.storePreviousVariables &&
            previousQuery &&
            previousQuery.networkStatus !== NetworkStatus.loading) {
            if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_5__.equal)(previousQuery.variables, query.variables)) {
                isSetVariables = true;
                previousVariables = previousQuery.variables;
            }
        }
        var networkStatus;
        if (isSetVariables) {
            networkStatus = NetworkStatus.setVariables;
        }
        else if (query.isPoll) {
            networkStatus = NetworkStatus.poll;
        }
        else if (query.isRefetch) {
            networkStatus = NetworkStatus.refetch;
        }
        else {
            networkStatus = NetworkStatus.loading;
        }
        var graphQLErrors = [];
        if (previousQuery && previousQuery.graphQLErrors) {
            graphQLErrors = previousQuery.graphQLErrors;
        }
        this.store[query.queryId] = {
            document: query.document,
            variables: query.variables,
            previousVariables: previousVariables,
            networkError: null,
            graphQLErrors: graphQLErrors,
            networkStatus: networkStatus,
            metadata: query.metadata,
        };
        if (typeof query.fetchMoreForQueryId === 'string' &&
            this.store[query.fetchMoreForQueryId]) {
            this.store[query.fetchMoreForQueryId].networkStatus =
                NetworkStatus.fetchMore;
        }
    };
    QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {
        if (!this.store || !this.store[queryId])
            return;
        this.store[queryId].networkError = null;
        this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];
        this.store[queryId].previousVariables = null;
        this.store[queryId].networkStatus = NetworkStatus.ready;
        if (typeof fetchMoreForQueryId === 'string' &&
            this.store[fetchMoreForQueryId]) {
            this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;
        }
    };
    QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {
        if (!this.store || !this.store[queryId])
            return;
        this.store[queryId].networkError = error;
        this.store[queryId].networkStatus = NetworkStatus.error;
        if (typeof fetchMoreForQueryId === 'string') {
            this.markQueryResultClient(fetchMoreForQueryId, true);
        }
    };
    QueryStore.prototype.markQueryResultClient = function (queryId, complete) {
        var storeValue = this.store && this.store[queryId];
        if (storeValue) {
            storeValue.networkError = null;
            storeValue.previousVariables = null;
            if (complete) {
                storeValue.networkStatus = NetworkStatus.ready;
            }
        }
    };
    QueryStore.prototype.stopQuery = function (queryId) {
        delete this.store[queryId];
    };
    QueryStore.prototype.reset = function (observableQueryIds) {
        var _this = this;
        Object.keys(this.store).forEach(function (queryId) {
            if (observableQueryIds.indexOf(queryId) < 0) {
                _this.stopQuery(queryId);
            }
            else {
                _this.store[queryId].networkStatus = NetworkStatus.loading;
            }
        });
    };
    return QueryStore;
}());

function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

var LocalState = (function () {
    function LocalState(_a) {
        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
        this.cache = cache;
        if (client) {
            this.client = client;
        }
        if (resolvers) {
            this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
            this.setFragmentMatcher(fragmentMatcher);
        }
    }
    LocalState.prototype.addResolvers = function (resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
            resolvers.forEach(function (resolverGroup) {
                _this.resolvers = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.mergeDeep)(_this.resolvers, resolverGroup);
            });
        }
        else {
            this.resolvers = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.mergeDeep)(this.resolvers, resolvers);
        }
    };
    LocalState.prototype.setResolvers = function (resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
    };
    LocalState.prototype.getResolvers = function () {
        return this.resolvers || {};
    };
    LocalState.prototype.runResolvers = function (_a) {
        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_c) {
                if (document) {
                    return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return ((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, remoteResult), { data: localResult.result })); })];
                }
                return [2, remoteResult];
            });
        });
    };
    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
    };
    LocalState.prototype.getFragmentMatcher = function () {
        return this.fragmentMatcher;
    };
    LocalState.prototype.clientQuery = function (document) {
        if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.hasDirectives)(['client'], document)) {
            if (this.resolvers) {
                return document;
            }
             false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn('Found @client directives in a query but no ApolloClient resolvers ' +
                'were specified. This means ApolloClient local resolver handling ' +
                'has been disabled, and @client directives will be passed through ' +
                'to your link chain.');
        }
        return null;
    };
    LocalState.prototype.serverQuery = function (document) {
        return this.resolvers ? (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.removeClientSetsFromDocument)(document) : document;
    };
    LocalState.prototype.prepareContext = function (context) {
        if (context === void 0) { context = {}; }
        var cache = this.cache;
        var newContext = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, context), { cache: cache, getCacheKey: function (obj) {
                if (cache.config) {
                    return cache.config.dataIdFromObject(obj);
                }
                else {
                     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, 'To use context.getCacheKey, you need to use a cache that has ' +
                        'a configurable dataIdFromObject, like apollo-cache-inmemory.');
                }
            } });
        return newContext;
    };
    LocalState.prototype.addExportedVariables = function (document, variables, context) {
        if (variables === void 0) { variables = {}; }
        if (context === void 0) { context = {}; }
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                if (document) {
                    return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return ((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, variables), data.exportedVariables)); })];
                }
                return [2, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, variables)];
            });
        });
    };
    LocalState.prototype.shouldForceResolvers = function (document) {
        var forceResolvers = false;
        (0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_6__.visit)(document, {
            Directive: {
                enter: function (node) {
                    if (node.name.value === 'client' && node.arguments) {
                        forceResolvers = node.arguments.some(function (arg) {
                            return arg.name.value === 'always' &&
                                arg.value.kind === 'BooleanValue' &&
                                arg.value.value === true;
                        });
                        if (forceResolvers) {
                            return graphql_language_visitor__WEBPACK_IMPORTED_MODULE_6__.BREAK;
                        }
                    }
                },
            },
        });
        return forceResolvers;
    };
    LocalState.prototype.buildRootValueFromCache = function (document, variables) {
        return this.cache.diff({
            query: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.buildQueryFromSelectionSet)(document),
            variables: variables,
            returnPartialData: true,
            optimistic: false,
        }).result;
    };
    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        if (context === void 0) { context = {}; }
        if (variables === void 0) { variables = {}; }
        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }
        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_b) {
                mainDefinition = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.getMainDefinition)(document);
                fragments = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.getFragmentDefinitions)(document);
                fragmentMap = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.createFragmentMap)(fragments);
                definitionOperation = mainDefinition
                    .operation;
                defaultOperationType = definitionOperation
                    ? capitalizeFirstLetter(definitionOperation)
                    : 'Query';
                _a = this, cache = _a.cache, client = _a.client;
                execContext = {
                    fragmentMap: fragmentMap,
                    context: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, context), { cache: cache,
                        client: client }),
                    variables: variables,
                    fragmentMatcher: fragmentMatcher,
                    defaultOperationType: defaultOperationType,
                    exportedVariables: {},
                    onlyRunForcedResolvers: onlyRunForcedResolvers,
                };
                return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) { return ({
                        result: result,
                        exportedVariables: execContext.exportedVariables,
                    }); })];
            });
        });
    };
    LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            var fragmentMap, context, variables, resultsToMerge, execute;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
                resultsToMerge = [rootValue];
                execute = function (selection) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function () {
                    var fragment, typeCondition;
                    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                        if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.shouldInclude)(selection, variables)) {
                            return [2];
                        }
                        if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.isField)(selection)) {
                            return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {
                                    var _a;
                                    if (typeof fieldResult !== 'undefined') {
                                        resultsToMerge.push((_a = {},
                                            _a[(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.resultKeyNameFromField)(selection)] = fieldResult,
                                            _a));
                                    }
                                })];
                        }
                        if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.isInlineFragment)(selection)) {
                            fragment = selection;
                        }
                        else {
                            fragment = fragmentMap[selection.name.value];
                             false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(fragment, "No fragment named " + selection.name.value);
                        }
                        if (fragment && fragment.typeCondition) {
                            typeCondition = fragment.typeCondition.name.value;
                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                                return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {
                                        resultsToMerge.push(fragmentResult);
                                    })];
                            }
                        }
                        return [2];
                    });
                }); };
                return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {
                        return (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.mergeDeepArray)(resultsToMerge);
                    })];
            });
        });
    };
    LocalState.prototype.resolveField = function (field, rootValue, execContext) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                variables = execContext.variables;
                fieldName = field.name.value;
                aliasedFieldName = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.resultKeyNameFromField)(field);
                aliasUsed = fieldName !== aliasedFieldName;
                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
                resultPromise = Promise.resolve(defaultResult);
                if (!execContext.onlyRunForcedResolvers ||
                    this.shouldForceResolvers(field)) {
                    resolverType = rootValue.__typename || execContext.defaultOperationType;
                    resolverMap = this.resolvers && this.resolvers[resolverType];
                    if (resolverMap) {
                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                        if (resolve) {
                            resultPromise = Promise.resolve(resolve(rootValue, (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.argumentsObjectFromField)(field, variables), execContext.context, { field: field, fragmentMap: execContext.fragmentMap }));
                        }
                    }
                }
                return [2, resultPromise.then(function (result) {
                        if (result === void 0) { result = defaultResult; }
                        if (field.directives) {
                            field.directives.forEach(function (directive) {
                                if (directive.name.value === 'export' && directive.arguments) {
                                    directive.arguments.forEach(function (arg) {
                                        if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {
                                            execContext.exportedVariables[arg.value.value] = result;
                                        }
                                    });
                                }
                            });
                        }
                        if (!field.selectionSet) {
                            return result;
                        }
                        if (result == null) {
                            return result;
                        }
                        if (Array.isArray(result)) {
                            return _this.resolveSubSelectedArray(field, result, execContext);
                        }
                        if (field.selectionSet) {
                            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
                        }
                    })];
            });
        });
    };
    LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {
        var _this = this;
        return Promise.all(result.map(function (item) {
            if (item === null) {
                return null;
            }
            if (Array.isArray(item)) {
                return _this.resolveSubSelectedArray(field, item, execContext);
            }
            if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, item, execContext);
            }
        }));
    };
    return LocalState;
}());

function multiplex(inner) {
    var observers = new Set();
    var sub = null;
    return new Observable(function (observer) {
        observers.add(observer);
        sub = sub || inner.subscribe({
            next: function (value) {
                observers.forEach(function (obs) { return obs.next && obs.next(value); });
            },
            error: function (error) {
                observers.forEach(function (obs) { return obs.error && obs.error(error); });
            },
            complete: function () {
                observers.forEach(function (obs) { return obs.complete && obs.complete(); });
            },
        });
        return function () {
            if (observers.delete(observer) && !observers.size && sub) {
                sub.unsubscribe();
                sub = null;
            }
        };
    });
}
function asyncMap(observable, mapFn) {
    return new Observable(function (observer) {
        var next = observer.next, error = observer.error, complete = observer.complete;
        var activeNextCount = 0;
        var completed = false;
        var handler = {
            next: function (value) {
                ++activeNextCount;
                new Promise(function (resolve) {
                    resolve(mapFn(value));
                }).then(function (result) {
                    --activeNextCount;
                    next && next.call(observer, result);
                    completed && handler.complete();
                }, function (e) {
                    --activeNextCount;
                    error && error.call(observer, e);
                });
            },
            error: function (e) {
                error && error.call(observer, e);
            },
            complete: function () {
                completed = true;
                if (!activeNextCount) {
                    complete && complete.call(observer);
                }
            },
        };
        var sub = observable.subscribe(handler);
        return function () { return sub.unsubscribe(); };
    });
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var QueryManager = (function () {
    function QueryManager(_a) {
        var link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, store = _a.store, _c = _a.onBroadcast, onBroadcast = _c === void 0 ? function () { return undefined; } : _c, _d = _a.ssrMode, ssrMode = _d === void 0 ? false : _d, _e = _a.clientAwareness, clientAwareness = _e === void 0 ? {} : _e, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
        this.mutationStore = new MutationStore();
        this.queryStore = new QueryStore();
        this.clientAwareness = {};
        this.idCounter = 1;
        this.queries = new Map();
        this.fetchQueryRejectFns = new Map();
        this.transformCache = new (apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.canUseWeakMap ? WeakMap : Map)();
        this.inFlightLinkObservables = new Map();
        this.pollingInfoByQueryId = new Map();
        this.link = link;
        this.queryDeduplication = queryDeduplication;
        this.dataStore = store;
        this.onBroadcast = onBroadcast;
        this.clientAwareness = clientAwareness;
        this.localState = localState || new LocalState({ cache: store.getCache() });
        this.ssrMode = ssrMode;
        this.assumeImmutableResults = !!assumeImmutableResults;
    }
    QueryManager.prototype.stop = function () {
        var _this = this;
        this.queries.forEach(function (_info, queryId) {
            _this.stopQueryNoBroadcast(queryId);
        });
        this.fetchQueryRejectFns.forEach(function (reject) {
            reject( false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError('QueryManager stopped while query was in flight'));
        });
    };
    QueryManager.prototype.mutate = function (_a) {
        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueriesByName = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? 'none' : _d, fetchPolicy = _a.fetchPolicy, _e = _a.context, context = _e === void 0 ? {} : _e;
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            var mutationId, generateUpdateQueriesInfo, self;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_f) {
                switch (_f.label) {
                    case 0:
                         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.');
                         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!fetchPolicy || fetchPolicy === 'no-cache', "Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.");
                        mutationId = this.generateQueryId();
                        mutation = this.transform(mutation).document;
                        this.setQuery(mutationId, function () { return ({ document: mutation }); });
                        variables = this.getVariables(mutation, variables);
                        if (!this.transform(mutation).hasClientExports) return [3, 2];
                        return [4, this.localState.addExportedVariables(mutation, variables, context)];
                    case 1:
                        variables = _f.sent();
                        _f.label = 2;
                    case 2:
                        generateUpdateQueriesInfo = function () {
                            var ret = {};
                            if (updateQueriesByName) {
                                _this.queries.forEach(function (_a, queryId) {
                                    var observableQuery = _a.observableQuery;
                                    if (observableQuery) {
                                        var queryName = observableQuery.queryName;
                                        if (queryName &&
                                            hasOwnProperty.call(updateQueriesByName, queryName)) {
                                            ret[queryId] = {
                                                updater: updateQueriesByName[queryName],
                                                query: _this.queryStore.get(queryId),
                                            };
                                        }
                                    }
                                });
                            }
                            return ret;
                        };
                        this.mutationStore.initMutation(mutationId, mutation, variables);
                        this.dataStore.markMutationInit({
                            mutationId: mutationId,
                            document: mutation,
                            variables: variables,
                            updateQueries: generateUpdateQueriesInfo(),
                            update: updateWithProxyFn,
                            optimisticResponse: optimisticResponse,
                        });
                        this.broadcastQueries();
                        self = this;
                        return [2, new Promise(function (resolve, reject) {
                                var storeResult;
                                var error;
                                self.getObservableFromLink(mutation, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, context), { optimisticResponse: optimisticResponse }), variables, false).subscribe({
                                    next: function (result) {
                                        if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.graphQLResultHasError)(result) && errorPolicy === 'none') {
                                            error = new ApolloError({
                                                graphQLErrors: result.errors,
                                            });
                                            return;
                                        }
                                        self.mutationStore.markMutationResult(mutationId);
                                        if (fetchPolicy !== 'no-cache') {
                                            self.dataStore.markMutationResult({
                                                mutationId: mutationId,
                                                result: result,
                                                document: mutation,
                                                variables: variables,
                                                updateQueries: generateUpdateQueriesInfo(),
                                                update: updateWithProxyFn,
                                            });
                                        }
                                        storeResult = result;
                                    },
                                    error: function (err) {
                                        self.mutationStore.markMutationError(mutationId, err);
                                        self.dataStore.markMutationComplete({
                                            mutationId: mutationId,
                                            optimisticResponse: optimisticResponse,
                                        });
                                        self.broadcastQueries();
                                        self.setQuery(mutationId, function () { return ({ document: null }); });
                                        reject(new ApolloError({
                                            networkError: err,
                                        }));
                                    },
                                    complete: function () {
                                        if (error) {
                                            self.mutationStore.markMutationError(mutationId, error);
                                        }
                                        self.dataStore.markMutationComplete({
                                            mutationId: mutationId,
                                            optimisticResponse: optimisticResponse,
                                        });
                                        self.broadcastQueries();
                                        if (error) {
                                            reject(error);
                                            return;
                                        }
                                        if (typeof refetchQueries === 'function') {
                                            refetchQueries = refetchQueries(storeResult);
                                        }
                                        var refetchQueryPromises = [];
                                        if (isNonEmptyArray(refetchQueries)) {
                                            refetchQueries.forEach(function (refetchQuery) {
                                                if (typeof refetchQuery === 'string') {
                                                    self.queries.forEach(function (_a) {
                                                        var observableQuery = _a.observableQuery;
                                                        if (observableQuery &&
                                                            observableQuery.queryName === refetchQuery) {
                                                            refetchQueryPromises.push(observableQuery.refetch());
                                                        }
                                                    });
                                                }
                                                else {
                                                    var queryOptions = {
                                                        query: refetchQuery.query,
                                                        variables: refetchQuery.variables,
                                                        fetchPolicy: 'network-only',
                                                    };
                                                    if (refetchQuery.context) {
                                                        queryOptions.context = refetchQuery.context;
                                                    }
                                                    refetchQueryPromises.push(self.query(queryOptions));
                                                }
                                            });
                                        }
                                        Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {
                                            self.setQuery(mutationId, function () { return ({ document: null }); });
                                            if (errorPolicy === 'ignore' &&
                                                storeResult &&
                                                (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.graphQLResultHasError)(storeResult)) {
                                                delete storeResult.errors;
                                            }
                                            resolve(storeResult);
                                        });
                                    },
                                });
                            })];
                }
            });
        });
    };
    QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result, shouldFetch, requestId, cancel, networkResult;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? 'cache-first' : _b, _c = options.context, context = _c === void 0 ? {} : _c;
                        query = this.transform(options.query).document;
                        variables = this.getVariables(query, options.variables);
                        if (!this.transform(query).hasClientExports) return [3, 2];
                        return [4, this.localState.addExportedVariables(query, variables, context)];
                    case 1:
                        variables = _e.sent();
                        _e.label = 2;
                    case 2:
                        options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), { variables: variables });
                        isNetworkOnly = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';
                        needToFetch = isNetworkOnly;
                        if (!isNetworkOnly) {
                            _d = this.dataStore.getCache().diff({
                                query: query,
                                variables: variables,
                                returnPartialData: true,
                                optimistic: false,
                            }), complete = _d.complete, result = _d.result;
                            needToFetch = !complete || fetchPolicy === 'cache-and-network';
                            storeResult = result;
                        }
                        shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';
                        if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.hasDirectives)(['live'], query))
                            shouldFetch = true;
                        requestId = this.idCounter++;
                        cancel = fetchPolicy !== 'no-cache'
                            ? this.updateQueryWatch(queryId, query, options)
                            : undefined;
                        this.setQuery(queryId, function () { return ({
                            document: query,
                            lastRequestId: requestId,
                            invalidated: true,
                            cancel: cancel,
                        }); });
                        this.invalidate(fetchMoreForQueryId);
                        this.queryStore.initQuery({
                            queryId: queryId,
                            document: query,
                            storePreviousVariables: shouldFetch,
                            variables: variables,
                            isPoll: fetchType === FetchType.poll,
                            isRefetch: fetchType === FetchType.refetch,
                            metadata: metadata,
                            fetchMoreForQueryId: fetchMoreForQueryId,
                        });
                        this.broadcastQueries();
                        if (shouldFetch) {
                            networkResult = this.fetchRequest({
                                requestId: requestId,
                                queryId: queryId,
                                document: query,
                                options: options,
                                fetchMoreForQueryId: fetchMoreForQueryId,
                            }).catch(function (error) {
                                if (isApolloError(error)) {
                                    throw error;
                                }
                                else {
                                    if (requestId >= _this.getQuery(queryId).lastRequestId) {
                                        _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);
                                        _this.invalidate(queryId);
                                        _this.invalidate(fetchMoreForQueryId);
                                        _this.broadcastQueries();
                                    }
                                    throw new ApolloError({ networkError: error });
                                }
                            });
                            if (fetchPolicy !== 'cache-and-network') {
                                return [2, networkResult];
                            }
                            networkResult.catch(function () { });
                        }
                        this.queryStore.markQueryResultClient(queryId, !shouldFetch);
                        this.invalidate(queryId);
                        this.invalidate(fetchMoreForQueryId);
                        if (this.transform(query).hasForcedResolvers) {
                            return [2, this.localState.runResolvers({
                                    document: query,
                                    remoteResult: { data: storeResult },
                                    context: context,
                                    variables: variables,
                                    onlyRunForcedResolvers: true,
                                }).then(function (result) {
                                    _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);
                                    _this.broadcastQueries();
                                    return result;
                                })];
                        }
                        this.broadcastQueries();
                        return [2, { data: storeResult }];
                }
            });
        });
    };
    QueryManager.prototype.markQueryResult = function (queryId, result, _a, fetchMoreForQueryId) {
        var fetchPolicy = _a.fetchPolicy, variables = _a.variables, errorPolicy = _a.errorPolicy;
        if (fetchPolicy === 'no-cache') {
            this.setQuery(queryId, function () { return ({
                newData: { result: result.data, complete: true },
            }); });
        }
        else {
            this.dataStore.markQueryResult(result, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');
        }
    };
    QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {
        var _this = this;
        function invoke(method, argument) {
            if (observer[method]) {
                try {
                    observer[method](argument);
                }
                catch (e) {
                     false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.error(e);
                }
            }
            else if (method === 'error') {
                 false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.error(argument);
            }
        }
        return function (queryStoreValue, newData) {
            _this.invalidate(queryId, false);
            if (!queryStoreValue)
                return;
            var _a = _this.getQuery(queryId), observableQuery = _a.observableQuery, document = _a.document;
            var fetchPolicy = observableQuery
                ? observableQuery.options.fetchPolicy
                : options.fetchPolicy;
            if (fetchPolicy === 'standby')
                return;
            var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);
            var lastResult = observableQuery && observableQuery.getLastResult();
            var networkStatusChanged = !!(lastResult &&
                lastResult.networkStatus !== queryStoreValue.networkStatus);
            var shouldNotifyIfLoading = options.returnPartialData ||
                (!newData && queryStoreValue.previousVariables) ||
                (networkStatusChanged && options.notifyOnNetworkStatusChange) ||
                fetchPolicy === 'cache-only' ||
                fetchPolicy === 'cache-and-network';
            if (loading && !shouldNotifyIfLoading) {
                return;
            }
            var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);
            var errorPolicy = observableQuery
                && observableQuery.options.errorPolicy
                || options.errorPolicy
                || 'none';
            if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {
                return invoke('error', new ApolloError({
                    graphQLErrors: queryStoreValue.graphQLErrors,
                    networkError: queryStoreValue.networkError,
                }));
            }
            try {
                var data = void 0;
                var isMissing = void 0;
                if (newData) {
                    if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {
                        _this.setQuery(queryId, function () { return ({ newData: null }); });
                    }
                    data = newData.result;
                    isMissing = !newData.complete;
                }
                else {
                    var lastError = observableQuery && observableQuery.getLastError();
                    var errorStatusChanged = errorPolicy !== 'none' &&
                        (lastError && lastError.graphQLErrors) !==
                            queryStoreValue.graphQLErrors;
                    if (lastResult && lastResult.data && !errorStatusChanged) {
                        data = lastResult.data;
                        isMissing = false;
                    }
                    else {
                        var diffResult = _this.dataStore.getCache().diff({
                            query: document,
                            variables: queryStoreValue.previousVariables ||
                                queryStoreValue.variables,
                            returnPartialData: true,
                            optimistic: true,
                        });
                        data = diffResult.result;
                        isMissing = !diffResult.complete;
                    }
                }
                var stale = isMissing && !(options.returnPartialData ||
                    fetchPolicy === 'cache-only');
                var resultFromStore = {
                    data: stale ? lastResult && lastResult.data : data,
                    loading: loading,
                    networkStatus: queryStoreValue.networkStatus,
                    stale: stale,
                };
                if (errorPolicy === 'all' && hasGraphQLErrors) {
                    resultFromStore.errors = queryStoreValue.graphQLErrors;
                }
                invoke('next', resultFromStore);
            }
            catch (networkError) {
                invoke('error', new ApolloError({ networkError: networkError }));
            }
        };
    };
    QueryManager.prototype.transform = function (document) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document)) {
            var cache = this.dataStore.getCache();
            var transformed = cache.transformDocument(document);
            var forLink = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.removeConnectionDirectiveFromDocument)(cache.transformForLink(transformed));
            var clientQuery = this.localState.clientQuery(transformed);
            var serverQuery = this.localState.serverQuery(forLink);
            var cacheEntry_1 = {
                document: transformed,
                hasClientExports: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.hasClientExports)(transformed),
                hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
                clientQuery: clientQuery,
                serverQuery: serverQuery,
                defaultVars: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.getDefaultValues)((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.getOperationDefinition)(transformed)),
            };
            var add = function (doc) {
                if (doc && !transformCache.has(doc)) {
                    transformCache.set(doc, cacheEntry_1);
                }
            };
            add(document);
            add(transformed);
            add(clientQuery);
            add(serverQuery);
        }
        return transformCache.get(document);
    };
    QueryManager.prototype.getVariables = function (document, variables) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.transform(document).defaultVars), variables);
    };
    QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {
        if (shouldSubscribe === void 0) { shouldSubscribe = true; }
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(options.fetchPolicy !== 'standby', 'client.watchQuery cannot be called with fetchPolicy set to "standby"');
        options.variables = this.getVariables(options.query, options.variables);
        if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
            options.notifyOnNetworkStatusChange = false;
        }
        var transformedOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options);
        return new ObservableQuery({
            queryManager: this,
            options: transformedOptions,
            shouldSubscribe: shouldSubscribe,
        });
    };
    QueryManager.prototype.query = function (options) {
        var _this = this;
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(options.query, 'query option is required. You must specify your GraphQL document ' +
            'in the query option.');
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(options.query.kind === 'Document', 'You must wrap the query string in a "gql" tag.');
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.');
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!options.pollInterval, 'pollInterval option only supported on watchQuery.');
        return new Promise(function (resolve, reject) {
            var watchedQuery = _this.watchQuery(options, false);
            _this.fetchQueryRejectFns.set("query:" + watchedQuery.queryId, reject);
            watchedQuery
                .result()
                .then(resolve, reject)
                .then(function () {
                return _this.fetchQueryRejectFns.delete("query:" + watchedQuery.queryId);
            });
        });
    };
    QueryManager.prototype.generateQueryId = function () {
        return String(this.idCounter++);
    };
    QueryManager.prototype.stopQueryInStore = function (queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
    };
    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {
        this.stopPollingQuery(queryId);
        this.queryStore.stopQuery(queryId);
        this.invalidate(queryId);
    };
    QueryManager.prototype.addQueryListener = function (queryId, listener) {
        this.setQuery(queryId, function (_a) {
            var listeners = _a.listeners;
            listeners.add(listener);
            return { invalidated: false };
        });
    };
    QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {
        var _this = this;
        var cancel = this.getQuery(queryId).cancel;
        if (cancel)
            cancel();
        var previousResult = function () {
            var previousResult = null;
            var observableQuery = _this.getQuery(queryId).observableQuery;
            if (observableQuery) {
                var lastResult = observableQuery.getLastResult();
                if (lastResult) {
                    previousResult = lastResult.data;
                }
            }
            return previousResult;
        };
        return this.dataStore.getCache().watch({
            query: document,
            variables: options.variables,
            optimistic: true,
            previousResult: previousResult,
            callback: function (newData) {
                _this.setQuery(queryId, function () { return ({ invalidated: true, newData: newData }); });
            },
        });
    };
    QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {
        this.setQuery(queryId, function () { return ({ observableQuery: observableQuery }); });
    };
    QueryManager.prototype.removeObservableQuery = function (queryId) {
        var cancel = this.getQuery(queryId).cancel;
        this.setQuery(queryId, function () { return ({ observableQuery: null }); });
        if (cancel)
            cancel();
    };
    QueryManager.prototype.clearStore = function () {
        this.fetchQueryRejectFns.forEach(function (reject) {
            reject( false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError('Store reset while query was in flight (not completed in link chain)'));
        });
        var resetIds = [];
        this.queries.forEach(function (_a, queryId) {
            var observableQuery = _a.observableQuery;
            if (observableQuery)
                resetIds.push(queryId);
        });
        this.queryStore.reset(resetIds);
        this.mutationStore.reset();
        return this.dataStore.reset();
    };
    QueryManager.prototype.resetStore = function () {
        var _this = this;
        return this.clearStore().then(function () {
            return _this.reFetchObservableQueries();
        });
    };
    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
        var _this = this;
        if (includeStandby === void 0) { includeStandby = false; }
        var observableQueryPromises = [];
        this.queries.forEach(function (_a, queryId) {
            var observableQuery = _a.observableQuery;
            if (observableQuery) {
                var fetchPolicy = observableQuery.options.fetchPolicy;
                observableQuery.resetLastResults();
                if (fetchPolicy !== 'cache-only' &&
                    (includeStandby || fetchPolicy !== 'standby')) {
                    observableQueryPromises.push(observableQuery.refetch());
                }
                _this.setQuery(queryId, function () { return ({ newData: null }); });
                _this.invalidate(queryId);
            }
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
    };
    QueryManager.prototype.observeQuery = function (queryId, options, observer) {
        this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));
        return this.fetchQuery(queryId, options);
    };
    QueryManager.prototype.startQuery = function (queryId, options, listener) {
         false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn("The QueryManager.startQuery method has been deprecated");
        this.addQueryListener(queryId, listener);
        this.fetchQuery(queryId, options)
            .catch(function () { return undefined; });
        return queryId;
    };
    QueryManager.prototype.startGraphQLSubscription = function (_a) {
        var _this = this;
        var query = _a.query, fetchPolicy = _a.fetchPolicy, variables = _a.variables;
        query = this.transform(query).document;
        variables = this.getVariables(query, variables);
        var makeObservable = function (variables) {
            return _this.getObservableFromLink(query, {}, variables, false).map(function (result) {
                if (!fetchPolicy || fetchPolicy !== 'no-cache') {
                    _this.dataStore.markSubscriptionResult(result, query, variables);
                    _this.broadcastQueries();
                }
                if ((0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.graphQLResultHasError)(result)) {
                    throw new ApolloError({
                        graphQLErrors: result.errors,
                    });
                }
                return result;
            });
        };
        if (this.transform(query).hasClientExports) {
            var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);
            return new Observable(function (observer) {
                var sub = null;
                observablePromise_1.then(function (observable) { return sub = observable.subscribe(observer); }, observer.error);
                return function () { return sub && sub.unsubscribe(); };
            });
        }
        return makeObservable(variables);
    };
    QueryManager.prototype.stopQuery = function (queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
    };
    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
    };
    QueryManager.prototype.removeQuery = function (queryId) {
        this.fetchQueryRejectFns.delete("query:" + queryId);
        this.fetchQueryRejectFns.delete("fetchRequest:" + queryId);
        this.getQuery(queryId).subscriptions.forEach(function (x) { return x.unsubscribe(); });
        this.queries.delete(queryId);
    };
    QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {
        if (optimistic === void 0) { optimistic = true; }
        var _a = observableQuery.options, variables = _a.variables, query = _a.query, fetchPolicy = _a.fetchPolicy, returnPartialData = _a.returnPartialData;
        var lastResult = observableQuery.getLastResult();
        var newData = this.getQuery(observableQuery.queryId).newData;
        if (newData && newData.complete) {
            return { data: newData.result, partial: false };
        }
        if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {
            return { data: undefined, partial: false };
        }
        var _b = this.dataStore.getCache().diff({
            query: query,
            variables: variables,
            previousResult: lastResult ? lastResult.data : undefined,
            returnPartialData: true,
            optimistic: optimistic,
        }), result = _b.result, complete = _b.complete;
        return {
            data: (complete || returnPartialData) ? result : void 0,
            partial: !complete,
        };
    };
    QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {
        var observableQuery;
        if (typeof queryIdOrObservable === 'string') {
            var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;
             false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(foundObserveableQuery, "ObservableQuery with this id doesn't exist: " + queryIdOrObservable);
            observableQuery = foundObserveableQuery;
        }
        else {
            observableQuery = queryIdOrObservable;
        }
        var _a = observableQuery.options, variables = _a.variables, query = _a.query;
        return {
            previousResult: this.getCurrentQueryResult(observableQuery, false).data,
            variables: variables,
            document: query,
        };
    };
    QueryManager.prototype.broadcastQueries = function () {
        var _this = this;
        this.onBroadcast();
        this.queries.forEach(function (info, id) {
            if (info.invalidated) {
                info.listeners.forEach(function (listener) {
                    if (listener) {
                        listener(_this.queryStore.get(id), info.newData);
                    }
                });
            }
        });
    };
    QueryManager.prototype.getLocalState = function () {
        return this.localState;
    };
    QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {
        var _this = this;
        if (deduplication === void 0) { deduplication = this.queryDeduplication; }
        var observable;
        var serverQuery = this.transform(query).serverQuery;
        if (serverQuery) {
            var _a = this, inFlightLinkObservables_1 = _a.inFlightLinkObservables, link = _a.link;
            var operation = {
                query: serverQuery,
                variables: variables,
                operationName: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.getOperationName)(serverQuery) || void 0,
                context: this.prepareContext((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, context), { forceFetch: !deduplication })),
            };
            context = operation.context;
            if (deduplication) {
                var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
                inFlightLinkObservables_1.set(serverQuery, byVariables_1);
                var varJson_1 = JSON.stringify(variables);
                observable = byVariables_1.get(varJson_1);
                if (!observable) {
                    byVariables_1.set(varJson_1, observable = multiplex((0,apollo_link__WEBPACK_IMPORTED_MODULE_7__.execute)(link, operation)));
                    var cleanup = function () {
                        byVariables_1.delete(varJson_1);
                        if (!byVariables_1.size)
                            inFlightLinkObservables_1.delete(serverQuery);
                        cleanupSub_1.unsubscribe();
                    };
                    var cleanupSub_1 = observable.subscribe({
                        next: cleanup,
                        error: cleanup,
                        complete: cleanup,
                    });
                }
            }
            else {
                observable = multiplex((0,apollo_link__WEBPACK_IMPORTED_MODULE_7__.execute)(link, operation));
            }
        }
        else {
            observable = Observable.of({ data: {} });
            context = this.prepareContext(context);
        }
        var clientQuery = this.transform(query).clientQuery;
        if (clientQuery) {
            observable = asyncMap(observable, function (result) {
                return _this.localState.runResolvers({
                    document: clientQuery,
                    remoteResult: result,
                    context: context,
                    variables: variables,
                });
            });
        }
        return observable;
    };
    QueryManager.prototype.fetchRequest = function (_a) {
        var _this = this;
        var requestId = _a.requestId, queryId = _a.queryId, document = _a.document, options = _a.options, fetchMoreForQueryId = _a.fetchMoreForQueryId;
        var variables = options.variables, _b = options.errorPolicy, errorPolicy = _b === void 0 ? 'none' : _b, fetchPolicy = options.fetchPolicy;
        var resultFromStore;
        var errorsFromStore;
        return new Promise(function (resolve, reject) {
            var observable = _this.getObservableFromLink(document, options.context, variables);
            var fqrfId = "fetchRequest:" + queryId;
            _this.fetchQueryRejectFns.set(fqrfId, reject);
            var cleanup = function () {
                _this.fetchQueryRejectFns.delete(fqrfId);
                _this.setQuery(queryId, function (_a) {
                    var subscriptions = _a.subscriptions;
                    subscriptions.delete(subscription);
                });
            };
            var subscription = observable.map(function (result) {
                if (requestId >= _this.getQuery(queryId).lastRequestId) {
                    _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);
                    _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);
                    _this.invalidate(queryId);
                    _this.invalidate(fetchMoreForQueryId);
                    _this.broadcastQueries();
                }
                if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {
                    return reject(new ApolloError({
                        graphQLErrors: result.errors,
                    }));
                }
                if (errorPolicy === 'all') {
                    errorsFromStore = result.errors;
                }
                if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {
                    resultFromStore = result.data;
                }
                else {
                    var _a = _this.dataStore.getCache().diff({
                        variables: variables,
                        query: document,
                        optimistic: false,
                        returnPartialData: true,
                    }), result_1 = _a.result, complete = _a.complete;
                    if (complete || options.returnPartialData) {
                        resultFromStore = result_1;
                    }
                }
            }).subscribe({
                error: function (error) {
                    cleanup();
                    reject(error);
                },
                complete: function () {
                    cleanup();
                    resolve({
                        data: resultFromStore,
                        errors: errorsFromStore,
                        loading: false,
                        networkStatus: NetworkStatus.ready,
                        stale: false,
                    });
                },
            });
            _this.setQuery(queryId, function (_a) {
                var subscriptions = _a.subscriptions;
                subscriptions.add(subscription);
            });
        });
    };
    QueryManager.prototype.getQuery = function (queryId) {
        return (this.queries.get(queryId) || {
            listeners: new Set(),
            invalidated: false,
            document: null,
            newData: null,
            lastRequestId: 1,
            observableQuery: null,
            subscriptions: new Set(),
        });
    };
    QueryManager.prototype.setQuery = function (queryId, updater) {
        var prev = this.getQuery(queryId);
        var newInfo = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, prev), updater(prev));
        this.queries.set(queryId, newInfo);
    };
    QueryManager.prototype.invalidate = function (queryId, invalidated) {
        if (invalidated === void 0) { invalidated = true; }
        if (queryId) {
            this.setQuery(queryId, function () { return ({ invalidated: invalidated }); });
        }
    };
    QueryManager.prototype.prepareContext = function (context) {
        if (context === void 0) { context = {}; }
        var newContext = this.localState.prepareContext(context);
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, newContext), { clientAwareness: this.clientAwareness });
    };
    QueryManager.prototype.checkInFlight = function (queryId) {
        var query = this.queryStore.get(queryId);
        return (query &&
            query.networkStatus !== NetworkStatus.ready &&
            query.networkStatus !== NetworkStatus.error);
    };
    QueryManager.prototype.startPollingQuery = function (options, queryId, listener) {
        var _this = this;
        var pollInterval = options.pollInterval;
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(pollInterval, 'Attempted to start a polling query without a polling interval.');
        if (!this.ssrMode) {
            var info = this.pollingInfoByQueryId.get(queryId);
            if (!info) {
                this.pollingInfoByQueryId.set(queryId, (info = {}));
            }
            info.interval = pollInterval;
            info.options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), { fetchPolicy: 'network-only' });
            var maybeFetch_1 = function () {
                var info = _this.pollingInfoByQueryId.get(queryId);
                if (info) {
                    if (_this.checkInFlight(queryId)) {
                        poll_1();
                    }
                    else {
                        _this.fetchQuery(queryId, info.options, FetchType.poll).then(poll_1, poll_1);
                    }
                }
            };
            var poll_1 = function () {
                var info = _this.pollingInfoByQueryId.get(queryId);
                if (info) {
                    clearTimeout(info.timeout);
                    info.timeout = setTimeout(maybeFetch_1, info.interval);
                }
            };
            if (listener) {
                this.addQueryListener(queryId, listener);
            }
            poll_1();
        }
        return queryId;
    };
    QueryManager.prototype.stopPollingQuery = function (queryId) {
        this.pollingInfoByQueryId.delete(queryId);
    };
    return QueryManager;
}());

var DataStore = (function () {
    function DataStore(initialCache) {
        this.cache = initialCache;
    }
    DataStore.prototype.getCache = function () {
        return this.cache;
    };
    DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {
        if (ignoreErrors === void 0) { ignoreErrors = false; }
        var writeWithErrors = !(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.graphQLResultHasError)(result);
        if (ignoreErrors && (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.graphQLResultHasError)(result) && result.data) {
            writeWithErrors = true;
        }
        if (!fetchMoreForQueryId && writeWithErrors) {
            this.cache.write({
                result: result.data,
                dataId: 'ROOT_QUERY',
                query: document,
                variables: variables,
            });
        }
    };
    DataStore.prototype.markSubscriptionResult = function (result, document, variables) {
        if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.graphQLResultHasError)(result)) {
            this.cache.write({
                result: result.data,
                dataId: 'ROOT_SUBSCRIPTION',
                query: document,
                variables: variables,
            });
        }
    };
    DataStore.prototype.markMutationInit = function (mutation) {
        var _this = this;
        if (mutation.optimisticResponse) {
            var optimistic_1;
            if (typeof mutation.optimisticResponse === 'function') {
                optimistic_1 = mutation.optimisticResponse(mutation.variables);
            }
            else {
                optimistic_1 = mutation.optimisticResponse;
            }
            this.cache.recordOptimisticTransaction(function (c) {
                var orig = _this.cache;
                _this.cache = c;
                try {
                    _this.markMutationResult({
                        mutationId: mutation.mutationId,
                        result: { data: optimistic_1 },
                        document: mutation.document,
                        variables: mutation.variables,
                        updateQueries: mutation.updateQueries,
                        update: mutation.update,
                    });
                }
                finally {
                    _this.cache = orig;
                }
            }, mutation.mutationId);
        }
    };
    DataStore.prototype.markMutationResult = function (mutation) {
        var _this = this;
        if (!(0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.graphQLResultHasError)(mutation.result)) {
            var cacheWrites_1 = [{
                    result: mutation.result.data,
                    dataId: 'ROOT_MUTATION',
                    query: mutation.document,
                    variables: mutation.variables,
                }];
            var updateQueries_1 = mutation.updateQueries;
            if (updateQueries_1) {
                Object.keys(updateQueries_1).forEach(function (id) {
                    var _a = updateQueries_1[id], query = _a.query, updater = _a.updater;
                    var _b = _this.cache.diff({
                        query: query.document,
                        variables: query.variables,
                        returnPartialData: true,
                        optimistic: false,
                    }), currentQueryResult = _b.result, complete = _b.complete;
                    if (complete) {
                        var nextQueryResult = (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.tryFunctionOrLogError)(function () {
                            return updater(currentQueryResult, {
                                mutationResult: mutation.result,
                                queryName: (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.getOperationName)(query.document) || undefined,
                                queryVariables: query.variables,
                            });
                        });
                        if (nextQueryResult) {
                            cacheWrites_1.push({
                                result: nextQueryResult,
                                dataId: 'ROOT_QUERY',
                                query: query.document,
                                variables: query.variables,
                            });
                        }
                    }
                });
            }
            this.cache.performTransaction(function (c) {
                cacheWrites_1.forEach(function (write) { return c.write(write); });
                var update = mutation.update;
                if (update) {
                    (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_4__.tryFunctionOrLogError)(function () { return update(c, mutation.result); });
                }
            });
        }
    };
    DataStore.prototype.markMutationComplete = function (_a) {
        var mutationId = _a.mutationId, optimisticResponse = _a.optimisticResponse;
        if (optimisticResponse) {
            this.cache.removeOptimistic(mutationId);
        }
    };
    DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {
        this.cache.write({
            result: newResult,
            dataId: 'ROOT_QUERY',
            variables: variables,
            query: document,
        });
    };
    DataStore.prototype.reset = function () {
        return this.cache.reset();
    };
    return DataStore;
}());

var version = "2.6.10";

var hasSuggestedDevtools = false;
var ApolloClient = (function () {
    function ApolloClient(options) {
        var _this = this;
        this.defaultOptions = {};
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        var cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions = options.defaultOptions, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? false : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
        var link = options.link;
        if (!link && resolvers) {
            link = apollo_link__WEBPACK_IMPORTED_MODULE_7__.ApolloLink.empty();
        }
        if (!link || !cache) {
            throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError("In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\n" +
                "These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\n" +
                "For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup");
        }
        this.link = link;
        this.cache = cache;
        this.store = new DataStore(cache);
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions || {};
        this.typeDefs = typeDefs;
        if (ssrForceFetchDelay) {
            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        var defaultConnectToDevTools =  true &&
            typeof window !== 'undefined' &&
            !window.__APOLLO_CLIENT__;
        if (typeof connectToDevTools === 'undefined'
            ? defaultConnectToDevTools
            : connectToDevTools && typeof window !== 'undefined') {
            window.__APOLLO_CLIENT__ = this;
        }
        if (!hasSuggestedDevtools && "development" !== 'production') {
            hasSuggestedDevtools = true;
            if (typeof window !== 'undefined' &&
                window.document &&
                window.top === window.self) {
                if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                    if (window.navigator &&
                        window.navigator.userAgent &&
                        window.navigator.userAgent.indexOf('Chrome') > -1) {
                        console.debug('Download the Apollo DevTools ' +
                            'for a better development experience: ' +
                            'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');
                    }
                }
            }
        }
        this.version = version;
        this.localState = new LocalState({
            cache: cache,
            client: this,
            resolvers: resolvers,
            fragmentMatcher: fragmentMatcher,
        });
        this.queryManager = new QueryManager({
            link: this.link,
            store: this.store,
            queryDeduplication: queryDeduplication,
            ssrMode: ssrMode,
            clientAwareness: {
                name: clientAwarenessName,
                version: clientAwarenessVersion,
            },
            localState: this.localState,
            assumeImmutableResults: assumeImmutableResults,
            onBroadcast: function () {
                if (_this.devToolsHookCb) {
                    _this.devToolsHookCb({
                        action: {},
                        state: {
                            queries: _this.queryManager.queryStore.getStore(),
                            mutations: _this.queryManager.mutationStore.getStore(),
                        },
                        dataWithOptimisticResults: _this.cache.extract(true),
                    });
                }
            },
        });
    }
    ApolloClient.prototype.stop = function () {
        this.queryManager.stop();
    };
    ApolloClient.prototype.watchQuery = function (options) {
        if (this.defaultOptions.watchQuery) {
            options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.defaultOptions.watchQuery), options);
        }
        if (this.disableNetworkFetches &&
            (options.fetchPolicy === 'network-only' ||
                options.fetchPolicy === 'cache-and-network')) {
            options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), { fetchPolicy: 'cache-first' });
        }
        return this.queryManager.watchQuery(options);
    };
    ApolloClient.prototype.query = function (options) {
        if (this.defaultOptions.query) {
            options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.defaultOptions.query), options);
        }
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' +
            'client.query can only return a single result. Please use client.watchQuery ' +
            'to receive multiple results from the cache and the network, or consider ' +
            'using a different fetchPolicy, such as cache-first or network-only.');
        if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
            options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), { fetchPolicy: 'cache-first' });
        }
        return this.queryManager.query(options);
    };
    ApolloClient.prototype.mutate = function (options) {
        if (this.defaultOptions.mutate) {
            options = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.defaultOptions.mutate), options);
        }
        return this.queryManager.mutate(options);
    };
    ApolloClient.prototype.subscribe = function (options) {
        return this.queryManager.startGraphQLSubscription(options);
    };
    ApolloClient.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.cache.readQuery(options, optimistic);
    };
    ApolloClient.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.cache.readFragment(options, optimistic);
    };
    ApolloClient.prototype.writeQuery = function (options) {
        var result = this.cache.writeQuery(options);
        this.queryManager.broadcastQueries();
        return result;
    };
    ApolloClient.prototype.writeFragment = function (options) {
        var result = this.cache.writeFragment(options);
        this.queryManager.broadcastQueries();
        return result;
    };
    ApolloClient.prototype.writeData = function (options) {
        var result = this.cache.writeData(options);
        this.queryManager.broadcastQueries();
        return result;
    };
    ApolloClient.prototype.__actionHookForDevTools = function (cb) {
        this.devToolsHookCb = cb;
    };
    ApolloClient.prototype.__requestRaw = function (payload) {
        return (0,apollo_link__WEBPACK_IMPORTED_MODULE_7__.execute)(this.link, payload);
    };
    ApolloClient.prototype.initQueryManager = function () {
         false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn('Calling the initQueryManager method is no longer necessary, ' +
            'and it will be removed from ApolloClient in version 3.0.');
        return this.queryManager;
    };
    ApolloClient.prototype.resetStore = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () { return _this.queryManager.clearStore(); })
            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })
            .then(function () { return _this.reFetchObservableQueries(); });
    };
    ApolloClient.prototype.clearStore = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () { return _this.queryManager.clearStore(); })
            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });
    };
    ApolloClient.prototype.onResetStore = function (cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function () {
            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });
        };
    };
    ApolloClient.prototype.onClearStore = function (cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function () {
            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });
        };
    };
    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient.prototype.extract = function (optimistic) {
        return this.cache.extract(optimistic);
    };
    ApolloClient.prototype.restore = function (serializedState) {
        return this.cache.restore(serializedState);
    };
    ApolloClient.prototype.addResolvers = function (resolvers) {
        this.localState.addResolvers(resolvers);
    };
    ApolloClient.prototype.setResolvers = function (resolvers) {
        this.localState.setResolvers(resolvers);
    };
    ApolloClient.prototype.getResolvers = function () {
        return this.localState.getResolvers();
    };
    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
    };
    return ApolloClient;
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ApolloClient);

//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-link-context/lib/bundle.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-link-context/lib/bundle.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setContext": () => (/* binding */ setContext)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/bundle.esm.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-link */ "./node_modules/zen-observable-ts/lib/bundle.esm.js");



function setContext(setter) {
    return new apollo_link__WEBPACK_IMPORTED_MODULE_0__.ApolloLink(function (operation, forward) {
        var request = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(operation, []);
        return new apollo_link__WEBPACK_IMPORTED_MODULE_2__.default(function (observer) {
            var handle;
            Promise.resolve(request)
                .then(function (req) { return setter(req, operation.getContext()); })
                .then(operation.setContext)
                .then(function () {
                handle = forward(operation).subscribe({
                    next: observer.next.bind(observer),
                    error: observer.error.bind(observer),
                    complete: observer.complete.bind(observer),
                });
            })
                .catch(observer.error.bind(observer));
            return function () {
                if (handle)
                    handle.unsubscribe();
            };
        });
    });
}


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-link-http-common/lib/bundle.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-link-http-common/lib/bundle.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkFetcher": () => (/* binding */ checkFetcher),
/* harmony export */   "createSignalIfSupported": () => (/* binding */ createSignalIfSupported),
/* harmony export */   "fallbackHttpConfig": () => (/* binding */ fallbackHttpConfig),
/* harmony export */   "parseAndCheckHttpResponse": () => (/* binding */ parseAndCheckHttpResponse),
/* harmony export */   "selectHttpOptionsAndBody": () => (/* binding */ selectHttpOptionsAndBody),
/* harmony export */   "selectURI": () => (/* binding */ selectURI),
/* harmony export */   "serializeFetchParameter": () => (/* binding */ serializeFetchParameter),
/* harmony export */   "throwServerError": () => (/* binding */ throwServerError)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ts-invariant */ "./node_modules/ts-invariant/lib/invariant.esm.js");




var defaultHttpOptions = {
    includeQuery: true,
    includeExtensions: false,
};
var defaultHeaders = {
    accept: '*/*',
    'content-type': 'application/json',
};
var defaultOptions = {
    method: 'POST',
};
var fallbackHttpConfig = {
    http: defaultHttpOptions,
    headers: defaultHeaders,
    options: defaultOptions,
};
var throwServerError = function (response, result, message) {
    var error = new Error(message);
    error.name = 'ServerError';
    error.response = response;
    error.statusCode = response.status;
    error.result = result;
    throw error;
};
var parseAndCheckHttpResponse = function (operations) { return function (response) {
    return (response
        .text()
        .then(function (bodyText) {
        try {
            return JSON.parse(bodyText);
        }
        catch (err) {
            var parseError = err;
            parseError.name = 'ServerParseError';
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            return Promise.reject(parseError);
        }
    })
        .then(function (result) {
        if (response.status >= 300) {
            throwServerError(response, result, "Response not successful: Received status code " + response.status);
        }
        if (!Array.isArray(result) &&
            !result.hasOwnProperty('data') &&
            !result.hasOwnProperty('errors')) {
            throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations)
                ? operations.map(function (op) { return op.operationName; })
                : operations.operationName) + "'.");
        }
        return result;
    }));
}; };
var checkFetcher = function (fetcher) {
    if (!fetcher && typeof fetch === 'undefined') {
        var library = 'unfetch';
        if (typeof window === 'undefined')
            library = 'node-fetch';
        throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError("\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/" + library + ".\n\nFor example:\nimport fetch from '" + library + "';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });");
    }
};
var createSignalIfSupported = function () {
    if (typeof AbortController === 'undefined')
        return { controller: false, signal: false };
    var controller = new AbortController();
    var signal = controller.signal;
    return { controller: controller, signal: signal };
};
var selectHttpOptionsAndBody = function (operation, fallbackConfig) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
    }
    var options = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, fallbackConfig.options, { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
    var http = fallbackConfig.http;
    configs.forEach(function (config) {
        options = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, options, config.options, { headers: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, options.headers, config.headers) });
        if (config.credentials)
            options.credentials = config.credentials;
        http = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, http, config.http);
    });
    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
    var body = { operationName: operationName, variables: variables };
    if (http.includeExtensions)
        body.extensions = extensions;
    if (http.includeQuery)
        body.query = (0,graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__.print)(query);
    return {
        options: options,
        body: body,
    };
};
var serializeFetchParameter = function (p, label) {
    var serialized;
    try {
        serialized = JSON.stringify(p);
    }
    catch (e) {
        var parseError =  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError("Network request failed. " + label + " is not serializable: " + e.message);
        parseError.parseError = e;
        throw parseError;
    }
    return serialized;
};
var selectURI = function (operation, fallbackURI) {
    var context = operation.getContext();
    var contextURI = context.uri;
    if (contextURI) {
        return contextURI;
    }
    else if (typeof fallbackURI === 'function') {
        return fallbackURI(operation);
    }
    else {
        return fallbackURI || '/graphql';
    }
};


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-link-http/lib/bundle.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-link-http/lib/bundle.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpLink": () => (/* binding */ HttpLink),
/* harmony export */   "createHttpLink": () => (/* binding */ createHttpLink)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/bundle.esm.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! apollo-link */ "./node_modules/zen-observable-ts/lib/bundle.esm.js");
/* harmony import */ var apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-link-http-common */ "./node_modules/apollo-link-http-common/lib/bundle.esm.js");




var createHttpLink = function (linkOptions) {
    if (linkOptions === void 0) { linkOptions = {}; }
    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__rest)(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries"]);
    (0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.checkFetcher)(fetcher);
    if (!fetcher) {
        fetcher = fetch;
    }
    var linkConfig = {
        http: { includeExtensions: includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers,
    };
    return new apollo_link__WEBPACK_IMPORTED_MODULE_2__.ApolloLink(function (operation) {
        var chosenURI = (0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.selectURI)(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
            if (name_1) {
                clientAwarenessHeaders['apollographql-client-name'] = name_1;
            }
            if (version) {
                clientAwarenessHeaders['apollographql-client-version'] = version;
            }
        }
        var contextHeaders = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, clientAwarenessHeaders, context.headers);
        var contextConfig = {
            http: context.http,
            options: context.fetchOptions,
            credentials: context.credentials,
            headers: contextHeaders,
        };
        var _b = (0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.selectHttpOptionsAndBody)(operation, apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
        var controller;
        if (!options.signal) {
            var _c = (0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.createSignalIfSupported)(), _controller = _c.controller, signal = _c.signal;
            controller = _controller;
            if (controller)
                options.signal = signal;
        }
        var definitionIsMutation = function (d) {
            return d.kind === 'OperationDefinition' && d.operation === 'mutation';
        };
        if (useGETForQueries &&
            !operation.query.definitions.some(definitionIsMutation)) {
            options.method = 'GET';
        }
        if (options.method === 'GET') {
            var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
            if (parseError) {
                return (0,apollo_link__WEBPACK_IMPORTED_MODULE_2__.fromError)(parseError);
            }
            chosenURI = newURI;
        }
        else {
            try {
                options.body = (0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.serializeFetchParameter)(body, 'Payload');
            }
            catch (parseError) {
                return (0,apollo_link__WEBPACK_IMPORTED_MODULE_2__.fromError)(parseError);
            }
        }
        return new apollo_link__WEBPACK_IMPORTED_MODULE_3__.default(function (observer) {
            fetcher(chosenURI, options)
                .then(function (response) {
                operation.setContext({ response: response });
                return response;
            })
                .then((0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.parseAndCheckHttpResponse)(operation))
                .then(function (result) {
                observer.next(result);
                observer.complete();
                return result;
            })
                .catch(function (err) {
                if (err.name === 'AbortError')
                    return;
                if (err.result && err.result.errors && err.result.data) {
                    observer.next(err.result);
                }
                observer.error(err);
            });
            return function () {
                if (controller)
                    controller.abort();
            };
        });
    });
};
function rewriteURIForGET(chosenURI, body) {
    var queryParams = [];
    var addQueryParam = function (key, value) {
        queryParams.push(key + "=" + encodeURIComponent(value));
    };
    if ('query' in body) {
        addQueryParam('query', body.query);
    }
    if (body.operationName) {
        addQueryParam('operationName', body.operationName);
    }
    if (body.variables) {
        var serializedVariables = void 0;
        try {
            serializedVariables = (0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.serializeFetchParameter)(body.variables, 'Variables map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('variables', serializedVariables);
    }
    if (body.extensions) {
        var serializedExtensions = void 0;
        try {
            serializedExtensions = (0,apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__.serializeFetchParameter)(body.extensions, 'Extensions map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('extensions', serializedExtensions);
    }
    var fragment = '', preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf('#');
    if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
    return { newURI: newURI };
}
var HttpLink = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(HttpLink, _super);
    function HttpLink(opts) {
        return _super.call(this, createHttpLink(opts).request) || this;
    }
    return HttpLink;
}(apollo_link__WEBPACK_IMPORTED_MODULE_2__.ApolloLink));


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-link-ws/lib/bundle.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/apollo-link-ws/lib/bundle.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketLink": () => (/* binding */ WebSocketLink)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/bundle.esm.js");
/* harmony import */ var subscriptions_transport_ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! subscriptions-transport-ws */ "./node_modules/subscriptions-transport-ws/dist/client.js");
/* harmony import */ var subscriptions_transport_ws__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(subscriptions_transport_ws__WEBPACK_IMPORTED_MODULE_0__);




var WebSocketLink = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(WebSocketLink, _super);
    function WebSocketLink(paramsOrClient) {
        var _this = _super.call(this) || this;
        if (paramsOrClient instanceof subscriptions_transport_ws__WEBPACK_IMPORTED_MODULE_0__.SubscriptionClient) {
            _this.subscriptionClient = paramsOrClient;
        }
        else {
            _this.subscriptionClient = new subscriptions_transport_ws__WEBPACK_IMPORTED_MODULE_0__.SubscriptionClient(paramsOrClient.uri, paramsOrClient.options, paramsOrClient.webSocketImpl);
        }
        return _this;
    }
    WebSocketLink.prototype.request = function (operation) {
        return this.subscriptionClient.request(operation);
    };
    return WebSocketLink;
}(apollo_link__WEBPACK_IMPORTED_MODULE_2__.ApolloLink));


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-link/lib/bundle.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/apollo-link/lib/bundle.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Observable": () => (/* reexport safe */ zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default),
/* harmony export */   "getOperationName": () => (/* reexport safe */ apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getOperationName),
/* harmony export */   "ApolloLink": () => (/* binding */ ApolloLink),
/* harmony export */   "concat": () => (/* binding */ concat),
/* harmony export */   "createOperation": () => (/* binding */ createOperation),
/* harmony export */   "empty": () => (/* binding */ empty),
/* harmony export */   "execute": () => (/* binding */ execute),
/* harmony export */   "from": () => (/* binding */ from),
/* harmony export */   "fromError": () => (/* binding */ fromError),
/* harmony export */   "fromPromise": () => (/* binding */ fromPromise),
/* harmony export */   "makePromise": () => (/* binding */ makePromise),
/* harmony export */   "split": () => (/* binding */ split),
/* harmony export */   "toPromise": () => (/* binding */ toPromise)
/* harmony export */ });
/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zen-observable-ts */ "./node_modules/zen-observable-ts/lib/bundle.esm.js");
/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ts-invariant */ "./node_modules/ts-invariant/lib/invariant.esm.js");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/bundle.esm.js");







function validateOperation(operation) {
    var OPERATION_FIELDS = [
        'query',
        'operationName',
        'variables',
        'extensions',
        'context',
    ];
    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
            throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError("illegal argument: " + key);
        }
    }
    return operation;
}
var LinkError = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(LinkError, _super);
    function LinkError(message, link) {
        var _this = _super.call(this, message) || this;
        _this.link = link;
        return _this;
    }
    return LinkError;
}(Error));
function isTerminating(link) {
    return link.request.length <= 1;
}
function toPromise(observable) {
    var completed = false;
    return new Promise(function (resolve, reject) {
        observable.subscribe({
            next: function (data) {
                if (completed) {
                     false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn("Promise Wrapper does not support multiple results from Observable");
                }
                else {
                    completed = true;
                    resolve(data);
                }
            },
            error: reject,
        });
    });
}
var makePromise = toPromise;
function fromPromise(promise) {
    return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default(function (observer) {
        promise
            .then(function (value) {
            observer.next(value);
            observer.complete();
        })
            .catch(observer.error.bind(observer));
    });
}
function fromError(errorValue) {
    return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default(function (observer) {
        observer.error(errorValue);
    });
}
function transformOperation(operation) {
    var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query,
    };
    if (!transformedOperation.operationName) {
        transformedOperation.operationName =
            typeof transformedOperation.query !== 'string'
                ? (0,apollo_utilities__WEBPACK_IMPORTED_MODULE_2__.getOperationName)(transformedOperation.query)
                : '';
    }
    return transformedOperation;
}
function createOperation(starting, operation) {
    var context = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, starting);
    var setContext = function (next) {
        if (typeof next === 'function') {
            context = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, context, next(context));
        }
        else {
            context = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, context, next);
        }
    };
    var getContext = function () { return ((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, context)); };
    Object.defineProperty(operation, 'setContext', {
        enumerable: false,
        value: setContext,
    });
    Object.defineProperty(operation, 'getContext', {
        enumerable: false,
        value: getContext,
    });
    Object.defineProperty(operation, 'toKey', {
        enumerable: false,
        value: function () { return getKey(operation); },
    });
    return operation;
}
function getKey(operation) {
    var query = operation.query, variables = operation.variables, operationName = operation.operationName;
    return JSON.stringify([operationName, query, variables]);
}

function passthrough(op, forward) {
    return forward ? forward(op) : zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of();
}
function toLink(handler) {
    return typeof handler === 'function' ? new ApolloLink(handler) : handler;
}
function empty() {
    return new ApolloLink(function () { return zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of(); });
}
function from(links) {
    if (links.length === 0)
        return empty();
    return links.map(toLink).reduce(function (x, y) { return x.concat(y); });
}
function split(test, left, right) {
    var leftLink = toLink(left);
    var rightLink = toLink(right || new ApolloLink(passthrough));
    if (isTerminating(leftLink) && isTerminating(rightLink)) {
        return new ApolloLink(function (operation) {
            return test(operation)
                ? leftLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of()
                : rightLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of();
        });
    }
    else {
        return new ApolloLink(function (operation, forward) {
            return test(operation)
                ? leftLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of()
                : rightLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of();
        });
    }
}
var concat = function (first, second) {
    var firstLink = toLink(first);
    if (isTerminating(firstLink)) {
         false || ts_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
        return firstLink;
    }
    var nextLink = toLink(second);
    if (isTerminating(nextLink)) {
        return new ApolloLink(function (operation) {
            return firstLink.request(operation, function (op) { return nextLink.request(op) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of(); }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of();
        });
    }
    else {
        return new ApolloLink(function (operation, forward) {
            return (firstLink.request(operation, function (op) {
                return nextLink.request(op, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of();
            }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of());
        });
    }
};
var ApolloLink = (function () {
    function ApolloLink(request) {
        if (request)
            this.request = request;
    }
    ApolloLink.prototype.split = function (test, left, right) {
        return this.concat(split(test, left, right || new ApolloLink(passthrough)));
    };
    ApolloLink.prototype.concat = function (next) {
        return concat(this, next);
    };
    ApolloLink.prototype.request = function (operation, forward) {
        throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__.InvariantError('request is not implemented');
    };
    ApolloLink.empty = empty;
    ApolloLink.from = from;
    ApolloLink.split = split;
    ApolloLink.execute = execute;
    return ApolloLink;
}());
function execute(link, operation) {
    return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__.default.of());
}


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/apollo-utilities/lib/bundle.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/bundle.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isEqual": () => (/* reexport safe */ _wry_equality__WEBPACK_IMPORTED_MODULE_2__.equal),
/* harmony export */   "addTypenameToDocument": () => (/* binding */ addTypenameToDocument),
/* harmony export */   "argumentsObjectFromField": () => (/* binding */ argumentsObjectFromField),
/* harmony export */   "assign": () => (/* binding */ assign),
/* harmony export */   "buildQueryFromSelectionSet": () => (/* binding */ buildQueryFromSelectionSet),
/* harmony export */   "canUseWeakMap": () => (/* binding */ canUseWeakMap),
/* harmony export */   "checkDocument": () => (/* binding */ checkDocument),
/* harmony export */   "cloneDeep": () => (/* binding */ cloneDeep),
/* harmony export */   "createFragmentMap": () => (/* binding */ createFragmentMap),
/* harmony export */   "getDefaultValues": () => (/* binding */ getDefaultValues),
/* harmony export */   "getDirectiveInfoFromField": () => (/* binding */ getDirectiveInfoFromField),
/* harmony export */   "getDirectiveNames": () => (/* binding */ getDirectiveNames),
/* harmony export */   "getDirectivesFromDocument": () => (/* binding */ getDirectivesFromDocument),
/* harmony export */   "getEnv": () => (/* binding */ getEnv),
/* harmony export */   "getFragmentDefinition": () => (/* binding */ getFragmentDefinition),
/* harmony export */   "getFragmentDefinitions": () => (/* binding */ getFragmentDefinitions),
/* harmony export */   "getFragmentQueryDocument": () => (/* binding */ getFragmentQueryDocument),
/* harmony export */   "getInclusionDirectives": () => (/* binding */ getInclusionDirectives),
/* harmony export */   "getMainDefinition": () => (/* binding */ getMainDefinition),
/* harmony export */   "getMutationDefinition": () => (/* binding */ getMutationDefinition),
/* harmony export */   "getOperationDefinition": () => (/* binding */ getOperationDefinition),
/* harmony export */   "getOperationDefinitionOrDie": () => (/* binding */ getOperationDefinitionOrDie),
/* harmony export */   "getOperationName": () => (/* binding */ getOperationName),
/* harmony export */   "getQueryDefinition": () => (/* binding */ getQueryDefinition),
/* harmony export */   "getStoreKeyName": () => (/* binding */ getStoreKeyName),
/* harmony export */   "graphQLResultHasError": () => (/* binding */ graphQLResultHasError),
/* harmony export */   "hasClientExports": () => (/* binding */ hasClientExports),
/* harmony export */   "hasDirectives": () => (/* binding */ hasDirectives),
/* harmony export */   "isDevelopment": () => (/* binding */ isDevelopment),
/* harmony export */   "isEnv": () => (/* binding */ isEnv),
/* harmony export */   "isField": () => (/* binding */ isField),
/* harmony export */   "isIdValue": () => (/* binding */ isIdValue),
/* harmony export */   "isInlineFragment": () => (/* binding */ isInlineFragment),
/* harmony export */   "isJsonValue": () => (/* binding */ isJsonValue),
/* harmony export */   "isNumberValue": () => (/* binding */ isNumberValue),
/* harmony export */   "isProduction": () => (/* binding */ isProduction),
/* harmony export */   "isScalarValue": () => (/* binding */ isScalarValue),
/* harmony export */   "isTest": () => (/* binding */ isTest),
/* harmony export */   "maybeDeepFreeze": () => (/* binding */ maybeDeepFreeze),
/* harmony export */   "mergeDeep": () => (/* binding */ mergeDeep),
/* harmony export */   "mergeDeepArray": () => (/* binding */ mergeDeepArray),
/* harmony export */   "removeArgumentsFromDocument": () => (/* binding */ removeArgumentsFromDocument),
/* harmony export */   "removeClientSetsFromDocument": () => (/* binding */ removeClientSetsFromDocument),
/* harmony export */   "removeConnectionDirectiveFromDocument": () => (/* binding */ removeConnectionDirectiveFromDocument),
/* harmony export */   "removeDirectivesFromDocument": () => (/* binding */ removeDirectivesFromDocument),
/* harmony export */   "removeFragmentSpreadFromDocument": () => (/* binding */ removeFragmentSpreadFromDocument),
/* harmony export */   "resultKeyNameFromField": () => (/* binding */ resultKeyNameFromField),
/* harmony export */   "shouldInclude": () => (/* binding */ shouldInclude),
/* harmony export */   "storeKeyNameFromField": () => (/* binding */ storeKeyNameFromField),
/* harmony export */   "stripSymbols": () => (/* binding */ stripSymbols),
/* harmony export */   "toIdValue": () => (/* binding */ toIdValue),
/* harmony export */   "tryFunctionOrLogError": () => (/* binding */ tryFunctionOrLogError),
/* harmony export */   "valueFromNode": () => (/* binding */ valueFromNode),
/* harmony export */   "valueToObjectRepresentation": () => (/* binding */ valueToObjectRepresentation),
/* harmony export */   "variablesInOperation": () => (/* binding */ variablesInOperation),
/* harmony export */   "warnOnceInDevelopment": () => (/* binding */ warnOnceInDevelopment)
/* harmony export */ });
/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! graphql/language/visitor */ "./node_modules/graphql/language/visitor.js");
/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ts-invariant */ "./node_modules/ts-invariant/lib/invariant.esm.js");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");
/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wry/equality */ "./node_modules/@wry/equality/lib/equality.esm.js");






function isScalarValue(value) {
    return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;
}
function isNumberValue(value) {
    return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;
}
function isStringValue(value) {
    return value.kind === 'StringValue';
}
function isBooleanValue(value) {
    return value.kind === 'BooleanValue';
}
function isIntValue(value) {
    return value.kind === 'IntValue';
}
function isFloatValue(value) {
    return value.kind === 'FloatValue';
}
function isVariable(value) {
    return value.kind === 'Variable';
}
function isObjectValue(value) {
    return value.kind === 'ObjectValue';
}
function isListValue(value) {
    return value.kind === 'ListValue';
}
function isEnumValue(value) {
    return value.kind === 'EnumValue';
}
function isNullValue(value) {
    return value.kind === 'NullValue';
}
function valueToObjectRepresentation(argObj, name, value, variables) {
    if (isIntValue(value) || isFloatValue(value)) {
        argObj[name.value] = Number(value.value);
    }
    else if (isBooleanValue(value) || isStringValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isObjectValue(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function (obj) {
            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
    }
    else if (isVariable(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
    }
    else if (isListValue(value)) {
        argObj[name.value] = value.values.map(function (listValue) {
            var nestedArgArrayObj = {};
            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
            return nestedArgArrayObj[name.value];
        });
    }
    else if (isEnumValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isNullValue(value)) {
        argObj[name.value] = null;
    }
    else {
        throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError("The inline argument \"" + name.value + "\" of kind \"" + value.kind + "\"" +
            'is not supported. Use variables instead of inline arguments to ' +
            'overcome this limitation.');
    }
}
function storeKeyNameFromField(field, variables) {
    var directivesObj = null;
    if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function (directive) {
            directivesObj[directive.name.value] = {};
            if (directive.arguments) {
                directive.arguments.forEach(function (_a) {
                    var name = _a.name, value = _a.value;
                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                });
            }
        });
    }
    var argObj = null;
    if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj, name, value, variables);
        });
    }
    return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
    'connection',
    'include',
    'skip',
    'client',
    'rest',
    'export',
];
function getStoreKeyName(fieldName, args, directives) {
    if (directives &&
        directives['connection'] &&
        directives['connection']['key']) {
        if (directives['connection']['filter'] &&
            directives['connection']['filter'].length > 0) {
            var filterKeys = directives['connection']['filter']
                ? directives['connection']['filter']
                : [];
            filterKeys.sort();
            var queryArgs_1 = args;
            var filteredArgs_1 = {};
            filterKeys.forEach(function (key) {
                filteredArgs_1[key] = queryArgs_1[key];
            });
            return directives['connection']['key'] + "(" + JSON.stringify(filteredArgs_1) + ")";
        }
        else {
            return directives['connection']['key'];
        }
    }
    var completeFieldName = fieldName;
    if (args) {
        var stringifiedArgs = fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default()(args);
        completeFieldName += "(" + stringifiedArgs + ")";
    }
    if (directives) {
        Object.keys(directives).forEach(function (key) {
            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
                return;
            if (directives[key] && Object.keys(directives[key]).length) {
                completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
            }
            else {
                completeFieldName += "@" + key;
            }
        });
    }
    return completeFieldName;
}
function argumentsObjectFromField(field, variables) {
    if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj_1, name, value, variables);
        });
        return argObj_1;
    }
    return null;
}
function resultKeyNameFromField(field) {
    return field.alias ? field.alias.value : field.name.value;
}
function isField(selection) {
    return selection.kind === 'Field';
}
function isInlineFragment(selection) {
    return selection.kind === 'InlineFragment';
}
function isIdValue(idObject) {
    return idObject &&
        idObject.type === 'id' &&
        typeof idObject.generated === 'boolean';
}
function toIdValue(idConfig, generated) {
    if (generated === void 0) { generated = false; }
    return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({ type: 'id', generated: generated }, (typeof idConfig === 'string'
        ? { id: idConfig, typename: undefined }
        : idConfig));
}
function isJsonValue(jsonObject) {
    return (jsonObject != null &&
        typeof jsonObject === 'object' &&
        jsonObject.type === 'json');
}
function defaultValueFromVariable(node) {
    throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError("Variable nodes are not supported by valueFromNode");
}
function valueFromNode(node, onVariable) {
    if (onVariable === void 0) { onVariable = defaultValueFromVariable; }
    switch (node.kind) {
        case 'Variable':
            return onVariable(node);
        case 'NullValue':
            return null;
        case 'IntValue':
            return parseInt(node.value, 10);
        case 'FloatValue':
            return parseFloat(node.value);
        case 'ListValue':
            return node.values.map(function (v) { return valueFromNode(v, onVariable); });
        case 'ObjectValue': {
            var value = {};
            for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                value[field.name.value] = valueFromNode(field.value, onVariable);
            }
            return value;
        }
        default:
            return node.value;
    }
}

function getDirectiveInfoFromField(field, variables) {
    if (field.directives && field.directives.length) {
        var directiveObj_1 = {};
        field.directives.forEach(function (directive) {
            directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);
        });
        return directiveObj_1;
    }
    return null;
}
function shouldInclude(selection, variables) {
    if (variables === void 0) { variables = {}; }
    return getInclusionDirectives(selection.directives).every(function (_a) {
        var directive = _a.directive, ifArgument = _a.ifArgument;
        var evaledValue = false;
        if (ifArgument.value.kind === 'Variable') {
            evaledValue = variables[ifArgument.value.name.value];
             false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(evaledValue !== void 0, "Invalid variable referenced in @" + directive.name.value + " directive.");
        }
        else {
            evaledValue = ifArgument.value.value;
        }
        return directive.name.value === 'skip' ? !evaledValue : evaledValue;
    });
}
function getDirectiveNames(doc) {
    var names = [];
    (0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(doc, {
        Directive: function (node) {
            names.push(node.name.value);
        },
    });
    return names;
}
function hasDirectives(names, doc) {
    return getDirectiveNames(doc).some(function (name) { return names.indexOf(name) > -1; });
}
function hasClientExports(document) {
    return (document &&
        hasDirectives(['client'], document) &&
        hasDirectives(['export'], document));
}
function isInclusionDirective(_a) {
    var value = _a.name.value;
    return value === 'skip' || value === 'include';
}
function getInclusionDirectives(directives) {
    return directives ? directives.filter(isInclusionDirective).map(function (directive) {
        var directiveArguments = directive.arguments;
        var directiveName = directive.name.value;
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @" + directiveName + " directive.");
        var ifArgument = directiveArguments[0];
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(ifArgument.name && ifArgument.name.value === 'if', "Invalid argument for the @" + directiveName + " directive.");
        var ifValue = ifArgument.value;
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(ifValue &&
            (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), "Argument for the @" + directiveName + " directive must be a variable or a boolean value.");
        return { directive: directive, ifArgument: ifArgument };
    }) : [];
}

function getFragmentQueryDocument(document, fragmentName) {
    var actualFragmentName = fragmentName;
    var fragments = [];
    document.definitions.forEach(function (definition) {
        if (definition.kind === 'OperationDefinition') {
            throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : '') + ". " +
                'No operations are allowed when using a fragment as a query. Only fragments are allowed.');
        }
        if (definition.kind === 'FragmentDefinition') {
            fragments.push(definition);
        }
    });
    if (typeof actualFragmentName === 'undefined') {
         false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragments.length === 1, "Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.");
        actualFragmentName = fragments[0].name.value;
    }
    var query = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, document), { definitions: (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__spreadArrays)([
            {
                kind: 'OperationDefinition',
                operation: 'query',
                selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                        {
                            kind: 'FragmentSpread',
                            name: {
                                kind: 'Name',
                                value: actualFragmentName,
                            },
                        },
                    ],
                },
            }
        ], document.definitions) });
    return query;
}

function assign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) {
        if (typeof source === 'undefined' || source === null) {
            return;
        }
        Object.keys(source).forEach(function (key) {
            target[key] = source[key];
        });
    });
    return target;
}

function getMutationDefinition(doc) {
    checkDocument(doc);
    var mutationDef = doc.definitions.filter(function (definition) {
        return definition.kind === 'OperationDefinition' &&
            definition.operation === 'mutation';
    })[0];
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(mutationDef, 'Must contain a mutation definition.');
    return mutationDef;
}
function checkDocument(doc) {
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc && doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
    var operations = doc.definitions
        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })
        .map(function (definition) {
        if (definition.kind !== 'OperationDefinition') {
            throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError("Schema type definitions not allowed in queries. Found: \"" + definition.kind + "\"");
        }
        return definition;
    });
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(operations.length <= 1, "Ambiguous GraphQL document: contains " + operations.length + " operations");
    return doc;
}
function getOperationDefinition(doc) {
    checkDocument(doc);
    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];
}
function getOperationDefinitionOrDie(document) {
    var def = getOperationDefinition(document);
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(def, "GraphQL document is missing an operation");
    return def;
}
function getOperationName(doc) {
    return (doc.definitions
        .filter(function (definition) {
        return definition.kind === 'OperationDefinition' && definition.name;
    })
        .map(function (x) { return x.name.value; })[0] || null);
}
function getFragmentDefinitions(doc) {
    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });
}
function getQueryDefinition(doc) {
    var queryDef = getOperationDefinition(doc);
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(queryDef && queryDef.operation === 'query', 'Must contain a query definition.');
    return queryDef;
}
function getFragmentDefinition(doc) {
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc.definitions.length <= 1, 'Fragment must have exactly one definition.');
    var fragmentDef = doc.definitions[0];
     false ? 0 : (0,ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.');
    return fragmentDef;
}
function getMainDefinition(queryDoc) {
    checkDocument(queryDoc);
    var fragmentDefinition;
    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
        var definition = _a[_i];
        if (definition.kind === 'OperationDefinition') {
            var operation = definition.operation;
            if (operation === 'query' ||
                operation === 'mutation' ||
                operation === 'subscription') {
                return definition;
            }
        }
        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
            fragmentDefinition = definition;
        }
    }
    if (fragmentDefinition) {
        return fragmentDefinition;
    }
    throw  false ? 0 : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__.InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');
}
function createFragmentMap(fragments) {
    if (fragments === void 0) { fragments = []; }
    var symTable = {};
    fragments.forEach(function (fragment) {
        symTable[fragment.name.value] = fragment;
    });
    return symTable;
}
function getDefaultValues(definition) {
    if (definition &&
        definition.variableDefinitions &&
        definition.variableDefinitions.length) {
        var defaultValues = definition.variableDefinitions
            .filter(function (_a) {
            var defaultValue = _a.defaultValue;
            return defaultValue;
        })
            .map(function (_a) {
            var variable = _a.variable, defaultValue = _a.defaultValue;
            var defaultValueObj = {};
            valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);
            return defaultValueObj;
        });
        return assign.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__spreadArrays)([{}], defaultValues));
    }
    return {};
}
function variablesInOperation(operation) {
    var names = new Set();
    if (operation.variableDefinitions) {
        for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            names.add(definition.variable.name.value);
        }
    }
    return names;
}

function filterInPlace(array, test, context) {
    var target = 0;
    array.forEach(function (elem, i) {
        if (test.call(this, elem, i, array)) {
            array[target++] = elem;
        }
    }, context);
    array.length = target;
    return array;
}

var TYPENAME_FIELD = {
    kind: 'Field',
    name: {
        kind: 'Name',
        value: '__typename',
    },
};
function isEmpty(op, fragments) {
    return op.selectionSet.selections.every(function (selection) {
        return selection.kind === 'FragmentSpread' &&
            isEmpty(fragments[selection.name.value], fragments);
    });
}
function nullIfDocIsEmpty(doc) {
    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))
        ? null
        : doc;
}
function getDirectiveMatcher(directives) {
    return function directiveMatcher(directive) {
        return directives.some(function (dir) {
            return (dir.name && dir.name === directive.name.value) ||
                (dir.test && dir.test(directive));
        });
    };
}
function removeDirectivesFromDocument(directives, doc) {
    var variablesInUse = Object.create(null);
    var variablesToRemove = [];
    var fragmentSpreadsInUse = Object.create(null);
    var fragmentSpreadsToRemove = [];
    var modifiedDoc = nullIfDocIsEmpty((0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(doc, {
        Variable: {
            enter: function (node, _key, parent) {
                if (parent.kind !== 'VariableDefinition') {
                    variablesInUse[node.name.value] = true;
                }
            },
        },
        Field: {
            enter: function (node) {
                if (directives && node.directives) {
                    var shouldRemoveField = directives.some(function (directive) { return directive.remove; });
                    if (shouldRemoveField &&
                        node.directives &&
                        node.directives.some(getDirectiveMatcher(directives))) {
                        if (node.arguments) {
                            node.arguments.forEach(function (arg) {
                                if (arg.value.kind === 'Variable') {
                                    variablesToRemove.push({
                                        name: arg.value.name.value,
                                    });
                                }
                            });
                        }
                        if (node.selectionSet) {
                            getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {
                                fragmentSpreadsToRemove.push({
                                    name: frag.name.value,
                                });
                            });
                        }
                        return null;
                    }
                }
            },
        },
        FragmentSpread: {
            enter: function (node) {
                fragmentSpreadsInUse[node.name.value] = true;
            },
        },
        Directive: {
            enter: function (node) {
                if (getDirectiveMatcher(directives)(node)) {
                    return null;
                }
            },
        },
    }));
    if (modifiedDoc &&
        filterInPlace(variablesToRemove, function (v) { return !variablesInUse[v.name]; }).length) {
        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
    }
    if (modifiedDoc &&
        filterInPlace(fragmentSpreadsToRemove, function (fs) { return !fragmentSpreadsInUse[fs.name]; })
            .length) {
        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
    }
    return modifiedDoc;
}
function addTypenameToDocument(doc) {
    return (0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(checkDocument(doc), {
        SelectionSet: {
            enter: function (node, _key, parent) {
                if (parent &&
                    parent.kind === 'OperationDefinition') {
                    return;
                }
                var selections = node.selections;
                if (!selections) {
                    return;
                }
                var skip = selections.some(function (selection) {
                    return (isField(selection) &&
                        (selection.name.value === '__typename' ||
                            selection.name.value.lastIndexOf('__', 0) === 0));
                });
                if (skip) {
                    return;
                }
                var field = parent;
                if (isField(field) &&
                    field.directives &&
                    field.directives.some(function (d) { return d.name.value === 'export'; })) {
                    return;
                }
                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, node), { selections: (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__spreadArrays)(selections, [TYPENAME_FIELD]) });
            },
        },
    });
}
var connectionRemoveConfig = {
    test: function (directive) {
        var willRemove = directive.name.value === 'connection';
        if (willRemove) {
            if (!directive.arguments ||
                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {
                 false || ts_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant.warn('Removing an @connection directive even though it does not have a key. ' +
                    'You may want to use the key parameter to specify a store key.');
            }
        }
        return willRemove;
    },
};
function removeConnectionDirectiveFromDocument(doc) {
    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {
    if (nestedCheck === void 0) { nestedCheck = true; }
    return (selectionSet &&
        selectionSet.selections &&
        selectionSet.selections.some(function (selection) {
            return hasDirectivesInSelection(directives, selection, nestedCheck);
        }));
}
function hasDirectivesInSelection(directives, selection, nestedCheck) {
    if (nestedCheck === void 0) { nestedCheck = true; }
    if (!isField(selection)) {
        return true;
    }
    if (!selection.directives) {
        return false;
    }
    return (selection.directives.some(getDirectiveMatcher(directives)) ||
        (nestedCheck &&
            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));
}
function getDirectivesFromDocument(directives, doc) {
    checkDocument(doc);
    var parentPath;
    return nullIfDocIsEmpty((0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(doc, {
        SelectionSet: {
            enter: function (node, _key, _parent, path) {
                var currentPath = path.join('-');
                if (!parentPath ||
                    currentPath === parentPath ||
                    !currentPath.startsWith(parentPath)) {
                    if (node.selections) {
                        var selectionsWithDirectives = node.selections.filter(function (selection) { return hasDirectivesInSelection(directives, selection); });
                        if (hasDirectivesInSelectionSet(directives, node, false)) {
                            parentPath = currentPath;
                        }
                        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, node), { selections: selectionsWithDirectives });
                    }
                    else {
                        return null;
                    }
                }
            },
        },
    }));
}
function getArgumentMatcher(config) {
    return function argumentMatcher(argument) {
        return config.some(function (aConfig) {
            return argument.value &&
                argument.value.kind === 'Variable' &&
                argument.value.name &&
                (aConfig.name === argument.value.name.value ||
                    (aConfig.test && aConfig.test(argument)));
        });
    };
}
function removeArgumentsFromDocument(config, doc) {
    var argMatcher = getArgumentMatcher(config);
    return nullIfDocIsEmpty((0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(doc, {
        OperationDefinition: {
            enter: function (node) {
                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) {
                        return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });
                    }) });
            },
        },
        Field: {
            enter: function (node) {
                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });
                if (shouldRemoveField) {
                    var argMatchCount_1 = 0;
                    node.arguments.forEach(function (arg) {
                        if (argMatcher(arg)) {
                            argMatchCount_1 += 1;
                        }
                    });
                    if (argMatchCount_1 === 1) {
                        return null;
                    }
                }
            },
        },
        Argument: {
            enter: function (node) {
                if (argMatcher(node)) {
                    return null;
                }
            },
        },
    }));
}
function removeFragmentSpreadFromDocument(config, doc) {
    function enter(node) {
        if (config.some(function (def) { return def.name === node.name.value; })) {
            return null;
        }
    }
    return nullIfDocIsEmpty((0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(doc, {
        FragmentSpread: { enter: enter },
        FragmentDefinition: { enter: enter },
    }));
}
function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
    var allFragments = [];
    selectionSet.selections.forEach(function (selection) {
        if ((isField(selection) || isInlineFragment(selection)) &&
            selection.selectionSet) {
            getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });
        }
        else if (selection.kind === 'FragmentSpread') {
            allFragments.push(selection);
        }
    });
    return allFragments;
}
function buildQueryFromSelectionSet(document) {
    var definition = getMainDefinition(document);
    var definitionOperation = definition.operation;
    if (definitionOperation === 'query') {
        return document;
    }
    var modifiedDoc = (0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(document, {
        OperationDefinition: {
            enter: function (node) {
                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, node), { operation: 'query' });
            },
        },
    });
    return modifiedDoc;
}
function removeClientSetsFromDocument(document) {
    checkDocument(document);
    var modifiedDoc = removeDirectivesFromDocument([
        {
            test: function (directive) { return directive.name.value === 'client'; },
            remove: true,
        },
    ], document);
    if (modifiedDoc) {
        modifiedDoc = (0,graphql_language_visitor__WEBPACK_IMPORTED_MODULE_4__.visit)(modifiedDoc, {
            FragmentDefinition: {
                enter: function (node) {
                    if (node.selectionSet) {
                        var isTypenameOnly = node.selectionSet.selections.every(function (selection) {
                            return isField(selection) && selection.name.value === '__typename';
                        });
                        if (isTypenameOnly) {
                            return null;
                        }
                    }
                },
            },
        });
    }
    return modifiedDoc;
}

var canUseWeakMap = typeof WeakMap === 'function' && !(typeof navigator === 'object' &&
    navigator.product === 'ReactNative');

var toString = Object.prototype.toString;
function cloneDeep(value) {
    return cloneDeepHelper(value, new Map());
}
function cloneDeepHelper(val, seen) {
    switch (toString.call(val)) {
        case "[object Array]": {
            if (seen.has(val))
                return seen.get(val);
            var copy_1 = val.slice(0);
            seen.set(val, copy_1);
            copy_1.forEach(function (child, i) {
                copy_1[i] = cloneDeepHelper(child, seen);
            });
            return copy_1;
        }
        case "[object Object]": {
            if (seen.has(val))
                return seen.get(val);
            var copy_2 = Object.create(Object.getPrototypeOf(val));
            seen.set(val, copy_2);
            Object.keys(val).forEach(function (key) {
                copy_2[key] = cloneDeepHelper(val[key], seen);
            });
            return copy_2;
        }
        default:
            return val;
    }
}

function getEnv() {
    if (typeof process !== 'undefined' && "development") {
        return "development";
    }
    return 'development';
}
function isEnv(env) {
    return getEnv() === env;
}
function isProduction() {
    return isEnv('production') === true;
}
function isDevelopment() {
    return isEnv('development') === true;
}
function isTest() {
    return isEnv('test') === true;
}

function tryFunctionOrLogError(f) {
    try {
        return f();
    }
    catch (e) {
        if (console.error) {
            console.error(e);
        }
    }
}
function graphQLResultHasError(result) {
    return result.errors && result.errors.length;
}

function deepFreeze(o) {
    Object.freeze(o);
    Object.getOwnPropertyNames(o).forEach(function (prop) {
        if (o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    });
    return o;
}
function maybeDeepFreeze(obj) {
    if (isDevelopment() || isTest()) {
        var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';
        if (!symbolIsPolyfilled) {
            return deepFreeze(obj);
        }
    }
    return obj;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function mergeDeep() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
    var target = sources[0] || {};
    var count = sources.length;
    if (count > 1) {
        var pastCopies = [];
        target = shallowCopyForMerge(target, pastCopies);
        for (var i = 1; i < count; ++i) {
            target = mergeHelper(target, sources[i], pastCopies);
        }
    }
    return target;
}
function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}
function mergeHelper(target, source, pastCopies) {
    if (isObject(source) && isObject(target)) {
        if (Object.isExtensible && !Object.isExtensible(target)) {
            target = shallowCopyForMerge(target, pastCopies);
        }
        Object.keys(source).forEach(function (sourceKey) {
            var sourceValue = source[sourceKey];
            if (hasOwnProperty.call(target, sourceKey)) {
                var targetValue = target[sourceKey];
                if (sourceValue !== targetValue) {
                    target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);
                }
            }
            else {
                target[sourceKey] = sourceValue;
            }
        });
        return target;
    }
    return source;
}
function shallowCopyForMerge(value, pastCopies) {
    if (value !== null &&
        typeof value === 'object' &&
        pastCopies.indexOf(value) < 0) {
        if (Array.isArray(value)) {
            value = value.slice(0);
        }
        else {
            value = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({ __proto__: Object.getPrototypeOf(value) }, value);
        }
        pastCopies.push(value);
    }
    return value;
}

var haveWarned = Object.create({});
function warnOnceInDevelopment(msg, type) {
    if (type === void 0) { type = 'warn'; }
    if (!isProduction() && !haveWarned[msg]) {
        if (!isTest()) {
            haveWarned[msg] = true;
        }
        if (type === 'error') {
            console.error(msg);
        }
        else {
            console.warn(msg);
        }
    }
}

function stripSymbols(data) {
    return JSON.parse(JSON.stringify(data));
}


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/***/ ((module) => {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};


/***/ }),

/***/ "./node_modules/graphql-tag/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/graphql-tag/src/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parser = __webpack_require__(/*! graphql/language/parser */ "./node_modules/graphql/language/parser.js");

var parse = parser.parse;

// Strip insignificant whitespace
// Note that this could do a lot more, such as reorder fields etc.
function normalize(string) {
  return string.replace(/[\s,]+/g, ' ').trim();
}

// A map docString -> graphql document
var docCache = {};

// A map fragmentName -> [normalized source]
var fragmentSourceMap = {};

function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}

// For testing.
function resetCaches() {
  docCache = {};
  fragmentSourceMap = {};
}

// Take a unstripped parsed document (query/mutation or even fragment), and
// check all fragment definitions, checking for name->source uniqueness.
// We also want to make sure only unique fragments exist in the document.
var printFragmentWarnings = true;
function processFragments(ast) {
  var astFragmentMap = {};
  var definitions = [];

  for (var i = 0; i < ast.definitions.length; i++) {
    var fragmentDefinition = ast.definitions[i];

    if (fragmentDefinition.kind === 'FragmentDefinition') {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);

      // We know something about this fragment
      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {

        // this is a problem because the app developer is trying to register another fragment with
        // the same name as one previously registered. So, we tell them about it.
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\n"
            + "graphql-tag enforces all fragment names across your application to be unique; read more about\n"
            + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }

        fragmentSourceMap[fragmentName][sourceKey] = true;

      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
        fragmentSourceMap[fragmentName] = {};
        fragmentSourceMap[fragmentName][sourceKey] = true;
      }

      if (!astFragmentMap[sourceKey]) {
        astFragmentMap[sourceKey] = true;
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  }

  ast.definitions = definitions;
  return ast;
}

function disableFragmentWarnings() {
  printFragmentWarnings = false;
}

function stripLoc(doc, removeLocAtThisLevel) {
  var docType = Object.prototype.toString.call(doc);

  if (docType === '[object Array]') {
    return doc.map(function (d) {
      return stripLoc(d, removeLocAtThisLevel);
    });
  }

  if (docType !== '[object Object]') {
    throw new Error('Unexpected input.');
  }

  // We don't want to remove the root loc field so we can use it
  // for fragment substitution (see below)
  if (removeLocAtThisLevel && doc.loc) {
    delete doc.loc;
  }

  // https://github.com/apollographql/graphql-tag/issues/40
  if (doc.loc) {
    delete doc.loc.startToken;
    delete doc.loc.endToken;
  }

  var keys = Object.keys(doc);
  var key;
  var value;
  var valueType;

  for (key in keys) {
    if (keys.hasOwnProperty(key)) {
      value = doc[keys[key]];
      valueType = Object.prototype.toString.call(value);

      if (valueType === '[object Object]' || valueType === '[object Array]') {
        doc[keys[key]] = stripLoc(value, true);
      }
    }
  }

  return doc;
}

var experimentalFragmentVariables = false;
function parseDocument(doc) {
  var cacheKey = normalize(doc);

  if (docCache[cacheKey]) {
    return docCache[cacheKey];
  }

  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });
  if (!parsed || parsed.kind !== 'Document') {
    throw new Error('Not a valid GraphQL document.');
  }

  // check that all "new" fragments inside the documents are consistent with
  // existing fragments of the same name
  parsed = processFragments(parsed);
  parsed = stripLoc(parsed, false);
  docCache[cacheKey] = parsed;

  return parsed;
}

function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}

function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}

// XXX This should eventually disallow arbitrary string interpolation, like Relay does
function gql(/* arguments */) {
  var args = Array.prototype.slice.call(arguments);

  var literals = args[0];

  // We always get literals[0] and then matching post literals for each arg given
  var result = (typeof(literals) === "string") ? literals : literals[0];

  for (var i = 1; i < args.length; i++) {
    if (args[i] && args[i].kind && args[i].kind === 'Document') {
      result += args[i].loc.source.body;
    } else {
      result += args[i];
    }

    result += literals[i];
  }

  return parseDocument(result);
}

// Support typescript, which isn't as nice as Babel about default exports
gql.default = gql;
gql.resetCaches = resetCaches;
gql.disableFragmentWarnings = disableFragmentWarnings;
gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;

module.exports = gql;


/***/ }),

/***/ "./node_modules/graphql/error/GraphQLError.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/error/GraphQLError.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.printError = printError;
exports.GraphQLError = void 0;

var _isObjectLike = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isObjectLike */ "./node_modules/graphql/jsutils/isObjectLike.js"));

var _symbols = __webpack_require__(/*! ../polyfills/symbols */ "./node_modules/graphql/polyfills/symbols.js");

var _location = __webpack_require__(/*! ../language/location */ "./node_modules/graphql/language/location.js");

var _printLocation = __webpack_require__(/*! ../language/printLocation */ "./node_modules/graphql/language/printLocation.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * A GraphQLError describes an Error found during the parse, validate, or
 * execute phases of performing a GraphQL operation. In addition to a message
 * and stack trace, it also includes information about the locations in a
 * GraphQL document and/or execution result that correspond to the Error.
 */
var GraphQLError = /*#__PURE__*/function (_Error) {
  _inherits(GraphQLError, _Error);

  var _super = _createSuper(GraphQLError);

  /**
   * A message describing the Error for debugging purposes.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   *
   * Note: should be treated as readonly, despite invariant usage.
   */

  /**
   * An array of { line, column } locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */

  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */

  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */

  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */

  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */

  /**
   * The original error thrown from a field resolver during execution.
   */

  /**
   * Extension fields to add to the formatted error.
   */
  function GraphQLError(message, nodes, source, positions, path, originalError, extensions) {
    var _locations2, _source2, _positions2, _extensions2;

    var _this;

    _classCallCheck(this, GraphQLError);

    _this = _super.call(this, message); // Compute list of blame nodes.

    var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.


    var _source = source;

    if (!_source && _nodes) {
      var _nodes$0$loc;

      _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;
    }

    var _positions = positions;

    if (!_positions && _nodes) {
      _positions = _nodes.reduce(function (list, node) {
        if (node.loc) {
          list.push(node.loc.start);
        }

        return list;
      }, []);
    }

    if (_positions && _positions.length === 0) {
      _positions = undefined;
    }

    var _locations;

    if (positions && source) {
      _locations = positions.map(function (pos) {
        return (0, _location.getLocation)(source, pos);
      });
    } else if (_nodes) {
      _locations = _nodes.reduce(function (list, node) {
        if (node.loc) {
          list.push((0, _location.getLocation)(node.loc.source, node.loc.start));
        }

        return list;
      }, []);
    }

    var _extensions = extensions;

    if (_extensions == null && originalError != null) {
      var originalExtensions = originalError.extensions;

      if ((0, _isObjectLike.default)(originalExtensions)) {
        _extensions = originalExtensions;
      }
    }

    Object.defineProperties(_assertThisInitialized(_this), {
      name: {
        value: 'GraphQLError'
      },
      message: {
        value: message,
        // By being enumerable, JSON.stringify will include `message` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: true,
        writable: true
      },
      locations: {
        // Coercing falsy values to undefined ensures they will not be included
        // in JSON.stringify() when not provided.
        value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : undefined,
        // By being enumerable, JSON.stringify will include `locations` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: _locations != null
      },
      path: {
        // Coercing falsy values to undefined ensures they will not be included
        // in JSON.stringify() when not provided.
        value: path !== null && path !== void 0 ? path : undefined,
        // By being enumerable, JSON.stringify will include `path` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: path != null
      },
      nodes: {
        value: _nodes !== null && _nodes !== void 0 ? _nodes : undefined
      },
      source: {
        value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : undefined
      },
      positions: {
        value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : undefined
      },
      originalError: {
        value: originalError
      },
      extensions: {
        // Coercing falsy values to undefined ensures they will not be included
        // in JSON.stringify() when not provided.
        value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : undefined,
        // By being enumerable, JSON.stringify will include `path` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: _extensions != null
      }
    }); // Include (non-enumerable) stack trace.

    if (originalError === null || originalError === void 0 ? void 0 : originalError.stack) {
      Object.defineProperty(_assertThisInitialized(_this), 'stack', {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
      return _possibleConstructorReturn(_this);
    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')


    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError);
    } else {
      Object.defineProperty(_assertThisInitialized(_this), 'stack', {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }

    return _this;
  }

  _createClass(GraphQLError, [{
    key: "toString",
    value: function toString() {
      return printError(this);
    } // FIXME: workaround to not break chai comparisons, should be remove in v16
    // $FlowFixMe Flow doesn't support computed properties yet

  }, {
    key: _symbols.SYMBOL_TO_STRING_TAG,
    get: function get() {
      return 'Object';
    }
  }]);

  return GraphQLError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Prints a GraphQLError to a string, representing useful location information
 * about the error's position in the source.
 */


exports.GraphQLError = GraphQLError;

function printError(error) {
  var output = error.message;

  if (error.nodes) {
    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];

      if (node.loc) {
        output += '\n\n' + (0, _printLocation.printLocation)(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
      var location = _error$locations2[_i4];
      output += '\n\n' + (0, _printLocation.printSourceLocation)(error.source, location);
    }
  }

  return output;
}


/***/ }),

/***/ "./node_modules/graphql/error/syntaxError.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/error/syntaxError.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.syntaxError = syntaxError;

var _GraphQLError = __webpack_require__(/*! ./GraphQLError */ "./node_modules/graphql/error/GraphQLError.js");

/**
 * Produces a GraphQLError representing a syntax error, containing useful
 * descriptive information about the syntax error's position in the source.
 */
function syntaxError(source, position, description) {
  return new _GraphQLError.GraphQLError("Syntax Error: ".concat(description), undefined, source, [position]);
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/defineInspect.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphql/jsutils/defineInspect.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = defineInspect;

var _invariant = _interopRequireDefault(__webpack_require__(/*! ./invariant */ "./node_modules/graphql/jsutils/invariant.js"));

var _nodejsCustomInspectSymbol = _interopRequireDefault(__webpack_require__(/*! ./nodejsCustomInspectSymbol */ "./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The `defineInspect()` function defines `inspect()` prototype method as alias of `toJSON`
 */
function defineInspect(classObject) {
  var fn = classObject.prototype.toJSON;
  typeof fn === 'function' || (0, _invariant.default)(0);
  classObject.prototype.inspect = fn; // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2317')

  if (_nodejsCustomInspectSymbol.default) {
    classObject.prototype[_nodejsCustomInspectSymbol.default] = fn;
  }
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/devAssert.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/devAssert.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = devAssert;

function devAssert(condition, message) {
  var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

  if (!booleanCondition) {
    throw new Error(message);
  }
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/inspect.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = inspect;

var _nodejsCustomInspectSymbol = _interopRequireDefault(__webpack_require__(/*! ./nodejsCustomInspectSymbol */ "./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */

function inspect(value) {
  return formatValue(value, []);
}

function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case 'string':
      return JSON.stringify(value);

    case 'function':
      return value.name ? "[function ".concat(value.name, "]") : '[function]';

    case 'object':
      if (value === null) {
        return 'null';
      }

      return formatObjectValue(value, seenValues);

    default:
      return String(value);
  }
}

function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return '[Circular]';
  }

  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);

  if (customInspectFn !== undefined) {
    // $FlowFixMe(>=0.90.0)
    var customValue = customInspectFn.call(value); // check for infinite recursion

    if (customValue !== value) {
      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }

  return formatObject(value, seenValues);
}

function formatObject(object, seenValues) {
  var keys = Object.keys(object);

  if (keys.length === 0) {
    return '{}';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[' + getObjectTag(object) + ']';
  }

  var properties = keys.map(function (key) {
    var value = formatValue(object[key], seenValues);
    return key + ': ' + value;
  });
  return '{ ' + properties.join(', ') + ' }';
}

function formatArray(array, seenValues) {
  if (array.length === 0) {
    return '[]';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[Array]';
  }

  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];

  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }

  if (remaining === 1) {
    items.push('... 1 more item');
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }

  return '[' + items.join(', ') + ']';
}

function getCustomFn(object) {
  var customInspectFn = object[String(_nodejsCustomInspectSymbol.default)];

  if (typeof customInspectFn === 'function') {
    return customInspectFn;
  }

  if (typeof object.inspect === 'function') {
    return object.inspect;
  }
}

function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');

  if (tag === 'Object' && typeof object.constructor === 'function') {
    var name = object.constructor.name;

    if (typeof name === 'string' && name !== '') {
      return name;
    }
  }

  return tag;
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/invariant.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/invariant.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = invariant;

function invariant(condition, message) {
  var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

  if (!booleanCondition) {
    throw new Error(message != null ? message : 'Unexpected invariant triggered.');
  }
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/isObjectLike.js":
/*!******************************************************!*\
  !*** ./node_modules/graphql/jsutils/isObjectLike.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isObjectLike;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Return true if `value` is object-like. A value is object-like if it's not
 * `null` and has a `typeof` result of "object".
 */
function isObjectLike(value) {
  return _typeof(value) == 'object' && value !== null;
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;
var _default = nodejsCustomInspectSymbol;
exports.default = _default;


/***/ }),

/***/ "./node_modules/graphql/language/ast.js":
/*!**********************************************!*\
  !*** ./node_modules/graphql/language/ast.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNode = isNode;
exports.Token = exports.Location = void 0;

var _defineInspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/defineInspect */ "./node_modules/graphql/jsutils/defineInspect.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Contains a range of UTF-8 character offsets and token references that
 * identify the region of the source from which the AST derived.
 */
var Location = /*#__PURE__*/function () {
  /**
   * The character offset at which this Node begins.
   */

  /**
   * The character offset at which this Node ends.
   */

  /**
   * The Token at which this Node begins.
   */

  /**
   * The Token at which this Node ends.
   */

  /**
   * The Source document the AST represents.
   */
  function Location(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }

  var _proto = Location.prototype;

  _proto.toJSON = function toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  };

  return Location;
}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.


exports.Location = Location;
(0, _defineInspect.default)(Location);
/**
 * Represents a range of characters represented by a lexical token
 * within a Source.
 */

var Token = /*#__PURE__*/function () {
  /**
   * The kind of Token.
   */

  /**
   * The character offset at which this Node begins.
   */

  /**
   * The character offset at which this Node ends.
   */

  /**
   * The 1-indexed line number on which this Token appears.
   */

  /**
   * The 1-indexed column number at which this Token begins.
   */

  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   */

  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  function Token(kind, start, end, line, column, prev, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev;
    this.next = null;
  }

  var _proto2 = Token.prototype;

  _proto2.toJSON = function toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };

  return Token;
}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.


exports.Token = Token;
(0, _defineInspect.default)(Token);
/**
 * @internal
 */

function isNode(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === 'string';
}
/**
 * The list of all possible AST node types.
 */


/***/ }),

/***/ "./node_modules/graphql/language/blockString.js":
/*!******************************************************!*\
  !*** ./node_modules/graphql/language/blockString.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.dedentBlockStringValue = dedentBlockStringValue;
exports.getBlockStringIndentation = getBlockStringIndentation;
exports.printBlockString = printBlockString;

/**
 * Produces the value of a block string from its parsed raw value, similar to
 * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
 *
 * This implements the GraphQL spec's BlockStringValue() static algorithm.
 *
 * @internal
 */
function dedentBlockStringValue(rawString) {
  // Expand a block string's raw value into independent lines.
  var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

  var commonIndent = getBlockStringIndentation(lines);

  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  } // Remove leading and trailing blank lines.


  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }

  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  } // Return a string of the lines joined with U+000A.


  return lines.join('\n');
}
/**
 * @internal
 */


function getBlockStringIndentation(lines) {
  var commonIndent = null;

  for (var i = 1; i < lines.length; i++) {
    var line = lines[i];
    var indent = leadingWhitespace(line);

    if (indent === line.length) {
      continue; // skip empty lines
    }

    if (commonIndent === null || indent < commonIndent) {
      commonIndent = indent;

      if (commonIndent === 0) {
        break;
      }
    }
  }

  return commonIndent === null ? 0 : commonIndent;
}

function leadingWhitespace(str) {
  var i = 0;

  while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
    i++;
  }

  return i;
}

function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 *
 * @internal
 */


function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSingleLine = value.indexOf('\n') === -1;
  var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
  var hasTrailingQuote = value[value.length - 1] === '"';
  var hasTrailingSlash = value[value.length - 1] === '\\';
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result = ''; // Format a multi-line block quote to account for leading space.

  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += '\n' + indentation;
  }

  result += indentation ? value.replace(/\n/g, '\n' + indentation) : value;

  if (printAsMultipleLines) {
    result += '\n';
  }

  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}


/***/ }),

/***/ "./node_modules/graphql/language/directiveLocation.js":
/*!************************************************************!*\
  !*** ./node_modules/graphql/language/directiveLocation.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DirectiveLocation = void 0;

/**
 * The set of allowed directive location values.
 */
var DirectiveLocation = Object.freeze({
  // Request Definitions
  QUERY: 'QUERY',
  MUTATION: 'MUTATION',
  SUBSCRIPTION: 'SUBSCRIPTION',
  FIELD: 'FIELD',
  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
  INLINE_FRAGMENT: 'INLINE_FRAGMENT',
  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
  // Type System Definitions
  SCHEMA: 'SCHEMA',
  SCALAR: 'SCALAR',
  OBJECT: 'OBJECT',
  FIELD_DEFINITION: 'FIELD_DEFINITION',
  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
  INTERFACE: 'INTERFACE',
  UNION: 'UNION',
  ENUM: 'ENUM',
  ENUM_VALUE: 'ENUM_VALUE',
  INPUT_OBJECT: 'INPUT_OBJECT',
  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
});
/**
 * The enum type representing the directive location values.
 */

exports.DirectiveLocation = DirectiveLocation;


/***/ }),

/***/ "./node_modules/graphql/language/kinds.js":
/*!************************************************!*\
  !*** ./node_modules/graphql/language/kinds.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Kind = void 0;

/**
 * The set of allowed kind values for AST nodes.
 */
var Kind = Object.freeze({
  // Name
  NAME: 'Name',
  // Document
  DOCUMENT: 'Document',
  OPERATION_DEFINITION: 'OperationDefinition',
  VARIABLE_DEFINITION: 'VariableDefinition',
  SELECTION_SET: 'SelectionSet',
  FIELD: 'Field',
  ARGUMENT: 'Argument',
  // Fragments
  FRAGMENT_SPREAD: 'FragmentSpread',
  INLINE_FRAGMENT: 'InlineFragment',
  FRAGMENT_DEFINITION: 'FragmentDefinition',
  // Values
  VARIABLE: 'Variable',
  INT: 'IntValue',
  FLOAT: 'FloatValue',
  STRING: 'StringValue',
  BOOLEAN: 'BooleanValue',
  NULL: 'NullValue',
  ENUM: 'EnumValue',
  LIST: 'ListValue',
  OBJECT: 'ObjectValue',
  OBJECT_FIELD: 'ObjectField',
  // Directives
  DIRECTIVE: 'Directive',
  // Types
  NAMED_TYPE: 'NamedType',
  LIST_TYPE: 'ListType',
  NON_NULL_TYPE: 'NonNullType',
  // Type System Definitions
  SCHEMA_DEFINITION: 'SchemaDefinition',
  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
  // Type Definitions
  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
  FIELD_DEFINITION: 'FieldDefinition',
  INPUT_VALUE_DEFINITION: 'InputValueDefinition',
  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
  // Directive Definitions
  DIRECTIVE_DEFINITION: 'DirectiveDefinition',
  // Type System Extensions
  SCHEMA_EXTENSION: 'SchemaExtension',
  // Type Extensions
  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
  UNION_TYPE_EXTENSION: 'UnionTypeExtension',
  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
});
/**
 * The enum type representing the possible kind values of AST nodes.
 */

exports.Kind = Kind;


/***/ }),

/***/ "./node_modules/graphql/language/lexer.js":
/*!************************************************!*\
  !*** ./node_modules/graphql/language/lexer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
exports.Lexer = void 0;

var _syntaxError = __webpack_require__(/*! ../error/syntaxError */ "./node_modules/graphql/error/syntaxError.js");

var _ast = __webpack_require__(/*! ./ast */ "./node_modules/graphql/language/ast.js");

var _tokenKind = __webpack_require__(/*! ./tokenKind */ "./node_modules/graphql/language/tokenKind.js");

var _blockString = __webpack_require__(/*! ./blockString */ "./node_modules/graphql/language/blockString.js");

/**
 * Given a Source object, creates a Lexer for that source.
 * A Lexer is a stateful stream generator in that every time
 * it is advanced, it returns the next token in the Source. Assuming the
 * source lexes, the final Token emitted by the lexer will be of kind
 * EOF, after which the lexer will repeatedly return the same EOF token
 * whenever called.
 */
var Lexer = /*#__PURE__*/function () {
  /**
   * The previously focused non-ignored token.
   */

  /**
   * The currently focused non-ignored token.
   */

  /**
   * The (1-indexed) line containing the current token.
   */

  /**
   * The character offset at which the current line begins.
   */
  function Lexer(source) {
    var startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0, null);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */


  var _proto = Lexer.prototype;

  _proto.advance = function advance() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  ;

  _proto.lookahead = function lookahead() {
    var token = this.token;

    if (token.kind !== _tokenKind.TokenKind.EOF) {
      do {
        var _token$next;

        // Note: next is only mutable during parsing, so we cast to allow this.
        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
      } while (token.kind === _tokenKind.TokenKind.COMMENT);
    }

    return token;
  };

  return Lexer;
}();
/**
 * @internal
 */


exports.Lexer = Lexer;

function isPunctuatorTokenKind(kind) {
  return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
}

function printCharCode(code) {
  return (// NaN/undefined represents access beyond the end of the file.
    isNaN(code) ? _tokenKind.TokenKind.EOF : // Trust JSON for ASCII.
    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.
    "\"\\u".concat(('00' + code.toString(16).toUpperCase()).slice(-4), "\"")
  );
}
/**
 * Gets the next token from the source starting at the given position.
 *
 * This skips over whitespace until it finds the next lexable token, then lexes
 * punctuators immediately or calls the appropriate helper function for more
 * complicated tokens.
 */


function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = positionAfterWhitespace(body, prev.end, lexer);
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;

  if (pos >= bodyLength) {
    return new _ast.Token(_tokenKind.TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
  }

  var code = body.charCodeAt(pos); // SourceCharacter

  switch (code) {
    // !
    case 33:
      return new _ast.Token(_tokenKind.TokenKind.BANG, pos, pos + 1, line, col, prev);
    // #

    case 35:
      return readComment(source, pos, line, col, prev);
    // $

    case 36:
      return new _ast.Token(_tokenKind.TokenKind.DOLLAR, pos, pos + 1, line, col, prev);
    // &

    case 38:
      return new _ast.Token(_tokenKind.TokenKind.AMP, pos, pos + 1, line, col, prev);
    // (

    case 40:
      return new _ast.Token(_tokenKind.TokenKind.PAREN_L, pos, pos + 1, line, col, prev);
    // )

    case 41:
      return new _ast.Token(_tokenKind.TokenKind.PAREN_R, pos, pos + 1, line, col, prev);
    // .

    case 46:
      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
        return new _ast.Token(_tokenKind.TokenKind.SPREAD, pos, pos + 3, line, col, prev);
      }

      break;
    // :

    case 58:
      return new _ast.Token(_tokenKind.TokenKind.COLON, pos, pos + 1, line, col, prev);
    // =

    case 61:
      return new _ast.Token(_tokenKind.TokenKind.EQUALS, pos, pos + 1, line, col, prev);
    // @

    case 64:
      return new _ast.Token(_tokenKind.TokenKind.AT, pos, pos + 1, line, col, prev);
    // [

    case 91:
      return new _ast.Token(_tokenKind.TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);
    // ]

    case 93:
      return new _ast.Token(_tokenKind.TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);
    // {

    case 123:
      return new _ast.Token(_tokenKind.TokenKind.BRACE_L, pos, pos + 1, line, col, prev);
    // |

    case 124:
      return new _ast.Token(_tokenKind.TokenKind.PIPE, pos, pos + 1, line, col, prev);
    // }

    case 125:
      return new _ast.Token(_tokenKind.TokenKind.BRACE_R, pos, pos + 1, line, col, prev);
    // A-Z _ a-z

    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 95:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
      return readName(source, pos, line, col, prev);
    // - 0-9

    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return readNumber(source, pos, code, line, col, prev);
    // "

    case 34:
      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
        return readBlockString(source, pos, line, col, prev, lexer);
      }

      return readString(source, pos, line, col, prev);
  }

  throw (0, _syntaxError.syntaxError)(source, pos, unexpectedCharacterMessage(code));
}
/**
 * Report a message that an unexpected character was encountered.
 */


function unexpectedCharacterMessage(code) {
  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }

  if (code === 39) {
    // '
    return 'Unexpected single quote character (\'), did you mean to use a double quote (")?';
  }

  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
/**
 * Reads from body starting at startPosition until it finds a non-whitespace
 * character, then returns the position of that character for lexing.
 */


function positionAfterWhitespace(body, startPosition, lexer) {
  var bodyLength = body.length;
  var position = startPosition;

  while (position < bodyLength) {
    var code = body.charCodeAt(position); // tab | space | comma | BOM

    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {
      ++position;
    } else if (code === 10) {
      // new line
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      // carriage return
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }

      ++lexer.line;
      lexer.lineStart = position;
    } else {
      break;
    }
  }

  return position;
}
/**
 * Reads a comment token from the source file.
 *
 * #[\u0009\u0020-\uFFFF]*
 */


function readComment(source, start, line, col, prev) {
  var body = source.body;
  var code;
  var position = start;

  do {
    code = body.charCodeAt(++position);
  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator
  code > 0x001f || code === 0x0009));

  return new _ast.Token(_tokenKind.TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
}
/**
 * Reads a number token from the source file, either a float
 * or an int depending on whether a decimal point appears.
 *
 * Int:   -?(0|[1-9][0-9]*)
 * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
 */


function readNumber(source, start, firstCode, line, col, prev) {
  var body = source.body;
  var code = firstCode;
  var position = start;
  var isFloat = false;

  if (code === 45) {
    // -
    code = body.charCodeAt(++position);
  }

  if (code === 48) {
    // 0
    code = body.charCodeAt(++position);

    if (code >= 48 && code <= 57) {
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }

  if (code === 46) {
    // .
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }

  if (code === 69 || code === 101) {
    // E e
    isFloat = true;
    code = body.charCodeAt(++position);

    if (code === 43 || code === 45) {
      // + -
      code = body.charCodeAt(++position);
    }

    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  } // Numbers cannot be followed by . or NameStart


  if (code === 46 || isNameStart(code)) {
    throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }

  return new _ast.Token(isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
}
/**
 * Returns the new position in the source after reading digits.
 */


function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;

  if (code >= 48 && code <= 57) {
    // 0 - 9
    do {
      code = body.charCodeAt(++position);
    } while (code >= 48 && code <= 57); // 0 - 9


    return position;
  }

  throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
/**
 * Reads a string token from the source file.
 *
 * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
 */


function readString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code = 0;
  var value = '';

  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator
  code !== 0x000a && code !== 0x000d) {
    // Closing Quote (")
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return new _ast.Token(_tokenKind.TokenKind.STRING, start, position + 1, line, col, prev, value);
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009) {
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }

    ++position;

    if (code === 92) {
      // \
      value += body.slice(chunkStart, position - 1);
      code = body.charCodeAt(position);

      switch (code) {
        case 34:
          value += '"';
          break;

        case 47:
          value += '/';
          break;

        case 92:
          value += '\\';
          break;

        case 98:
          value += '\b';
          break;

        case 102:
          value += '\f';
          break;

        case 110:
          value += '\n';
          break;

        case 114:
          value += '\r';
          break;

        case 116:
          value += '\t';
          break;

        case 117:
          {
            // uXXXX
            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));

            if (charCode < 0) {
              var invalidSequence = body.slice(position + 1, position + 5);
              throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
            }

            value += String.fromCharCode(charCode);
            position += 4;
            break;
          }

        default:
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }

      ++position;
      chunkStart = position;
    }
  }

  throw (0, _syntaxError.syntaxError)(source, position, 'Unterminated string.');
}
/**
 * Reads a block string token from the source file.
 *
 * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
 */


function readBlockString(source, start, line, col, prev, lexer) {
  var body = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code = 0;
  var rawValue = '';

  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
    // Closing Triple-Quote (""")
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      rawValue += body.slice(chunkStart, position);
      return new _ast.Token(_tokenKind.TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockString.dedentBlockStringValue)(rawValue));
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }

    if (code === 10) {
      // new line
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      // carriage return
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }

      ++lexer.line;
      lexer.lineStart = position;
    } else if ( // Escape Triple-Quote (\""")
    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      rawValue += body.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }

  throw (0, _syntaxError.syntaxError)(source, position, 'Unterminated string.');
}
/**
 * Converts four hexadecimal chars to the integer that the
 * string represents. For example, uniCharCode('0','0','0','f')
 * will return 15, and uniCharCode('0','0','f','f') returns 255.
 *
 * Returns a negative number on error, if a char was invalid.
 *
 * This is implemented by noting that char2hex() returns -1 on error,
 * which means the result of ORing the char2hex() will also be negative.
 */


function uniCharCode(a, b, c, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
}
/**
 * Converts a hex character to its integer value.
 * '0' becomes 0, '9' becomes 9
 * 'A' becomes 10, 'F' becomes 15
 * 'a' becomes 10, 'f' becomes 15
 *
 * Returns -1 on error.
 */


function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 // 0-9
  : a >= 65 && a <= 70 ? a - 55 // A-F
  : a >= 97 && a <= 102 ? a - 87 // a-f
  : -1;
}
/**
 * Reads an alphanumeric + underscore name from the source.
 *
 * [_A-Za-z][_0-9A-Za-z]*
 */


function readName(source, start, line, col, prev) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start + 1;
  var code = 0;

  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _
  code >= 48 && code <= 57 || // 0-9
  code >= 65 && code <= 90 || // A-Z
  code >= 97 && code <= 122) // a-z
  ) {
    ++position;
  }

  return new _ast.Token(_tokenKind.TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
} // _ A-Z a-z


function isNameStart(code) {
  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
}


/***/ }),

/***/ "./node_modules/graphql/language/location.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/language/location.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getLocation = getLocation;

/**
 * Represents a location in a Source.
 */

/**
 * Takes a Source and a UTF-8 character offset, and returns the corresponding
 * line and column as a SourceLocation.
 */
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;

  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }

  return {
    line: line,
    column: column
  };
}


/***/ }),

/***/ "./node_modules/graphql/language/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/language/parser.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parse = parse;
exports.parseValue = parseValue;
exports.parseType = parseType;

var _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ "./node_modules/graphql/jsutils/inspect.js"));

var _devAssert = _interopRequireDefault(__webpack_require__(/*! ../jsutils/devAssert */ "./node_modules/graphql/jsutils/devAssert.js"));

var _syntaxError = __webpack_require__(/*! ../error/syntaxError */ "./node_modules/graphql/error/syntaxError.js");

var _kinds = __webpack_require__(/*! ./kinds */ "./node_modules/graphql/language/kinds.js");

var _ast = __webpack_require__(/*! ./ast */ "./node_modules/graphql/language/ast.js");

var _source = __webpack_require__(/*! ./source */ "./node_modules/graphql/language/source.js");

var _tokenKind = __webpack_require__(/*! ./tokenKind */ "./node_modules/graphql/language/tokenKind.js");

var _directiveLocation = __webpack_require__(/*! ./directiveLocation */ "./node_modules/graphql/language/directiveLocation.js");

var _lexer = __webpack_require__(/*! ./lexer */ "./node_modules/graphql/language/lexer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Given a GraphQL source, parses it into a Document.
 * Throws GraphQLError if a syntax error is encountered.
 */
function parse(source, options) {
  var parser = new Parser(source, options);
  return parser.parseDocument();
}
/**
 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
 * that value.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Values directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: valueFromAST().
 */


function parseValue(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(_tokenKind.TokenKind.SOF);
  var value = parser.parseValueLiteral(false);
  parser.expectToken(_tokenKind.TokenKind.EOF);
  return value;
}
/**
 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
 * that type.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Types directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: typeFromAST().
 */


function parseType(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(_tokenKind.TokenKind.SOF);
  var type = parser.parseTypeReference();
  parser.expectToken(_tokenKind.TokenKind.EOF);
  return type;
}

var Parser = /*#__PURE__*/function () {
  function Parser(source, options) {
    var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
    sourceObj instanceof _source.Source || (0, _devAssert.default)(0, "Must provide Source. Received: ".concat((0, _inspect.default)(sourceObj), "."));
    this._lexer = new _lexer.Lexer(sourceObj);
    this._options = options;
  }
  /**
   * Converts a name lex token into a name parse node.
   */


  var _proto = Parser.prototype;

  _proto.parseName = function parseName() {
    var token = this.expectToken(_tokenKind.TokenKind.NAME);
    return {
      kind: _kinds.Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  } // Implements the parsing rules in the Document section.

  /**
   * Document : Definition+
   */
  ;

  _proto.parseDocument = function parseDocument() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.DOCUMENT,
      definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF),
      loc: this.loc(start)
    };
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   */
  ;

  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(_tokenKind.TokenKind.NAME)) {
      switch (this._lexer.token.value) {
        case 'query':
        case 'mutation':
        case 'subscription':
          return this.parseOperationDefinition();

        case 'fragment':
          return this.parseFragmentDefinition();

        case 'schema':
        case 'scalar':
        case 'type':
        case 'interface':
        case 'union':
        case 'enum':
        case 'input':
        case 'directive':
          return this.parseTypeSystemDefinition();

        case 'extend':
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }

    throw this.unexpected();
  } // Implements the parsing rules in the Operations section.

  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  ;

  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;

    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
      return {
        kind: _kinds.Kind.OPERATION_DEFINITION,
        operation: 'query',
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }

    var operation = this.parseOperationType();
    var name;

    if (this.peek(_tokenKind.TokenKind.NAME)) {
      name = this.parseName();
    }

    return {
      kind: _kinds.Kind.OPERATION_DEFINITION,
      operation: operation,
      name: name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * OperationType : one of query mutation subscription
   */
  ;

  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);

    switch (operationToken.value) {
      case 'query':
        return 'query';

      case 'mutation':
        return 'mutation';

      case 'subscription':
        return 'subscription';
    }

    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  ;

  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  ;

  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,
      directives: this.parseDirectives(true),
      loc: this.loc(start)
    };
  }
  /**
   * Variable : $ Name
   */
  ;

  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(_tokenKind.TokenKind.DOLLAR);
    return {
      kind: _kinds.Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  }
  /**
   * SelectionSet : { Selection+ }
   */
  ;

  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.SELECTION_SET,
      selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  ;

  _proto.parseSelection = function parseSelection() {
    return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  ;

  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;

    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }

    return {
      kind: _kinds.Kind.FIELD,
      alias: alias,
      name: name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,
      loc: this.loc(start)
    };
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  ;

  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  ;

  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(_tokenKind.TokenKind.COLON);
    return {
      kind: _kinds.Kind.ARGUMENT,
      name: name,
      value: this.parseValueLiteral(false),
      loc: this.loc(start)
    };
  };

  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseValueLiteral(true)),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Fragments section.

  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  ;

  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(_tokenKind.TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword('on');

    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
      return {
        kind: _kinds.Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start)
      };
    }

    return {
      kind: _kinds.Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  ;

  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var _this$_options;

    var start = this._lexer.token;
    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes
    // the grammar of FragmentDefinition:
    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
      return {
        kind: _kinds.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }

    return {
      kind: _kinds.Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * FragmentName : Name but not `on`
   */
  ;

  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === 'on') {
      throw this.unexpected();
    }

    return this.parseName();
  } // Implements the parsing rules in the Values section.

  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  ;

  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;

    switch (token.kind) {
      case _tokenKind.TokenKind.BRACKET_L:
        return this.parseList(isConst);

      case _tokenKind.TokenKind.BRACE_L:
        return this.parseObject(isConst);

      case _tokenKind.TokenKind.INT:
        this._lexer.advance();

        return {
          kind: _kinds.Kind.INT,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind.TokenKind.FLOAT:
        this._lexer.advance();

        return {
          kind: _kinds.Kind.FLOAT,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind.TokenKind.STRING:
      case _tokenKind.TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();

      case _tokenKind.TokenKind.NAME:
        this._lexer.advance();

        switch (token.value) {
          case 'true':
            return {
              kind: _kinds.Kind.BOOLEAN,
              value: true,
              loc: this.loc(token)
            };

          case 'false':
            return {
              kind: _kinds.Kind.BOOLEAN,
              value: false,
              loc: this.loc(token)
            };

          case 'null':
            return {
              kind: _kinds.Kind.NULL,
              loc: this.loc(token)
            };

          default:
            return {
              kind: _kinds.Kind.ENUM,
              value: token.value,
              loc: this.loc(token)
            };
        }

      case _tokenKind.TokenKind.DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }

        break;
    }

    throw this.unexpected();
  };

  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;

    this._lexer.advance();

    return {
      kind: _kinds.Kind.STRING,
      value: token.value,
      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  ;

  _proto.parseList = function parseList(isConst) {
    var _this = this;

    var start = this._lexer.token;

    var item = function item() {
      return _this.parseValueLiteral(isConst);
    };

    return {
      kind: _kinds.Kind.LIST,
      values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R),
      loc: this.loc(start)
    };
  }
  /**
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   */
  ;

  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;

    var start = this._lexer.token;

    var item = function item() {
      return _this2.parseObjectField(isConst);
    };

    return {
      kind: _kinds.Kind.OBJECT,
      fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  ;

  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(_tokenKind.TokenKind.COLON);
    return {
      kind: _kinds.Kind.OBJECT_FIELD,
      name: name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Directives section.

  /**
   * Directives[Const] : Directive[?Const]+
   */
  ;

  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];

    while (this.peek(_tokenKind.TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }

    return directives;
  }
  /**
   * Directive[Const] : @ Name Arguments[?Const]?
   */
  ;

  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(_tokenKind.TokenKind.AT);
    return {
      kind: _kinds.Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Types section.

  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  ;

  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type;

    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
      type = this.parseTypeReference();
      this.expectToken(_tokenKind.TokenKind.BRACKET_R);
      type = {
        kind: _kinds.Kind.LIST_TYPE,
        type: type,
        loc: this.loc(start)
      };
    } else {
      type = this.parseNamedType();
    }

    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
      return {
        kind: _kinds.Kind.NON_NULL_TYPE,
        type: type,
        loc: this.loc(start)
      };
    }

    return type;
  }
  /**
   * NamedType : Name
   */
  ;

  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Type Definition section.

  /**
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  ;

  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    // Many definitions begin with a description and require a lookahead.
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;

    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
      switch (keywordToken.value) {
        case 'schema':
          return this.parseSchemaDefinition();

        case 'scalar':
          return this.parseScalarTypeDefinition();

        case 'type':
          return this.parseObjectTypeDefinition();

        case 'interface':
          return this.parseInterfaceTypeDefinition();

        case 'union':
          return this.parseUnionTypeDefinition();

        case 'enum':
          return this.parseEnumTypeDefinition();

        case 'input':
          return this.parseInputObjectTypeDefinition();

        case 'directive':
          return this.parseDirectiveDefinition();
      }
    }

    throw this.unexpected(keywordToken);
  };

  _proto.peekDescription = function peekDescription() {
    return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  ;

  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   */
  ;

  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('schema');
    var directives = this.parseDirectives(true);
    var operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
    return {
      kind: _kinds.Kind.SCHEMA_DEFINITION,
      description: description,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  ;

  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(_tokenKind.TokenKind.COLON);
    var type = this.parseNamedType();
    return {
      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
      operation: operation,
      type: type,
      loc: this.loc(start)
    };
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  ;

  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('scalar');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  ;

  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('type');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  ;

  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var types = [];

    if (this.expectOptionalKeyword('implements')) {
      // Optional leading ampersand
      this.expectOptionalToken(_tokenKind.TokenKind.AMP);

      do {
        var _this$_options2;

        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(_tokenKind.TokenKind.AMP) || // Legacy support for the SDL?
      ((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true && this.peek(_tokenKind.TokenKind.NAME));
    }

    return types;
  }
  /**
   * FieldsDefinition : { FieldDefinition+ }
   */
  ;

  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    var _this$_options3;

    // Legacy support for the SDL?
    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(_tokenKind.TokenKind.BRACE_L) && this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R) {
      this._lexer.advance();

      this._lexer.advance();

      return [];
    }

    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  ;

  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(_tokenKind.TokenKind.COLON);
    var type = this.parseTypeReference();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.FIELD_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      type: type,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  ;

  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  ;

  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(_tokenKind.TokenKind.COLON);
    var type = this.parseTypeReference();
    var defaultValue;

    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }

    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
      description: description,
      name: name,
      type: type,
      defaultValue: defaultValue,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  ;

  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('interface');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
      description: description,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  ;

  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('union');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: _kinds.Kind.UNION_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  ;

  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    var types = [];

    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
      // Optional leading pipe
      this.expectOptionalToken(_tokenKind.TokenKind.PIPE);

      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));
    }

    return types;
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  ;

  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('enum');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  }
  /**
   * EnumValuesDefinition : { EnumValueDefinition+ }
   */
  ;

  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   *
   * EnumValue : Name
   */
  ;

  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  ;

  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('input');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * InputFieldsDefinition : { InputValueDefinition+ }
   */
  ;

  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  ;

  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();

    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
      switch (keywordToken.value) {
        case 'schema':
          return this.parseSchemaExtension();

        case 'scalar':
          return this.parseScalarTypeExtension();

        case 'type':
          return this.parseObjectTypeExtension();

        case 'interface':
          return this.parseInterfaceTypeExtension();

        case 'union':
          return this.parseUnionTypeExtension();

        case 'enum':
          return this.parseEnumTypeExtension();

        case 'input':
          return this.parseInputObjectTypeExtension();
      }
    }

    throw this.unexpected(keywordToken);
  }
  /**
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   */
  ;

  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('schema');
    var directives = this.parseDirectives(true);
    var operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);

    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.SCHEMA_EXTENSION,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  ;

  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('scalar');
    var name = this.parseName();
    var directives = this.parseDirectives(true);

    if (directives.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  ;

  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('type');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();

    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  ;

  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('interface');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();

    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  ;

  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('union');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();

    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.UNION_TYPE_EXTENSION,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  ;

  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('enum');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();

    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  ;

  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('input');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();

    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   */
  ;

  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('directive');
    this.expectToken(_tokenKind.TokenKind.AT);
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword('repeatable');
    this.expectKeyword('on');
    var locations = this.parseDirectiveLocations();
    return {
      kind: _kinds.Kind.DIRECTIVE_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      repeatable: repeatable,
      locations: locations,
      loc: this.loc(start)
    };
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  ;

  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    // Optional leading pipe
    this.expectOptionalToken(_tokenKind.TokenKind.PIPE);
    var locations = [];

    do {
      locations.push(this.parseDirectiveLocation());
    } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));

    return locations;
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  ;

  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();

    if (_directiveLocation.DirectiveLocation[name.value] !== undefined) {
      return name;
    }

    throw this.unexpected(start);
  } // Core parsing utility functions

  /**
   * Returns a location object, used to identify the place in
   * the source that created a given parsed object.
   */
  ;

  _proto.loc = function loc(startToken) {
    var _this$_options4;

    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
      return new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
  }
  /**
   * Determines if the next token is of a given kind
   */
  ;

  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing
   * the lexer. Otherwise, do not change the parser state and throw an error.
   */
  ;

  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;

    if (token.kind === kind) {
      this._lexer.advance();

      return token;
    }

    throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
  }
  /**
   * If the next token is of the given kind, return that token after advancing
   * the lexer. Otherwise, do not change the parser state and return undefined.
   */
  ;

  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;

    if (token.kind === kind) {
      this._lexer.advance();

      return token;
    }

    return undefined;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  ;

  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;

    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Expected \"".concat(value, "\", found ").concat(getTokenDesc(token), "."));
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing
   * the lexer. Otherwise, do not change the parser state and return "false".
   */
  ;

  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;

    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
      this._lexer.advance();

      return true;
    }

    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token
   * is encountered.
   */
  ;

  _proto.unexpected = function unexpected(atToken) {
    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by
   * the parseFn. This list begins with a lex token of openKind
   * and ends with a lex token of closeKind. Advances the parser
   * to the next lex token after the closing token.
   */
  ;

  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];

    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }

    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always
   * return non-empty list that begins with a lex token of openKind and ends
   * with a lex token of closeKind. Advances the parser to the next lex token
   * after the closing token.
   */
  ;

  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];

      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));

      return nodes;
    }

    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by
   * the parseFn. This list begins with a lex token of openKind
   * and ends with a lex token of closeKind. Advances the parser
   * to the next lex token after the closing token.
   */
  ;

  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];

    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));

    return nodes;
  };

  return Parser;
}();
/**
 * A helper function to describe a token as a string for debugging
 */


function getTokenDesc(token) {
  var value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? " \"".concat(value, "\"") : '');
}
/**
 * A helper function to describe a token kind as a string for debugging
 */


function getTokenKindDesc(kind) {
  return (0, _lexer.isPunctuatorTokenKind)(kind) ? "\"".concat(kind, "\"") : kind;
}


/***/ }),

/***/ "./node_modules/graphql/language/printLocation.js":
/*!********************************************************!*\
  !*** ./node_modules/graphql/language/printLocation.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.printLocation = printLocation;
exports.printSourceLocation = printSourceLocation;

var _location = __webpack_require__(/*! ./location */ "./node_modules/graphql/language/location.js");

/**
 * Render a helpful description of the location in the GraphQL Source document.
 */
function printLocation(location) {
  return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
}
/**
 * Render a helpful description of the location in the GraphQL Source document.
 */


function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex]; // Special case for minified documents

  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];

    for (var i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }

    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function (subLine) {
      return ['', subLine];
    }), [[' ', whitespace(subLineColumnNum - 1) + '^'], ['', subLines[subLineIndex + 1]]]));
  }

  return locationStr + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
  ["".concat(lineNum - 1), lines[lineIndex - 1]], ["".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1), lines[lineIndex + 1]]]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter(function (_ref) {
    var _ = _ref[0],
        line = _ref[1];
    return line !== undefined;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function (_ref3) {
    var prefix = _ref3[0],
        line = _ref3[1];
    return leftPad(padLen, prefix) + (line ? ' | ' + line : ' |');
  }).join('\n');
}

function whitespace(len) {
  return Array(len + 1).join(' ');
}

function leftPad(len, str) {
  return whitespace(len - str.length) + str;
}


/***/ }),

/***/ "./node_modules/graphql/language/printer.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/language/printer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.print = print;

var _visitor = __webpack_require__(/*! ./visitor */ "./node_modules/graphql/language/visitor.js");

var _blockString = __webpack_require__(/*! ./blockString */ "./node_modules/graphql/language/blockString.js");

/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */
function print(ast) {
  return (0, _visitor.visit)(ast, {
    leave: printDocASTReducer
  });
} // TODO: provide better type coverage in future


var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return '$' + node.name;
  },
  // Document
  Document: function Document(node) {
    return join(node.definitions, '\n\n') + '\n';
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
    var directives = join(node.directives, ' ');
    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
    // the query short form.

    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable,
        type = _ref.type,
        defaultValue = _ref.defaultValue,
        directives = _ref.directives;
    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias,
        name = _ref3.name,
        args = _ref3.arguments,
        directives = _ref3.directives,
        selectionSet = _ref3.selectionSet;
    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name,
        value = _ref4.value;
    return name + ': ' + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name,
        directives = _ref5.directives;
    return '...' + name + wrap(' ', join(directives, ' '));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition,
        directives = _ref6.directives,
        selectionSet = _ref6.selectionSet;
    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name,
        typeCondition = _ref7.typeCondition,
        variableDefinitions = _ref7.variableDefinitions,
        directives = _ref7.directives,
        selectionSet = _ref7.selectionSet;
    return (// Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap('', join(directives, ' '), ' ')) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value,
        isBlockString = _ref10.block;
    return isBlockString ? (0, _blockString.printBlockString)(value, key === 'description' ? '' : '  ') : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? 'true' : 'false';
  },
  NullValue: function NullValue() {
    return 'null';
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return '[' + join(values, ', ') + ']';
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return '{' + join(fields, ', ') + '}';
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name,
        value = _ref15.value;
    return name + ': ' + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name = _ref16.name,
        args = _ref16.arguments;
    return '@' + name + wrap('(', join(args, ', '), ')');
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return '[' + type + ']';
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + '!';
  },
  // Type System Definitions
  SchemaDefinition: addDescription(function (_ref20) {
    var directives = _ref20.directives,
        operationTypes = _ref20.operationTypes;
    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
  }),
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation,
        type = _ref21.type;
    return operation + ': ' + type;
  },
  ScalarTypeDefinition: addDescription(function (_ref22) {
    var name = _ref22.name,
        directives = _ref22.directives;
    return join(['scalar', name, join(directives, ' ')], ' ');
  }),
  ObjectTypeDefinition: addDescription(function (_ref23) {
    var name = _ref23.name,
        interfaces = _ref23.interfaces,
        directives = _ref23.directives,
        fields = _ref23.fields;
    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  FieldDefinition: addDescription(function (_ref24) {
    var name = _ref24.name,
        args = _ref24.arguments,
        type = _ref24.type,
        directives = _ref24.directives;
    return name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));
  }),
  InputValueDefinition: addDescription(function (_ref25) {
    var name = _ref25.name,
        type = _ref25.type,
        defaultValue = _ref25.defaultValue,
        directives = _ref25.directives;
    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
  }),
  InterfaceTypeDefinition: addDescription(function (_ref26) {
    var name = _ref26.name,
        interfaces = _ref26.interfaces,
        directives = _ref26.directives,
        fields = _ref26.fields;
    return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  UnionTypeDefinition: addDescription(function (_ref27) {
    var name = _ref27.name,
        directives = _ref27.directives,
        types = _ref27.types;
    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  }),
  EnumTypeDefinition: addDescription(function (_ref28) {
    var name = _ref28.name,
        directives = _ref28.directives,
        values = _ref28.values;
    return join(['enum', name, join(directives, ' '), block(values)], ' ');
  }),
  EnumValueDefinition: addDescription(function (_ref29) {
    var name = _ref29.name,
        directives = _ref29.directives;
    return join([name, join(directives, ' ')], ' ');
  }),
  InputObjectTypeDefinition: addDescription(function (_ref30) {
    var name = _ref30.name,
        directives = _ref30.directives,
        fields = _ref30.fields;
    return join(['input', name, join(directives, ' '), block(fields)], ' ');
  }),
  DirectiveDefinition: addDescription(function (_ref31) {
    var name = _ref31.name,
        args = _ref31.arguments,
        repeatable = _ref31.repeatable,
        locations = _ref31.locations;
    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives,
        operationTypes = _ref32.operationTypes;
    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name,
        directives = _ref33.directives;
    return join(['extend scalar', name, join(directives, ' ')], ' ');
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name,
        interfaces = _ref34.interfaces,
        directives = _ref34.directives,
        fields = _ref34.fields;
    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name,
        interfaces = _ref35.interfaces,
        directives = _ref35.directives,
        fields = _ref35.fields;
    return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name,
        directives = _ref36.directives,
        types = _ref36.types;
    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name,
        directives = _ref37.directives,
        values = _ref37.values;
    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name,
        directives = _ref38.directives,
        fields = _ref38.fields;
    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
  }
};

function addDescription(cb) {
  return function (node) {
    return join([node.description, cb(node)], '\n');
  };
}
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */


function join(maybeArray) {
  var _maybeArray$filter$jo;

  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function (x) {
    return x;
  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : '';
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */


function block(array) {
  return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise
 * print an empty string.
 */


function wrap(start, maybeString) {
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return maybeString ? start + maybeString + end : '';
}

function indent(maybeString) {
  return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
}

function isMultiline(string) {
  return string.indexOf('\n') !== -1;
}

function hasMultilineItems(maybeArray) {
  return maybeArray && maybeArray.some(isMultiline);
}


/***/ }),

/***/ "./node_modules/graphql/language/source.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/language/source.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Source = void 0;

var _symbols = __webpack_require__(/*! ../polyfills/symbols */ "./node_modules/graphql/polyfills/symbols.js");

var _devAssert = _interopRequireDefault(__webpack_require__(/*! ../jsutils/devAssert */ "./node_modules/graphql/jsutils/devAssert.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are
 * optional, but they are useful for clients who store GraphQL documents in source files.
 * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might
 * be useful for `name` to be `"Foo.graphql"` and location to be `{ line: 40, column: 1 }`.
 * The `line` and `column` properties in `locationOffset` are 1-indexed.
 */
var Source = /*#__PURE__*/function () {
  function Source(body) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GraphQL request';
    var locationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      line: 1,
      column: 1
    };
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || (0, _devAssert.default)(0, 'line in locationOffset is 1-indexed and must be positive.');
    this.locationOffset.column > 0 || (0, _devAssert.default)(0, 'column in locationOffset is 1-indexed and must be positive.');
  } // $FlowFixMe Flow doesn't support computed properties yet


  _createClass(Source, [{
    key: _symbols.SYMBOL_TO_STRING_TAG,
    get: function get() {
      return 'Source';
    }
  }]);

  return Source;
}();

exports.Source = Source;


/***/ }),

/***/ "./node_modules/graphql/language/tokenKind.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/language/tokenKind.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TokenKind = void 0;

/**
 * An exported enum describing the different kinds of tokens that the
 * lexer emits.
 */
var TokenKind = Object.freeze({
  SOF: '<SOF>',
  EOF: '<EOF>',
  BANG: '!',
  DOLLAR: '$',
  AMP: '&',
  PAREN_L: '(',
  PAREN_R: ')',
  SPREAD: '...',
  COLON: ':',
  EQUALS: '=',
  AT: '@',
  BRACKET_L: '[',
  BRACKET_R: ']',
  BRACE_L: '{',
  PIPE: '|',
  BRACE_R: '}',
  NAME: 'Name',
  INT: 'Int',
  FLOAT: 'Float',
  STRING: 'String',
  BLOCK_STRING: 'BlockString',
  COMMENT: 'Comment'
});
/**
 * The enum type representing the token kinds values.
 */

exports.TokenKind = TokenKind;


/***/ }),

/***/ "./node_modules/graphql/language/visitor.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/language/visitor.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.visit = visit;
exports.visitInParallel = visitInParallel;
exports.getVisitFn = getVisitFn;
exports.BREAK = exports.QueryDocumentKeys = void 0;

var _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ "./node_modules/graphql/jsutils/inspect.js"));

var _ast = __webpack_require__(/*! ./ast */ "./node_modules/graphql/language/ast.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QueryDocumentKeys = {
  Name: [],
  Document: ['definitions'],
  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
  Variable: ['name'],
  SelectionSet: ['selections'],
  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
  Argument: ['name', 'value'],
  FragmentSpread: ['name', 'directives'],
  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
  // or removed in the future.
  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ['values'],
  ObjectValue: ['fields'],
  ObjectField: ['name', 'value'],
  Directive: ['name', 'arguments'],
  NamedType: ['name'],
  ListType: ['type'],
  NonNullType: ['type'],
  SchemaDefinition: ['description', 'directives', 'operationTypes'],
  OperationTypeDefinition: ['type'],
  ScalarTypeDefinition: ['description', 'name', 'directives'],
  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
  InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
  EnumValueDefinition: ['description', 'name', 'directives'],
  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
  SchemaExtension: ['directives', 'operationTypes'],
  ScalarTypeExtension: ['name', 'directives'],
  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  UnionTypeExtension: ['name', 'directives', 'types'],
  EnumTypeExtension: ['name', 'directives', 'values'],
  InputObjectTypeExtension: ['name', 'directives', 'fields']
};
exports.QueryDocumentKeys = QueryDocumentKeys;
var BREAK = Object.freeze({});
/**
 * visit() will walk through an AST using a depth-first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     const editedAST = visit(ast, {
 *       enter(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: skip visiting this node
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       leave(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: no action
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     });
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to four permutations of the
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node of a specific kind.
 *
 *     visit(ast, {
 *       Kind(node) {
 *         // enter the "Kind" node
 *       }
 *     })
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     visit(ast, {
 *       Kind: {
 *         enter(node) {
 *           // enter the "Kind" node
 *         }
 *         leave(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     visit(ast, {
 *       enter(node) {
 *         // enter any node
 *       },
 *       leave(node) {
 *         // leave any node
 *       }
 *     })
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     visit(ast, {
 *       enter: {
 *         Kind(node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       leave: {
 *         Kind(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 */

exports.BREAK = BREAK;

function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

  /* eslint-disable no-undef-init */
  var stack = undefined;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = undefined;
  var key = undefined;
  var parent = undefined;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  /* eslint-enable no-undef-init */

  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;

    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();

      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};

          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }

          node = clone;
        }

        var editOffset = 0;

        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];

          if (inArray) {
            editKey -= editOffset;
          }

          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }

      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : undefined;
      node = parent ? parent[key] : newRoot;

      if (node === null || node === undefined) {
        continue;
      }

      if (parent) {
        path.push(key);
      }
    }

    var result = void 0;

    if (!Array.isArray(node)) {
      if (!(0, _ast.isNode)(node)) {
        throw new Error("Invalid AST Node: ".concat((0, _inspect.default)(node), "."));
      }

      var visitFn = getVisitFn(visitor, node.kind, isLeaving);

      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);

        if (result === BREAK) {
          break;
        }

        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);

          if (!isLeaving) {
            if ((0, _ast.isNode)(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }

    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }

    if (isLeaving) {
      path.pop();
    } else {
      var _visitorKeys$node$kin;

      stack = {
        inArray: inArray,
        index: index,
        keys: keys,
        edits: edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index = -1;
      edits = [];

      if (parent) {
        ancestors.push(parent);
      }

      parent = node;
    }
  } while (stack !== undefined);

  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }

  return newRoot;
}
/**
 * Creates a new visitor instance which delegates to many visitors to run in
 * parallel. Each visitor will be visited for each node before moving on.
 *
 * If a prior visitor edits a node, no following visitors will see that node.
 */


function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (skipping[i] == null) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          false);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (skipping[i] == null) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          true);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          }
        } else if (skipping[i] === node) {
          skipping[i] = null;
        }
      }
    }
  };
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 */


function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];

  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === 'function') {
      // { Kind() {} }
      return kindVisitor;
    }

    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

    if (typeof kindSpecificVisitor === 'function') {
      // { Kind: { enter() {}, leave() {} } }
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

    if (specificVisitor) {
      if (typeof specificVisitor === 'function') {
        // { enter() {}, leave() {} }
        return specificVisitor;
      }

      var specificKindVisitor = specificVisitor[kind];

      if (typeof specificKindVisitor === 'function') {
        // { enter: { Kind() {} }, leave: { Kind() {} } }
        return specificKindVisitor;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/graphql/polyfills/symbols.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/polyfills/symbols.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SYMBOL_TO_STRING_TAG = exports.SYMBOL_ASYNC_ITERATOR = exports.SYMBOL_ITERATOR = void 0;
// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator
// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
var SYMBOL_ITERATOR = typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'; // In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator
// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

exports.SYMBOL_ITERATOR = SYMBOL_ITERATOR;
var SYMBOL_ASYNC_ITERATOR = // $FlowFixMe Flow doesn't define `Symbol.asyncIterator` yet
typeof Symbol === 'function' ? Symbol.asyncIterator : '@@asyncIterator'; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

exports.SYMBOL_ASYNC_ITERATOR = SYMBOL_ASYNC_ITERATOR;
var SYMBOL_TO_STRING_TAG = // $FlowFixMe Flow doesn't define `Symbol.toStringTag` yet
typeof Symbol === 'function' ? Symbol.toStringTag : '@@toStringTag';
exports.SYMBOL_TO_STRING_TAG = SYMBOL_TO_STRING_TAG;


/***/ }),

/***/ "./node_modules/graphql/utilities/getOperationAST.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql/utilities/getOperationAST.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getOperationAST = getOperationAST;

var _kinds = __webpack_require__(/*! ../language/kinds */ "./node_modules/graphql/language/kinds.js");

/**
 * Returns an operation AST given a document AST and optionally an operation
 * name. If a name is not provided, an operation is only returned if only one is
 * provided in the document.
 */
function getOperationAST(documentAST, operationName) {
  var operation = null;

  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var definition = _documentAST$definiti2[_i2];

    if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
      var _definition$name;

      if (operationName == null) {
        // If no operation name was provided, only return an Operation if there
        // is one defined in the document. Upon encountering the second, return
        // null.
        if (operation) {
          return null;
        }

        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
        return definition;
      }
    }
  }

  return operation;
}


/***/ }),

/***/ "./node_modules/opentracing/lib/binary_carrier.js":
/*!********************************************************!*\
  !*** ./node_modules/opentracing/lib/binary_carrier.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Convenience class to use as a binary carrier.
 *
 * Any valid Object with a field named `buffer` may be used as a binary carrier;
 * this class is only one such type of object that can be used.
 */
var BinaryCarrier = /** @class */ (function () {
    function BinaryCarrier(buffer) {
        this.buffer = buffer;
    }
    return BinaryCarrier;
}());
exports.default = BinaryCarrier;
//# sourceMappingURL=binary_carrier.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/opentracing/lib/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * The FORMAT_BINARY format represents SpanContexts in an opaque binary
 * carrier.
 *
 * Tracer.inject() will set the buffer field to an Array-like (Array,
 * ArrayBuffer, or TypedBuffer) object containing the injected binary data.
 * Any valid Object can be used as long as the buffer field of the object
 * can be set.
 *
 * Tracer.extract() will look for `carrier.buffer`, and that field is
 * expected to be an Array-like object (Array, ArrayBuffer, or
 * TypedBuffer).
 */
exports.FORMAT_BINARY = 'binary';
/**
 * The FORMAT_TEXT_MAP format represents SpanContexts using a
 * string->string map (backed by a Javascript Object) as a carrier.
 *
 * NOTE: Unlike FORMAT_HTTP_HEADERS, FORMAT_TEXT_MAP places no restrictions
 * on the characters used in either the keys or the values of the map
 * entries.
 *
 * The FORMAT_TEXT_MAP carrier map may contain unrelated data (e.g.,
 * arbitrary gRPC metadata); as such, the Tracer implementation should use
 * a prefix or other convention to distinguish Tracer-specific key:value
 * pairs.
 */
exports.FORMAT_TEXT_MAP = 'text_map';
/**
 * The FORMAT_HTTP_HEADERS format represents SpanContexts using a
 * character-restricted string->string map (backed by a Javascript Object)
 * as a carrier.
 *
 * Keys and values in the FORMAT_HTTP_HEADERS carrier must be suitable for
 * use as HTTP headers (without modification or further escaping). That is,
 * the keys have a greatly restricted character set, casing for the keys
 * may not be preserved by various intermediaries, and the values should be
 * URL-escaped.
 *
 * The FORMAT_HTTP_HEADERS carrier map may contain unrelated data (e.g.,
 * arbitrary HTTP headers); as such, the Tracer implementation should use a
 * prefix or other convention to distinguish Tracer-specific key:value
 * pairs.
 */
exports.FORMAT_HTTP_HEADERS = 'http_headers';
/**
 * A Span may be the "child of" a parent Span. In a “child of” reference,
 * the parent Span depends on the child Span in some capacity.
 *
 * See more about reference types at https://github.com/opentracing/specification
 */
exports.REFERENCE_CHILD_OF = 'child_of';
/**
 * Some parent Spans do not depend in any way on the result of their child
 * Spans. In these cases, we say merely that the child Span “follows from”
 * the parent Span in a causal sense.
 *
 * See more about reference types at https://github.com/opentracing/specification
 */
exports.REFERENCE_FOLLOWS_FROM = 'follows_from';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/ext/tags.js":
/*!**************************************************!*\
  !*** ./node_modules/opentracing/lib/ext/tags.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/** SPAN_KIND hints at relationship between spans, e.g. client/server */
exports.SPAN_KIND = 'span.kind';
/** Marks a span representing the client-side of an RPC or other remote call */
exports.SPAN_KIND_RPC_CLIENT = 'client';
/** Marks a span representing the server-side of an RPC or other remote call */
exports.SPAN_KIND_RPC_SERVER = 'server';
/** Marks a span representing the producing-side within a messaging system or other remote call */
exports.SPAN_KIND_MESSAGING_PRODUCER = 'producer';
/** Marks a span representing the consuming-side within a messaging system or other remote call */
exports.SPAN_KIND_MESSAGING_CONSUMER = 'consumer';
/**
 * ERROR (boolean) true if and only if the application considers the operation
 * represented by the Span to have failed
 */
exports.ERROR = 'error';
/**
 * COMPONENT (string) ia s low-cardinality identifier of the module, library,
 * or package that is generating a span.
 */
exports.COMPONENT = 'component';
/**
 * SAMPLING_PRIORITY (number) determines the priority of sampling this Span.
 * If greater than 0, a hint to the Tracer to do its best to capture the trace.
 * If 0, a hint to the trace to not-capture the trace. If absent, the Tracer
 * should use its default sampling mechanism.
 */
exports.SAMPLING_PRIORITY = 'sampling.priority';
// ---------------------------------------------------------------------------
// PEER_* tags can be emitted by either client-side of server-side to describe
// the other side/service in a peer-to-peer communications, like an RPC call.
// ---------------------------------------------------------------------------
/**
 * PEER_SERVICE (string) Remote service name (for some unspecified
 * definition of "service"). E.g., "elasticsearch", "a_custom_microservice", "memcache"
 */
exports.PEER_SERVICE = 'peer.service';
/** PEER_HOSTNAME (string) Remote hostname. E.g., "opentracing.io", "internal.dns.name" */
exports.PEER_HOSTNAME = 'peer.hostname';
/**
 * PEER_ADDRESS (string) Remote "address", suitable for use in a
 * networking client library. This may be a "ip:port", a bare
 * "hostname", a FQDN, or even a JDBC substring like "mysql://prod-db:3306"
 */
exports.PEER_ADDRESS = 'peer.address';
/**
 * PEER_HOST_IPV4 (number) Remote IPv4 address as a .-separated tuple.
 * E.g., "127.0.0.1"
 */
exports.PEER_HOST_IPV4 = 'peer.ipv4';
// PEER_HOST_IPV6 (string) Remote IPv6 address as a string of
// colon-separated 4-char hex tuples. E.g., "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
exports.PEER_HOST_IPV6 = 'peer.ipv6';
// PEER_PORT (number) Remote port. E.g., 80
exports.PEER_PORT = 'peer.port';
// ---------------------------------------------------------------------------
// HTTP tags
// ---------------------------------------------------------------------------
/**
 * HTTP_URL (string) URL of the request being handled in this segment of the
 * trace, in standard URI format. E.g., "https://domain.net/path/to?resource=here"
 */
exports.HTTP_URL = 'http.url';
/**
 * HTTP_METHOD (string) HTTP method of the request for the associated Span. E.g.,
 * "GET", "POST"
 */
exports.HTTP_METHOD = 'http.method';
/**
 * HTTP_STATUS_CODE (number) HTTP response status code for the associated Span.
 * E.g., 200, 503, 404
 */
exports.HTTP_STATUS_CODE = 'http.status_code';
// -------------------------------------------------------------------------
// Messaging tags
// -------------------------------------------------------------------------
/**
 * MESSAGE_BUS_DESTINATION (string) An address at which messages can be exchanged.
 * E.g. A Kafka record has an associated "topic name" that can be extracted
 * by the instrumented producer or consumer and stored using this tag.
 */
exports.MESSAGE_BUS_DESTINATION = 'message_bus.destination';
// --------------------------------------------------------------------------
// Database tags
// --------------------------------------------------------------------------
/**
 * DB_INSTANCE (string) Database instance name. E.g., In java, if the
 * jdbc.url="jdbc:mysql://127.0.0.1:3306/customers", the instance name is "customers".
 */
exports.DB_INSTANCE = 'db.instance';
/**
 * DB_STATEMENT (string) A database statement for the given database type.
 * E.g., for db.type="SQL", "SELECT * FROM wuser_table";
 * for db.type="redis", "SET mykey 'WuValue'".
 */
exports.DB_STATEMENT = 'db.statement';
/**
 * DB_TYPE (string) Database type. For any SQL database, "sql". For others,
 * the lower-case database category, e.g. "cassandra", "hbase", or "redis".
 */
exports.DB_TYPE = 'db.type';
/**
 * DB_USER (string) Username for accessing database. E.g., "readonly_user"
 * or "reporting_user"
 */
exports.DB_USER = 'db.user';
//# sourceMappingURL=tags.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/functions.js":
/*!***************************************************!*\
  !*** ./node_modules/opentracing/lib/functions.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Constants = __webpack_require__(/*! ./constants */ "./node_modules/opentracing/lib/constants.js");
var reference_1 = __webpack_require__(/*! ./reference */ "./node_modules/opentracing/lib/reference.js");
var span_1 = __webpack_require__(/*! ./span */ "./node_modules/opentracing/lib/span.js");
/**
 * Return a new REFERENCE_CHILD_OF reference.
 *
 * @param {SpanContext} spanContext - the parent SpanContext instance to
 *        reference.
 * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`
 */
function childOf(spanContext) {
    // Allow the user to pass a Span instead of a SpanContext
    if (spanContext instanceof span_1.default) {
        spanContext = spanContext.context();
    }
    return new reference_1.default(Constants.REFERENCE_CHILD_OF, spanContext);
}
exports.childOf = childOf;
/**
 * Return a new REFERENCE_FOLLOWS_FROM reference.
 *
 * @param {SpanContext} spanContext - the parent SpanContext instance to
 *        reference.
 * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`
 */
function followsFrom(spanContext) {
    // Allow the user to pass a Span instead of a SpanContext
    if (spanContext instanceof span_1.default) {
        spanContext = spanContext.context();
    }
    return new reference_1.default(Constants.REFERENCE_FOLLOWS_FROM, spanContext);
}
exports.followsFrom = followsFrom;
//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/global_tracer.js":
/*!*******************************************************!*\
  !*** ./node_modules/opentracing/lib/global_tracer.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tracer_1 = __webpack_require__(/*! ./tracer */ "./node_modules/opentracing/lib/tracer.js");
var noopTracer = new tracer_1.default();
var _globalTracer = null;
// Allows direct importing/requiring of the global tracer:
//
// let globalTracer = require('opentracing/global');
//      OR
// import globalTracer from 'opentracing/global';
//
// Acts a bridge to the global tracer that can be safely called before the
// global tracer is initialized. The purpose of the delegation is to avoid the
// sometimes nearly intractible initialization order problems that can arise in
// applications with a complex set of dependencies, while also avoiding the
// case where
var GlobalTracerDelegate = /** @class */ (function (_super) {
    __extends(GlobalTracerDelegate, _super);
    function GlobalTracerDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalTracerDelegate.prototype.startSpan = function () {
        var tracer = _globalTracer || noopTracer;
        return tracer.startSpan.apply(tracer, arguments);
    };
    GlobalTracerDelegate.prototype.inject = function () {
        var tracer = _globalTracer || noopTracer;
        return tracer.inject.apply(tracer, arguments);
    };
    GlobalTracerDelegate.prototype.extract = function () {
        var tracer = _globalTracer || noopTracer;
        return tracer.extract.apply(tracer, arguments);
    };
    return GlobalTracerDelegate;
}(tracer_1.default));
var globalTracerDelegate = new GlobalTracerDelegate();
/**
 * Set the global Tracer.
 *
 * The behavior is undefined if this function is called more than once.
 *
 * @param {Tracer} tracer - the Tracer implementation
 */
function initGlobalTracer(tracer) {
    _globalTracer = tracer;
}
exports.initGlobalTracer = initGlobalTracer;
/**
 * Returns the global tracer.
 */
function globalTracer() {
    // Return the delegate.  Since the global tracer is largely a convenience
    // (the user can always create their own tracers), the delegate is used to
    // give the added convenience of not needing to worry about initialization
    // order.
    return globalTracerDelegate;
}
exports.globalTracer = globalTracer;
//# sourceMappingURL=global_tracer.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/opentracing/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var binary_carrier_1 = __webpack_require__(/*! ./binary_carrier */ "./node_modules/opentracing/lib/binary_carrier.js");
exports.BinaryCarrier = binary_carrier_1.default;
var Tags = __webpack_require__(/*! ./ext/tags */ "./node_modules/opentracing/lib/ext/tags.js");
exports.Tags = Tags;
var Noop = __webpack_require__(/*! ./noop */ "./node_modules/opentracing/lib/noop.js");
var reference_1 = __webpack_require__(/*! ./reference */ "./node_modules/opentracing/lib/reference.js");
exports.Reference = reference_1.default;
var span_1 = __webpack_require__(/*! ./span */ "./node_modules/opentracing/lib/span.js");
exports.Span = span_1.default;
var span_context_1 = __webpack_require__(/*! ./span_context */ "./node_modules/opentracing/lib/span_context.js");
exports.SpanContext = span_context_1.default;
var tracer_1 = __webpack_require__(/*! ./tracer */ "./node_modules/opentracing/lib/tracer.js");
exports.Tracer = tracer_1.Tracer;
var mock_tracer_1 = __webpack_require__(/*! ./mock_tracer */ "./node_modules/opentracing/lib/mock_tracer/index.js");
exports.MockTracer = mock_tracer_1.MockTracer;
__export(__webpack_require__(/*! ./global_tracer */ "./node_modules/opentracing/lib/global_tracer.js"));
__export(__webpack_require__(/*! ./constants */ "./node_modules/opentracing/lib/constants.js"));
__export(__webpack_require__(/*! ./functions */ "./node_modules/opentracing/lib/functions.js"));
// Initialize the noops last to avoid a dependecy cycle between the classes.
Noop.initialize();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/mock_tracer/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/opentracing/lib/mock_tracer/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var mock_context_1 = __webpack_require__(/*! ./mock_context */ "./node_modules/opentracing/lib/mock_tracer/mock_context.js");
exports.MockContext = mock_context_1.default;
var mock_span_1 = __webpack_require__(/*! ./mock_span */ "./node_modules/opentracing/lib/mock_tracer/mock_span.js");
exports.MockSpan = mock_span_1.default;
var mock_tracer_1 = __webpack_require__(/*! ./mock_tracer */ "./node_modules/opentracing/lib/mock_tracer/mock_tracer.js");
exports.MockTracer = mock_tracer_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/mock_tracer/mock_context.js":
/*!******************************************************************!*\
  !*** ./node_modules/opentracing/lib/mock_tracer/mock_context.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var opentracing = __webpack_require__(/*! ../index */ "./node_modules/opentracing/lib/index.js");
/**
 * OpenTracing Context implementation designed for use in
 * unit tests.
 */
var MockContext = /** @class */ (function (_super) {
    __extends(MockContext, _super);
    function MockContext(span) {
        var _this = _super.call(this) || this;
        // Store a reference to the span itself since this is a mock tracer
        // intended to make debugging and unit testing easier.
        _this._span = span;
        return _this;
    }
    MockContext.prototype.span = function () {
        return this._span;
    };
    return MockContext;
}(opentracing.SpanContext));
exports.MockContext = MockContext;
exports.default = MockContext;
//# sourceMappingURL=mock_context.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/mock_tracer/mock_report.js":
/*!*****************************************************************!*\
  !*** ./node_modules/opentracing/lib/mock_tracer/mock_report.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Index a collection of reported MockSpans in a way that's easy to run unit
 * test assertions against.
 */
var MockReport = /** @class */ (function () {
    function MockReport(spans) {
        var _this = this;
        this.spans = spans;
        this.spansByUUID = {};
        this.spansByTag = {};
        this.debugSpans = [];
        this.unfinishedSpans = [];
        spans.forEach(function (span) {
            if (span._finishMs === 0) {
                _this.unfinishedSpans.push(span);
            }
            _this.spansByUUID[span.uuid()] = span;
            _this.debugSpans.push(span.debug());
            var tags = span.tags();
            Object.keys(tags).forEach(function (key) {
                var val = tags[key];
                _this.spansByTag[key] = _this.spansByTag[key] || {};
                _this.spansByTag[key][val] = _this.spansByTag[key][val] || [];
                _this.spansByTag[key][val].push(span);
            });
        });
    }
    MockReport.prototype.firstSpanWithTagValue = function (key, val) {
        var m = this.spansByTag[key];
        if (!m) {
            return null;
        }
        var n = m[val];
        if (!n) {
            return null;
        }
        return n[0];
    };
    return MockReport;
}());
exports.MockReport = MockReport;
exports.default = MockReport;
//# sourceMappingURL=mock_report.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/mock_tracer/mock_span.js":
/*!***************************************************************!*\
  !*** ./node_modules/opentracing/lib/mock_tracer/mock_span.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable import/no-extraneous-dependencies */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var opentracing = __webpack_require__(/*! ../index */ "./node_modules/opentracing/lib/index.js");
var mock_context_1 = __webpack_require__(/*! ./mock_context */ "./node_modules/opentracing/lib/mock_tracer/mock_context.js");
/**
 * OpenTracing Span implementation designed for use in unit tests.
 */
var MockSpan = /** @class */ (function (_super) {
    __extends(MockSpan, _super);
    //------------------------------------------------------------------------//
    // MockSpan-specific
    //------------------------------------------------------------------------//
    function MockSpan(tracer) {
        var _this = _super.call(this) || this;
        _this._mockTracer = tracer;
        _this._uuid = _this._generateUUID();
        _this._startMs = Date.now();
        _this._finishMs = 0;
        _this._operationName = '';
        _this._tags = {};
        _this._logs = [];
        return _this;
    }
    //------------------------------------------------------------------------//
    // OpenTracing implementation
    //------------------------------------------------------------------------//
    MockSpan.prototype._context = function () {
        return new mock_context_1.default(this);
    };
    MockSpan.prototype._setOperationName = function (name) {
        this._operationName = name;
    };
    MockSpan.prototype._addTags = function (set) {
        var keys = Object.keys(set);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            this._tags[key] = set[key];
        }
    };
    MockSpan.prototype._log = function (fields, timestamp) {
        this._logs.push({
            fields: fields,
            timestamp: timestamp
        });
    };
    MockSpan.prototype._finish = function (finishTime) {
        this._finishMs = finishTime || Date.now();
    };
    MockSpan.prototype.uuid = function () {
        return this._uuid;
    };
    MockSpan.prototype.operationName = function () {
        return this._operationName;
    };
    MockSpan.prototype.durationMs = function () {
        return this._finishMs - this._startMs;
    };
    MockSpan.prototype.tags = function () {
        return this._tags;
    };
    MockSpan.prototype.tracer = function () {
        return this._mockTracer;
    };
    MockSpan.prototype._generateUUID = function () {
        var p0 = ("00000000" + Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)).substr(-8);
        var p1 = ("00000000" + Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)).substr(-8);
        return "" + p0 + p1;
    };
    MockSpan.prototype.addReference = function (ref) {
    };
    /**
     * Returns a simplified object better for console.log()'ing.
     */
    MockSpan.prototype.debug = function () {
        var obj = {
            uuid: this._uuid,
            operation: this._operationName,
            millis: [this._finishMs - this._startMs, this._startMs, this._finishMs]
        };
        if (Object.keys(this._tags).length) {
            obj.tags = this._tags;
        }
        return obj;
    };
    return MockSpan;
}(opentracing.Span));
exports.MockSpan = MockSpan;
exports.default = MockSpan;
//# sourceMappingURL=mock_span.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/mock_tracer/mock_tracer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/opentracing/lib/mock_tracer/mock_tracer.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: Move mock-tracer to its own NPM package once it is complete and tested.
var opentracing = __webpack_require__(/*! ../index */ "./node_modules/opentracing/lib/index.js");
var mock_report_1 = __webpack_require__(/*! ./mock_report */ "./node_modules/opentracing/lib/mock_tracer/mock_report.js");
var mock_span_1 = __webpack_require__(/*! ./mock_span */ "./node_modules/opentracing/lib/mock_tracer/mock_span.js");
/**
 * OpenTracing Tracer implementation designed for use in unit tests.
 */
var MockTracer = /** @class */ (function (_super) {
    __extends(MockTracer, _super);
    //------------------------------------------------------------------------//
    // MockTracer-specific
    //------------------------------------------------------------------------//
    function MockTracer() {
        var _this = _super.call(this) || this;
        _this._spans = [];
        return _this;
    }
    //------------------------------------------------------------------------//
    // OpenTracing implementation
    //------------------------------------------------------------------------//
    MockTracer.prototype._startSpan = function (name, fields) {
        // _allocSpan is given it's own method so that derived classes can
        // allocate any type of object they want, but not have to duplicate
        // the other common logic in startSpan().
        var span = this._allocSpan();
        span.setOperationName(name);
        this._spans.push(span);
        if (fields.references) {
            for (var _i = 0, _a = fields.references; _i < _a.length; _i++) {
                var ref = _a[_i];
                span.addReference(ref);
            }
        }
        // Capture the stack at the time the span started
        span._startStack = new Error().stack;
        return span;
    };
    MockTracer.prototype._inject = function (span, format, carrier) {
        throw new Error('NOT YET IMPLEMENTED');
    };
    MockTracer.prototype._extract = function (format, carrier) {
        throw new Error('NOT YET IMPLEMENTED');
    };
    MockTracer.prototype._allocSpan = function () {
        return new mock_span_1.default(this);
    };
    /**
     * Discard any buffered data.
     */
    MockTracer.prototype.clear = function () {
        this._spans = [];
    };
    /**
     * Return the buffered data in a format convenient for making unit test
     * assertions.
     */
    MockTracer.prototype.report = function () {
        return new mock_report_1.default(this._spans);
    };
    return MockTracer;
}(opentracing.Tracer));
exports.MockTracer = MockTracer;
exports.default = MockTracer;
//# sourceMappingURL=mock_tracer.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/noop.js":
/*!**********************************************!*\
  !*** ./node_modules/opentracing/lib/noop.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var span_1 = __webpack_require__(/*! ./span */ "./node_modules/opentracing/lib/span.js");
var span_context_1 = __webpack_require__(/*! ./span_context */ "./node_modules/opentracing/lib/span_context.js");
var tracer_1 = __webpack_require__(/*! ./tracer */ "./node_modules/opentracing/lib/tracer.js");
exports.tracer = null;
exports.spanContext = null;
exports.span = null;
// Deferred initialization to avoid a dependency cycle where Tracer depends on
// Span which depends on the noop tracer.
function initialize() {
    exports.tracer = new tracer_1.default();
    exports.span = new span_1.default();
    exports.spanContext = new span_context_1.default();
}
exports.initialize = initialize;
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/reference.js":
/*!***************************************************!*\
  !*** ./node_modules/opentracing/lib/reference.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var span_1 = __webpack_require__(/*! ./span */ "./node_modules/opentracing/lib/span.js");
/**
 * Reference pairs a reference type constant (e.g., REFERENCE_CHILD_OF or
 * REFERENCE_FOLLOWS_FROM) with the SpanContext it points to.
 *
 * See the exported childOf() and followsFrom() functions at the package level.
 */
var Reference = /** @class */ (function () {
    /**
     * Initialize a new Reference instance.
     *
     * @param {string} type - the Reference type constant (e.g.,
     *        REFERENCE_CHILD_OF or REFERENCE_FOLLOWS_FROM).
     * @param {SpanContext} referencedContext - the SpanContext being referred
     *        to. As a convenience, a Span instance may be passed in instead
     *        (in which case its .context() is used here).
     */
    function Reference(type, referencedContext) {
        this._type = type;
        this._referencedContext = (referencedContext instanceof span_1.default ?
            referencedContext.context() :
            referencedContext);
    }
    /**
     * @return {string} The Reference type (e.g., REFERENCE_CHILD_OF or
     *         REFERENCE_FOLLOWS_FROM).
     */
    Reference.prototype.type = function () {
        return this._type;
    };
    /**
     * @return {SpanContext} The SpanContext being referred to (e.g., the
     *         parent in a REFERENCE_CHILD_OF Reference).
     */
    Reference.prototype.referencedContext = function () {
        return this._referencedContext;
    };
    return Reference;
}());
exports.default = Reference;
//# sourceMappingURL=reference.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/span.js":
/*!**********************************************!*\
  !*** ./node_modules/opentracing/lib/span.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var noop = __webpack_require__(/*! ./noop */ "./node_modules/opentracing/lib/noop.js");
/**
 * Span represents a logical unit of work as part of a broader Trace. Examples
 * of span might include remote procedure calls or a in-process function calls
 * to sub-components. A Trace has a single, top-level "root" Span that in turn
 * may have zero or more child Spans, which in turn may have children.
 */
var Span = /** @class */ (function () {
    function Span() {
    }
    // ---------------------------------------------------------------------- //
    // OpenTracing API methods
    // ---------------------------------------------------------------------- //
    /**
     * Returns the SpanContext object associated with this Span.
     *
     * @return {SpanContext}
     */
    Span.prototype.context = function () {
        return this._context();
    };
    /**
     * Returns the Tracer object used to create this Span.
     *
     * @return {Tracer}
     */
    Span.prototype.tracer = function () {
        return this._tracer();
    };
    /**
     * Sets the string name for the logical operation this span represents.
     *
     * @param {string} name
     */
    Span.prototype.setOperationName = function (name) {
        this._setOperationName(name);
        return this;
    };
    /**
     * Sets a key:value pair on this Span that also propagates to future
     * children of the associated Span.
     *
     * setBaggageItem() enables powerful functionality given a full-stack
     * opentracing integration (e.g., arbitrary application data from a web
     * client can make it, transparently, all the way into the depths of a
     * storage system), and with it some powerful costs: use this feature with
     * care.
     *
     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to
     * *future* causal descendants of the associated Span.
     *
     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and
     * value is copied into every local *and remote* child of the associated
     * Span, and that can add up to a lot of network and cpu overhead.
     *
     * @param {string} key
     * @param {string} value
     */
    Span.prototype.setBaggageItem = function (key, value) {
        this._setBaggageItem(key, value);
        return this;
    };
    /**
     * Returns the value for a baggage item given its key.
     *
     * @param  {string} key
     *         The key for the given trace attribute.
     * @return {string}
     *         String value for the given key, or undefined if the key does not
     *         correspond to a set trace attribute.
     */
    Span.prototype.getBaggageItem = function (key) {
        return this._getBaggageItem(key);
    };
    /**
     * Adds a single tag to the span.  See `addTags()` for details.
     *
     * @param {string} key
     * @param {any} value
     */
    Span.prototype.setTag = function (key, value) {
        var _a;
        // NOTE: the call is normalized to a call to _addTags()
        this._addTags((_a = {}, _a[key] = value, _a));
        return this;
    };
    /**
     * Adds the given key value pairs to the set of span tags.
     *
     * Multiple calls to addTags() results in the tags being the superset of
     * all calls.
     *
     * The behavior of setting the same key multiple times on the same span
     * is undefined.
     *
     * The supported type of the values is implementation-dependent.
     * Implementations are expected to safely handle all types of values but
     * may choose to ignore unrecognized / unhandle-able values (e.g. objects
     * with cyclic references, function objects).
     *
     * @return {[type]} [description]
     */
    Span.prototype.addTags = function (keyValueMap) {
        this._addTags(keyValueMap);
        return this;
    };
    /**
     * Add a log record to this Span, optionally at a user-provided timestamp.
     *
     * For example:
     *
     *     span.log({
     *         size: rpc.size(),  // numeric value
     *         URI: rpc.URI(),  // string value
     *         payload: rpc.payload(),  // Object value
     *         "keys can be arbitrary strings": rpc.foo(),
     *     });
     *
     *     span.log({
     *         "error.description": someError.description(),
     *     }, someError.timestampMillis());
     *
     * @param {object} keyValuePairs
     *        An object mapping string keys to arbitrary value types. All
     *        Tracer implementations should support bool, string, and numeric
     *        value types, and some may also support Object values.
     * @param {number} timestamp
     *        An optional parameter specifying the timestamp in milliseconds
     *        since the Unix epoch. Fractional values are allowed so that
     *        timestamps with sub-millisecond accuracy can be represented. If
     *        not specified, the implementation is expected to use its notion
     *        of the current time of the call.
     */
    Span.prototype.log = function (keyValuePairs, timestamp) {
        this._log(keyValuePairs, timestamp);
        return this;
    };
    /**
     * DEPRECATED
     */
    Span.prototype.logEvent = function (eventName, payload) {
        return this._log({ event: eventName, payload: payload });
    };
    /**
     * Sets the end timestamp and finalizes Span state.
     *
     * With the exception of calls to Span.context() (which are always allowed),
     * finish() must be the last call made to any span instance, and to do
     * otherwise leads to undefined behavior.
     *
     * @param  {number} finishTime
     *         Optional finish time in milliseconds as a Unix timestamp. Decimal
     *         values are supported for timestamps with sub-millisecond accuracy.
     *         If not specified, the current time (as defined by the
     *         implementation) will be used.
     */
    Span.prototype.finish = function (finishTime) {
        this._finish(finishTime);
        // Do not return `this`. The Span generally should not be used after it
        // is finished so chaining is not desired in this context.
    };
    // ---------------------------------------------------------------------- //
    // Derived classes can choose to implement the below
    // ---------------------------------------------------------------------- //
    // By default returns a no-op SpanContext.
    Span.prototype._context = function () {
        return noop.spanContext;
    };
    // By default returns a no-op tracer.
    //
    // The base class could store the tracer that created it, but it does not
    // in order to ensure the no-op span implementation has zero members,
    // which allows V8 to aggressively optimize calls to such objects.
    Span.prototype._tracer = function () {
        return noop.tracer;
    };
    // By default does nothing
    Span.prototype._setOperationName = function (name) {
    };
    // By default does nothing
    Span.prototype._setBaggageItem = function (key, value) {
    };
    // By default does nothing
    Span.prototype._getBaggageItem = function (key) {
        return undefined;
    };
    // By default does nothing
    //
    // NOTE: both setTag() and addTags() map to this function. keyValuePairs
    // will always be an associative array.
    Span.prototype._addTags = function (keyValuePairs) {
    };
    // By default does nothing
    Span.prototype._log = function (keyValuePairs, timestamp) {
    };
    // By default does nothing
    //
    // finishTime is expected to be either a number or undefined.
    Span.prototype._finish = function (finishTime) {
    };
    return Span;
}());
exports.Span = Span;
exports.default = Span;
//# sourceMappingURL=span.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/span_context.js":
/*!******************************************************!*\
  !*** ./node_modules/opentracing/lib/span_context.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * SpanContext represents Span state that must propagate to descendant Spans
 * and across process boundaries.
 *
 * SpanContext is logically divided into two pieces: the user-level "Baggage"
 * (see setBaggageItem and getBaggageItem) that propagates across Span
 * boundaries and any Tracer-implementation-specific fields that are needed to
 * identify or otherwise contextualize the associated Span instance (e.g., a
 * <trace_id, span_id, sampled> tuple).
 */
var SpanContext = /** @class */ (function () {
    function SpanContext() {
    }
    // The SpanContext is entirely implementation dependent
    /**
     * Returns a string representation of the implementation internal trace ID.
     *
     * @returns {string}
     */
    SpanContext.prototype.toTraceId = function () {
        return '';
    };
    /**
     * Returns a string representation of the implementation internal span ID.
     *
     * @returns {string}
     */
    SpanContext.prototype.toSpanId = function () {
        return '';
    };
    return SpanContext;
}());
exports.SpanContext = SpanContext;
exports.default = SpanContext;
//# sourceMappingURL=span_context.js.map

/***/ }),

/***/ "./node_modules/opentracing/lib/tracer.js":
/*!************************************************!*\
  !*** ./node_modules/opentracing/lib/tracer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Functions = __webpack_require__(/*! ./functions */ "./node_modules/opentracing/lib/functions.js");
var Noop = __webpack_require__(/*! ./noop */ "./node_modules/opentracing/lib/noop.js");
var span_1 = __webpack_require__(/*! ./span */ "./node_modules/opentracing/lib/span.js");
/**
 * Tracer is the entry-point between the instrumentation API and the tracing
 * implementation.
 *
 * The default object acts as a no-op implementation.
 *
 * Note to implementators: derived classes can choose to directly implement the
 * methods in the "OpenTracing API methods" section, or optionally the subset of
 * underscore-prefixed methods to pick up the argument checking and handling
 * automatically from the base class.
 */
var Tracer = /** @class */ (function () {
    function Tracer() {
    }
    // ---------------------------------------------------------------------- //
    // OpenTracing API methods
    // ---------------------------------------------------------------------- //
    /**
     * Starts and returns a new Span representing a logical unit of work.
     *
     * For example:
     *
     *     // Start a new (parentless) root Span:
     *     var parent = Tracer.startSpan('DoWork');
     *
     *     // Start a new (child) Span:
     *     var child = Tracer.startSpan('load-from-db', {
     *         childOf: parent.context(),
     *     });
     *
     *     // Start a new async (FollowsFrom) Span:
     *     var child = Tracer.startSpan('async-cache-write', {
     *         references: [
     *             opentracing.followsFrom(parent.context())
     *         ],
     *     });
     *
     * @param {string} name - the name of the operation (REQUIRED).
     * @param {SpanOptions} [options] - options for the newly created span.
     * @return {Span} - a new Span object.
     */
    Tracer.prototype.startSpan = function (name, options) {
        if (options === void 0) { options = {}; }
        // Convert options.childOf to fields.references as needed.
        if (options.childOf) {
            // Convert from a Span or a SpanContext into a Reference.
            var childOf = Functions.childOf(options.childOf);
            if (options.references) {
                options.references.push(childOf);
            }
            else {
                options.references = [childOf];
            }
            delete (options.childOf);
        }
        return this._startSpan(name, options);
    };
    /**
     * Injects the given SpanContext instance for cross-process propagation
     * within `carrier`. The expected type of `carrier` depends on the value of
     * `format.
     *
     * OpenTracing defines a common set of `format` values (see
     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has
     * an expected carrier type.
     *
     * Consider this pseudocode example:
     *
     *     var clientSpan = ...;
     *     ...
     *     // Inject clientSpan into a text carrier.
     *     var headersCarrier = {};
     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);
     *     // Incorporate the textCarrier into the outbound HTTP request header
     *     // map.
     *     Object.assign(outboundHTTPReq.headers, headersCarrier);
     *     // ... send the httpReq
     *
     * @param  {SpanContext} spanContext - the SpanContext to inject into the
     *         carrier object. As a convenience, a Span instance may be passed
     *         in instead (in which case its .context() is used for the
     *         inject()).
     * @param  {string} format - the format of the carrier.
     * @param  {any} carrier - see the documentation for the chosen `format`
     *         for a description of the carrier object.
     */
    Tracer.prototype.inject = function (spanContext, format, carrier) {
        // Allow the user to pass a Span instead of a SpanContext
        if (spanContext instanceof span_1.default) {
            spanContext = spanContext.context();
        }
        return this._inject(spanContext, format, carrier);
    };
    /**
     * Returns a SpanContext instance extracted from `carrier` in the given
     * `format`.
     *
     * OpenTracing defines a common set of `format` values (see
     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has
     * an expected carrier type.
     *
     * Consider this pseudocode example:
     *
     *     // Use the inbound HTTP request's headers as a text map carrier.
     *     var headersCarrier = inboundHTTPReq.headers;
     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);
     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });
     *
     * @param  {string} format - the format of the carrier.
     * @param  {any} carrier - the type of the carrier object is determined by
     *         the format.
     * @return {SpanContext}
     *         The extracted SpanContext, or null if no such SpanContext could
     *         be found in `carrier`
     */
    Tracer.prototype.extract = function (format, carrier) {
        return this._extract(format, carrier);
    };
    // ---------------------------------------------------------------------- //
    // Derived classes can choose to implement the below
    // ---------------------------------------------------------------------- //
    // NOTE: the input to this method is *always* an associative array. The
    // public-facing startSpan() method normalizes the arguments so that
    // all N implementations do not need to worry about variations in the call
    // signature.
    //
    // The default behavior returns a no-op span.
    Tracer.prototype._startSpan = function (name, fields) {
        return Noop.span;
    };
    // The default behavior is a no-op.
    Tracer.prototype._inject = function (spanContext, format, carrier) {
    };
    // The default behavior is to return a no-op SpanContext.
    Tracer.prototype._extract = function (format, carrier) {
        return Noop.spanContext;
    };
    return Tracer;
}());
exports.Tracer = Tracer;
exports.default = Tracer;
//# sourceMappingURL=tracer.js.map

/***/ }),

/***/ "./node_modules/optimism/lib/bundle.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/optimism/lib/bundle.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asyncFromGen": () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.asyncFromGen),
/* harmony export */   "bindContext": () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.bind),
/* harmony export */   "noContext": () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.noContext),
/* harmony export */   "setTimeout": () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.setTimeout),
/* harmony export */   "KeyTrie": () => (/* binding */ KeyTrie),
/* harmony export */   "defaultMakeCacheKey": () => (/* binding */ defaultMakeCacheKey),
/* harmony export */   "wrap": () => (/* binding */ wrap)
/* harmony export */ });
/* harmony import */ var _wry_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/context */ "./node_modules/@wry/context/lib/context.esm.js");



function defaultDispose() { }
var Cache = /** @class */ (function () {
    function Cache(max, dispose) {
        if (max === void 0) { max = Infinity; }
        if (dispose === void 0) { dispose = defaultDispose; }
        this.max = max;
        this.dispose = dispose;
        this.map = new Map();
        this.newest = null;
        this.oldest = null;
    }
    Cache.prototype.has = function (key) {
        return this.map.has(key);
    };
    Cache.prototype.get = function (key) {
        var entry = this.getEntry(key);
        return entry && entry.value;
    };
    Cache.prototype.getEntry = function (key) {
        var entry = this.map.get(key);
        if (entry && entry !== this.newest) {
            var older = entry.older, newer = entry.newer;
            if (newer) {
                newer.older = older;
            }
            if (older) {
                older.newer = newer;
            }
            entry.older = this.newest;
            entry.older.newer = entry;
            entry.newer = null;
            this.newest = entry;
            if (entry === this.oldest) {
                this.oldest = newer;
            }
        }
        return entry;
    };
    Cache.prototype.set = function (key, value) {
        var entry = this.getEntry(key);
        if (entry) {
            return entry.value = value;
        }
        entry = {
            key: key,
            value: value,
            newer: null,
            older: this.newest
        };
        if (this.newest) {
            this.newest.newer = entry;
        }
        this.newest = entry;
        this.oldest = this.oldest || entry;
        this.map.set(key, entry);
        return entry.value;
    };
    Cache.prototype.clean = function () {
        while (this.oldest && this.map.size > this.max) {
            this.delete(this.oldest.key);
        }
    };
    Cache.prototype.delete = function (key) {
        var entry = this.map.get(key);
        if (entry) {
            if (entry === this.newest) {
                this.newest = entry.older;
            }
            if (entry === this.oldest) {
                this.oldest = entry.newer;
            }
            if (entry.newer) {
                entry.newer.older = entry.older;
            }
            if (entry.older) {
                entry.older.newer = entry.newer;
            }
            this.map.delete(key);
            this.dispose(entry.value, key);
            return true;
        }
        return false;
    };
    return Cache;
}());

var parentEntrySlot = new _wry_context__WEBPACK_IMPORTED_MODULE_0__.Slot();

var reusableEmptyArray = [];
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
// Since this package might be used browsers, we should avoid using the
// Node built-in assert module.
function assert(condition, optionalMessage) {
    if (!condition) {
        throw new Error(optionalMessage || "assertion failure");
    }
}
function valueIs(a, b) {
    var len = a.length;
    return (
    // Unknown values are not equal to each other.
    len > 0 &&
        // Both values must be ordinary (or both exceptional) to be equal.
        len === b.length &&
        // The underlying value or exception must be the same.
        a[len - 1] === b[len - 1]);
}
function valueGet(value) {
    switch (value.length) {
        case 0: throw new Error("unknown value");
        case 1: return value[0];
        case 2: throw value[1];
    }
}
function valueCopy(value) {
    return value.slice(0);
}
var Entry = /** @class */ (function () {
    function Entry(fn, args) {
        this.fn = fn;
        this.args = args;
        this.parents = new Set();
        this.childValues = new Map();
        // When this Entry has children that are dirty, this property becomes
        // a Set containing other Entry objects, borrowed from emptySetPool.
        // When the set becomes empty, it gets recycled back to emptySetPool.
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        ++Entry.count;
    }
    // This is the most important method of the Entry API, because it
    // determines whether the cached this.value can be returned immediately,
    // or must be recomputed. The overall performance of the caching system
    // depends on the truth of the following observations: (1) this.dirty is
    // usually false, (2) this.dirtyChildren is usually null/empty, and thus
    // (3) valueGet(this.value) is usually returned without recomputation.
    Entry.prototype.recompute = function () {
        assert(!this.recomputing, "already recomputing");
        if (!rememberParent(this) && maybeReportOrphan(this)) {
            // The recipient of the entry.reportOrphan callback decided to dispose
            // of this orphan entry by calling entry.dispose(), so we don't need to
            // (and should not) proceed with the recomputation.
            return void 0;
        }
        return mightBeDirty(this)
            ? reallyRecompute(this)
            : valueGet(this.value);
    };
    Entry.prototype.setDirty = function () {
        if (this.dirty)
            return;
        this.dirty = true;
        this.value.length = 0;
        reportDirty(this);
        // We can go ahead and unsubscribe here, since any further dirty
        // notifications we receive will be redundant, and unsubscribing may
        // free up some resources, e.g. file watchers.
        maybeUnsubscribe(this);
    };
    Entry.prototype.dispose = function () {
        var _this = this;
        forgetChildren(this).forEach(maybeReportOrphan);
        maybeUnsubscribe(this);
        // Because this entry has been kicked out of the cache (in index.js),
        // we've lost the ability to find out if/when this entry becomes dirty,
        // whether that happens through a subscription, because of a direct call
        // to entry.setDirty(), or because one of its children becomes dirty.
        // Because of this loss of future information, we have to assume the
        // worst (that this entry might have become dirty very soon), so we must
        // immediately mark this entry's parents as dirty. Normally we could
        // just call entry.setDirty() rather than calling parent.setDirty() for
        // each parent, but that would leave this entry in parent.childValues
        // and parent.dirtyChildren, which would prevent the child from being
        // truly forgotten.
        this.parents.forEach(function (parent) {
            parent.setDirty();
            forgetChild(parent, _this);
        });
    };
    Entry.count = 0;
    return Entry;
}());
function rememberParent(child) {
    var parent = parentEntrySlot.getValue();
    if (parent) {
        child.parents.add(parent);
        if (!parent.childValues.has(child)) {
            parent.childValues.set(child, []);
        }
        if (mightBeDirty(child)) {
            reportDirtyChild(parent, child);
        }
        else {
            reportCleanChild(parent, child);
        }
        return parent;
    }
}
function reallyRecompute(entry) {
    // Since this recomputation is likely to re-remember some of this
    // entry's children, we forget our children here but do not call
    // maybeReportOrphan until after the recomputation finishes.
    var originalChildren = forgetChildren(entry);
    // Set entry as the parent entry while calling recomputeNewValue(entry).
    parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);
    if (maybeSubscribe(entry)) {
        // If we successfully recomputed entry.value and did not fail to
        // (re)subscribe, then this Entry is no longer explicitly dirty.
        setClean(entry);
    }
    // Now that we've had a chance to re-remember any children that were
    // involved in the recomputation, we can safely report any orphan
    // children that remain.
    originalChildren.forEach(maybeReportOrphan);
    return valueGet(entry.value);
}
function recomputeNewValue(entry) {
    entry.recomputing = true;
    // Set entry.value as unknown.
    entry.value.length = 0;
    try {
        // If entry.fn succeeds, entry.value will become a normal Value.
        entry.value[0] = entry.fn.apply(null, entry.args);
    }
    catch (e) {
        // If entry.fn throws, entry.value will become exceptional.
        entry.value[1] = e;
    }
    // Either way, this line is always reached.
    entry.recomputing = false;
}
function mightBeDirty(entry) {
    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
    entry.dirty = false;
    if (mightBeDirty(entry)) {
        // This Entry may still have dirty children, in which case we can't
        // let our parents know we're clean just yet.
        return;
    }
    reportClean(entry);
}
function reportDirty(child) {
    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });
}
function reportClean(child) {
    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });
}
// Let a parent Entry know that one of its children may be dirty.
function reportDirtyChild(parent, child) {
    // Must have called rememberParent(child) before calling
    // reportDirtyChild(parent, child).
    assert(parent.childValues.has(child));
    assert(mightBeDirty(child));
    if (!parent.dirtyChildren) {
        parent.dirtyChildren = emptySetPool.pop() || new Set;
    }
    else if (parent.dirtyChildren.has(child)) {
        // If we already know this child is dirty, then we must have already
        // informed our own parents that we are dirty, so we can terminate
        // the recursion early.
        return;
    }
    parent.dirtyChildren.add(child);
    reportDirty(parent);
}
// Let a parent Entry know that one of its children is no longer dirty.
function reportCleanChild(parent, child) {
    // Must have called rememberChild(child) before calling
    // reportCleanChild(parent, child).
    assert(parent.childValues.has(child));
    assert(!mightBeDirty(child));
    var childValue = parent.childValues.get(child);
    if (childValue.length === 0) {
        parent.childValues.set(child, valueCopy(child.value));
    }
    else if (!valueIs(childValue, child.value)) {
        parent.setDirty();
    }
    removeDirtyChild(parent, child);
    if (mightBeDirty(parent)) {
        return;
    }
    reportClean(parent);
}
function removeDirtyChild(parent, child) {
    var dc = parent.dirtyChildren;
    if (dc) {
        dc.delete(child);
        if (dc.size === 0) {
            if (emptySetPool.length < POOL_TARGET_SIZE) {
                emptySetPool.push(dc);
            }
            parent.dirtyChildren = null;
        }
    }
}
// If the given entry has a reportOrphan method, and no remaining parents,
// call entry.reportOrphan and return true iff it returns true. The
// reportOrphan function should return true to indicate entry.dispose()
// has been called, and the entry has been removed from any other caches
// (see index.js for the only current example).
function maybeReportOrphan(entry) {
    return entry.parents.size === 0 &&
        typeof entry.reportOrphan === "function" &&
        entry.reportOrphan() === true;
}
// Removes all children from this entry and returns an array of the
// removed children.
function forgetChildren(parent) {
    var children = reusableEmptyArray;
    if (parent.childValues.size > 0) {
        children = [];
        parent.childValues.forEach(function (_value, child) {
            forgetChild(parent, child);
            children.push(child);
        });
    }
    // After we forget all our children, this.dirtyChildren must be empty
    // and therefore must have been reset to null.
    assert(parent.dirtyChildren === null);
    return children;
}
function forgetChild(parent, child) {
    child.parents.delete(parent);
    parent.childValues.delete(child);
    removeDirtyChild(parent, child);
}
function maybeSubscribe(entry) {
    if (typeof entry.subscribe === "function") {
        try {
            maybeUnsubscribe(entry); // Prevent double subscriptions.
            entry.unsubscribe = entry.subscribe.apply(null, entry.args);
        }
        catch (e) {
            // If this Entry has a subscribe function and it threw an exception
            // (or an unsubscribe function it previously returned now throws),
            // return false to indicate that we were not able to subscribe (or
            // unsubscribe), and this Entry should remain dirty.
            entry.setDirty();
            return false;
        }
    }
    // Returning true indicates either that there was no entry.subscribe
    // function or that it succeeded.
    return true;
}
function maybeUnsubscribe(entry) {
    var unsubscribe = entry.unsubscribe;
    if (typeof unsubscribe === "function") {
        entry.unsubscribe = void 0;
        unsubscribe();
    }
}

// A trie data structure that holds object keys weakly, yet can also hold
// non-object keys, unlike the native `WeakMap`.
var KeyTrie = /** @class */ (function () {
    function KeyTrie(weakness) {
        this.weakness = weakness;
    }
    KeyTrie.prototype.lookup = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
        }
        return this.lookupArray(array);
    };
    KeyTrie.prototype.lookupArray = function (array) {
        var node = this;
        array.forEach(function (key) { return node = node.getChildTrie(key); });
        return node.data || (node.data = Object.create(null));
    };
    KeyTrie.prototype.getChildTrie = function (key) {
        var map = this.weakness && isObjRef(key)
            ? this.weak || (this.weak = new WeakMap())
            : this.strong || (this.strong = new Map());
        var child = map.get(key);
        if (!child)
            map.set(key, child = new KeyTrie(this.weakness));
        return child;
    };
    return KeyTrie;
}());
function isObjRef(value) {
    switch (typeof value) {
        case "object":
            if (value === null)
                break;
        // Fall through to return true...
        case "function":
            return true;
    }
    return false;
}

// The defaultMakeCacheKey function is remarkably powerful, because it gives
// a unique object for any shallow-identical list of arguments. If you need
// to implement a custom makeCacheKey function, you may find it helpful to
// delegate the final work to defaultMakeCacheKey, which is why we export it
// here. However, you may want to avoid defaultMakeCacheKey if your runtime
// does not support WeakMap, or you have the ability to return a string key.
// In those cases, just write your own custom makeCacheKey functions.
var keyTrie = new KeyTrie(typeof WeakMap === "function");
function defaultMakeCacheKey() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return keyTrie.lookupArray(args);
}
var caches = new Set();
function wrap(originalFunction, options) {
    if (options === void 0) { options = Object.create(null); }
    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });
    var disposable = !!options.disposable;
    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
    function optimistic() {
        if (disposable && !parentEntrySlot.hasValue()) {
            // If there's no current parent computation, and this wrapped
            // function is disposable (meaning we don't care about entry.value,
            // just dependency tracking), then we can short-cut everything else
            // in this function, because entry.recompute() is going to recycle
            // the entry object without recomputing anything, anyway.
            return void 0;
        }
        var key = makeCacheKey.apply(null, arguments);
        if (key === void 0) {
            return originalFunction.apply(null, arguments);
        }
        var args = Array.prototype.slice.call(arguments);
        var entry = cache.get(key);
        if (entry) {
            entry.args = args;
        }
        else {
            entry = new Entry(originalFunction, args);
            cache.set(key, entry);
            entry.subscribe = options.subscribe;
            if (disposable) {
                entry.reportOrphan = function () { return cache.delete(key); };
            }
        }
        var value = entry.recompute();
        // Move this entry to the front of the least-recently used queue,
        // since we just finished computing its value.
        cache.set(key, entry);
        caches.add(cache);
        // Clean up any excess entries in the cache, but only if there is no
        // active parent entry, meaning we're not in the middle of a larger
        // computation that might be flummoxed by the cleaning.
        if (!parentEntrySlot.hasValue()) {
            caches.forEach(function (cache) { return cache.clean(); });
            caches.clear();
        }
        // If options.disposable is truthy, the caller of wrap is telling us
        // they don't care about the result of entry.recompute(), so we should
        // avoid returning the value, so it won't be accidentally used.
        return disposable ? void 0 : value;
    }
    optimistic.dirty = function () {
        var key = makeCacheKey.apply(null, arguments);
        var child = key !== void 0 && cache.get(key);
        if (child) {
            child.setDirty();
        }
    };
    return optimistic;
}


//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/client.js":
/*!****************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/client.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubscriptionClient = void 0;
var _global = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : (typeof window !== 'undefined' ? window : {});
var NativeWebSocket = _global.WebSocket || _global.MozWebSocket;
var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");
var eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
var is_string_1 = __webpack_require__(/*! ./utils/is-string */ "./node_modules/subscriptions-transport-ws/dist/utils/is-string.js");
var is_object_1 = __webpack_require__(/*! ./utils/is-object */ "./node_modules/subscriptions-transport-ws/dist/utils/is-object.js");
var printer_1 = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
var getOperationAST_1 = __webpack_require__(/*! graphql/utilities/getOperationAST */ "./node_modules/graphql/utilities/getOperationAST.js");
var symbol_observable_1 = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");
var protocol_1 = __webpack_require__(/*! ./protocol */ "./node_modules/subscriptions-transport-ws/dist/protocol.js");
var defaults_1 = __webpack_require__(/*! ./defaults */ "./node_modules/subscriptions-transport-ws/dist/defaults.js");
var message_types_1 = __webpack_require__(/*! ./message-types */ "./node_modules/subscriptions-transport-ws/dist/message-types.js");
var SubscriptionClient = (function () {
    function SubscriptionClient(url, options, webSocketImpl, webSocketProtocols) {
        var _a = (options || {}), _b = _a.connectionCallback, connectionCallback = _b === void 0 ? undefined : _b, _c = _a.connectionParams, connectionParams = _c === void 0 ? {} : _c, _d = _a.minTimeout, minTimeout = _d === void 0 ? defaults_1.MIN_WS_TIMEOUT : _d, _e = _a.timeout, timeout = _e === void 0 ? defaults_1.WS_TIMEOUT : _e, _f = _a.reconnect, reconnect = _f === void 0 ? false : _f, _g = _a.reconnectionAttempts, reconnectionAttempts = _g === void 0 ? Infinity : _g, _h = _a.lazy, lazy = _h === void 0 ? false : _h, _j = _a.inactivityTimeout, inactivityTimeout = _j === void 0 ? 0 : _j, _k = _a.wsOptionArguments, wsOptionArguments = _k === void 0 ? [] : _k;
        this.wsImpl = webSocketImpl || NativeWebSocket;
        if (!this.wsImpl) {
            throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');
        }
        this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;
        this.connectionCallback = connectionCallback;
        this.url = url;
        this.operations = {};
        this.nextOperationId = 0;
        this.minWsTimeout = minTimeout;
        this.wsTimeout = timeout;
        this.unsentMessagesQueue = [];
        this.reconnect = reconnect;
        this.reconnecting = false;
        this.reconnectionAttempts = reconnectionAttempts;
        this.lazy = !!lazy;
        this.inactivityTimeout = inactivityTimeout;
        this.closedByUser = false;
        this.backoff = new Backoff({ jitter: 0.5 });
        this.eventEmitter = new eventemitter3_1.EventEmitter();
        this.middlewares = [];
        this.client = null;
        this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();
        this.connectionParams = this.getConnectionParams(connectionParams);
        this.wsOptionArguments = wsOptionArguments;
        if (!this.lazy) {
            this.connect();
        }
    }
    Object.defineProperty(SubscriptionClient.prototype, "status", {
        get: function () {
            if (this.client === null) {
                return this.wsImpl.CLOSED;
            }
            return this.client.readyState;
        },
        enumerable: false,
        configurable: true
    });
    SubscriptionClient.prototype.close = function (isForced, closedByUser) {
        if (isForced === void 0) { isForced = true; }
        if (closedByUser === void 0) { closedByUser = true; }
        this.clearInactivityTimeout();
        if (this.client !== null) {
            this.closedByUser = closedByUser;
            if (isForced) {
                this.clearCheckConnectionInterval();
                this.clearMaxConnectTimeout();
                this.clearTryReconnectTimeout();
                this.unsubscribeAll();
                this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_TERMINATE, null);
            }
            this.client.close();
            this.client.onopen = null;
            this.client.onclose = null;
            this.client.onerror = null;
            this.client.onmessage = null;
            this.client = null;
            this.eventEmitter.emit('disconnected');
            if (!isForced) {
                this.tryReconnect();
            }
        }
    };
    SubscriptionClient.prototype.request = function (request) {
        var _a;
        var getObserver = this.getObserver.bind(this);
        var executeOperation = this.executeOperation.bind(this);
        var unsubscribe = this.unsubscribe.bind(this);
        var opId;
        this.clearInactivityTimeout();
        return _a = {},
            _a[symbol_observable_1.default] = function () {
                return this;
            },
            _a.subscribe = function (observerOrNext, onError, onComplete) {
                var observer = getObserver(observerOrNext, onError, onComplete);
                opId = executeOperation(request, function (error, result) {
                    if (error === null && result === null) {
                        if (observer.complete) {
                            observer.complete();
                        }
                    }
                    else if (error) {
                        if (observer.error) {
                            observer.error(error[0]);
                        }
                    }
                    else {
                        if (observer.next) {
                            observer.next(result);
                        }
                    }
                });
                return {
                    unsubscribe: function () {
                        if (opId) {
                            unsubscribe(opId);
                            opId = null;
                        }
                    },
                };
            },
            _a;
    };
    SubscriptionClient.prototype.on = function (eventName, callback, context) {
        var handler = this.eventEmitter.on(eventName, callback, context);
        return function () {
            handler.off(eventName, callback, context);
        };
    };
    SubscriptionClient.prototype.onConnected = function (callback, context) {
        return this.on('connected', callback, context);
    };
    SubscriptionClient.prototype.onConnecting = function (callback, context) {
        return this.on('connecting', callback, context);
    };
    SubscriptionClient.prototype.onDisconnected = function (callback, context) {
        return this.on('disconnected', callback, context);
    };
    SubscriptionClient.prototype.onReconnected = function (callback, context) {
        return this.on('reconnected', callback, context);
    };
    SubscriptionClient.prototype.onReconnecting = function (callback, context) {
        return this.on('reconnecting', callback, context);
    };
    SubscriptionClient.prototype.onError = function (callback, context) {
        return this.on('error', callback, context);
    };
    SubscriptionClient.prototype.unsubscribeAll = function () {
        var _this = this;
        Object.keys(this.operations).forEach(function (subId) {
            _this.unsubscribe(subId);
        });
    };
    SubscriptionClient.prototype.applyMiddlewares = function (options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var queue = function (funcs, scope) {
                var next = function (error) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        if (funcs.length > 0) {
                            var f = funcs.shift();
                            if (f) {
                                f.applyMiddleware.apply(scope, [options, next]);
                            }
                        }
                        else {
                            resolve(options);
                        }
                    }
                };
                next();
            };
            queue(__spreadArrays(_this.middlewares), _this);
        });
    };
    SubscriptionClient.prototype.use = function (middlewares) {
        var _this = this;
        middlewares.map(function (middleware) {
            if (typeof middleware.applyMiddleware === 'function') {
                _this.middlewares.push(middleware);
            }
            else {
                throw new Error('Middleware must implement the applyMiddleware function.');
            }
        });
        return this;
    };
    SubscriptionClient.prototype.getConnectionParams = function (connectionParams) {
        return function () { return new Promise(function (resolve, reject) {
            if (typeof connectionParams === 'function') {
                try {
                    return resolve(connectionParams.call(null));
                }
                catch (error) {
                    return reject(error);
                }
            }
            resolve(connectionParams);
        }); };
    };
    SubscriptionClient.prototype.executeOperation = function (options, handler) {
        var _this = this;
        if (this.client === null) {
            this.connect();
        }
        var opId = this.generateOperationId();
        this.operations[opId] = { options: options, handler: handler };
        this.applyMiddlewares(options)
            .then(function (processedOptions) {
            _this.checkOperationOptions(processedOptions, handler);
            if (_this.operations[opId]) {
                _this.operations[opId] = { options: processedOptions, handler: handler };
                _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);
            }
        })
            .catch(function (error) {
            _this.unsubscribe(opId);
            handler(_this.formatErrors(error));
        });
        return opId;
    };
    SubscriptionClient.prototype.getObserver = function (observerOrNext, error, complete) {
        if (typeof observerOrNext === 'function') {
            return {
                next: function (v) { return observerOrNext(v); },
                error: function (e) { return error && error(e); },
                complete: function () { return complete && complete(); },
            };
        }
        return observerOrNext;
    };
    SubscriptionClient.prototype.createMaxConnectTimeGenerator = function () {
        var minValue = this.minWsTimeout;
        var maxValue = this.wsTimeout;
        return new Backoff({
            min: minValue,
            max: maxValue,
            factor: 1.2,
        });
    };
    SubscriptionClient.prototype.clearCheckConnectionInterval = function () {
        if (this.checkConnectionIntervalId) {
            clearInterval(this.checkConnectionIntervalId);
            this.checkConnectionIntervalId = null;
        }
    };
    SubscriptionClient.prototype.clearMaxConnectTimeout = function () {
        if (this.maxConnectTimeoutId) {
            clearTimeout(this.maxConnectTimeoutId);
            this.maxConnectTimeoutId = null;
        }
    };
    SubscriptionClient.prototype.clearTryReconnectTimeout = function () {
        if (this.tryReconnectTimeoutId) {
            clearTimeout(this.tryReconnectTimeoutId);
            this.tryReconnectTimeoutId = null;
        }
    };
    SubscriptionClient.prototype.clearInactivityTimeout = function () {
        if (this.inactivityTimeoutId) {
            clearTimeout(this.inactivityTimeoutId);
            this.inactivityTimeoutId = null;
        }
    };
    SubscriptionClient.prototype.setInactivityTimeout = function () {
        var _this = this;
        if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {
            this.inactivityTimeoutId = setTimeout(function () {
                if (Object.keys(_this.operations).length === 0) {
                    _this.close();
                }
            }, this.inactivityTimeout);
        }
    };
    SubscriptionClient.prototype.checkOperationOptions = function (options, handler) {
        var query = options.query, variables = options.variables, operationName = options.operationName;
        if (!query) {
            throw new Error('Must provide a query.');
        }
        if (!handler) {
            throw new Error('Must provide an handler.');
        }
        if ((!is_string_1.default(query) && !getOperationAST_1.getOperationAST(query, operationName)) ||
            (operationName && !is_string_1.default(operationName)) ||
            (variables && !is_object_1.default(variables))) {
            throw new Error('Incorrect option types. query must be a string or a document,' +
                '`operationName` must be a string, and `variables` must be an object.');
        }
    };
    SubscriptionClient.prototype.buildMessage = function (id, type, payload) {
        var payloadToReturn = payload && payload.query ? __assign(__assign({}, payload), { query: typeof payload.query === 'string' ? payload.query : printer_1.print(payload.query) }) :
            payload;
        return {
            id: id,
            type: type,
            payload: payloadToReturn,
        };
    };
    SubscriptionClient.prototype.formatErrors = function (errors) {
        if (Array.isArray(errors)) {
            return errors;
        }
        if (errors && errors.errors) {
            return this.formatErrors(errors.errors);
        }
        if (errors && errors.message) {
            return [errors];
        }
        return [{
                name: 'FormatedError',
                message: 'Unknown error',
                originalError: errors,
            }];
    };
    SubscriptionClient.prototype.sendMessage = function (id, type, payload) {
        this.sendMessageRaw(this.buildMessage(id, type, payload));
    };
    SubscriptionClient.prototype.sendMessageRaw = function (message) {
        switch (this.status) {
            case this.wsImpl.OPEN:
                var serializedMessage = JSON.stringify(message);
                try {
                    JSON.parse(serializedMessage);
                }
                catch (e) {
                    this.eventEmitter.emit('error', new Error("Message must be JSON-serializable. Got: " + message));
                }
                this.client.send(serializedMessage);
                break;
            case this.wsImpl.CONNECTING:
                this.unsentMessagesQueue.push(message);
                break;
            default:
                if (!this.reconnecting) {
                    this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' +
                        'is already closed. Message was: ' + JSON.stringify(message)));
                }
        }
    };
    SubscriptionClient.prototype.generateOperationId = function () {
        return String(++this.nextOperationId);
    };
    SubscriptionClient.prototype.tryReconnect = function () {
        var _this = this;
        if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {
            return;
        }
        if (!this.reconnecting) {
            Object.keys(this.operations).forEach(function (key) {
                _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));
            });
            this.reconnecting = true;
        }
        this.clearTryReconnectTimeout();
        var delay = this.backoff.duration();
        this.tryReconnectTimeoutId = setTimeout(function () {
            _this.connect();
        }, delay);
    };
    SubscriptionClient.prototype.flushUnsentMessagesQueue = function () {
        var _this = this;
        this.unsentMessagesQueue.forEach(function (message) {
            _this.sendMessageRaw(message);
        });
        this.unsentMessagesQueue = [];
    };
    SubscriptionClient.prototype.checkConnection = function () {
        if (this.wasKeepAliveReceived) {
            this.wasKeepAliveReceived = false;
            return;
        }
        if (!this.reconnecting) {
            this.close(false, true);
        }
    };
    SubscriptionClient.prototype.checkMaxConnectTimeout = function () {
        var _this = this;
        this.clearMaxConnectTimeout();
        this.maxConnectTimeoutId = setTimeout(function () {
            if (_this.status !== _this.wsImpl.OPEN) {
                _this.reconnecting = true;
                _this.close(false, true);
            }
        }, this.maxConnectTimeGenerator.duration());
    };
    SubscriptionClient.prototype.connect = function () {
        var _a;
        var _this = this;
        this.client = new ((_a = this.wsImpl).bind.apply(_a, __spreadArrays([void 0, this.url, this.wsProtocols], this.wsOptionArguments)))();
        this.checkMaxConnectTimeout();
        this.client.onopen = function () { return __awaiter(_this, void 0, void 0, function () {
            var connectionParams, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.status === this.wsImpl.OPEN)) return [3, 4];
                        this.clearMaxConnectTimeout();
                        this.closedByUser = false;
                        this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4, this.connectionParams()];
                    case 2:
                        connectionParams = _a.sent();
                        this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);
                        this.flushUnsentMessagesQueue();
                        return [3, 4];
                    case 3:
                        error_1 = _a.sent();
                        this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_ERROR, error_1);
                        this.flushUnsentMessagesQueue();
                        return [3, 4];
                    case 4: return [2];
                }
            });
        }); };
        this.client.onclose = function () {
            if (!_this.closedByUser) {
                _this.close(false, false);
            }
        };
        this.client.onerror = function (err) {
            _this.eventEmitter.emit('error', err);
        };
        this.client.onmessage = function (_a) {
            var data = _a.data;
            _this.processReceivedData(data);
        };
    };
    SubscriptionClient.prototype.processReceivedData = function (receivedData) {
        var parsedMessage;
        var opId;
        try {
            parsedMessage = JSON.parse(receivedData);
            opId = parsedMessage.id;
        }
        catch (e) {
            throw new Error("Message must be JSON-parseable. Got: " + receivedData);
        }
        if ([message_types_1.default.GQL_DATA,
            message_types_1.default.GQL_COMPLETE,
            message_types_1.default.GQL_ERROR,
        ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {
            this.unsubscribe(opId);
            return;
        }
        switch (parsedMessage.type) {
            case message_types_1.default.GQL_CONNECTION_ERROR:
                if (this.connectionCallback) {
                    this.connectionCallback(parsedMessage.payload);
                }
                break;
            case message_types_1.default.GQL_CONNECTION_ACK:
                this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected', parsedMessage.payload);
                this.reconnecting = false;
                this.backoff.reset();
                this.maxConnectTimeGenerator.reset();
                if (this.connectionCallback) {
                    this.connectionCallback();
                }
                break;
            case message_types_1.default.GQL_COMPLETE:
                var handler = this.operations[opId].handler;
                delete this.operations[opId];
                handler.call(this, null, null);
                break;
            case message_types_1.default.GQL_ERROR:
                this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);
                delete this.operations[opId];
                break;
            case message_types_1.default.GQL_DATA:
                var parsedPayload = !parsedMessage.payload.errors ?
                    parsedMessage.payload : __assign(__assign({}, parsedMessage.payload), { errors: this.formatErrors(parsedMessage.payload.errors) });
                this.operations[opId].handler(null, parsedPayload);
                break;
            case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:
                var firstKA = typeof this.wasKeepAliveReceived === 'undefined';
                this.wasKeepAliveReceived = true;
                if (firstKA) {
                    this.checkConnection();
                }
                if (this.checkConnectionIntervalId) {
                    clearInterval(this.checkConnectionIntervalId);
                    this.checkConnection();
                }
                this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);
                break;
            default:
                throw new Error('Invalid message type!');
        }
    };
    SubscriptionClient.prototype.unsubscribe = function (opId) {
        if (this.operations[opId]) {
            delete this.operations[opId];
            this.setInactivityTimeout();
            this.sendMessage(opId, message_types_1.default.GQL_STOP, undefined);
        }
    };
    return SubscriptionClient;
}());
exports.SubscriptionClient = SubscriptionClient;
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/defaults.js":
/*!******************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/defaults.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WS_TIMEOUT = exports.MIN_WS_TIMEOUT = void 0;
var MIN_WS_TIMEOUT = 1000;
exports.MIN_WS_TIMEOUT = MIN_WS_TIMEOUT;
var WS_TIMEOUT = 30000;
exports.WS_TIMEOUT = WS_TIMEOUT;
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/message-types.js":
/*!***********************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/message-types.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var MessageTypes = (function () {
    function MessageTypes() {
        throw new Error('Static Class');
    }
    MessageTypes.GQL_CONNECTION_INIT = 'connection_init';
    MessageTypes.GQL_CONNECTION_ACK = 'connection_ack';
    MessageTypes.GQL_CONNECTION_ERROR = 'connection_error';
    MessageTypes.GQL_CONNECTION_KEEP_ALIVE = 'ka';
    MessageTypes.GQL_CONNECTION_TERMINATE = 'connection_terminate';
    MessageTypes.GQL_START = 'start';
    MessageTypes.GQL_DATA = 'data';
    MessageTypes.GQL_ERROR = 'error';
    MessageTypes.GQL_COMPLETE = 'complete';
    MessageTypes.GQL_STOP = 'stop';
    MessageTypes.SUBSCRIPTION_START = 'subscription_start';
    MessageTypes.SUBSCRIPTION_DATA = 'subscription_data';
    MessageTypes.SUBSCRIPTION_SUCCESS = 'subscription_success';
    MessageTypes.SUBSCRIPTION_FAIL = 'subscription_fail';
    MessageTypes.SUBSCRIPTION_END = 'subscription_end';
    MessageTypes.INIT = 'init';
    MessageTypes.INIT_SUCCESS = 'init_success';
    MessageTypes.INIT_FAIL = 'init_fail';
    MessageTypes.KEEP_ALIVE = 'keepalive';
    return MessageTypes;
}());
exports.default = MessageTypes;
//# sourceMappingURL=message-types.js.map

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/protocol.js":
/*!******************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/protocol.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GRAPHQL_SUBSCRIPTIONS = exports.GRAPHQL_WS = void 0;
var GRAPHQL_WS = 'graphql-ws';
exports.GRAPHQL_WS = GRAPHQL_WS;
var GRAPHQL_SUBSCRIPTIONS = 'graphql-subscriptions';
exports.GRAPHQL_SUBSCRIPTIONS = GRAPHQL_SUBSCRIPTIONS;
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/utils/is-object.js":
/*!*************************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/utils/is-object.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isObject(value) {
    return ((value !== null) && (typeof value === 'object'));
}
exports.default = isObject;
//# sourceMappingURL=is-object.js.map

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/utils/is-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/utils/is-string.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isString(value) {
    return typeof value === 'string';
}
exports.default = isString;
//# sourceMappingURL=is-string.js.map

/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/es/ponyfill.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  root = __webpack_require__.g;
} else if (true) {
  root = module;
} else {}

var result = (0,_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.default)(root);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (result);


/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ symbolObservablePonyfill)
/* harmony export */ });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "./node_modules/ton-client-js/dist/TONClient.js":
/*!******************************************************!*\
  !*** ./node_modules/ton-client-js/dist/TONClient.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TONClient = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _opentracing = __webpack_require__(/*! opentracing */ "./node_modules/opentracing/lib/index.js");

var _TONConfigModule = _interopRequireDefault(__webpack_require__(/*! ./modules/TONConfigModule */ "./node_modules/ton-client-js/dist/modules/TONConfigModule.js"));

var _TONContractsModule = _interopRequireDefault(__webpack_require__(/*! ./modules/TONContractsModule */ "./node_modules/ton-client-js/dist/modules/TONContractsModule.js"));

var _TONCryptoModule = _interopRequireDefault(__webpack_require__(/*! ./modules/TONCryptoModule */ "./node_modules/ton-client-js/dist/modules/TONCryptoModule.js"));

var _TONQueriesModule = _interopRequireDefault(__webpack_require__(/*! ./modules/TONQueriesModule */ "./node_modules/ton-client-js/dist/modules/TONQueriesModule.js"));

var _TONModule = __webpack_require__(/*! ./TONModule */ "./node_modules/ton-client-js/dist/TONModule.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Main object provided functionality of the TON Client Library
 * Each instance of TONClient has own set of TON Client modules
 * and has own preconfigured client context
 */
var TONClient = /*#__PURE__*/function () {
  _createClass(TONClient, null, [{
    key: "setLibrary",
    value: function setLibrary(clientPlatform) {
      TONClient.clientPlatform = clientPlatform;
    } // Public

  }]);

  function TONClient() {
    _classCallCheck(this, TONClient);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "crypto", void 0);

    _defineProperty(this, "contracts", void 0);

    _defineProperty(this, "queries", void 0);

    _defineProperty(this, "_queries", void 0);

    _defineProperty(this, "_context", void 0);

    _defineProperty(this, "_coreBridge", void 0);

    _defineProperty(this, "modules", void 0);

    this.modules = new Map();
    this.config = this.getModule(_TONConfigModule["default"]);
    this.crypto = this.getModule(_TONCryptoModule["default"]);
    this.contracts = this.getModule(_TONContractsModule["default"]);
    this._queries = this.getModule(_TONQueriesModule["default"]);
    this.queries = this._queries;
    this._context = 0;
    this._coreBridge = null;
  }
  /**
   * Convenient way to create configured instance of the TON Client
   * @param {TONConfigData} config
   * @return {Promise<TONClient>}
   */


  _createClass(TONClient, [{
    key: "setup",

    /**
     * Set up the client instance
     * @return {Promise<void>}
     */
    value: function () {
      var _setup = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var modules, _iterator, _step, module;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getCoreBridge();

              case 2:
                modules = _toConsumableArray(this.modules.values());
                _iterator = _createForOfIteratorHelper(modules);
                _context.prev = 4;

                _iterator.s();

              case 6:
                if ((_step = _iterator.n()).done) {
                  _context.next = 12;
                  break;
                }

                module = _step.value;
                _context.next = 10;
                return module.setup();

              case 10:
                _context.next = 6;
                break;

              case 12:
                _context.next = 17;
                break;

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](4);

                _iterator.e(_context.t0);

              case 17:
                _context.prev = 17;

                _iterator.f();

                return _context.finish(17);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 14, 17, 20]]);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
    /**
     * Tear down this client instance.
     * Note that after you have called this method all future use of this instance will fail
     * @return {Promise<void>}
     */

  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var library, context;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.queries.close();

              case 2:
                library = TONClient.coreLibrary;

                if (!(this._context > 0 && library !== null && library !== undefined)) {
                  _context2.next = 9;
                  break;
                }

                context = this._context;
                this._coreBridge = null;
                this._context = 0;
                _context2.next = 9;
                return new Promise(function (resolve) {
                  return library.coreDestroyContext(context, resolve);
                });

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }() // TONModuleContext

  }, {
    key: "completeErrorData",
    value: function () {
      var _completeErrorData = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(data) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.t0 = _objectSpread;
                _context3.t1 = _objectSpread({}, data);
                _context3.t2 = {};
                _context3.next = 5;
                return this.config.getVersion();

              case 5:
                _context3.t3 = _context3.sent;
                _context3.t4 = this.config.getConfigServer();
                _context3.t5 = this._queries.getQueryUrl();
                _context3.t6 = {
                  core_version: _context3.t3,
                  config_server: _context3.t4,
                  query_url: _context3.t5
                };
                return _context3.abrupt("return", (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t6));

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function completeErrorData(_x) {
        return _completeErrorData.apply(this, arguments);
      }

      return completeErrorData;
    }()
  }, {
    key: "tryCreateLibrary",
    value: function () {
      var _tryCreateLibrary = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var platform;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                platform = TONClient.clientPlatform;

                if (!(platform === null || platform === undefined)) {
                  _context4.next = 3;
                  break;
                }

                return _context4.abrupt("return", null);

              case 3:
                _context4.next = 5;
                return platform.createLibrary();

              case 5:
                TONClient.coreLibrary = _context4.sent;
                return _context4.abrupt("return", TONClient.coreLibrary);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function tryCreateLibrary() {
        return _tryCreateLibrary.apply(this, arguments);
      }

      return tryCreateLibrary;
    }()
  }, {
    key: "tryCreateCoreBridge",
    value: function () {
      var _tryCreateCoreBridge = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
        var _this = this;

        var library;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.t0 = TONClient.coreLibrary;

                if (_context5.t0) {
                  _context5.next = 5;
                  break;
                }

                _context5.next = 4;
                return this.tryCreateLibrary();

              case 4:
                _context5.t0 = _context5.sent;

              case 5:
                library = _context5.t0;

                if (library) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt("return");

              case 8:
                if (!library.coreCreateContext) {
                  _context5.next = 15;
                  break;
                }

                _context5.next = 11;
                return new Promise(function (resolve) {
                  return library.coreCreateContext(resolve);
                });

              case 11:
                this._context = _context5.sent;
                this._coreBridge = {
                  request: function request(method, paramsJson, onResult) {
                    if (TONClient.coreLibrary) {
                      TONClient.coreLibrary.coreRequest(_this._context, method, paramsJson, onResult);
                    }
                  }
                };
                _context5.next = 16;
                break;

              case 15:
                this._coreBridge = library;

              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function tryCreateCoreBridge() {
        return _tryCreateCoreBridge.apply(this, arguments);
      }

      return tryCreateCoreBridge;
    }()
  }, {
    key: "getCoreBridge",
    value: function () {
      var _getCoreBridge = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this._coreBridge) {
                  _context6.next = 3;
                  break;
                }

                _context6.next = 3;
                return this.tryCreateCoreBridge();

              case 3:
                return _context6.abrupt("return", this._coreBridge);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getCoreBridge() {
        return _getCoreBridge.apply(this, arguments);
      }

      return getCoreBridge;
    }()
  }, {
    key: "getModule",
    value: function getModule(ModuleClass) {
      var name = ModuleClass.moduleName;
      var existingModule = this.modules.get(name);

      if (existingModule) {
        return existingModule;
      }

      var module = new ModuleClass(this);
      this.modules.set(name, module);
      return module;
    }
  }, {
    key: "serverTimeDelta",
    value: function serverTimeDelta() {
      return this._queries.serverTimeDelta();
    }
  }, {
    key: "serverNow",
    value: function serverNow() {
      return this._queries.serverNow();
    }
  }, {
    key: "getManagementAccessKey",
    value: function () {
      var _getManagementAccessKey = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
        var result;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._queries.query('query{getManagementAccessKey}');

              case 2:
                result = _context7.sent;
                return _context7.abrupt("return", result.data.getManagementAccessKey);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getManagementAccessKey() {
        return _getManagementAccessKey.apply(this, arguments);
      }

      return getManagementAccessKey;
    }()
  }, {
    key: "_resolveSignedManagementAccessKey",
    value: function () {
      var _resolveSignedManagementAccessKey2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee8(params) {
        var signKeys, managementAccessKey;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!params.signedManagementAccessKey) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", params.signedManagementAccessKey);

              case 2:
                signKeys = params.accountKeys;

                if (!signKeys) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 6;
                return this.getManagementAccessKey();

              case 6:
                managementAccessKey = _context8.sent;
                return _context8.abrupt("return", this.crypto.naclSign({
                  text: managementAccessKey
                }, "".concat(signKeys.secret).concat(signKeys["public"]), 'Hex'));

              case 8:
                return _context8.abrupt("return", '');

              case 9:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _resolveSignedManagementAccessKey(_x2) {
        return _resolveSignedManagementAccessKey2.apply(this, arguments);
      }

      return _resolveSignedManagementAccessKey;
    }()
  }, {
    key: "registerAccessKeys",
    value: function () {
      var _registerAccessKeys = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee9(params) {
        var signedManagementAccessKey, result;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._resolveSignedManagementAccessKey(params);

              case 2:
                signedManagementAccessKey = _context9.sent;
                _context9.next = 5;
                return this._queries.mutation("mutation registerAccessKeys($account: String, $keys: [AccessKey], $signedManagementAccessKey: String) {\n                    registerAccessKeys(account: $account, keys: $keys, signedManagementAccessKey: $signedManagementAccessKey)\n                }", {
                  account: params.account,
                  keys: params.keys,
                  signedManagementAccessKey: signedManagementAccessKey
                });

              case 5:
                result = _context9.sent;
                return _context9.abrupt("return", result.data.registerAccessKeys);

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function registerAccessKeys(_x3) {
        return _registerAccessKeys.apply(this, arguments);
      }

      return registerAccessKeys;
    }()
  }, {
    key: "revokeAccessKeys",
    value: function () {
      var _revokeAccessKeys = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee10(params) {
        var signedManagementAccessKey, result;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._resolveSignedManagementAccessKey(params);

              case 2:
                signedManagementAccessKey = _context10.sent;
                _context10.next = 5;
                return this._queries.mutation("mutation revokeAccessKeys($account: String, $keys: [String], $signedManagementAccessKey: String) {\n                    revokeAccessKeys(account: $account, keys: $keys, signedManagementAccessKey: $signedManagementAccessKey)\n                }", {
                  account: params.account,
                  keys: params.keys,
                  signedManagementAccessKey: signedManagementAccessKey
                });

              case 5:
                result = _context10.sent;
                return _context10.abrupt("return", result.data.revokeAccessKeys);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function revokeAccessKeys(_x4) {
        return _revokeAccessKeys.apply(this, arguments);
      }

      return revokeAccessKeys;
    }()
  }, {
    key: "startRootSpan",
    value: function startRootSpan(traceId, spanId, operationName) {
      var tracer = this.config.tracer;
      var span = null;

      if (tracer._startInternalSpan) {
        try {
          var ctx = tracer.extract(_opentracing.FORMAT_TEXT_MAP, {
            'uber-trace-id': "".concat(traceId, ":").concat(spanId, ":0:1")
          });

          if (ctx) {
            span = this.config.tracer._startInternalSpan(ctx, operationName, Date.now(), // startTime
            undefined, // userTags
            {}, // internalTags
            [], // references
            false, // hasValidParent
            false // isRpcServer
            );
          }
        } catch (_unused) {// tracer can't create message span using private method,
          // so we are fallback to create span using regular method
        }
      }

      return span || tracer.startSpan(operationName);
    }
  }, {
    key: "trace",
    value: function () {
      var _trace = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee11(name, f, parentSpan) {
        var span, result;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                span = this.config.tracer.startSpan(name, {
                  childOf: parentSpan
                });
                _context11.prev = 1;
                span.setTag(_opentracing.Tags.SPAN_KIND, 'client');
                _context11.next = 5;
                return f(span);

              case 5:
                result = _context11.sent;

                if (result !== undefined) {
                  span.setTag('result', result);
                }

                span.finish();
                return _context11.abrupt("return", result);

              case 11:
                _context11.prev = 11;
                _context11.t0 = _context11["catch"](1);
                span.log({
                  event: 'failed',
                  payload: _context11.t0
                });
                span.finish();
                throw _context11.t0;

              case 16:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[1, 11]]);
      }));

      function trace(_x5, _x6, _x7) {
        return _trace.apply(this, arguments);
      }

      return trace;
    }() // Internals

  }], [{
    key: "create",
    value: function () {
      var _create = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee12(config) {
        var client;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                client = new TONClient();
                client.config.setData(config);
                _context12.next = 4;
                return client.setup();

              case 4:
                return _context12.abrupt("return", client);

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      }));

      function create(_x8) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }]);

  return TONClient;
}();

exports.TONClient = TONClient;

_defineProperty(TONClient, "clientPlatform", null);

_defineProperty(TONClient, "coreLibrary", null);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9UT05DbGllbnQuanMiXSwibmFtZXMiOlsiVE9OQ2xpZW50IiwiY2xpZW50UGxhdGZvcm0iLCJtb2R1bGVzIiwiTWFwIiwiY29uZmlnIiwiZ2V0TW9kdWxlIiwiVE9OQ29uZmlnTW9kdWxlIiwiY3J5cHRvIiwiVE9OQ3J5cHRvTW9kdWxlIiwiY29udHJhY3RzIiwiVE9OQ29udHJhY3RzTW9kdWxlIiwiX3F1ZXJpZXMiLCJUT05RdWVyaWVzTW9kdWxlIiwicXVlcmllcyIsIl9jb250ZXh0IiwiX2NvcmVCcmlkZ2UiLCJnZXRDb3JlQnJpZGdlIiwidmFsdWVzIiwibW9kdWxlIiwic2V0dXAiLCJjbG9zZSIsImxpYnJhcnkiLCJjb3JlTGlicmFyeSIsInVuZGVmaW5lZCIsImNvbnRleHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvcmVEZXN0cm95Q29udGV4dCIsImRhdGEiLCJnZXRWZXJzaW9uIiwiZ2V0Q29uZmlnU2VydmVyIiwiZ2V0UXVlcnlVcmwiLCJjb3JlX3ZlcnNpb24iLCJjb25maWdfc2VydmVyIiwicXVlcnlfdXJsIiwicGxhdGZvcm0iLCJjcmVhdGVMaWJyYXJ5IiwidHJ5Q3JlYXRlTGlicmFyeSIsImNvcmVDcmVhdGVDb250ZXh0IiwicmVxdWVzdCIsIm1ldGhvZCIsInBhcmFtc0pzb24iLCJvblJlc3VsdCIsImNvcmVSZXF1ZXN0IiwidHJ5Q3JlYXRlQ29yZUJyaWRnZSIsIk1vZHVsZUNsYXNzIiwibmFtZSIsIm1vZHVsZU5hbWUiLCJleGlzdGluZ01vZHVsZSIsImdldCIsInNldCIsInNlcnZlclRpbWVEZWx0YSIsInNlcnZlck5vdyIsInF1ZXJ5IiwicmVzdWx0IiwiZ2V0TWFuYWdlbWVudEFjY2Vzc0tleSIsInBhcmFtcyIsInNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXkiLCJzaWduS2V5cyIsImFjY291bnRLZXlzIiwibWFuYWdlbWVudEFjY2Vzc0tleSIsIm5hY2xTaWduIiwidGV4dCIsInNlY3JldCIsIl9yZXNvbHZlU2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleSIsIm11dGF0aW9uIiwiYWNjb3VudCIsImtleXMiLCJyZWdpc3RlckFjY2Vzc0tleXMiLCJyZXZva2VBY2Nlc3NLZXlzIiwidHJhY2VJZCIsInNwYW5JZCIsIm9wZXJhdGlvbk5hbWUiLCJ0cmFjZXIiLCJzcGFuIiwiX3N0YXJ0SW50ZXJuYWxTcGFuIiwiY3R4IiwiZXh0cmFjdCIsIkZPUk1BVF9URVhUX01BUCIsIkRhdGUiLCJub3ciLCJzdGFydFNwYW4iLCJmIiwicGFyZW50U3BhbiIsImNoaWxkT2YiLCJzZXRUYWciLCJUYWdzIiwiU1BBTl9LSU5EIiwiZmluaXNoIiwibG9nIiwiZXZlbnQiLCJwYXlsb2FkIiwiY2xpZW50Iiwic2V0RGF0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBS0E7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7O0lBS2FBLFM7OzsrQkFDU0MsYyxFQUFtQztBQUNqREQsTUFBQUEsU0FBUyxDQUFDQyxjQUFWLEdBQTJCQSxjQUEzQjtBQUNILEssQ0FHRDs7OztBQVNBLHVCQUFjO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQ1YsU0FBS0MsT0FBTCxHQUFlLElBQUlDLEdBQUosRUFBZjtBQUNBLFNBQUtDLE1BQUwsR0FBYyxLQUFLQyxTQUFMLENBQWVDLDJCQUFmLENBQWQ7QUFDQSxTQUFLQyxNQUFMLEdBQWMsS0FBS0YsU0FBTCxDQUFlRywyQkFBZixDQUFkO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQixLQUFLSixTQUFMLENBQWVLLDhCQUFmLENBQWpCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixLQUFLTixTQUFMLENBQWVPLDRCQUFmLENBQWhCO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLEtBQUtGLFFBQXBCO0FBQ0EsU0FBS0csUUFBTCxHQUFnQixDQUFoQjtBQUNBLFNBQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDSDtBQUVEOzs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7dUJBS1UsS0FBS0MsYUFBTCxFOzs7QUFDQWQsZ0JBQUFBLE8sc0JBQTJCLEtBQUtBLE9BQUwsQ0FBYWUsTUFBYixFO3VEQUNaZixPOzs7Ozs7Ozs7OztBQUFWZ0IsZ0JBQUFBLE07O3VCQUNEQSxNQUFNLENBQUNDLEtBQVAsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlkOzs7Ozs7Ozs7Ozs7Ozs7O3VCQU1VLEtBQUtOLE9BQUwsQ0FBYU8sS0FBYixFOzs7QUFDQUMsZ0JBQUFBLE8sR0FBVXJCLFNBQVMsQ0FBQ3NCLFc7O3NCQUN0QixLQUFLUixRQUFMLEdBQWdCLENBQWhCLElBQXFCTyxPQUFPLEtBQUssSUFBakMsSUFBeUNBLE9BQU8sS0FBS0UsUzs7Ozs7QUFDL0NDLGdCQUFBQSxPLEdBQVUsS0FBS1YsUTtBQUNyQixxQkFBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLHFCQUFLRCxRQUFMLEdBQWdCLENBQWhCOzt1QkFDTSxJQUFJVyxPQUFKLENBQVksVUFBQUMsT0FBTztBQUFBLHlCQUFJTCxPQUFPLENBQUNNLGtCQUFSLENBQTJCSCxPQUEzQixFQUFvQ0UsT0FBcEMsQ0FBSjtBQUFBLGlCQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7UUFJZDs7Ozs7OEdBRXdCRSxJOzs7Ozs7aURBRWJBLEk7Ozt1QkFDaUIsS0FBS3hCLE1BQUwsQ0FBWXlCLFVBQVosRTs7OzsrQkFDTCxLQUFLekIsTUFBTCxDQUFZMEIsZUFBWixFOytCQUNKLEtBQUtuQixRQUFMLENBQWNvQixXQUFkLEU7O0FBRlhDLGtCQUFBQSxZO0FBQ0FDLGtCQUFBQSxhO0FBQ0FDLGtCQUFBQSxTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLRUMsZ0JBQUFBLFEsR0FBV25DLFNBQVMsQ0FBQ0MsYzs7c0JBQ3ZCa0MsUUFBUSxLQUFLLElBQWIsSUFBcUJBLFFBQVEsS0FBS1osUzs7Ozs7a0RBQzNCLEk7Ozs7dUJBRW1CWSxRQUFRLENBQUNDLGFBQVQsRTs7O0FBQTlCcEMsZ0JBQUFBLFNBQVMsQ0FBQ3NCLFc7a0RBQ0h0QixTQUFTLENBQUNzQixXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBSUR0QixTQUFTLENBQUNzQixXOzs7Ozs7Ozt1QkFBcUIsS0FBS2UsZ0JBQUwsRTs7Ozs7O0FBQXpDaEIsZ0JBQUFBLE87O29CQUNEQSxPOzs7Ozs7OztxQkFHREEsT0FBTyxDQUFDaUIsaUI7Ozs7Ozt1QkFDYyxJQUFJYixPQUFKLENBQVksVUFBQ0MsT0FBRDtBQUFBLHlCQUFhTCxPQUFPLENBQUNpQixpQkFBUixDQUEwQlosT0FBMUIsQ0FBYjtBQUFBLGlCQUFaLEM7OztBQUF0QixxQkFBS1osUTtBQUNMLHFCQUFLQyxXQUFMLEdBQW1CO0FBQ2Z3QixrQkFBQUEsT0FBTyxFQUFFLGlCQUNMQyxNQURLLEVBRUxDLFVBRkssRUFHTEMsUUFISyxFQUlFO0FBQ1Asd0JBQUkxQyxTQUFTLENBQUNzQixXQUFkLEVBQTJCO0FBQ3ZCdEIsc0JBQUFBLFNBQVMsQ0FBQ3NCLFdBQVYsQ0FBc0JxQixXQUF0QixDQUNJLEtBQUksQ0FBQzdCLFFBRFQsRUFFSTBCLE1BRkosRUFHSUMsVUFISixFQUlJQyxRQUpKO0FBTUg7QUFDSjtBQWRjLGlCQUFuQjs7Ozs7QUFpQkEscUJBQUszQixXQUFMLEdBQW1CTSxPQUFuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUtDLEtBQUtOLFc7Ozs7Ozt1QkFDQSxLQUFLNkIsbUJBQUwsRTs7O2tEQUVILEtBQUs3QixXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBR0g4QixXLEVBQWtDO0FBQzNDLFVBQU1DLElBQUksR0FBR0QsV0FBVyxDQUFDRSxVQUF6QjtBQUNBLFVBQU1DLGNBQWMsR0FBRyxLQUFLOUMsT0FBTCxDQUFhK0MsR0FBYixDQUFpQkgsSUFBakIsQ0FBdkI7O0FBQ0EsVUFBSUUsY0FBSixFQUFvQjtBQUNoQixlQUFRQSxjQUFSO0FBQ0g7O0FBQ0QsVUFBTTlCLE1BQU0sR0FBRyxJQUFJMkIsV0FBSixDQUFnQixJQUFoQixDQUFmO0FBQ0EsV0FBSzNDLE9BQUwsQ0FBYWdELEdBQWIsQ0FBaUJKLElBQWpCLEVBQXVCNUIsTUFBdkI7QUFDQSxhQUFRQSxNQUFSO0FBQ0g7OztzQ0FFa0M7QUFDL0IsYUFBTyxLQUFLUCxRQUFMLENBQWN3QyxlQUFkLEVBQVA7QUFDSDs7O2dDQUU0QjtBQUN6QixhQUFPLEtBQUt4QyxRQUFMLENBQWN5QyxTQUFkLEVBQVA7QUFDSDs7Ozs7Ozs7Ozs7dUJBR3dCLEtBQUt6QyxRQUFMLENBQWMwQyxLQUFkLENBQW9CLCtCQUFwQixDOzs7QUFBZkMsZ0JBQUFBLE07a0RBQ0NBLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTJCLHNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhIQUtuQkMsTTs7Ozs7O3FCQUVJQSxNQUFNLENBQUNDLHlCOzs7OztrREFDQUQsTUFBTSxDQUFDQyx5Qjs7O0FBRVpDLGdCQUFBQSxRLEdBQVdGLE1BQU0sQ0FBQ0csVzs7cUJBQ3BCRCxROzs7Ozs7dUJBQ2tDLEtBQUtILHNCQUFMLEU7OztBQUE1QkssZ0JBQUFBLG1CO2tEQUNDLEtBQUtyRCxNQUFMLENBQVlzRCxRQUFaLENBQ0g7QUFBRUMsa0JBQUFBLElBQUksRUFBRUY7QUFBUixpQkFERyxZQUVBRixRQUFRLENBQUNLLE1BRlQsU0FFa0JMLFFBQVEsVUFGMUIsR0FHSCxLQUhHLEM7OztrREFNSixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OytHQUlQRixNOzs7Ozs7O3VCQUV3QyxLQUFLUSxpQ0FBTCxDQUF1Q1IsTUFBdkMsQzs7O0FBQWxDQyxnQkFBQUEseUI7O3VCQUNlLEtBQUs5QyxRQUFMLENBQWNzRCxRQUFkLDhQQUdUO0FBQ0pDLGtCQUFBQSxPQUFPLEVBQUVWLE1BQU0sQ0FBQ1UsT0FEWjtBQUVKQyxrQkFBQUEsSUFBSSxFQUFFWCxNQUFNLENBQUNXLElBRlQ7QUFHSlYsa0JBQUFBLHlCQUF5QixFQUF6QkE7QUFISSxpQkFIUyxDOzs7QUFBZkgsZ0JBQUFBLE07a0RBU0NBLE1BQU0sQ0FBQzFCLElBQVAsQ0FBWXdDLGtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhHQUluQlosTTs7Ozs7Ozt1QkFFd0MsS0FBS1EsaUNBQUwsQ0FBdUNSLE1BQXZDLEM7OztBQUFsQ0MsZ0JBQUFBLHlCOzt1QkFDZSxLQUFLOUMsUUFBTCxDQUFjc0QsUUFBZCx1UEFHVDtBQUNKQyxrQkFBQUEsT0FBTyxFQUFFVixNQUFNLENBQUNVLE9BRFo7QUFFSkMsa0JBQUFBLElBQUksRUFBRVgsTUFBTSxDQUFDVyxJQUZUO0FBR0pWLGtCQUFBQSx5QkFBeUIsRUFBekJBO0FBSEksaUJBSFMsQzs7O0FBQWZILGdCQUFBQSxNO21EQVNDQSxNQUFNLENBQUMxQixJQUFQLENBQVl5QyxnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUdUQyxPLEVBQWlCQyxNLEVBQWdCQyxhLEVBQTZCO0FBQ3hFLFVBQU1DLE1BQU0sR0FBRyxLQUFLckUsTUFBTCxDQUFZcUUsTUFBM0I7QUFDQSxVQUFJQyxJQUFXLEdBQUcsSUFBbEI7O0FBQ0EsVUFBSUQsTUFBTSxDQUFDRSxrQkFBWCxFQUErQjtBQUMzQixZQUFJO0FBQ0EsY0FBTUMsR0FBRyxHQUFHSCxNQUFNLENBQUNJLE9BQVAsQ0FBZUMsNEJBQWYsRUFBZ0M7QUFDeEMsdUNBQW9CUixPQUFwQixjQUErQkMsTUFBL0I7QUFEd0MsV0FBaEMsQ0FBWjs7QUFHQSxjQUFJSyxHQUFKLEVBQVM7QUFDTEYsWUFBQUEsSUFBSSxHQUFHLEtBQUt0RSxNQUFMLENBQVlxRSxNQUFaLENBQW1CRSxrQkFBbkIsQ0FDSEMsR0FERyxFQUVISixhQUZHLEVBR0hPLElBQUksQ0FBQ0MsR0FBTCxFQUhHLEVBR1M7QUFDWnpELFlBQUFBLFNBSkcsRUFJUTtBQUNYLGNBTEcsRUFLQztBQUNKLGNBTkcsRUFNQztBQUNKLGlCQVBHLEVBT0k7QUFDUCxpQkFSRyxDQVFJO0FBUkosYUFBUDtBQVVIO0FBQ0osU0FoQkQsQ0FnQkUsZ0JBQU0sQ0FDSjtBQUNBO0FBQ0g7QUFDSjs7QUFDRCxhQUFPbUQsSUFBSSxJQUFJRCxNQUFNLENBQUNRLFNBQVAsQ0FBaUJULGFBQWpCLENBQWY7QUFDSDs7OzttR0FHRzFCLEksRUFDQW9DLEMsRUFDQUMsVTs7Ozs7O0FBRU1ULGdCQUFBQSxJLEdBQU8sS0FBS3RFLE1BQUwsQ0FBWXFFLE1BQVosQ0FBbUJRLFNBQW5CLENBQTZCbkMsSUFBN0IsRUFBbUM7QUFBRXNDLGtCQUFBQSxPQUFPLEVBQUVEO0FBQVgsaUJBQW5DLEM7O0FBRVRULGdCQUFBQSxJQUFJLENBQUNXLE1BQUwsQ0FBWUMsa0JBQUtDLFNBQWpCLEVBQTRCLFFBQTVCOzt1QkFDcUJMLENBQUMsQ0FBQ1IsSUFBRCxDOzs7QUFBaEJwQixnQkFBQUEsTTs7QUFDTixvQkFBSUEsTUFBTSxLQUFLL0IsU0FBZixFQUEwQjtBQUN0Qm1ELGtCQUFBQSxJQUFJLENBQUNXLE1BQUwsQ0FBWSxRQUFaLEVBQXNCL0IsTUFBdEI7QUFDSDs7QUFDRG9CLGdCQUFBQSxJQUFJLENBQUNjLE1BQUw7bURBQ09sQyxNOzs7OztBQUVQb0IsZ0JBQUFBLElBQUksQ0FBQ2UsR0FBTCxDQUFTO0FBQ0xDLGtCQUFBQSxLQUFLLEVBQUUsUUFERjtBQUVMQyxrQkFBQUEsT0FBTztBQUZGLGlCQUFUO0FBSUFqQixnQkFBQUEsSUFBSSxDQUFDYyxNQUFMOzs7Ozs7Ozs7Ozs7Ozs7O1FBS1I7Ozs7O29HQXpOb0JwRixNOzs7Ozs7QUFDVndGLGdCQUFBQSxNLEdBQVMsSUFBSTVGLFNBQUosRTtBQUNmNEYsZ0JBQUFBLE1BQU0sQ0FBQ3hGLE1BQVAsQ0FBY3lGLE9BQWQsQ0FBc0J6RixNQUF0Qjs7dUJBQ013RixNQUFNLENBQUN6RSxLQUFQLEU7OzttREFDQ3lFLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQW5DRjVGLFMsb0JBMFBtQyxJOztnQkExUG5DQSxTLGlCQTJQbUMsSSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIwIFRPTiBERVYgU09MVVRJT05TIExURC5cbiAqL1xuLy8gQGZsb3dcblxuaW1wb3J0IHtcbiAgICBUYWdzLCBTcGFuLCBTcGFuQ29udGV4dCwgRk9STUFUX1RFWFRfTUFQLFxufSBmcm9tICdvcGVudHJhY2luZyc7XG5pbXBvcnQgdHlwZSB7XG4gICAgSVRPTkNsaWVudCxcbiAgICBUT05BY2Nlc3NLZXlzTWFuYWdlbWVudFBhcmFtcyxcbiAgICBUT05Db25maWdEYXRhLFxuICAgIFRPTkNvbnRyYWN0cyxcbiAgICBUT05DcnlwdG8sXG4gICAgVE9OUXVlcmllcyxcbiAgICBUT05SZWdpc3RlckFjY2Vzc0tleXNQYXJhbXMsXG4gICAgVE9OUmV2b2tlQWNjZXNzS2V5c1BhcmFtcyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgVE9OQ29uZmlnTW9kdWxlIGZyb20gJy4vbW9kdWxlcy9UT05Db25maWdNb2R1bGUnO1xuaW1wb3J0IFRPTkNvbnRyYWN0c01vZHVsZSBmcm9tICcuL21vZHVsZXMvVE9OQ29udHJhY3RzTW9kdWxlJztcbmltcG9ydCBUT05DcnlwdG9Nb2R1bGUgZnJvbSAnLi9tb2R1bGVzL1RPTkNyeXB0b01vZHVsZSc7XG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLCBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuaW1wb3J0IFRPTlF1ZXJpZXNNb2R1bGUgZnJvbSAnLi9tb2R1bGVzL1RPTlF1ZXJpZXNNb2R1bGUnO1xuaW1wb3J0IHR5cGUgeyBUT05FcnJvckRhdGEgfSBmcm9tICcuL1RPTkNsaWVudEVycm9yJztcblxuaW1wb3J0IHR5cGUge1xuICAgIFRPTkNsaWVudENvcmVMaWJyYXJ5LFxuICAgIFRPTkNsaWVudENvcmVCcmlkZ2UsXG4gICAgVE9OTW9kdWxlQ29udGV4dCxcbn0gZnJvbSAnLi9UT05Nb2R1bGUnO1xuaW1wb3J0IHsgVE9OTW9kdWxlIH0gZnJvbSAnLi9UT05Nb2R1bGUnO1xuXG4vKipcbiAqIEphdmFTY3JpcHQgcGxhdGZvcm0gc3BlY2lmaWMgY29uZmlndXJhdGlvblxuICovXG50eXBlIFRPTkNsaWVudFBsYXRmb3JtID0ge1xuICAgIC8qKlxuICAgICAqIFBsYXRmb3JtIHNwZWNpZmljIGBmZXRjaGAgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmZXRjaDogYW55LFxuICAgIC8qKlxuICAgICAqIFBsYXRmb3JtIHNwZWNpZmljIGBXZWJTb2NrZXRgIGltcGxlbWVudGF0aW9uXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBtdXN0IGNvbmZvcm1zIHRvIFczQyBXZWJTb2NrZXRcbiAgICAgKi9cbiAgICBXZWJTb2NrZXQ6IGFueSxcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNyZWF0aW9uIG9mIHRoZSBjbGllbnQgY29yZVxuICAgICAqL1xuICAgIGNyZWF0ZUxpYnJhcnk6ICgpID0+IFByb21pc2U8VE9OQ2xpZW50Q29yZUxpYnJhcnk+LFxufTtcblxuLyoqXG4gKiBNYWluIG9iamVjdCBwcm92aWRlZCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBUT04gQ2xpZW50IExpYnJhcnlcbiAqIEVhY2ggaW5zdGFuY2Ugb2YgVE9OQ2xpZW50IGhhcyBvd24gc2V0IG9mIFRPTiBDbGllbnQgbW9kdWxlc1xuICogYW5kIGhhcyBvd24gcHJlY29uZmlndXJlZCBjbGllbnQgY29udGV4dFxuICovXG5leHBvcnQgY2xhc3MgVE9OQ2xpZW50IGltcGxlbWVudHMgVE9OTW9kdWxlQ29udGV4dCwgSVRPTkNsaWVudCB7XG4gICAgc3RhdGljIHNldExpYnJhcnkoY2xpZW50UGxhdGZvcm06IFRPTkNsaWVudFBsYXRmb3JtKSB7XG4gICAgICAgIFRPTkNsaWVudC5jbGllbnRQbGF0Zm9ybSA9IGNsaWVudFBsYXRmb3JtO1xuICAgIH1cblxuXG4gICAgLy8gUHVibGljXG4gICAgY29uZmlnOiBUT05Db25maWdNb2R1bGU7XG4gICAgY3J5cHRvOiBUT05DcnlwdG87XG4gICAgY29udHJhY3RzOiBUT05Db250cmFjdHM7XG4gICAgcXVlcmllczogVE9OUXVlcmllcztcbiAgICBfcXVlcmllczogVE9OUXVlcmllc01vZHVsZTtcbiAgICBfY29udGV4dDogbnVtYmVyO1xuICAgIF9jb3JlQnJpZGdlOiA/VE9OQ2xpZW50Q29yZUJyaWRnZTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5nZXRNb2R1bGUoVE9OQ29uZmlnTW9kdWxlKTtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSB0aGlzLmdldE1vZHVsZShUT05DcnlwdG9Nb2R1bGUpO1xuICAgICAgICB0aGlzLmNvbnRyYWN0cyA9IHRoaXMuZ2V0TW9kdWxlKFRPTkNvbnRyYWN0c01vZHVsZSk7XG4gICAgICAgIHRoaXMuX3F1ZXJpZXMgPSB0aGlzLmdldE1vZHVsZShUT05RdWVyaWVzTW9kdWxlKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gdGhpcy5fcXVlcmllcztcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IDA7XG4gICAgICAgIHRoaXMuX2NvcmVCcmlkZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbnQgd2F5IHRvIGNyZWF0ZSBjb25maWd1cmVkIGluc3RhbmNlIG9mIHRoZSBUT04gQ2xpZW50XG4gICAgICogQHBhcmFtIHtUT05Db25maWdEYXRhfSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFRPTkNsaWVudD59XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShjb25maWc6IFRPTkNvbmZpZ0RhdGEpOiBQcm9taXNlPFRPTkNsaWVudD4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgVE9OQ2xpZW50KCk7XG4gICAgICAgIGNsaWVudC5jb25maWcuc2V0RGF0YShjb25maWcpO1xuICAgICAgICBhd2FpdCBjbGllbnQuc2V0dXAoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgdGhlIGNsaWVudCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgc2V0dXAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0Q29yZUJyaWRnZSgpO1xuICAgICAgICBjb25zdCBtb2R1bGVzOiBUT05Nb2R1bGVbXSA9IFsuLi50aGlzLm1vZHVsZXMudmFsdWVzKCldO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICAgICAgICBhd2FpdCBtb2R1bGUuc2V0dXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlYXIgZG93biB0aGlzIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgKiBOb3RlIHRoYXQgYWZ0ZXIgeW91IGhhdmUgY2FsbGVkIHRoaXMgbWV0aG9kIGFsbCBmdXR1cmUgdXNlIG9mIHRoaXMgaW5zdGFuY2Ugd2lsbCBmYWlsXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5xdWVyaWVzLmNsb3NlKCk7XG4gICAgICAgIGNvbnN0IGxpYnJhcnkgPSBUT05DbGllbnQuY29yZUxpYnJhcnk7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0ID4gMCAmJiBsaWJyYXJ5ICE9PSBudWxsICYmIGxpYnJhcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9jb3JlQnJpZGdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSAwO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBsaWJyYXJ5LmNvcmVEZXN0cm95Q29udGV4dChjb250ZXh0LCByZXNvbHZlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT05Nb2R1bGVDb250ZXh0XG5cbiAgICBhc3luYyBjb21wbGV0ZUVycm9yRGF0YShkYXRhPzogeyBbc3RyaW5nXTogYW55IH0pOiBQcm9taXNlPFRPTkVycm9yRGF0YT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGNvcmVfdmVyc2lvbjogYXdhaXQgdGhpcy5jb25maWcuZ2V0VmVyc2lvbigpLFxuICAgICAgICAgICAgY29uZmlnX3NlcnZlcjogdGhpcy5jb25maWcuZ2V0Q29uZmlnU2VydmVyKCksXG4gICAgICAgICAgICBxdWVyeV91cmw6IHRoaXMuX3F1ZXJpZXMuZ2V0UXVlcnlVcmwoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyB0cnlDcmVhdGVMaWJyYXJ5KCkge1xuICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IFRPTkNsaWVudC5jbGllbnRQbGF0Zm9ybTtcbiAgICAgICAgaWYgKHBsYXRmb3JtID09PSBudWxsIHx8IHBsYXRmb3JtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFRPTkNsaWVudC5jb3JlTGlicmFyeSA9IGF3YWl0IHBsYXRmb3JtLmNyZWF0ZUxpYnJhcnkoKTtcbiAgICAgICAgcmV0dXJuIFRPTkNsaWVudC5jb3JlTGlicmFyeTtcbiAgICB9XG5cbiAgICBhc3luYyB0cnlDcmVhdGVDb3JlQnJpZGdlKCkge1xuICAgICAgICBjb25zdCBsaWJyYXJ5ID0gVE9OQ2xpZW50LmNvcmVMaWJyYXJ5IHx8IGF3YWl0IHRoaXMudHJ5Q3JlYXRlTGlicmFyeSgpO1xuICAgICAgICBpZiAoIWxpYnJhcnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlicmFyeS5jb3JlQ3JlYXRlQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBsaWJyYXJ5LmNvcmVDcmVhdGVDb250ZXh0KHJlc29sdmUpKTtcbiAgICAgICAgICAgIHRoaXMuX2NvcmVCcmlkZ2UgPSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogKFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zSnNvbjogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBvblJlc3VsdDogKHJlc3VsdEpzb246IHN0cmluZywgZXJyb3JKc29uOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgICAgICAgICAgICAgKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUT05DbGllbnQuY29yZUxpYnJhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRPTkNsaWVudC5jb3JlTGlicmFyeS5jb3JlUmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNKc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29yZUJyaWRnZSA9IGxpYnJhcnk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRDb3JlQnJpZGdlKCk6IFByb21pc2U8P1RPTkNsaWVudENvcmVCcmlkZ2U+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb3JlQnJpZGdlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRyeUNyZWF0ZUNvcmVCcmlkZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29yZUJyaWRnZTtcbiAgICB9XG5cbiAgICBnZXRNb2R1bGU8VD4oTW9kdWxlQ2xhc3M6IHR5cGVvZiBUT05Nb2R1bGUpOiBUIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IE1vZHVsZUNsYXNzLm1vZHVsZU5hbWU7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTW9kdWxlID0gdGhpcy5tb2R1bGVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGV4aXN0aW5nTW9kdWxlOiBhbnkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBNb2R1bGVDbGFzcyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnNldChuYW1lLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm4gKG1vZHVsZTogYW55KTtcbiAgICB9XG5cbiAgICBzZXJ2ZXJUaW1lRGVsdGEoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJpZXMuc2VydmVyVGltZURlbHRhKCk7XG4gICAgfVxuXG4gICAgc2VydmVyTm93KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyaWVzLnNlcnZlck5vdygpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldE1hbmFnZW1lbnRBY2Nlc3NLZXkoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcXVlcmllcy5xdWVyeSgncXVlcnl7Z2V0TWFuYWdlbWVudEFjY2Vzc0tleX0nKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhLmdldE1hbmFnZW1lbnRBY2Nlc3NLZXk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBfcmVzb2x2ZVNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXkoXG4gICAgICAgIHBhcmFtczogVE9OQWNjZXNzS2V5c01hbmFnZW1lbnRQYXJhbXMsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgaWYgKHBhcmFtcy5zaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLnNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbktleXMgPSBwYXJhbXMuYWNjb3VudEtleXM7XG4gICAgICAgIGlmIChzaWduS2V5cykge1xuICAgICAgICAgICAgY29uc3QgbWFuYWdlbWVudEFjY2Vzc0tleSA9IGF3YWl0IHRoaXMuZ2V0TWFuYWdlbWVudEFjY2Vzc0tleSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvLm5hY2xTaWduKFxuICAgICAgICAgICAgICAgIHsgdGV4dDogbWFuYWdlbWVudEFjY2Vzc0tleSB9LFxuICAgICAgICAgICAgICAgIGAke3NpZ25LZXlzLnNlY3JldH0ke3NpZ25LZXlzLnB1YmxpY31gLFxuICAgICAgICAgICAgICAgICdIZXgnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVnaXN0ZXJBY2Nlc3NLZXlzKFxuICAgICAgICBwYXJhbXM6IFRPTlJlZ2lzdGVyQWNjZXNzS2V5c1BhcmFtcyxcbiAgICApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICBjb25zdCBzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5ID0gYXdhaXQgdGhpcy5fcmVzb2x2ZVNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXkocGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcXVlcmllcy5tdXRhdGlvbihcbiAgICAgICAgICAgIGBtdXRhdGlvbiByZWdpc3RlckFjY2Vzc0tleXMoJGFjY291bnQ6IFN0cmluZywgJGtleXM6IFtBY2Nlc3NLZXldLCAkc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleTogU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQWNjZXNzS2V5cyhhY2NvdW50OiAkYWNjb3VudCwga2V5czogJGtleXMsIHNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXk6ICRzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5KVxuICAgICAgICAgICAgICAgIH1gLCB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogcGFyYW1zLmFjY291bnQsXG4gICAgICAgICAgICAgICAga2V5czogcGFyYW1zLmtleXMsXG4gICAgICAgICAgICAgICAgc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQuZGF0YS5yZWdpc3RlckFjY2Vzc0tleXM7XG4gICAgfVxuXG4gICAgYXN5bmMgcmV2b2tlQWNjZXNzS2V5cyhcbiAgICAgICAgcGFyYW1zOiBUT05SZXZva2VBY2Nlc3NLZXlzUGFyYW1zLFxuICAgICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXkgPSBhd2FpdCB0aGlzLl9yZXNvbHZlU2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleShwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9xdWVyaWVzLm11dGF0aW9uKFxuICAgICAgICAgICAgYG11dGF0aW9uIHJldm9rZUFjY2Vzc0tleXMoJGFjY291bnQ6IFN0cmluZywgJGtleXM6IFtTdHJpbmddLCAkc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleTogU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldm9rZUFjY2Vzc0tleXMoYWNjb3VudDogJGFjY291bnQsIGtleXM6ICRrZXlzLCBzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5OiAkc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleSlcbiAgICAgICAgICAgICAgICB9YCwge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6IHBhcmFtcy5hY2NvdW50LFxuICAgICAgICAgICAgICAgIGtleXM6IHBhcmFtcy5rZXlzLFxuICAgICAgICAgICAgICAgIHNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXksXG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGEucmV2b2tlQWNjZXNzS2V5cztcbiAgICB9XG5cbiAgICBzdGFydFJvb3RTcGFuKHRyYWNlSWQ6IHN0cmluZywgc3BhbklkOiBzdHJpbmcsIG9wZXJhdGlvbk5hbWU6IHN0cmluZyk6IFNwYW4ge1xuICAgICAgICBjb25zdCB0cmFjZXIgPSB0aGlzLmNvbmZpZy50cmFjZXI7XG4gICAgICAgIGxldCBzcGFuOiA/U3BhbiA9IG51bGw7XG4gICAgICAgIGlmICh0cmFjZXIuX3N0YXJ0SW50ZXJuYWxTcGFuKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRyYWNlci5leHRyYWN0KEZPUk1BVF9URVhUX01BUCwge1xuICAgICAgICAgICAgICAgICAgICAndWJlci10cmFjZS1pZCc6IGAke3RyYWNlSWR9OiR7c3BhbklkfTowOjFgLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiA9IHRoaXMuY29uZmlnLnRyYWNlci5fc3RhcnRJbnRlcm5hbFNwYW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSwgLy8gc3RhcnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIC8vIHVzZXJUYWdzXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSwgLy8gaW50ZXJuYWxUYWdzXG4gICAgICAgICAgICAgICAgICAgICAgICBbXSwgLy8gcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIC8vIGhhc1ZhbGlkUGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSwgLy8gaXNScGNTZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyB0cmFjZXIgY2FuJ3QgY3JlYXRlIG1lc3NhZ2Ugc3BhbiB1c2luZyBwcml2YXRlIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBhcmUgZmFsbGJhY2sgdG8gY3JlYXRlIHNwYW4gdXNpbmcgcmVndWxhciBtZXRob2RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbiB8fCB0cmFjZXIuc3RhcnRTcGFuKG9wZXJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGFzeW5jIHRyYWNlPFQ+KFxuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIGY6IChzcGFuOiBTcGFuKSA9PiBQcm9taXNlPFQ+LFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUPiB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmNvbmZpZy50cmFjZXIuc3RhcnRTcGFuKG5hbWUsIHsgY2hpbGRPZjogcGFyZW50U3BhbiB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4uc2V0VGFnKFRhZ3MuU1BBTl9LSU5ELCAnY2xpZW50Jyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmKHNwYW4pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRUYWcoJ3Jlc3VsdCcsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFuLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNwYW4ubG9nKHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2ZhaWxlZCcsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwYW4uZmluaXNoKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgc3RhdGljIGNsaWVudFBsYXRmb3JtOiA/VE9OQ2xpZW50UGxhdGZvcm0gPSBudWxsO1xuICAgIHN0YXRpYyBjb3JlTGlicmFyeTogP1RPTkNsaWVudENvcmVMaWJyYXJ5ID0gbnVsbDtcblxuICAgIG1vZHVsZXM6IE1hcDxzdHJpbmcsIFRPTk1vZHVsZT47XG59XG4iXX0=

/***/ }),

/***/ "./node_modules/ton-client-js/dist/TONClientError.js":
/*!***********************************************************!*\
  !*** ./node_modules/ton-client-js/dist/TONClientError.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TONClientError = exports.TONContractExitCode = exports.TONErrorCode = exports.TONErrorSource = exports.emptyTONErrorData = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var emptyTONErrorData = {
  core_version: '',
  config_server: '',
  query_url: ''
};
exports.emptyTONErrorData = emptyTONErrorData;
var TONErrorSource = {
  CLIENT: 'client',
  NODE: 'node'
};
exports.TONErrorSource = TONErrorSource;
var TONErrorCode = {
  CLIENT_IS_NOT_SETUP: 1000,
  SEND_NODE_REQUEST_FAILED: 1001,
  MESSAGE_ALREADY_EXPIRED: 1001,
  RUN_LOCAL_ACCOUNT_DOES_NOT_EXISTS: 1002,
  WAIT_FOR_TIMEOUT: 1003,
  INTERNAL_ERROR: 1004,
  QUERY_FAILED: 1005,
  MESSAGE_EXPIRED: 1006,
  SERVER_DOESNT_SUPPORT_AGGREGATIONS: 1007,
  INVALID_CONS: 1008,
  ADDRESS_REQUIRED_FOR_RUN_LOCAL: 1009,
  NETWORK_SILENT: 1010,
  TRANSACTION_LAG: 1011,
  TRANSACTION_WAIT_TIMEOUT: 1012,
  CLOCK_OUT_OF_SYNC: 1013,
  ACCOUNT_MISSING: 1014,
  ACCOUNT_CODE_MISSING: 1015,
  ACCOUNT_BALANCE_TOO_LOW: 1016,
  ACCOUNT_FROZEN_OR_DELETED: 1017,
  // Crypto
  SIGNING_SOURCE_IS_NOT_SPECIFIED: 2021,
  INVALID_CRYPTO_BOX_PARAMS: 2030,
  // Contracts
  CONTRACT_EXECUTION_FAILED: 3025,
  // Queries
  QUERY_FORCIBLY_ABORTED: 4005
};
exports.TONErrorCode = TONErrorCode;
var TONContractExitCode = {
  REPLAY_PROTECTION: 52,
  MESSAGE_EXPIRED: 57,
  NO_GAS: 13
};
exports.TONContractExitCode = TONContractExitCode;

var TONClientError = /*#__PURE__*/function () {
  function TONClientError(code, message, data, source) {
    _classCallCheck(this, TONClientError);

    _defineProperty(this, "message", void 0);

    _defineProperty(this, "source", void 0);

    _defineProperty(this, "code", void 0);

    _defineProperty(this, "data", void 0);

    this.code = code;
    this.message = message;
    this.data = data;
    this.source = source || TONErrorSource.CLIENT;
  } // Testers


  _createClass(TONClientError, null, [{
    key: "isClientError",
    value: function isClientError(error, code) {
      return error.source === TONErrorSource.CLIENT && error.code === code;
    }
  }, {
    key: "isNodeError",
    value: function isNodeError(error, code) {
      return error.source === TONErrorSource.NODE && error.code === code;
    }
  }, {
    key: "isContractError",
    value: function isContractError(error, exitCode) {
      return error.source === TONErrorSource.NODE && error.code === TONErrorCode.CONTRACT_EXECUTION_FAILED && error.data && error.data.exit_code === exitCode;
    }
  }, {
    key: "isOriginalContractError",
    value: function isOriginalContractError(error, exitCode) {
      var _error$data;

      return TONClientError.isContractError(error, exitCode) && !((_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.original_error);
    }
  }, {
    key: "isResolvedContractErrorAfterExpire",
    value: function isResolvedContractErrorAfterExpire(error, exitCode) {
      return TONClientError.isContractError(error, exitCode) && error.data && error.data.original_error && TONClientError.isMessageExpired(error.data.original_error);
    }
  }, {
    key: "isMessageExpired",
    value: function isMessageExpired(error) {
      return TONClientError.isClientError(error, TONErrorCode.MESSAGE_EXPIRED);
    }
  }, {
    key: "isWaitForTimeout",
    value: function isWaitForTimeout(error) {
      return TONClientError.isClientError(error, TONErrorCode.WAIT_FOR_TIMEOUT);
    } // Builders

  }, {
    key: "internalError",
    value: function internalError(message, data) {
      return new TONClientError(TONErrorCode.INTERNAL_ERROR, "Internal error: ".concat(message), data);
    }
  }, {
    key: "invalidCons",
    value: function invalidCons(data) {
      return new TONClientError(TONErrorCode.INVALID_CONS, 'Invalid CONS structure. Each CONS item must contains of two elements.', data);
    }
  }, {
    key: "sendNodeRequestFailed",
    value: function sendNodeRequestFailed(responseText, data) {
      return new TONClientError(TONErrorCode.SEND_NODE_REQUEST_FAILED, "Send node request failed: ".concat(responseText), data);
    }
  }, {
    key: "runLocalAccountDoesNotExists",
    value: function runLocalAccountDoesNotExists(functionName, address, data) {
      return new TONClientError(TONErrorCode.RUN_LOCAL_ACCOUNT_DOES_NOT_EXISTS, "[".concat(functionName, "] run local failed: account [").concat(address, "] does not exists"), data);
    }
  }, {
    key: "waitForTimeout",
    value: function waitForTimeout(data) {
      return new TONClientError(TONErrorCode.WAIT_FOR_TIMEOUT, 'Wait for operation rejected on timeout', data);
    }
  }, {
    key: "queryFailed",
    value: function queryFailed(errors, data) {
      return new TONClientError(TONErrorCode.QUERY_FAILED, "Query failed: ".concat(errors.map(function (x) {
        return x.message || x.toString();
      }).join('\n')), data);
    }
  }, {
    key: "formatTime",
    value: function formatTime(time) {
      if (time) {
        return "".concat(new Date(time * 1000).toISOString(), " (").concat(time, ")");
      }

      return null;
    }
  }, {
    key: "messageExpired",
    value: function messageExpired(data) {
      return new TONClientError(TONErrorCode.MESSAGE_EXPIRED, 'Message expired', _objectSpread(_objectSpread({}, data), {}, {
        sending_time: TONClientError.formatTime(data.sending_time),
        expiration_time: TONClientError.formatTime(data.expire),
        block_time: TONClientError.formatTime(data.block_time)
      }), TONErrorSource.CLIENT);
    }
  }, {
    key: "serverDoesntSupportAggregations",
    value: function serverDoesntSupportAggregations(data) {
      return new TONClientError(TONErrorCode.SERVER_DOESNT_SUPPORT_AGGREGATIONS, 'Server doesn\'t support aggregations', data);
    }
  }, {
    key: "addressRequiredForRunLocal",
    value: function addressRequiredForRunLocal(data) {
      return new TONClientError(TONErrorCode.ADDRESS_REQUIRED_FOR_RUN_LOCAL, 'Address required for run local. You haven\'t specified contract code or data ' + 'so address is required to load missing parts from network.', data);
    }
  }, {
    key: "networkSilent",
    value: function networkSilent(data) {
      return new TONClientError(TONErrorCode.NETWORK_SILENT, 'Network silent: no blocks produced during timeout.', _objectSpread(_objectSpread({}, data), {}, {
        sending_time: TONClientError.formatTime(data.sending_time),
        expiration_time: TONClientError.formatTime(data.expire)
      }));
    }
  }, {
    key: "transactionWaitTimeout",
    value: function transactionWaitTimeout(data) {
      return new TONClientError(TONErrorCode.TRANSACTION_WAIT_TIMEOUT, 'Transaction did not produced during specified timeout', _objectSpread(_objectSpread({}, data), {}, {
        sending_time: TONClientError.formatTime(data.sending_time)
      }));
    }
  }, {
    key: "clockOutOfSync",
    value: function clockOutOfSync(data) {
      return new TONClientError(TONErrorCode.CLOCK_OUT_OF_SYNC, 'You local clock is out of sync with the server time. ' + 'It is a critical condition for sending messages to the blockchain. ' + 'Please sync you clock with the internet time.', data);
    }
  }, {
    key: "accountMissing",
    value: function accountMissing(address, data) {
      return new TONClientError(TONErrorCode.ACCOUNT_MISSING, "Account with address [".concat(address, "] doesn't exists. ") + 'You have to prepaid this account to have a positive balance on them and then deploy ' + 'a contract code for this account.' + 'See SDK documentation for detailed instructions.', data);
    }
  }, {
    key: "accountCodeMissing",
    value: function accountCodeMissing(address, balance, data) {
      return new TONClientError(TONErrorCode.ACCOUNT_CODE_MISSING, "Account with address [".concat(address, "] exists but haven't a contract code yet. ") + 'You have to ensure that an account has an enough balance for deploying ' + 'a contract code and then deploy a contract code for this account. ' + "Current account balance is [".concat(balance, "]. ") + 'See SDK documentation for detailed instructions.', data);
    }
  }, {
    key: "accountBalanceTooLow",
    value: function accountBalanceTooLow(address, balance, data) {
      return new TONClientError(TONErrorCode.ACCOUNT_BALANCE_TOO_LOW, "Account with address [".concat(address, "] has too low balance [").concat(balance, "]. ") + 'You have to send some value to account balance from other contract ' + '(e.g. Wallet contract). ' + 'See SDK documentation for detailed instructions.', data);
    }
  }, {
    key: "noBlocks",
    value: function noBlocks(workchain, data) {
      var workchainName = workchain === -1 ? 'masterchain' : "workchain ".concat(workchain);
      return new TONClientError(TONErrorCode.NETWORK_SILENT, "\"No blocks for ".concat(workchainName, " found\"."), data);
    }
  }, {
    key: "invalidBlockchain",
    value: function invalidBlockchain(message, data) {
      return new TONClientError(TONErrorCode.NETWORK_SILENT, message, data);
    }
  }, {
    key: "queryForciblyAborted",
    value: function queryForciblyAborted(data) {
      return new TONClientError(TONErrorCode.QUERY_FORCIBLY_ABORTED, 'GraphQL query was forcibly aborted on timeout.', data);
    }
  }, {
    key: "signingSourceIsNotSpecified",
    value: function signingSourceIsNotSpecified() {
      return new TONClientError('You must provide signing keys or signing box to sign you message.', TONErrorCode.SIGNING_SOURCE_IS_NOT_SPECIFIED);
    }
  }, {
    key: "invalidCryptoBoxParams",
    value: function invalidCryptoBoxParams(encryptedSeedPhrase) {
      return new TONClientError('You must provide a valid encrypted seed phrase to create a core crypto box. ' + "Provided phrase is: ".concat(JSON.stringify(encryptedSeedPhrase), "."), TONErrorCode.INVALID_CRYPTO_BOX_PARAMS);
    }
  }, {
    key: "clientIsNotSetup",
    value: function clientIsNotSetup() {
      return new TONClientError(TONErrorCode.CLIENT_IS_NOT_SETUP, 'TON Client Library isn\'t set up properly', emptyTONErrorData);
    }
  }]);

  return TONClientError;
}();

exports.TONClientError = TONClientError;

_defineProperty(TONClientError, "source", TONErrorSource);

_defineProperty(TONClientError, "code", TONErrorCode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9UT05DbGllbnRFcnJvci5qcyJdLCJuYW1lcyI6WyJlbXB0eVRPTkVycm9yRGF0YSIsImNvcmVfdmVyc2lvbiIsImNvbmZpZ19zZXJ2ZXIiLCJxdWVyeV91cmwiLCJUT05FcnJvclNvdXJjZSIsIkNMSUVOVCIsIk5PREUiLCJUT05FcnJvckNvZGUiLCJDTElFTlRfSVNfTk9UX1NFVFVQIiwiU0VORF9OT0RFX1JFUVVFU1RfRkFJTEVEIiwiTUVTU0FHRV9BTFJFQURZX0VYUElSRUQiLCJSVU5fTE9DQUxfQUNDT1VOVF9ET0VTX05PVF9FWElTVFMiLCJXQUlUX0ZPUl9USU1FT1VUIiwiSU5URVJOQUxfRVJST1IiLCJRVUVSWV9GQUlMRUQiLCJNRVNTQUdFX0VYUElSRUQiLCJTRVJWRVJfRE9FU05UX1NVUFBPUlRfQUdHUkVHQVRJT05TIiwiSU5WQUxJRF9DT05TIiwiQUREUkVTU19SRVFVSVJFRF9GT1JfUlVOX0xPQ0FMIiwiTkVUV09SS19TSUxFTlQiLCJUUkFOU0FDVElPTl9MQUciLCJUUkFOU0FDVElPTl9XQUlUX1RJTUVPVVQiLCJDTE9DS19PVVRfT0ZfU1lOQyIsIkFDQ09VTlRfTUlTU0lORyIsIkFDQ09VTlRfQ09ERV9NSVNTSU5HIiwiQUNDT1VOVF9CQUxBTkNFX1RPT19MT1ciLCJBQ0NPVU5UX0ZST1pFTl9PUl9ERUxFVEVEIiwiU0lHTklOR19TT1VSQ0VfSVNfTk9UX1NQRUNJRklFRCIsIklOVkFMSURfQ1JZUFRPX0JPWF9QQVJBTVMiLCJDT05UUkFDVF9FWEVDVVRJT05fRkFJTEVEIiwiUVVFUllfRk9SQ0lCTFlfQUJPUlRFRCIsIlRPTkNvbnRyYWN0RXhpdENvZGUiLCJSRVBMQVlfUFJPVEVDVElPTiIsIk5PX0dBUyIsIlRPTkNsaWVudEVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJkYXRhIiwic291cmNlIiwiZXJyb3IiLCJleGl0Q29kZSIsImV4aXRfY29kZSIsImlzQ29udHJhY3RFcnJvciIsIm9yaWdpbmFsX2Vycm9yIiwiaXNNZXNzYWdlRXhwaXJlZCIsImlzQ2xpZW50RXJyb3IiLCJyZXNwb25zZVRleHQiLCJmdW5jdGlvbk5hbWUiLCJhZGRyZXNzIiwiZXJyb3JzIiwibWFwIiwieCIsInRvU3RyaW5nIiwiam9pbiIsInRpbWUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzZW5kaW5nX3RpbWUiLCJmb3JtYXRUaW1lIiwiZXhwaXJhdGlvbl90aW1lIiwiZXhwaXJlIiwiYmxvY2tfdGltZSIsImJhbGFuY2UiLCJ3b3JrY2hhaW4iLCJ3b3JrY2hhaW5OYW1lIiwiZW5jcnlwdGVkU2VlZFBocmFzZSIsIkpTT04iLCJzdHJpbmdpZnkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNQSxpQkFBK0IsR0FBRztBQUMzQ0MsRUFBQUEsWUFBWSxFQUFFLEVBRDZCO0FBRTNDQyxFQUFBQSxhQUFhLEVBQUUsRUFGNEI7QUFHM0NDLEVBQUFBLFNBQVMsRUFBRTtBQUhnQyxDQUF4Qzs7QUFNQSxJQUFNQyxjQUFjLEdBQUc7QUFDMUJDLEVBQUFBLE1BQU0sRUFBRSxRQURrQjtBQUUxQkMsRUFBQUEsSUFBSSxFQUFFO0FBRm9CLENBQXZCOztBQUtBLElBQU1DLFlBQVksR0FBRztBQUN4QkMsRUFBQUEsbUJBQW1CLEVBQUUsSUFERztBQUV4QkMsRUFBQUEsd0JBQXdCLEVBQUUsSUFGRjtBQUd4QkMsRUFBQUEsdUJBQXVCLEVBQUUsSUFIRDtBQUl4QkMsRUFBQUEsaUNBQWlDLEVBQUUsSUFKWDtBQUt4QkMsRUFBQUEsZ0JBQWdCLEVBQUUsSUFMTTtBQU14QkMsRUFBQUEsY0FBYyxFQUFFLElBTlE7QUFPeEJDLEVBQUFBLFlBQVksRUFBRSxJQVBVO0FBUXhCQyxFQUFBQSxlQUFlLEVBQUUsSUFSTztBQVN4QkMsRUFBQUEsa0NBQWtDLEVBQUUsSUFUWjtBQVV4QkMsRUFBQUEsWUFBWSxFQUFFLElBVlU7QUFXeEJDLEVBQUFBLDhCQUE4QixFQUFFLElBWFI7QUFZeEJDLEVBQUFBLGNBQWMsRUFBRSxJQVpRO0FBYXhCQyxFQUFB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SE8sSUFIRyxDQUFQO0FBS0g7OztrREFFb0M7QUFDakMsYUFBTyxJQUFJSCxjQUFKLENBQ0gsbUVBREcsRUFFSDNCLFlBQVksQ0FBQ29CLCtCQUZWLENBQVA7QUFJSDs7OzJDQUU2QnNDLG1CLEVBQXNDO0FBQ2hFLGFBQU8sSUFBSS9CLGNBQUosQ0FDSCwrR0FDeUJnQyxJQUFJLENBQUNDLFNBQUwsQ0FBZUYsbUJBQWYsQ0FEekIsTUFERyxFQUdIMUQsWUFBWSxDQUFDcUIseUJBSFYsQ0FBUDtBQUtIOzs7dUNBRXlCO0FBQ3RCLGFBQU8sSUFBSU0sY0FBSixDQUNIM0IsWUFBWSxDQUFDQyxtQkFEVixFQUVILDJDQUZHLEVBR0hSLGlCQUhHLENBQVA7QUFLSDs7Ozs7Ozs7Z0JBclRRa0MsYyxZQUNPOUIsYzs7Z0JBRFA4QixjLFVBRUszQixZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBUT05JbnB1dE1lc3NhZ2UsIFRPTk1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFRPTkVycm9yRGF0YSA9IHtcbiAgICBjb3JlX3ZlcnNpb246IHN0cmluZztcbiAgICBjb25maWdfc2VydmVyOiBzdHJpbmc7XG4gICAgcXVlcnlfdXJsOiBzdHJpbmc7XG4gICAgW3N0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGNvbnN0IGVtcHR5VE9ORXJyb3JEYXRhOiBUT05FcnJvckRhdGEgPSB7XG4gICAgY29yZV92ZXJzaW9uOiAnJyxcbiAgICBjb25maWdfc2VydmVyOiAnJyxcbiAgICBxdWVyeV91cmw6ICcnLFxufTtcblxuZXhwb3J0IGNvbnN0IFRPTkVycm9yU291cmNlID0ge1xuICAgIENMSUVOVDogJ2NsaWVudCcsXG4gICAgTk9ERTogJ25vZGUnLFxufTtcblxuZXhwb3J0IGNvbnN0IFRPTkVycm9yQ29kZSA9IHtcbiAgICBDTElFTlRfSVNfTk9UX1NFVFVQOiAxMDAwLFxuICAgIFNFTkRfTk9ERV9SRVFVRVNUX0ZBSUxFRDogMTAwMSxcbiAgICBNRVNTQUdFX0FMUkVBRFlfRVhQSVJFRDogMTAwMSxcbiAgICBSVU5fTE9DQUxfQUNDT1VOVF9ET0VTX05PVF9FWElTVFM6IDEwMDIsXG4gICAgV0FJVF9GT1JfVElNRU9VVDogMTAwMyxcbiAgICBJTlRFUk5BTF9FUlJPUjogMTAwNCxcbiAgICBRVUVSWV9GQUlMRUQ6IDEwMDUsXG4gICAgTUVTU0FHRV9FWFBJUkVEOiAxMDA2LFxuICAgIFNFUlZFUl9ET0VTTlRfU1VQUE9SVF9BR0dSRUdBVElPTlM6IDEwMDcsXG4gICAgSU5WQUxJRF9DT05TOiAxMDA4LFxuICAgIEFERFJFU1NfUkVRVUlSRURfRk9SX1JVTl9MT0NBTDogMTAwOSxcbiAgICBORVRXT1JLX1NJTEVOVDogMTAxMCxcbiAgICBUUkFOU0FDVElPTl9MQUc6IDEwMTEsXG4gICAgVFJBTlNBQ1RJT05fV0FJVF9USU1FT1VUOiAxMDEyLFxuICAgIENMT0NLX09VVF9PRl9TWU5DOiAxMDEzLFxuICAgIEFDQ09VTlRfTUlTU0lORzogMTAxNCxcbiAgICBBQ0NPVU5UX0NPREVfTUlTU0lORzogMTAxNSxcbiAgICBBQ0NPVU5UX0JBTEFOQ0VfVE9PX0xPVzogMTAxNixcbiAgICBBQ0NPVU5UX0ZST1pFTl9PUl9ERUxFVEVEOiAxMDE3LFxuXG4gICAgLy8gQ3J5cHRvXG5cbiAgICBTSUdOSU5HX1NPVVJDRV9JU19OT1RfU1BFQ0lGSUVEOiAyMDIxLFxuICAgIElOVkFMSURfQ1JZUFRPX0JPWF9QQVJBTVM6IDIwMzAsXG5cbiAgICAvLyBDb250cmFjdHNcblxuICAgIENPTlRSQUNUX0VYRUNVVElPTl9GQUlMRUQ6IDMwMjUsXG5cbiAgICAvLyBRdWVyaWVzXG5cbiAgICBRVUVSWV9GT1JDSUJMWV9BQk9SVEVEOiA0MDA1LFxufTtcblxuZXhwb3J0IGNvbnN0IFRPTkNvbnRyYWN0RXhpdENvZGUgPSB7XG4gICAgUkVQTEFZX1BST1RFQ1RJT046IDUyLFxuICAgIE1FU1NBR0VfRVhQSVJFRDogNTcsXG4gICAgTk9fR0FTOiAxMyxcbn07XG5cbmV4cG9ydCBjbGFzcyBUT05DbGllbnRFcnJvciB7XG4gICAgc3RhdGljIHNvdXJjZSA9IFRPTkVycm9yU291cmNlO1xuICAgIHN0YXRpYyBjb2RlID0gVE9ORXJyb3JDb2RlO1xuXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHNvdXJjZTogc3RyaW5nO1xuICAgIGNvZGU6IG51bWJlcjtcbiAgICBkYXRhOiBUT05FcnJvckRhdGE7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgY29kZTogbnVtYmVyLFxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSxcbiAgICAgICAgc291cmNlPzogc3RyaW5nLFxuICAgICkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSB8fCBUT05FcnJvclNvdXJjZS5DTElFTlQ7XG4gICAgfVxuXG4gICAgLy8gVGVzdGVyc1xuXG4gICAgc3RhdGljIGlzQ2xpZW50RXJyb3IoZXJyb3I6IGFueSwgY29kZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoZXJyb3Iuc291cmNlID09PSBUT05FcnJvclNvdXJjZS5DTElFTlQpXG4gICAgICAgICAgICAmJiAoZXJyb3IuY29kZSA9PT0gY29kZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzTm9kZUVycm9yKGVycm9yOiBhbnksIGNvZGU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGVycm9yLnNvdXJjZSA9PT0gVE9ORXJyb3JTb3VyY2UuTk9ERSlcbiAgICAgICAgICAgICYmIChlcnJvci5jb2RlID09PSBjb2RlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNDb250cmFjdEVycm9yKGVycm9yOiBhbnksIGV4aXRDb2RlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChlcnJvci5zb3VyY2UgPT09IFRPTkVycm9yU291cmNlLk5PREUpXG4gICAgICAgICAgICAmJiAoZXJyb3IuY29kZSA9PT0gVE9ORXJyb3JDb2RlLkNPTlRSQUNUX0VYRUNVVElPTl9GQUlMRUQpXG4gICAgICAgICAgICAmJiAoZXJyb3IuZGF0YSAmJiBlcnJvci5kYXRhLmV4aXRfY29kZSA9PT0gZXhpdENvZGUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc09yaWdpbmFsQ29udHJhY3RFcnJvcihlcnJvcjogYW55LCBleGl0Q29kZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUT05DbGllbnRFcnJvci5pc0NvbnRyYWN0RXJyb3IoZXJyb3IsIGV4aXRDb2RlKVxuICAgICAgICAgICAgJiYgKCFlcnJvci5kYXRhPy5vcmlnaW5hbF9lcnJvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzUmVzb2x2ZWRDb250cmFjdEVycm9yQWZ0ZXJFeHBpcmUoZXJyb3I6IGFueSwgZXhpdENvZGU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gVE9OQ2xpZW50RXJyb3IuaXNDb250cmFjdEVycm9yKGVycm9yLCBleGl0Q29kZSlcbiAgICAgICAgICAgICYmIChlcnJvci5kYXRhICYmIGVycm9yLmRhdGEub3JpZ2luYWxfZXJyb3JcbiAgICAgICAgICAgICAgICAmJiBUT05DbGllbnRFcnJvci5pc01lc3NhZ2VFeHBpcmVkKGVycm9yLmRhdGEub3JpZ2luYWxfZXJyb3IpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNNZXNzYWdlRXhwaXJlZChlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUT05DbGllbnRFcnJvci5pc0NsaWVudEVycm9yKGVycm9yLCBUT05FcnJvckNvZGUuTUVTU0FHRV9FWFBJUkVEKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNXYWl0Rm9yVGltZW91dChlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUT05DbGllbnRFcnJvci5pc0NsaWVudEVycm9yKGVycm9yLCBUT05FcnJvckNvZGUuV0FJVF9GT1JfVElNRU9VVCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGRlcnNcblxuICAgIHN0YXRpYyBpbnRlcm5hbEVycm9yKFxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSxcbiAgICApOiBUT05DbGllbnRFcnJvciB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuSU5URVJOQUxfRVJST1IsXG4gICAgICAgICAgICBgSW50ZXJuYWwgZXJyb3I6ICR7bWVzc2FnZX1gLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW52YWxpZENvbnMoZGF0YTogVE9ORXJyb3JEYXRhKTogVE9OQ2xpZW50RXJyb3Ige1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLklOVkFMSURfQ09OUyxcbiAgICAgICAgICAgICdJbnZhbGlkIENPTlMgc3RydWN0dXJlLiBFYWNoIENPTlMgaXRlbSBtdXN0IGNvbnRhaW5zIG9mIHR3byBlbGVtZW50cy4nLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VuZE5vZGVSZXF1ZXN0RmFpbGVkKFxuICAgICAgICByZXNwb25zZVRleHQ6IHN0cmluZyxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICk6IFRPTkNsaWVudEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5TRU5EX05PREVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBgU2VuZCBub2RlIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlVGV4dH1gLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcnVuTG9jYWxBY2NvdW50RG9lc05vdEV4aXN0cyhcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gICAgICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICk6IFRPTkNsaWVudEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5SVU5fTE9DQUxfQUNDT1VOVF9ET0VTX05PVF9FWElTVFMsXG4gICAgICAgICAgICBgWyR7ZnVuY3Rpb25OYW1lfV0gcnVuIGxvY2FsIGZhaWxlZDogYWNjb3VudCBbJHthZGRyZXNzfV0gZG9lcyBub3QgZXhpc3RzYCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHdhaXRGb3JUaW1lb3V0KGRhdGE6IFRPTkVycm9yRGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLldBSVRfRk9SX1RJTUVPVVQsXG4gICAgICAgICAgICAnV2FpdCBmb3Igb3BlcmF0aW9uIHJlamVjdGVkIG9uIHRpbWVvdXQnLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcXVlcnlGYWlsZWQoXG4gICAgICAgIGVycm9yczogRXJyb3JbXSxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLlFVRVJZX0ZBSUxFRCxcbiAgICAgICAgICAgIGBRdWVyeSBmYWlsZWQ6ICR7ZXJyb3JzLm1hcCh4ID0+IHgubWVzc2FnZSB8fCB4LnRvU3RyaW5nKCkpLmpvaW4oJ1xcbicpfWAsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBmb3JtYXRUaW1lKHRpbWU6ID9udW1iZXIpOiA/c3RyaW5nIHtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtuZXcgRGF0ZSh0aW1lICogMTAwMCkudG9JU09TdHJpbmcoKX0gKCR7dGltZX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWVzc2FnZUV4cGlyZWQoXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSAmIHtcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IHN0cmluZyxcbiAgICAgICAgICAgIHNlbmRpbmdfdGltZTogbnVtYmVyLFxuICAgICAgICAgICAgZXhwaXJlPzogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tfdGltZT86IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrX2lkPzogc3RyaW5nLFxuICAgICAgICB9LFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLk1FU1NBR0VfRVhQSVJFRCxcbiAgICAgICAgICAgICdNZXNzYWdlIGV4cGlyZWQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2VuZGluZ190aW1lOiBUT05DbGllbnRFcnJvci5mb3JtYXRUaW1lKGRhdGEuc2VuZGluZ190aW1lKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5leHBpcmUpLFxuICAgICAgICAgICAgICAgIGJsb2NrX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5ibG9ja190aW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBUT05FcnJvclNvdXJjZS5DTElFTlQsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlcnZlckRvZXNudFN1cHBvcnRBZ2dyZWdhdGlvbnMoZGF0YTogVE9ORXJyb3JEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuU0VSVkVSX0RPRVNOVF9TVVBQT1JUX0FHR1JFR0FUSU9OUyxcbiAgICAgICAgICAgICdTZXJ2ZXIgZG9lc25cXCd0IHN1cHBvcnQgYWdncmVnYXRpb25zJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFkZHJlc3NSZXF1aXJlZEZvclJ1bkxvY2FsKGRhdGE6IFRPTkVycm9yRGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLkFERFJFU1NfUkVRVUlSRURfRk9SX1JVTl9MT0NBTCxcbiAgICAgICAgICAgICdBZGRyZXNzIHJlcXVpcmVkIGZvciBydW4gbG9jYWwuIFlvdSBoYXZlblxcJ3Qgc3BlY2lmaWVkIGNvbnRyYWN0IGNvZGUgb3IgZGF0YSAnXG4gICAgICAgICAgICArICdzbyBhZGRyZXNzIGlzIHJlcXVpcmVkIHRvIGxvYWQgbWlzc2luZyBwYXJ0cyBmcm9tIG5ldHdvcmsuJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG5ldHdvcmtTaWxlbnQoXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSAmIHtcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IHN0cmluZyxcbiAgICAgICAgICAgIHNlbmRpbmdfdGltZTogbnVtYmVyLFxuICAgICAgICAgICAgZXhwaXJlOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lb3V0OiBudW1iZXIsXG4gICAgICAgICAgICBibG9ja19pZD86IHN0cmluZyxcbiAgICAgICAgICAgIG1lc3NhZ2VfcHJvY2Vzc2luZ19zdGF0ZT86IFRPTk1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUsXG4gICAgICAgIH0sXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuTkVUV09SS19TSUxFTlQsXG4gICAgICAgICAgICAnTmV0d29yayBzaWxlbnQ6IG5vIGJsb2NrcyBwcm9kdWNlZCBkdXJpbmcgdGltZW91dC4nLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2VuZGluZ190aW1lOiBUT05DbGllbnRFcnJvci5mb3JtYXRUaW1lKGRhdGEuc2VuZGluZ190aW1lKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5leHBpcmUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdHJhbnNhY3Rpb25XYWl0VGltZW91dChcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhICYge1xuICAgICAgICAgICAgbWVzc2FnZV9pZDogc3RyaW5nLFxuICAgICAgICAgICAgc2VuZGluZ190aW1lOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lb3V0OiBudW1iZXIsXG4gICAgICAgICAgICBtZXNzYWdlX3Byb2Nlc3Npbmdfc3RhdGU/OiBUT05NZXNzYWdlUHJvY2Vzc2luZ1N0YXRlLFxuICAgICAgICB9LFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLlRSQU5TQUNUSU9OX1dBSVRfVElNRU9VVCxcbiAgICAgICAgICAgICdUcmFuc2FjdGlvbiBkaWQgbm90IHByb2R1Y2VkIGR1cmluZyBzcGVjaWZpZWQgdGltZW91dCcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZW5kaW5nX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5zZW5kaW5nX3RpbWUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvY2tPdXRPZlN5bmMoZGF0YTogVE9ORXJyb3JEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuQ0xPQ0tfT1VUX09GX1NZTkMsXG4gICAgICAgICAgICAnWW91IGxvY2FsIGNsb2NrIGlzIG91dCBvZiBzeW5jIHdpdGggdGhlIHNlcnZlciB0aW1lLiAnXG4gICAgICAgICAgICArICdJdCBpcyBhIGNyaXRpY2FsIGNvbmRpdGlvbiBmb3Igc2VuZGluZyBtZXNzYWdlcyB0byB0aGUgYmxvY2tjaGFpbi4gJ1xuICAgICAgICAgICAgKyAnUGxlYXNlIHN5bmMgeW91IGNsb2NrIHdpdGggdGhlIGludGVybmV0IHRpbWUuJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFjY291bnRNaXNzaW5nKFxuICAgICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSxcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5BQ0NPVU5UX01JU1NJTkcsXG4gICAgICAgICAgICBgQWNjb3VudCB3aXRoIGFkZHJlc3MgWyR7YWRkcmVzc31dIGRvZXNuJ3QgZXhpc3RzLiBgXG4gICAgICAgICAgICArICdZb3UgaGF2ZSB0byBwcmVwYWlkIHRoaXMgYWNjb3VudCB0byBoYXZlIGEgcG9zaXRpdmUgYmFsYW5jZSBvbiB0aGVtIGFuZCB0aGVuIGRlcGxveSAnXG4gICAgICAgICAgICArICdhIGNvbnRyYWN0IGNvZGUgZm9yIHRoaXMgYWNjb3VudC4nXG4gICAgICAgICAgICArICdTZWUgU0RLIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbGVkIGluc3RydWN0aW9ucy4nLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWNjb3VudENvZGVNaXNzaW5nKFxuICAgICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIGJhbGFuY2U6IHN0cmluZyxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLkFDQ09VTlRfQ09ERV9NSVNTSU5HLFxuICAgICAgICAgICAgYEFjY291bnQgd2l0aCBhZGRyZXNzIFske2FkZHJlc3N9XSBleGlzdHMgYnV0IGhhdmVuJ3QgYSBjb250cmFjdCBjb2RlIHlldC4gYFxuICAgICAgICAgICAgKyAnWW91IGhhdmUgdG8gZW5zdXJlIHRoYXQgYW4gYWNjb3VudCBoYXMgYW4gZW5vdWdoIGJhbGFuY2UgZm9yIGRlcGxveWluZyAnXG4gICAgICAgICAgICArICdhIGNvbnRyYWN0IGNvZGUgYW5kIHRoZW4gZGVwbG95IGEgY29udHJhY3QgY29kZSBmb3IgdGhpcyBhY2NvdW50LiAnXG4gICAgICAgICAgICArIGBDdXJyZW50IGFjY291bnQgYmFsYW5jZSBpcyBbJHtiYWxhbmNlfV0uIGBcbiAgICAgICAgICAgICsgJ1NlZSBTREsgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlsZWQgaW5zdHJ1Y3Rpb25zLicsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBhY2NvdW50QmFsYW5jZVRvb0xvdyhcbiAgICAgICAgYWRkcmVzczogc3RyaW5nLFxuICAgICAgICBiYWxhbmNlOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSxcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5BQ0NPVU5UX0JBTEFOQ0VfVE9PX0xPVyxcbiAgICAgICAgICAgIGBBY2NvdW50IHdpdGggYWRkcmVzcyBbJHthZGRyZXNzfV0gaGFzIHRvbyBsb3cgYmFsYW5jZSBbJHtiYWxhbmNlfV0uIGBcbiAgICAgICAgICAgICsgJ1lvdSBoYXZlIHRvIHNlbmQgc29tZSB2YWx1ZSB0byBhY2NvdW50IGJhbGFuY2UgZnJvbSBvdGhlciBjb250cmFjdCAnXG4gICAgICAgICAgICArICcoZS5nLiBXYWxsZXQgY29udHJhY3QpLiAnXG4gICAgICAgICAgICArICdTZWUgU0RLIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbGVkIGluc3RydWN0aW9ucy4nLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbm9CbG9ja3MoXG4gICAgICAgIHdvcmtjaGFpbjogbnVtYmVyLFxuICAgICAgICBkYXRhOiBUT05FcnJvckRhdGEsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IHdvcmtjaGFpbk5hbWUgPSB3b3JrY2hhaW4gPT09IC0xID8gJ21hc3RlcmNoYWluJyA6IGB3b3JrY2hhaW4gJHt3b3JrY2hhaW59YDtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5ORVRXT1JLX1NJTEVOVCxcbiAgICAgICAgICAgIGBcIk5vIGJsb2NrcyBmb3IgJHt3b3JrY2hhaW5OYW1lfSBmb3VuZFwiLmAsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnZhbGlkQmxvY2tjaGFpbihcbiAgICAgICAgbWVzc2FnZTogc3RyaW5nLFxuICAgICAgICBkYXRhOiBUT05FcnJvckRhdGEsXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLk5FVFdPUktfU0lMRU5ULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcXVlcnlGb3JjaWJseUFib3J0ZWQoZGF0YTogVE9ORXJyb3JEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuUVVFUllfRk9SQ0lCTFlfQUJPUlRFRCxcbiAgICAgICAgICAgICdHcmFwaFFMIHF1ZXJ5IHdhcyBmb3JjaWJseSBhYm9ydGVkIG9uIHRpbWVvdXQuJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNpZ25pbmdTb3VyY2VJc05vdFNwZWNpZmllZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIHNpZ25pbmcga2V5cyBvciBzaWduaW5nIGJveCB0byBzaWduIHlvdSBtZXNzYWdlLicsXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuU0lHTklOR19TT1VSQ0VfSVNfTk9UX1NQRUNJRklFRCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW52YWxpZENyeXB0b0JveFBhcmFtcyhlbmNyeXB0ZWRTZWVkUGhyYXNlOiBUT05JbnB1dE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgZW5jcnlwdGVkIHNlZWQgcGhyYXNlIHRvIGNyZWF0ZSBhIGNvcmUgY3J5cHRvIGJveC4gJ1xuICAgICAgICAgICAgKyBgUHJvdmlkZWQgcGhyYXNlIGlzOiAke0pTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFNlZWRQaHJhc2UpfS5gLFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLklOVkFMSURfQ1JZUFRPX0JPWF9QQVJBTVMsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsaWVudElzTm90U2V0dXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuQ0xJRU5UX0lTX05PVF9TRVRVUCxcbiAgICAgICAgICAgICdUT04gQ2xpZW50IExpYnJhcnkgaXNuXFwndCBzZXQgdXAgcHJvcGVybHknLFxuICAgICAgICAgICAgZW1wdHlUT05FcnJvckRhdGEsXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19

/***/ }),

/***/ "./node_modules/ton-client-js/dist/TONModule.js":
/*!******************************************************!*\
  !*** ./node_modules/ton-client-js/dist/TONModule.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TONModule = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _opentracing = __webpack_require__(/*! opentracing */ "./node_modules/opentracing/lib/index.js");

var _TONClientError = __webpack_require__(/*! ./TONClientError */ "./node_modules/ton-client-js/dist/TONClientError.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * TON Client module
 * Each module must provides a common constructor and a `setup` method.
 * Also each specific module provides specific set of methods.
 */
var TONModule = /*#__PURE__*/function () {
  /**
   * Context to which this module is bound
   */

  /**
   * Initialize module instance.
   * Note that module must not gets references to other modules here
   * (for this purpose there is a `setup` method).
   *
   * @param context
   */
  function TONModule(context) {
    _classCallCheck(this, TONModule);

    _defineProperty(this, "context", void 0);

    this.context = context;
  } // Module

  /**
   * Performs necessary setup of this module.
   * The method is a safe place to get a references to other modules from the `context`.
   * @return {Promise<void>}
   */
  // eslint-disable-next-line no-empty-function


  _createClass(TONModule, [{
    key: "setup",
    value: function () {
      var _setup = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }, {
    key: "completeErrorData",
    value: function () {
      var _completeErrorData = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(data) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.context.completeErrorData(data));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function completeErrorData(_x) {
        return _completeErrorData.apply(this, arguments);
      }

      return completeErrorData;
    }()
    /**
     * Requests a core for specified method and parameters.
     * @param {string} method Method name
     * @param {Object} params Method parameters will be stringified into JSON
     * @return {Promise<Object>}
     */

  }, {
    key: "requestCore",
    value: function () {
      var _requestCore = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(method, params) {
        var coreBridge;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.context.getCoreBridge();

              case 2:
                coreBridge = _context3.sent;

                if (coreBridge) {
                  _context3.next = 5;
                  break;
                }

                throw _TONClientError.TONClientError.clientIsNotSetup();

              case 5:
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  coreBridge.request(method, params !== undefined ? JSON.stringify(params) || '' : '', function (resultJson, errorJson) {
                    if (errorJson) {
                      reject(JSON.parse(errorJson));
                    } else if (resultJson) {
                      resolve(JSON.parse(resultJson));
                    } else {
                      resolve({});
                    }
                  });
                }));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function requestCore(_x2, _x3) {
        return _requestCore.apply(this, arguments);
      }

      return requestCore;
    }()
  }]);

  return TONModule;
}();

exports.TONModule = TONModule;

_defineProperty(TONModule, "moduleName", void 0);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9UT05Nb2R1bGUuanMiXSwibmFtZXMiOlsiVE9OTW9kdWxlIiwiY29udGV4dCIsImRhdGEiLCJjb21wbGV0ZUVycm9yRGF0YSIsIm1ldGhvZCIsInBhcmFtcyIsImdldENvcmVCcmlkZ2UiLCJjb3JlQnJpZGdlIiwiVE9OQ2xpZW50RXJyb3IiLCJjbGllbnRJc05vdFNldHVwIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXF1ZXN0IiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdEpzb24iLCJlcnJvckpzb24iLCJwYXJzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBb0JBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBNEZBOzs7OztJQUthQSxTO0FBR1Q7Ozs7QUFLQTs7Ozs7OztBQU9BLHFCQUFZQyxPQUFaLEVBQXVDO0FBQUE7O0FBQUE7O0FBQ25DLFNBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNILEcsQ0FFRDs7QUFFQTs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhHQUl3QkMsSTs7Ozs7a0RBQ2IsS0FBS0QsT0FBTCxDQUFhRSxpQkFBYixDQUErQkQsSUFBL0IsQzs7Ozs7Ozs7Ozs7Ozs7OztBQUdYOzs7Ozs7Ozs7O3dHQU1rQ0UsTSxFQUFnQkMsTTs7Ozs7Ozt1QkFDckIsS0FBS0osT0FBTCxDQUFhSyxhQUFiLEU7OztBQUFuQkMsZ0JBQUFBLFU7O29CQUNEQSxVOzs7OztzQkFDS0MsK0JBQWVDLGdCQUFmLEU7OztrREFFSCxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUE0QkMsTUFBNUIsRUFBd0Q7QUFDdkVMLGtCQUFBQSxVQUFVLENBQUNNLE9BQVgsQ0FDSVQsTUFESixFQUVJQyxNQUFNLEtBQUtTLFNBQVgsR0FBd0JDLElBQUksQ0FBQ0MsU0FBTCxDQUFlWCxNQUFmLEtBQTBCLEVBQWxELEdBQXdELEVBRjVELEVBR0ksVUFBQ1ksVUFBRCxFQUFhQyxTQUFiLEVBQTJCO0FBQ3ZCLHdCQUFJQSxTQUFKLEVBQWU7QUFDWE4sc0JBQUFBLE1BQU0sQ0FBQ0csSUFBSSxDQUFDSSxLQUFMLENBQVdELFNBQVgsQ0FBRCxDQUFOO0FBQ0gscUJBRkQsTUFFTyxJQUFJRCxVQUFKLEVBQWdCO0FBQ25CTixzQkFBQUEsT0FBTyxDQUFDSSxJQUFJLENBQUNJLEtBQUwsQ0FBV0YsVUFBWCxDQUFELENBQVA7QUFDSCxxQkFGTSxNQUVBO0FBQ0hOLHNCQUFBQSxPQUFPLENBQUUsRUFBRixDQUFQO0FBQ0g7QUFDSixtQkFYTDtBQWFILGlCQWRNLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQTdDRlgsUyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIwIFRPTiBERVYgU09MVVRJT05TIExURC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgU09GVFdBUkUgRVZBTFVBVElPTiBMaWNlbnNlICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbiAqIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxuICogTGljZW5zZSBhdDpcbiAqXG4gKiBodHRwOi8vd3d3LnRvbi5kZXYvbGljZW5zZXNcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIFRPTiBERVYgc29mdHdhcmUgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gQGZsb3dcbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsIG5vLXVzZS1iZWZvcmUtZGVmaW5lLCBuby11bmRlZiAqL1xuXG4vLyBEZXByZWNhdGVkOiBUT05DbGllbnRDb3JlIHYwLjE3LjBcbmltcG9ydCB7IFNwYW4sIFNwYW5Db250ZXh0IH0gZnJvbSAnb3BlbnRyYWNpbmcnO1xuaW1wb3J0IHsgVE9OQ2xpZW50RXJyb3IgfSBmcm9tICcuL1RPTkNsaWVudEVycm9yJztcbmltcG9ydCB0eXBlIHsgVE9ORXJyb3JEYXRhIH0gZnJvbSAnLi9UT05DbGllbnRFcnJvcic7XG5cbi8qKlxuICogVE9OQ2xpZW50Q29yZUJyaWRnZVxuICogTWluaW1hbGlzdGljIGxlZ2FjeSBpbnRlcmZhY2UgdG8gY29yZSBsaWJyYXJ5LlxuICogT2xkIHN0eWxlIGNvcmVzIGRpZCBwcm92aWRlIG9ubHkgdGhpcyBBUEkuXG4gKiBGb3IgbmV3IHN0eWxlIGNvcmVzIFRPTkNsaWVudCBjcmVhdGVzIGNvbnRleHQgYm91bmQgd3JhcHBlciB3aXRoIHRoaXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRPTkNsaWVudENvcmVCcmlkZ2Uge1xuICAgIC8qKlxuICAgICAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgKiBAcGFyYW0gbWV0aG9kXG4gICAgICogQHBhcmFtIHBhcmFtc0pzb25cbiAgICAgKiBAcGFyYW0gb25SZXN1bHRcbiAgICAgKi9cbiAgICByZXF1ZXN0KFxuICAgICAgICBtZXRob2Q6IHN0cmluZyxcbiAgICAgICAgcGFyYW1zSnNvbjogc3RyaW5nLFxuICAgICAgICBvblJlc3VsdDogKHJlc3VsdEpzb246IHN0cmluZywgZXJyb3JKc29uOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgKTogdm9pZDtcbn1cblxuLyoqXG4gKiBUT04gQ2xpZW50IENvcmUgQVBJXG4gKiBDbGllbnQgQ29yZSBwZXJmb3JtcyBjbGllbnQgdGFza3MgdGhyb3VnaCBzaW5nbGUgSlNPTi1iYXNlZCB0dW5uZWxpbmcgbWV0aG9kIGNhbGxlZCBgY29yZVJlcXVlc3RgXG4gKiBFdmVyeSBjb3JlIHJlcXVlc3QgY2FuIGJlIHBlcmZvcm1lZCBpbiB0d28gd2F5czpcbiAqIC0gYXN5bmMgcmVxdWVzdCB3aXRoIGBjb3JlUmVxdWVzdGAgbWV0aG9kXG4gKiBDbGllbnQgaXMgYSBzdGF0ZWZ1bCBvYmplY3QuIEVhY2ggY2xpZW50IHN0YXRlIGNhbGxlZCBhIGBjb250ZXh0YC5cbiAqIFNvIHlvdSBtdXN0IHVzZSBmb2xsb3dpbmcgcnVsZXMgd2hlbiB3b3JraW5nIHdpdGggYSBjb3JlOlxuICogLSBjcmVhdGUgYSBjb250ZXh0IG9iamVjdCBhbmQgcmVjZWl2ZSBjb250ZXh0IGhhbmRsZSB3aXRoIGBjb3JlQ3JlYXRlQ29udGV4dGBcbiAqIC0gY29uZmlndXJlIGBjb250ZXh0YCB3aXRoIGBjb25maWdgIGludm9jYXRpb24gbWV0aG9kXG4gKiAtIHBhc3MgY29udGV4dCBoYW5kbGUgdG8gYGNvcmVSZXF1ZXN0YFxuICogLSB3aGVuIHlvdSBkb24ndCBuZWVkIGNvbnRleHQgeW91IG11c3QgZGVzdHJveSBpdCB3aXRoIGBjb3JlRGVzdHJveUNvbnRleHRgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVE9OQ2xpZW50Q29yZUxpYnJhcnkgZXh0ZW5kcyBUT05DbGllbnRDb3JlQnJpZGdlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmV3IGNvbnRleHQgYW5kIHJldHVybnMgaGFuZGxlIHRvIGl0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25Db250ZXh0XG4gICAgICovXG4gICAgY29yZUNyZWF0ZUNvbnRleHQob25Db250ZXh0OiAoY29udGV4dDogbnVtYmVyKSA9PiB2b2lkKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgY29udGV4dCB3aXRoIHNwZWNpZmllZCBoYW5kbGVcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgY29yZURlc3Ryb3lDb250ZXh0KGNvbnRleHQ6IG51bWJlciwgb25Db21wbGV0ZTogKCkgPT4gdm9pZCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBQb3N0IGFzeW5jIHJlcXVlc3QgdG8gY29yZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXNKc29uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25SZXN1bHRcbiAgICAgKi9cbiAgICBjb3JlUmVxdWVzdChcbiAgICAgICAgY29udGV4dDogbnVtYmVyLFxuICAgICAgICBtZXRob2Q6IHN0cmluZyxcbiAgICAgICAgcGFyYW1zSnNvbjogc3RyaW5nLFxuICAgICAgICBvblJlc3VsdDogKHJlc3VsdEpzb246IHN0cmluZywgZXJyb3JKc29uOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgKTogdm9pZDtcbn1cblxuLyoqXG4gKiBDb250ZXh0IGluIHdoaWNoIG1vZHVsZXMgYXJlIHdvcmtpbmdcbiAqIEFsbCBtb2R1bGUgaW5zdGFuY2VzIGFyZSBib3VuZCB0byBzaW5nbGUgY29udGV4dFxuICogYW5kIGNhbiBjb21tdW5pY2F0ZSB3aXRoIHNpYmxpbmcgbW9kdWxlcy5cbiAqIENvbnRleHQgcHJvdmlkZXMgYm91bmRlZCBtb2R1bGVzIHdpdGg6XG4gKiAtIGFjY2VzcyB0byBjb21tb24gY2xpZW50IGNvcmUgYW5kIHByZWNvbmZpZ3VyZWQgY29yZSBjb250ZXh0XG4gKiAtIGFjY2VzcyB0byBzaWJsaW5nIG1vZHVsZXMgKHVzaW5nIGEgbW9kdWxlIGNsYXNzIGFzIGFuIGlkKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRPTk1vZHVsZUNvbnRleHQge1xuICAgIGdldENvcmVCcmlkZ2UoKTogUHJvbWlzZTw/VE9OQ2xpZW50Q29yZUJyaWRnZT4sXG5cbiAgICBjb21wbGV0ZUVycm9yRGF0YShkYXRhPzogeyBbc3RyaW5nXTogYW55IH0pOiBQcm9taXNlPFRPTkVycm9yRGF0YT4sXG5cbiAgICBnZXRNb2R1bGU8VD4oTW9kdWxlQ2xhc3M6IHR5cGVvZiBUT05Nb2R1bGUpOiBULFxuXG4gICAgc2VydmVyVGltZURlbHRhKCk6IFByb21pc2U8bnVtYmVyPixcblxuICAgIHNlcnZlck5vdygpOiBQcm9taXNlPG51bWJlcj4sXG5cbiAgICBzdGFydFJvb3RTcGFuKHRyYWNlSWQ6IHN0cmluZywgc3BhbklkOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IFNwYW4sXG5cbiAgICB0cmFjZTxUPihcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBmOiAoc3BhbjogU3BhbikgPT4gUHJvbWlzZTxUPixcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpLFxuICAgICk6IFByb21pc2U8VD4sXG59XG5cbi8qKlxuICogVE9OIENsaWVudCBtb2R1bGVcbiAqIEVhY2ggbW9kdWxlIG11c3QgcHJvdmlkZXMgYSBjb21tb24gY29uc3RydWN0b3IgYW5kIGEgYHNldHVwYCBtZXRob2QuXG4gKiBBbHNvIGVhY2ggc3BlY2lmaWMgbW9kdWxlIHByb3ZpZGVzIHNwZWNpZmljIHNldCBvZiBtZXRob2RzLlxuICovXG5leHBvcnQgY2xhc3MgVE9OTW9kdWxlIHtcbiAgICBzdGF0aWMgbW9kdWxlTmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCB0byB3aGljaCB0aGlzIG1vZHVsZSBpcyBib3VuZFxuICAgICAqL1xuICAgIGNvbnRleHQ6IFRPTk1vZHVsZUNvbnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG1vZHVsZSBpbnN0YW5jZS5cbiAgICAgKiBOb3RlIHRoYXQgbW9kdWxlIG11c3Qgbm90IGdldHMgcmVmZXJlbmNlcyB0byBvdGhlciBtb2R1bGVzIGhlcmVcbiAgICAgKiAoZm9yIHRoaXMgcHVycG9zZSB0aGVyZSBpcyBhIGBzZXR1cGAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udGV4dDogVE9OTW9kdWxlQ29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIC8vIE1vZHVsZVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbmVjZXNzYXJ5IHNldHVwIG9mIHRoaXMgbW9kdWxlLlxuICAgICAqIFRoZSBtZXRob2QgaXMgYSBzYWZlIHBsYWNlIHRvIGdldCBhIHJlZmVyZW5jZXMgdG8gb3RoZXIgbW9kdWxlcyBmcm9tIHRoZSBgY29udGV4dGAuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cbiAgICBhc3luYyBzZXR1cCgpIHtcbiAgICB9XG5cbiAgICBhc3luYyBjb21wbGV0ZUVycm9yRGF0YShkYXRhPzogeyBbc3RyaW5nXTogYW55IH0pOiBQcm9taXNlPFRPTkVycm9yRGF0YT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNvbXBsZXRlRXJyb3JEYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgY29yZSBmb3Igc3BlY2lmaWVkIG1ldGhvZCBhbmQgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBNZXRob2QgcGFyYW1ldGVycyB3aWxsIGJlIHN0cmluZ2lmaWVkIGludG8gSlNPTlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0Q29yZTxQYXJhbXMsIFJlc3VsdD4obWV0aG9kOiBzdHJpbmcsIHBhcmFtcz86IFBhcmFtcyk6IFByb21pc2U8UmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGNvcmVCcmlkZ2UgPSBhd2FpdCB0aGlzLmNvbnRleHQuZ2V0Q29yZUJyaWRnZSgpO1xuICAgICAgICBpZiAoIWNvcmVCcmlkZ2UpIHtcbiAgICAgICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLmNsaWVudElzTm90U2V0dXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmU6IChSZXN1bHQpID0+IHZvaWQsIHJlamVjdDogKEVycm9yKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgICAgICBjb3JlQnJpZGdlLnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtcyAhPT0gdW5kZWZpbmVkID8gKEpTT04uc3RyaW5naWZ5KHBhcmFtcykgfHwgJycpIDogJycsXG4gICAgICAgICAgICAgICAgKHJlc3VsdEpzb24sIGVycm9ySnNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoSlNPTi5wYXJzZShlcnJvckpzb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UocmVzdWx0SnNvbikpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgoe306IGFueSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==

/***/ }),

/***/ "./node_modules/ton-client-js/dist/modules/TONConfigModule.js":
/*!********************************************************************!*\
  !*** ./node_modules/ton-client-js/dist/modules/TONConfigModule.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = exports.URLParts = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _TONModule2 = __webpack_require__(/*! ../TONModule */ "./node_modules/ton-client-js/dist/TONModule.js");

var _opentracing = __webpack_require__(/*! opentracing */ "./node_modules/opentracing/lib/index.js");

var _noop = __webpack_require__(/*! opentracing/lib/noop */ "./node_modules/opentracing/lib/noop.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_MESSAGE_RETRIES_COUNT = 10;
var DEFAULT_MESSAGE_PROCESSING_TIMEOUT = 40000;
var DEFAULT_WAIT_FOR_TIMEOUT = 40000;
var DEFAULT_NETWORK_TIMEOUT = 0;
var DEFAULT_OUT_OF_SYNC_THRESHOLD = 15000;

var URLParts = /*#__PURE__*/function () {
  _createClass(URLParts, [{
    key: "fixProtocol",
    value: function fixProtocol(fix) {
      this.protocol = fix(this.protocol);
      return this;
    }
  }, {
    key: "fixHost",
    value: function fixHost(fix) {
      this.host = fix(this.host);
      return this;
    }
  }, {
    key: "fixPath",
    value: function fixPath(fix) {
      this.path = fix(this.path);
      return this;
    }
  }, {
    key: "fixQuery",
    value: function fixQuery(fix) {
      this.query = fix(this.query);
      return this;
    }
  }], [{
    key: "parse",
    value: function parse(url) {
      var protocolSeparatorPos = url.indexOf('://');
      var protocolEnd = protocolSeparatorPos >= 0 ? protocolSeparatorPos + 3 : 0;
      var questionPos = url.indexOf('?', protocolEnd);
      var queryStart = questionPos >= 0 ? questionPos + 1 : url.length;
      var pathEnd = questionPos >= 0 ? questionPos : url.length;
      var pathSeparatorPos = url.indexOf('/', protocolEnd); // eslint-disable-next-line no-nested-ternary

      var pathStart = pathSeparatorPos >= 0 ? pathSeparatorPos < pathEnd ? pathSeparatorPos : pathEnd : questionPos >= 0 ? questionPos : url.length;
      return new URLParts(url.substring(0, protocolEnd), url.substring(protocolEnd, pathStart), url.substring(pathStart, pathEnd), url.substring(queryStart));
    }
  }, {
    key: "resolveUrl",
    value: function resolveUrl(baseUrl, url) {
      var baseParts = URLParts.parse(baseUrl);
      return URLParts.parse(url).fixProtocol(function (x) {
        return x || baseParts.protocol;
      }).fixHost(function (x) {
        return x || baseParts.host;
      }).toString();
    }
  }]);

  function URLParts(protocol, host, path, query) {
    _classCallCheck(this, URLParts);

    _defineProperty(this, "protocol", void 0);

    _defineProperty(this, "host", void 0);

    _defineProperty(this, "path", void 0);

    _defineProperty(this, "query", void 0);

    this.protocol = protocol;
    this.host = host;
    this.path = path;
    this.query = query;
  }

  _createClass(URLParts, [{
    key: "toString",
    value: function toString() {
      var path = this.path;

      while (path.indexOf('//') >= 0) {
        path = path.replace('//', '/');
      }

      if (path !== '' && !path.startsWith('/')) {
        path = "/".concat(path);
      }

      return "".concat(this.protocol).concat(this.host).concat(path).concat(this.query !== '' ? '?' : '').concat(this.query);
    }
  }]);

  return URLParts;
}();

exports.URLParts = URLParts;
var defaultServer = 'http://localhost';

function valueOrDefault(value, defaultValue) {
  return value === undefined || value === null ? defaultValue : value;
}

var TONConfigModule = /*#__PURE__*/function (_TONModule) {
  _inherits(TONConfigModule, _TONModule);

  var _super = _createSuper(TONConfigModule);

  function TONConfigModule(context) {
    var _this;

    _classCallCheck(this, TONConfigModule);

    _this = _super.call(this, context);

    _defineProperty(_assertThisInitialized(_this), "data", void 0);

    _defineProperty(_assertThisInitialized(_this), "tracer", void 0);

    _defineProperty(_assertThisInitialized(_this), "_logVerbose", void 0);

    _defineProperty(_assertThisInitialized(_this), "_errLogVerbose", void 0);

    _defineProperty(_assertThisInitialized(_this), "_profileStart", void 0);

    _defineProperty(_assertThisInitialized(_this), "_profilePrev", void 0);

    _this.data = {
      servers: [defaultServer]
    };
    return _this;
  }

  _createClass(TONConfigModule, [{
    key: "setData",
    value: function setData(data) {
      this.data = data || this.data;

      if (this.data.servers.length === 0) {
        this.data.servers.push(defaultServer);
      }

      this.tracer = data.tracer || _noop.tracer;
    }
  }, {
    key: "getConfigServer",
    value: function getConfigServer() {
      var _this$data, _this$data$servers;

      return ((_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$servers = _this$data.servers) === null || _this$data$servers === void 0 ? void 0 : _this$data$servers[0]) || '';
    }
  }, {
    key: "outOfSyncThreshold",
    value: function outOfSyncThreshold() {
      return valueOrDefault(this.data.outOfSyncThreshold, DEFAULT_OUT_OF_SYNC_THRESHOLD);
    }
  }, {
    key: "messageRetriesCount",
    value: function messageRetriesCount() {
      return valueOrDefault(this.data.messageRetriesCount, DEFAULT_MESSAGE_RETRIES_COUNT);
    }
  }, {
    key: "messageProcessingTimeout",
    value: function messageProcessingTimeout() {
      var timeout = this.data.messageProcessingTimeout;
      return timeout === 0 ? 0 : timeout || DEFAULT_MESSAGE_PROCESSING_TIMEOUT;
    }
  }, {
    key: "waitForTimeout",
    value: function waitForTimeout() {
      return valueOrDefault(this.data.waitForTimeout, DEFAULT_WAIT_FOR_TIMEOUT);
    }
  }, {
    key: "networkTimeout",
    value: function networkTimeout() {
      return valueOrDefault(this.data.networkTimeout, DEFAULT_NETWORK_TIMEOUT);
    }
  }, {
    key: "isNetworkTimeoutExpiredSince",
    value: function isNetworkTimeoutExpiredSince(startTime) {
      var timeout = this.networkTimeout();

      if (timeout === 0) {
        return false;
      }

      return Date.now() > startTime + timeout;
    }
  }, {
    key: "log",
    value: function log() {
      var profile = (this._profileStart || 0) !== 0;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (profile) {
        var current = Date.now() / 1000;
        var timeString = "".concat(String(current.toFixed(3)), " ").concat(String((current - this._profileStart).toFixed(3)), " ").concat(String((current - this._profilePrev).toFixed(3)));

        if (this._logVerbose) {
          var _console;

          (_console = console).log.apply(_console, ["[".concat(timeString, "]\n")].concat(args));
        } else {
          console.log("[".concat(timeString, "]\n"), args[0]);
        }

        this._profilePrev = current;
      } else if (this._logVerbose) {
        var _console2;

        (_console2 = console).log.apply(_console2, ["[".concat(Date.now() / 1000, "]")].concat(args));
      }
    }
  }, {
    key: "startProfile",
    value: function startProfile() {
      this._profileStart = Date.now() / 1000;
      this._profilePrev = this._profileStart;
    }
  }, {
    key: "stopProfile",
    value: function stopProfile() {
      this._profileStart = this._profilePrev = 0;
    }
  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.requestCore('version'));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getVersion() {
        return _getVersion.apply(this, arguments);
      }

      return getVersion;
    }()
  }, {
    key: "setup",
    value: function () {
      var _setup = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var coreConfig;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.data) {
                  _context2.next = 5;
                  break;
                }

                coreConfig = Object.assign({}, this.data);
                delete coreConfig.tracer;
                _context2.next = 5;
                return this.requestCore('setup', coreConfig);

              case 5:
                this._logVerbose = this.data.log_verbose || false;

                if (this._logVerbose) {
                  this.startProfile();
                }

                this._errLogVerbose = this.data.err_log_verbose || true;

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }]);

  return TONConfigModule;
}(_TONModule2.TONModule);

exports.default = TONConfigModule;
TONConfigModule.moduleName = 'TONConfigModule';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2R1bGVzL1RPTkNvbmZpZ01vZHVsZS5qcyJdLCJuYW1lcyI6WyJERUZBVUxUX01FU1NBR0VfUkVUUklFU19DT1VOVCIsIkRFRkFVTFRfTUVTU0FHRV9QUk9DRVNTSU5HX1RJTUVPVVQiLCJERUZBVUxUX1dBSVRfRk9SX1RJTUVPVVQiLCJERUZBVUxUX05FVFdPUktfVElNRU9VVCIsIkRFRkFVTFRfT1VUX09GX1NZTkNfVEhSRVNIT0xEIiwiVVJMUGFydHMiLCJmaXgiLCJwcm90b2NvbCIsImhvc3QiLCJwYXRoIiwicXVlcnkiLCJ1cmwiLCJwcm90b2NvbFNlcGFyYXRvclBvcyIsImluZGV4T2YiLCJwcm90b2NvbEVuZCIsInF1ZXN0aW9uUG9zIiwicXVlcnlTdGFydCIsImxlbmd0aCIsInBhdGhFbmQiLCJwYXRoU2VwYXJhdG9yUG9zIiwicGF0aFN0YXJ0Iiwic3Vic3RyaW5nIiwiYmFzZVVybCIsImJhc2VQYXJ0cyIsInBhcnNlIiwiZml4UHJvdG9jb2wiLCJ4IiwiZml4SG9zdCIsInRvU3RyaW5nIiwicmVwbGFjZSIsInN0YXJ0c1dpdGgiLCJkZWZhdWx0U2VydmVyIiwidmFsdWVPckRlZmF1bHQiLCJ2YWx1ZSIsImRlZmF1bHRWYWx1ZSIsInVuZGVmaW5lZCIsIlRPTkNvbmZpZ01vZHVsZSIsImNvbnRleHQiLCJkYXRhIiwic2VydmVycyIsInB1c2giLCJ0cmFjZXIiLCJub29wVHJhY2VyIiwib3V0T2ZTeW5jVGhyZXNob2xkIiwibWVzc2FnZVJldHJpZXNDb3VudCIsInRpbWVvdXQiLCJtZXNzYWdlUHJvY2Vzc2luZ1RpbWVvdXQiLCJ3YWl0Rm9yVGltZW91dCIsIm5ldHdvcmtUaW1lb3V0Iiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInByb2ZpbGUiLCJfcHJvZmlsZVN0YXJ0IiwiYXJncyIsImN1cnJlbnQiLCJ0aW1lU3RyaW5nIiwiU3RyaW5nIiwidG9GaXhlZCIsIl9wcm9maWxlUHJldiIsIl9sb2dWZXJib3NlIiwiY29uc29sZSIsImxvZyIsInJlcXVlc3RDb3JlIiwiY29yZUNvbmZpZyIsIk9iamVjdCIsImFzc2lnbiIsImxvZ192ZXJib3NlIiwic3RhcnRQcm9maWxlIiwiX2VyckxvZ1ZlcmJvc2UiLCJlcnJfbG9nX3ZlcmJvc2UiLCJUT05Nb2R1bGUiLCJtb2R1bGVOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFPQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSw2QkFBNkIsR0FBRyxFQUF0QztBQUNBLElBQU1DLGtDQUFrQyxHQUFHLEtBQTNDO0FBQ0EsSUFBTUMsd0JBQXdCLEdBQUcsS0FBakM7QUFDQSxJQUFNQyx1QkFBdUIsR0FBRyxDQUFoQztBQUVBLElBQU1DLDZCQUE2QixHQUFHLEtBQXRDOztJQUVhQyxROzs7Z0NBNEJHQyxHLEVBQXNDO0FBQzlDLFdBQUtDLFFBQUwsR0FBZ0JELEdBQUcsQ0FBQyxLQUFLQyxRQUFOLENBQW5CO0FBQ0EsYUFBTyxJQUFQO0FBQ0g7Ozs0QkFFT0QsRyxFQUFzQztBQUMxQyxXQUFLRSxJQUFMLEdBQVlGLEdBQUcsQ0FBQyxLQUFLRSxJQUFOLENBQWY7QUFDQSxhQUFPLElBQVA7QUFDSDs7OzRCQUVPRixHLEVBQXNDO0FBQzFDLFdBQUtHLElBQUwsR0FBWUgsR0FBRyxDQUFDLEtBQUtHLElBQU4sQ0FBZjtBQUNBLGFBQU8sSUFBUDtBQUNIOzs7NkJBRVFILEcsRUFBc0M7QUFDM0MsV0FBS0ksS0FBTCxHQUFhSixHQUFHLENBQUMsS0FBS0ksS0FBTixDQUFoQjtBQUNBLGFBQU8sSUFBUDtBQUNIOzs7MEJBN0NZQyxHLEVBQXVCO0FBQ2hDLFVBQU1DLG9CQUFvQixHQUFHRCxHQUFHLENBQUNFLE9BQUosQ0FBWSxLQUFaLENBQTdCO0FBQ0EsVUFBTUMsV0FBVyxHQUFHRixvQkFBb0IsSUFBSSxDQUF4QixHQUE0QkEsb0JBQW9CLEdBQUcsQ0FBbkQsR0FBdUQsQ0FBM0U7QUFDQSxVQUFNRyxXQUFXLEdBQUdKLEdBQUcsQ0FB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YSxJQUE3QixlQUF5Q0csSUFBekM7QUFDSDtBQUNKOzs7bUNBRWM7QUFDWCxXQUFLRCxhQUFMLEdBQXFCSCxJQUFJLENBQUNDLEdBQUwsS0FBYSxJQUFsQztBQUNBLFdBQUtRLFlBQUwsR0FBb0IsS0FBS04sYUFBekI7QUFDSDs7O2tDQUVhO0FBQ1YsV0FBS0EsYUFBTCxHQUFxQixLQUFLTSxZQUFMLEdBQW9CLENBQXpDO0FBQ0g7Ozs7Ozs7OztpREFHVSxLQUFLSSxXQUFMLENBQWlCLFNBQWpCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBS0gsS0FBS3pCLEk7Ozs7O0FBQ0MwQixnQkFBQUEsVSxHQUFhQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUs1QixJQUF2QixDO0FBQ25CLHVCQUFPMEIsVUFBVSxDQUFDdkIsTUFBbEI7O3VCQUNNLEtBQUtzQixXQUFMLENBQWlCLE9BQWpCLEVBQTBCQyxVQUExQixDOzs7QUFFVixxQkFBS0osV0FBTCxHQUFtQixLQUFLdEIsSUFBTCxDQUFVNkIsV0FBVixJQUF5QixLQUE1Qzs7QUFDQSxvQkFBSSxLQUFLUCxXQUFULEVBQXNCO0FBQ2xCLHVCQUFLUSxZQUFMO0FBQ0g7O0FBQ0QscUJBQUtDLGNBQUwsR0FBc0IsS0FBSy9CLElBQUwsQ0FBVWdDLGVBQVYsSUFBNkIsSUFBbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE5RnFDQyxxQjs7O0FBd0c3Q25DLGVBQWUsQ0FBQ29DLFVBQWhCLEdBQTZCLGlCQUE3QiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIwIFRPTiBERVYgU09MVVRJT05TIExURC5cbiAqL1xuXG4vLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBUT05Db25maWdEYXRhIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IFRPTk1vZHVsZUNvbnRleHQgfSBmcm9tIFwiLi4vVE9OTW9kdWxlXCI7XG5pbXBvcnQgeyBUT05Nb2R1bGUgfSBmcm9tICcuLi9UT05Nb2R1bGUnO1xuaW1wb3J0IHsgVHJhY2VyIH0gZnJvbSAnb3BlbnRyYWNpbmcnO1xuaW1wb3J0IHsgdHJhY2VyIGFzIG5vb3BUcmFjZXIgfSBmcm9tIFwib3BlbnRyYWNpbmcvbGliL25vb3BcIjtcblxuY29uc3QgREVGQVVMVF9NRVNTQUdFX1JFVFJJRVNfQ09VTlQgPSAxMDtcbmNvbnN0IERFRkFVTFRfTUVTU0FHRV9QUk9DRVNTSU5HX1RJTUVPVVQgPSA0MDAwMDtcbmNvbnN0IERFRkFVTFRfV0FJVF9GT1JfVElNRU9VVCA9IDQwMDAwO1xuY29uc3QgREVGQVVMVF9ORVRXT1JLX1RJTUVPVVQgPSAwO1xuXG5jb25zdCBERUZBVUxUX09VVF9PRl9TWU5DX1RIUkVTSE9MRCA9IDE1MDAwO1xuXG5leHBvcnQgY2xhc3MgVVJMUGFydHMge1xuICAgIHN0YXRpYyBwYXJzZSh1cmw6IHN0cmluZyk6IFVSTFBhcnRzIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2xTZXBhcmF0b3JQb3MgPSB1cmwuaW5kZXhPZignOi8vJyk7XG4gICAgICAgIGNvbnN0IHByb3RvY29sRW5kID0gcHJvdG9jb2xTZXBhcmF0b3JQb3MgPj0gMCA/IHByb3RvY29sU2VwYXJhdG9yUG9zICsgMyA6IDA7XG4gICAgICAgIGNvbnN0IHF1ZXN0aW9uUG9zID0gdXJsLmluZGV4T2YoJz8nLCBwcm90b2NvbEVuZCk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RhcnQgPSBxdWVzdGlvblBvcyA+PSAwID8gcXVlc3Rpb25Qb3MgKyAxIDogdXJsLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGF0aEVuZCA9IHF1ZXN0aW9uUG9zID49IDAgPyBxdWVzdGlvblBvcyA6IHVybC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBhdGhTZXBhcmF0b3JQb3MgPSB1cmwuaW5kZXhPZignLycsIHByb3RvY29sRW5kKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgIGNvbnN0IHBhdGhTdGFydCA9IHBhdGhTZXBhcmF0b3JQb3MgPj0gMFxuICAgICAgICAgICAgPyAocGF0aFNlcGFyYXRvclBvcyA8IHBhdGhFbmQgPyBwYXRoU2VwYXJhdG9yUG9zIDogcGF0aEVuZClcbiAgICAgICAgICAgIDogKHF1ZXN0aW9uUG9zID49IDAgPyBxdWVzdGlvblBvcyA6IHVybC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IFVSTFBhcnRzKFxuICAgICAgICAgICAgdXJsLnN1YnN0cmluZygwLCBwcm90b2NvbEVuZCksXG4gICAgICAgICAgICB1cmwuc3Vic3RyaW5nKHByb3RvY29sRW5kLCBwYXRoU3RhcnQpLFxuICAgICAgICAgICAgdXJsLnN1YnN0cmluZyhwYXRoU3RhcnQsIHBhdGhFbmQpLFxuICAgICAgICAgICAgdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0KSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzb2x2ZVVybChiYXNlVXJsOiBzdHJpbmcsIHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgYmFzZVBhcnRzID0gVVJMUGFydHMucGFyc2UoYmFzZVVybCk7XG4gICAgICAgIHJldHVybiBVUkxQYXJ0cy5wYXJzZSh1cmwpXG4gICAgICAgICAgICAuZml4UHJvdG9jb2woeCA9PiB4IHx8IGJhc2VQYXJ0cy5wcm90b2NvbClcbiAgICAgICAgICAgIC5maXhIb3N0KHggPT4geCB8fCBiYXNlUGFydHMuaG9zdClcbiAgICAgICAgICAgIC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGZpeFByb3RvY29sKGZpeDogKHA6IHN0cmluZykgPT4gc3RyaW5nKTogVVJMUGFydHMge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gZml4KHRoaXMucHJvdG9jb2wpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmaXhIb3N0KGZpeDogKHA6IHN0cmluZykgPT4gc3RyaW5nKTogVVJMUGFydHMge1xuICAgICAgICB0aGlzLmhvc3QgPSBmaXgodGhpcy5ob3N0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZml4UGF0aChmaXg6IChwOiBzdHJpbmcpID0+IHN0cmluZyk6IFVSTFBhcnRzIHtcbiAgICAgICAgdGhpcy5wYXRoID0gZml4KHRoaXMucGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZpeFF1ZXJ5KGZpeDogKHE6IHN0cmluZykgPT4gc3RyaW5nKTogVVJMUGFydHMge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gZml4KHRoaXMucXVlcnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIHByb3RvY29sOiBzdHJpbmc7XG5cbiAgICBob3N0OiBzdHJpbmc7XG5cbiAgICBwYXRoOiBzdHJpbmc7XG5cbiAgICBxdWVyeTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJvdG9jb2w6IHN0cmluZywgaG9zdDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgfVxuXG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgeyBwYXRoIH0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocGF0aC5pbmRleE9mKCcvLycpID49IDApIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAhPT0gJycgJiYgIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBwYXRoID0gYC8ke3BhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5wcm90b2NvbH0ke3RoaXMuaG9zdH0ke3BhdGh9JHt0aGlzLnF1ZXJ5ICE9PSAnJyA/ICc/JyA6ICcnfSR7dGhpcy5xdWVyeX1gO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRTZXJ2ZXIgPSAnaHR0cDovL2xvY2FsaG9zdCc7XG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUT05Db25maWdNb2R1bGUgZXh0ZW5kcyBUT05Nb2R1bGUge1xuICAgIGRhdGE6IFRPTkNvbmZpZ0RhdGE7XG4gICAgdHJhY2VyOiBUcmFjZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBUT05Nb2R1bGVDb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICBzZXJ2ZXJzOiBbZGVmYXVsdFNlcnZlcl0sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXREYXRhKGRhdGE6IFRPTkNvbmZpZ0RhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCB0aGlzLmRhdGE7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuc2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXJ2ZXJzLnB1c2goZGVmYXVsdFNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZXIgPSBkYXRhLnRyYWNlciB8fCBub29wVHJhY2VyO1xuICAgIH1cblxuICAgIGdldENvbmZpZ1NlcnZlcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhPy5zZXJ2ZXJzPy5bMF0gfHwgJyc7XG4gICAgfVxuXG4gICAgb3V0T2ZTeW5jVGhyZXNob2xkKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aGlzLmRhdGEub3V0T2ZTeW5jVGhyZXNob2xkLCBERUZBVUxUX09VVF9PRl9TWU5DX1RIUkVTSE9MRCk7XG4gICAgfVxuXG4gICAgbWVzc2FnZVJldHJpZXNDb3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGhpcy5kYXRhLm1lc3NhZ2VSZXRyaWVzQ291bnQsIERFRkFVTFRfTUVTU0FHRV9SRVRSSUVTX0NPVU5UKTtcbiAgICB9XG5cbiAgICBtZXNzYWdlUHJvY2Vzc2luZ1RpbWVvdXQoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuZGF0YS5tZXNzYWdlUHJvY2Vzc2luZ1RpbWVvdXQ7XG4gICAgICAgIHJldHVybiB0aW1lb3V0ID09PSAwID8gMCA6ICh0aW1lb3V0IHx8IERFRkFVTFRfTUVTU0FHRV9QUk9DRVNTSU5HX1RJTUVPVVQpO1xuICAgIH1cblxuICAgIHdhaXRGb3JUaW1lb3V0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aGlzLmRhdGEud2FpdEZvclRpbWVvdXQsIERFRkFVTFRfV0FJVF9GT1JfVElNRU9VVCk7XG4gICAgfVxuXG4gICAgbmV0d29ya1RpbWVvdXQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRoaXMuZGF0YS5uZXR3b3JrVGltZW91dCwgREVGQVVMVF9ORVRXT1JLX1RJTUVPVVQpO1xuICAgIH1cblxuICAgIGlzTmV0d29ya1RpbWVvdXRFeHBpcmVkU2luY2Uoc3RhcnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMubmV0d29ya1RpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSA+IChzdGFydFRpbWUgKyB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICBsb2coLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9ICh0aGlzLl9wcm9maWxlU3RhcnQgfHwgMCkgIT09IDA7XG4gICAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICBjb25zdCB0aW1lU3RyaW5nID0gYCR7U3RyaW5nKGN1cnJlbnQudG9GaXhlZCgzKSl9ICR7XG4gICAgICAgICAgICAgICAgU3RyaW5nKChjdXJyZW50IC0gdGhpcy5fcHJvZmlsZVN0YXJ0KS50b0ZpeGVkKDMpKX0gJHtcbiAgICAgICAgICAgICAgICBTdHJpbmcoKGN1cnJlbnQgLSB0aGlzLl9wcm9maWxlUHJldikudG9GaXhlZCgzKSl9YDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2dWZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3RpbWVTdHJpbmd9XVxcbmAsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGltZVN0cmluZ31dXFxuYCwgYXJnc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlUHJldiA9IGN1cnJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9nVmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFske0RhdGUubm93KCkgLyAxMDAwfV1gLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0UHJvZmlsZSgpIHtcbiAgICAgICAgdGhpcy5fcHJvZmlsZVN0YXJ0ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIHRoaXMuX3Byb2ZpbGVQcmV2ID0gdGhpcy5fcHJvZmlsZVN0YXJ0O1xuICAgIH1cblxuICAgIHN0b3BQcm9maWxlKCkge1xuICAgICAgICB0aGlzLl9wcm9maWxlU3RhcnQgPSB0aGlzLl9wcm9maWxlUHJldiA9IDA7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VmVyc2lvbigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgndmVyc2lvbicpO1xuICAgIH1cblxuXG4gICAgYXN5bmMgc2V0dXAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcmVDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIGNvcmVDb25maWcudHJhY2VyO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0Q29yZSgnc2V0dXAnLCBjb3JlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dWZXJib3NlID0gdGhpcy5kYXRhLmxvZ192ZXJib3NlIHx8IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fbG9nVmVyYm9zZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFByb2ZpbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJMb2dWZXJib3NlID0gdGhpcy5kYXRhLmVycl9sb2dfdmVyYm9zZSB8fCB0cnVlO1xuICAgIH1cblxuICAgIF9sb2dWZXJib3NlOiBib29sZWFuO1xuICAgIF9lcnJMb2dWZXJib3NlOiBib29sZWFuO1xuICAgIF9wcm9maWxlU3RhcnQ6IG51bWJlcjtcblxuICAgIF9wcm9maWxlUHJldjogbnVtYmVyO1xufVxuXG5UT05Db25maWdNb2R1bGUubW9kdWxlTmFtZSA9ICdUT05Db25maWdNb2R1bGUnO1xuIl19

/***/ }),

/***/ "./node_modules/ton-client-js/dist/modules/TONContractsModule.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ton-client-js/dist/modules/TONContractsModule.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.removeProps = removeProps;
exports.default = exports.QBounceType = exports.QSkipReason = exports.QComputeType = exports.QAccountStatusChange = exports.QAccountStatus = exports.QTransactionProcessingStatus = exports.QTransactionType = exports.QAccountType = exports.QSplitType = exports.QBlockProcessingStatus = exports.QMessageProcessingStatus = exports.QMessageType = exports.QOutMsgType = exports.QInMsgType = exports.TONClientStorageStatus = exports.TONClientComputeSkippedStatus = exports.TONClientTransactionPhase = exports.TONAddressStringVariant = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _opentracing = __webpack_require__(/*! opentracing */ "./node_modules/opentracing/lib/index.js");

var _TONClientError = __webpack_require__(/*! ../TONClientError */ "./node_modules/ton-client-js/dist/TONClientError.js");

var _TONModule2 = __webpack_require__(/*! ../TONModule */ "./node_modules/ton-client-js/dist/TONModule.js");

var _TONConfigModule = _interopRequireDefault(__webpack_require__(/*! ./TONConfigModule */ "./node_modules/ton-client-js/dist/modules/TONConfigModule.js"));

var _TONCryptoModule = _interopRequireWildcard(__webpack_require__(/*! ./TONCryptoModule */ "./node_modules/ton-client-js/dist/modules/TONCryptoModule.js"));

var _TONQueriesModule = _interopRequireWildcard(__webpack_require__(/*! ./TONQueriesModule */ "./node_modules/ton-client-js/dist/modules/TONQueriesModule.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var TONAddressStringVariant = {
  AccountId: 'AccountId',
  Hex: 'Hex',
  Base64: 'Base64'
};
exports.TONAddressStringVariant = TONAddressStringVariant;
var TONClientTransactionPhase = {
  storage: 'storage',
  computeSkipped: 'computeSkipped',
  computeVm: 'computeVm',
  action: 'action',
  unknown: 'unknown'
};
exports.TONClientTransactionPhase = TONClientTransactionPhase;
var TONClientComputeSkippedStatus = {
  noState: 0,
  badState: 1,
  noGas: 2
};
exports.TONClientComputeSkippedStatus = TONClientComputeSkippedStatus;
var TONClientStorageStatus = {
  unchanged: 0,
  frozen: 1,
  deleted: 2
};
exports.TONClientStorageStatus = TONClientStorageStatus;
var QInMsgType = {
  external: 0,
  ihr: 1,
  immediately: 2,
  "final": 3,
  transit: 4,
  discardedFinal: 5,
  discardedTransit: 6
};
exports.QInMsgType = QInMsgType;
var QOutMsgType = {
  external: 0,
  immediately: 1,
  outMsgNew: 2,
  transit: 3,
  dequeueImmediately: 4,
  dequeue: 5,
  transitRequired: 6,
  none: -1
};
exports.QOutMsgType = QOutMsgType;
var QMessageType = {
  internal: 0,
  extIn: 1,
  extOut: 2
};
exports.QMessageType = QMessageType;
var QMessageProcessingStatus = {
  unknown: 0,
  queued: 1,
  processing: 2,
  preliminary: 3,
  proposed: 4,
  finalized: 5,
  refused: 6,
  transiting: 7
};
exports.QMessageProcessingStatus = QMessageProcessingStatus;
var QBlockProcessingStatus = {
  unknown: 0,
  proposed: 1,
  finalized: 2,
  refused: 3
};
exports.QBlockProcessingStatus = QBlockProcessingStatus;
var QSplitType = {
  none: 0,
  split: 2,
  merge: 3
};
exports.QSplitType = QSplitType;
var QAccountType = {
  uninit: 0,
  active: 1,
  frozen: 2
};
exports.QAccountType = QAccountType;
var QTransactionType = {
  ordinary: 0,
  storage: 1,
  tick: 2,
  tock: 3,
  splitPrepare: 4,
  splitInstall: 5,
  mergePrepare: 6,
  mergeInstall: 7
};
exports.QTransactionType = QTransactionType;
var QTransactionProcessingStatus = {
  unknown: 0,
  preliminary: 1,
  proposed: 2,
  finalized: 3,
  refused: 4
};
exports.QTransactionProcessingStatus = QTransactionProcessingStatus;
var QAccountStatus = {
  uninit: 0,
  active: 1,
  frozen: 2,
  nonExist: 3
};
exports.QAccountStatus = QAccountStatus;
var QAccountStatusChange = {
  unchanged: 0,
  frozen: 1,
  deleted: 2
};
exports.QAccountStatusChange = QAccountStatusChange;
var QComputeType = {
  skipped: 0,
  vm: 1
};
exports.QComputeType = QComputeType;
var QSkipReason = {
  noState: 0,
  badState: 1,
  noGas: 2
};
exports.QSkipReason = QSkipReason;
var QBounceType = {
  negFunds: 0,
  noFunds: 1,
  ok: 2
};
exports.QBounceType = QBounceType;
var MASTERCHAIN_ID = -1;

function removeTypeName(obj) {
  if (obj.__typename) {
    delete obj.__typename;
  }

  Object.values(obj).forEach(function (value) {
    if (!!value && _typeof(value) === 'object') {
      removeTypeName(value);
    }
  });
}

function removeProps(obj, paths) {
  var result = obj;
  paths.forEach(function (path) {
    var dotPos = path.indexOf('.');

    if (dotPos < 0) {
      if (path in result) {
        result = _objectSpread({}, result);
        delete result[path];
      }
    } else {
      var name = path.substr(0, dotPos);
      var child = result[name];

      if (child) {
        var reducedChild = removeProps(child, [path.substr(dotPos + 1)]);

        if (reducedChild !== child) {
          result = _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, reducedChild));
        }
      }
    }
  });
  return result;
}

function startMessageTraceSpan(tracer, messageId, operationName, tags) {
  if (!messageId) {
    return null;
  }

  var traceId = messageId.substr(0, 16);
  var spanId = messageId.substr(16, 16);
  var rootContext = null;

  try {
    rootContext = tracer.extract(_opentracing.FORMAT_TEXT_MAP, {
      'uber-trace-id': "".concat(traceId, ":").concat(spanId, ":0:1")
    });
  } catch (_unused) {// tracer can't create jaeger compatible span,
    // so we are fallback to return null
  }

  if (!rootContext) {
    return null;
  }

  return tracer.startSpan(operationName, {
    childOf: rootContext,
    tags: tags
  });
}

function traceMessage(tracer, messageId, operationName, tags) {
  var span = startMessageTraceSpan(tracer, messageId, operationName, tags);

  if (span) {
    span.finish();
  }
}

function getSigningSource(_x, _x2) {
  return _getSigningSource.apply(this, arguments);
}

function _getSigningSource() {
  _getSigningSource = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee61(box, keys) {
    return _regenerator["default"].wrap(function _callee61$(_context61) {
      while (1) {
        switch (_context61.prev = _context61.next) {
          case 0:
            if (!box) {
              _context61.next = 7;
              break;
            }

            _context61.t0 = box;
            _context61.next = 4;
            return box.getPublicKey();

          case 4:
            _context61.t1 = _context61.sent;
            _context61.t2 = {
              secret: '',
              "public": _context61.t1
            };
            return _context61.abrupt("return", {
              box: _context61.t0,
              keys: _context61.t2
            });

          case 7:
            if (!(keys && keys.secret)) {
              _context61.next = 9;
              break;
            }

            return _context61.abrupt("return", {
              box: null,
              keys: keys
            });

          case 9:
            return _context61.abrupt("return", null);

          case 10:
          case "end":
            return _context61.stop();
        }
      }
    }, _callee61);
  }));
  return _getSigningSource.apply(this, arguments);
}

var TONContractsModule = /*#__PURE__*/function (_TONModule) {
  _inherits(TONContractsModule, _TONModule);

  var _super = _createSuper(TONContractsModule);

  function TONContractsModule() {
    var _this;

    _classCallCheck(this, TONContractsModule);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "config", void 0);

    _defineProperty(_assertThisInitialized(_this), "crypto", void 0);

    _defineProperty(_assertThisInitialized(_this), "queries", void 0);

    _defineProperty(_assertThisInitialized(_this), "bigBalance", '0x10000000000000');

    return _this;
  }

  _createClass(TONContractsModule, [{
    key: "setup",
    value: function () {
      var _setup = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.config = this.context.getModule(_TONConfigModule["default"]);
                this.queries = this.context.getModule(_TONQueriesModule["default"]);
                this.crypto = this.context.getModule(_TONCryptoModule["default"]);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(params, parentSpan) {
        var accounts;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.queries.accounts.query({
                  filter: {
                    id: {
                      eq: params.address
                    }
                  },
                  result: 'balance',
                  parentSpan: parentSpan
                });

              case 2:
                accounts = _context2.sent;

                if (!(accounts && accounts.length > 0)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", {
                  id: params.address,
                  balanceGrams: accounts[0].balance
                });

              case 5:
                return _context2.abrupt("return", {
                  id: null,
                  balanceGrams: null
                });

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function load(_x3, _x4) {
        return _load.apply(this, arguments);
      }

      return load;
    }() // Facade functions

  }, {
    key: "deploy",
    value: function () {
      var _deploy = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4(params, parentSpan) {
        var _this2 = this;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.context.trace('contracts.deploy', /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(span) {
                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            span.setTag('params', removeProps(params, ['keyPair.secret']));
                            return _context3.abrupt("return", _this2.internalDeployJs(params, span));

                          case 2:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x7) {
                    return _ref.apply(this, arguments);
                  };
                }(), parentSpan));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function deploy(_x5, _x6) {
        return _deploy.apply(this, arguments);
      }

      return deploy;
    }()
  }, {
    key: "run",
    value: function () {
      var _run = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee6(params, parentSpan) {
        var _this3 = this;

        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.context.trace('contracts.run', /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee5(span) {
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            span.setTag('params', removeProps(params, ['keyPair.secret']));
                            return _context5.abrupt("return", _this3.internalRunJs(params, span));

                          case 2:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x10) {
                    return _ref2.apply(this, arguments);
                  };
                }(), parentSpan));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function run(_x8, _x9) {
        return _run.apply(this, arguments);
      }

      return run;
    }()
  }, {
    key: "runLocal",
    value: function () {
      var _runLocal = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee8(params, parentSpan) {
        var _this4 = this;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", this.context.trace('contracts.runLocal', /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee7(span) {
                    return _regenerator["default"].wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            span.setTag('params', removeProps(params, ['keyPair.secret']));
                            return _context7.abrupt("return", _this4.internalRunLocalJs(params, span));

                          case 2:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7);
                  }));

                  return function (_x13) {
                    return _ref3.apply(this, arguments);
                  };
                }(), parentSpan));

              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function runLocal(_x11, _x12) {
        return _runLocal.apply(this, arguments);
      }

      return runLocal;
    }()
  }, {
    key: "runMessageLocal",
    value: function () {
      var _runMessageLocal = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee10(params, parentSpan) {
        var _this5 = this;

        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this.context.trace('runMessageLocal', /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee9(span) {
                    return _regenerator["default"].wrap(function _callee9$(_context9) {
                      while (1) {
                        switch (_context9.prev = _context9.next) {
                          case 0:
                            span.setTag('params', removeProps(params, ['keyPair.secret']));
                            return _context9.abrupt("return", _this5.internalRunMessageLocalJs(params, span));

                          case 2:
                          case "end":
                            return _context9.stop();
                        }
                      }
                    }, _callee9);
                  }));

                  return function (_x16) {
                    return _ref4.apply(this, arguments);
                  };
                }(), parentSpan));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function runMessageLocal(_x14, _x15) {
        return _runMessageLocal.apply(this, arguments);
      }

      return runMessageLocal;
    }()
  }, {
    key: "runGet",
    value: function () {
      var _runGet = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee11(params) {
        var coreParams, hasCode, address, account, paramsFromAccount;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                coreParams = params;
                hasCode = params.bocBase64 || params.codeBase64 && params.dataBase64;

                if (hasCode) {
                  _context11.next = 26;
                  break;
                }

                address = params.address;

                if (address) {
                  _context11.next = 10;
                  break;
                }

                _context11.t0 = _TONClientError.TONClientError;
                _context11.next = 8;
                return this.completeErrorData();

              case 8:
                _context11.t1 = _context11.sent;
                throw _context11.t0.addressRequiredForRunLocal.call(_context11.t0, _context11.t1);

              case 10:
                _context11.next = 12;
                return this.getAccount(address, false, {
                  timeout: this.config.waitForTimeout()
                });

              case 12:
                account = _context11.sent;

                if (account.code_hash) {
                  _context11.next = 21;
                  break;
                }

                _context11.t2 = _TONClientError.TONClientError;
                _context11.t3 = address;
                _context11.t4 = account.balance;
                _context11.next = 19;
                return this.completeErrorData();

              case 19:
                _context11.t5 = _context11.sent;
                throw _context11.t2.accountCodeMissing.call(_context11.t2, _context11.t3, _context11.t4, _context11.t5);

              case 21:
                paramsFromAccount = {};

                if (account.boc) {
                  paramsFromAccount.bocBase64 = account.boc;
                }

                if (account.last_paid) {
                  paramsFromAccount.last_paid = account.last_paid;
                }

                if (account.balance) {
                  paramsFromAccount.balance = account.balance;
                }

                coreParams = _objectSpread(_objectSpread({}, paramsFromAccount), params);

              case 26:
                return _context11.abrupt("return", this.requestCore('tvm.get', coreParams));

              case 27:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function runGet(_x17) {
        return _runGet.apply(this, arguments);
      }

      return runGet;
    }()
  }, {
    key: "arrayFromCONS",
    value: function arrayFromCONS(cons) {
      var result = [];
      var item = cons;

      while (item) {
        if (!item.length === 2) {
          throw _TONClientError.TONClientError.invalidCons(_TONClientError.emptyTONErrorData);
        }

        result.push(item[0]);
        item = item[1];
      }

      return result;
    } // Message creation

  }, {
    key: "createDeployMessage",
    value: function () {
      var _createDeployMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee12(params, retryIndex) {
        var source, unsignedMessage, message;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this.config.log('createDeployMessage', params);
                _context12.next = 3;
                return getSigningSource(params.signingBox, params.keyPair);

              case 3:
                source = _context12.sent;

                if (!source) {
                  _context12.next = 20;
                  break;
                }

                _context12.next = 7;
                return this.createUnsignedDeployMessage(_objectSpread(_objectSpread({}, params), {}, {
                  keyPair: source.keys
                }));

              case 7:
                unsignedMessage = _context12.sent;
                _context12.t0 = this;
                _context12.t1 = _objectSpread;
                _context12.t2 = _objectSpread;
                _context12.t3 = {};
                _context12.next = 14;
                return this.internalSign(unsignedMessage.signParams, source);

              case 14:
                _context12.t4 = _context12.sent;
                _context12.t5 = (0, _context12.t2)(_context12.t3, _context12.t4);
                _context12.t6 = {};
                _context12.t7 = {
                  unsignedMessage: unsignedMessage
                };
                _context12.t8 = (0, _context12.t1)(_context12.t5, _context12.t6, _context12.t7);
                return _context12.abrupt("return", _context12.t0.createSignedDeployMessage.call(_context12.t0, _context12.t8));

              case 20:
                _context12.next = 22;
                return this.requestCore('contracts.deploy.message', {
                  abi: params["package"].abi,
                  constructorHeader: params.constructorHeader,
                  constructorParams: params.constructorParams,
                  initParams: params.initParams,
                  imageBase64: params["package"].imageBase64,
                  keyPair: params.keyPair,
                  workchainId: params.workchainId
                });

              case 22:
                message = _context12.sent;
                return _context12.abrupt("return", {
                  address: message.address,
                  message: message
                });

              case 24:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function createDeployMessage(_x18, _x19) {
        return _createDeployMessage.apply(this, arguments);
      }

      return createDeployMessage;
    }()
  }, {
    key: "createRunMessage",
    value: function () {
      var _createRunMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee13(params, retryIndex) {
        var source, unsignedMessage, message;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.config.log('createRunMessage', params);
                _context13.next = 3;
                return getSigningSource(params.signingBox, params.keyPair);

              case 3:
                source = _context13.sent;

                if (!source) {
                  _context13.next = 20;
                  break;
                }

                _context13.next = 7;
                return this.createUnsignedRunMessage(params);

              case 7:
                unsignedMessage = _context13.sent;
                _context13.t0 = this;
                _context13.t1 = _objectSpread;
                _context13.t2 = _objectSpread;
                _context13.t3 = {};
                _context13.next = 14;
                return this.internalSign(unsignedMessage.signParams, source);

              case 14:
                _context13.t4 = _context13.sent;
                _context13.t5 = (0, _context13.t2)(_context13.t3, _context13.t4);
                _context13.t6 = {};
                _context13.t7 = {
                  unsignedMessage: unsignedMessage
                };
                _context13.t8 = (0, _context13.t1)(_context13.t5, _context13.t6, _context13.t7);
                return _context13.abrupt("return", _context13.t0.createSignedRunMessage.call(_context13.t0, _context13.t8));

              case 20:
                _context13.next = 22;
                return this.requestCore('contracts.run.message', {
                  address: params.address,
                  abi: params.abi,
                  functionName: params.functionName,
                  header: params.header,
                  tryIndex: retryIndex,
                  input: params.input,
                  keyPair: params.keyPair
                });

              case 22:
                message = _context13.sent;
                return _context13.abrupt("return", {
                  address: params.address,
                  abi: params.abi,
                  functionName: params.functionName,
                  message: message
                });

              case 24:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function createRunMessage(_x20, _x21) {
        return _createRunMessage.apply(this, arguments);
      }

      return createRunMessage;
    }()
  }, {
    key: "createUnsignedDeployMessage",
    value: function () {
      var _createUnsignedDeployMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee14(params, retryIndex) {
        var result;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.requestCore('contracts.deploy.encode_unsigned_message', {
                  abi: params["package"].abi,
                  constructorHeader: params.constructorHeader,
                  tryIndex: retryIndex,
                  constructorParams: params.constructorParams,
                  initParams: params.initParams,
                  imageBase64: params["package"].imageBase64,
                  publicKeyHex: params.keyPair["public"],
                  workchainId: params.workchainId
                });

              case 2:
                result = _context14.sent;
                return _context14.abrupt("return", {
                  address: result.addressHex,
                  signParams: _objectSpread(_objectSpread({}, result.encoded), {}, {
                    abi: params["package"].abi
                  })
                });

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function createUnsignedDeployMessage(_x22, _x23) {
        return _createUnsignedDeployMessage.apply(this, arguments);
      }

      return createUnsignedDeployMessage;
    }()
  }, {
    key: "createUnsignedRunMessage",
    value: function () {
      var _createUnsignedRunMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee15(params, retryIndex) {
        var _header;

        var header, _yield$getSigningSour, keys, signParams;

        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                header = params.header;

                if (!((params.abi.header || []).includes('pubkey') && !((_header = header) === null || _header === void 0 ? void 0 : _header.pubkey))) {
                  _context15.next = 15;
                  break;
                }

                _context15.next = 4;
                return getSigningSource(params.signingBox, params.keyPair);

              case 4:
                _context15.t1 = _yield$getSigningSour = _context15.sent;
                _context15.t0 = _context15.t1 === null;

                if (_context15.t0) {
                  _context15.next = 8;
                  break;
                }

                _context15.t0 = _yield$getSigningSour === void 0;

              case 8:
                if (!_context15.t0) {
                  _context15.next = 12;
                  break;
                }

                _context15.t2 = void 0;
                _context15.next = 13;
                break;

              case 12:
                _context15.t2 = _yield$getSigningSour.keys;

              case 13:
                keys = _context15.t2;

                if (keys) {
                  header = _objectSpread(_objectSpread({}, header), {}, {
                    pubkey: keys["public"]
                  });
                }

              case 15:
                _context15.next = 17;
                return this.requestCore('contracts.run.encode_unsigned_message', {
                  address: params.address,
                  abi: params.abi,
                  functionName: params.functionName,
                  header: header,
                  tryIndex: retryIndex,
                  input: params.input
                });

              case 17:
                signParams = _context15.sent;
                return _context15.abrupt("return", {
                  address: params.address,
                  functionName: params.functionName,
                  signParams: _objectSpread(_objectSpread({}, signParams), {}, {
                    abi: params.abi
                  })
                });

              case 19:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function createUnsignedRunMessage(_x24, _x25) {
        return _createUnsignedRunMessage.apply(this, arguments);
      }

      return createUnsignedRunMessage;
    }()
  }, {
    key: "createSignedMessage",
    value: function () {
      var _createSignedMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee16(params) {
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                return _context16.abrupt("return", this.requestCore('contracts.encode_message_with_sign', params));

              case 1:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function createSignedMessage(_x26) {
        return _createSignedMessage.apply(this, arguments);
      }

      return createSignedMessage;
    }()
  }, {
    key: "createSignedDeployMessage",
    value: function () {
      var _createSignedDeployMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee17(params) {
        var message;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.createSignedMessage({
                  abi: params.unsignedMessage.signParams.abi,
                  unsignedBytesBase64: params.unsignedMessage.signParams.unsignedBytesBase64,
                  signBytesBase64: params.signBytesBase64,
                  publicKeyHex: params.publicKeyHex
                });

              case 2:
                message = _context17.sent;
                message.expire = params.unsignedMessage.signParams.expire;
                return _context17.abrupt("return", {
                  address: params.unsignedMessage.address,
                  message: message
                });

              case 5:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function createSignedDeployMessage(_x27) {
        return _createSignedDeployMessage.apply(this, arguments);
      }

      return createSignedDeployMessage;
    }()
  }, {
    key: "createSignedRunMessage",
    value: function () {
      var _createSignedRunMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee18(params) {
        var message;
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.createSignedMessage({
                  abi: params.unsignedMessage.signParams.abi,
                  unsignedBytesBase64: params.unsignedMessage.signParams.unsignedBytesBase64,
                  signBytesBase64: params.signBytesBase64,
                  publicKeyHex: params.publicKeyHex
                });

              case 2:
                message = _context18.sent;
                message.expire = params.unsignedMessage.signParams.expire;
                return _context18.abrupt("return", {
                  address: params.unsignedMessage.address,
                  abi: params.unsignedMessage.signParams.abi,
                  functionName: params.unsignedMessage.functionName,
                  message: message
                });

              case 5:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function createSignedRunMessage(_x28) {
        return _createSignedRunMessage.apply(this, arguments);
      }

      return createSignedRunMessage;
    }()
  }, {
    key: "getCodeFromImage",
    value: function () {
      var _getCodeFromImage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee19(params) {
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                return _context19.abrupt("return", this.requestCore('contracts.image.code', params));

              case 1:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getCodeFromImage(_x29) {
        return _getCodeFromImage.apply(this, arguments);
      }

      return getCodeFromImage;
    }()
  }, {
    key: "getDeployData",
    value: function () {
      var _getDeployData = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee20(params) {
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", this.requestCore('contracts.deploy.data', params));

              case 1:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getDeployData(_x30) {
        return _getDeployData.apply(this, arguments);
      }

      return getDeployData;
    }()
  }, {
    key: "createRunBody",
    value: function () {
      var _createRunBody = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee21(params) {
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                return _context21.abrupt("return", this.requestCore('contracts.run.body', params));

              case 1:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function createRunBody(_x31) {
        return _createRunBody.apply(this, arguments);
      }

      return createRunBody;
    }()
  }, {
    key: "getFunctionId",
    value: function () {
      var _getFunctionId = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee22(params) {
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                return _context22.abrupt("return", this.requestCore('contracts.function.id', params));

              case 1:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getFunctionId(_x32) {
        return _getFunctionId.apply(this, arguments);
      }

      return getFunctionId;
    }()
  }, {
    key: "getBocHash",
    value: function () {
      var _getBocHash = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee23(params) {
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                return _context23.abrupt("return", this.requestCore('contracts.boc.hash', params));

              case 1:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getBocHash(_x33) {
        return _getBocHash.apply(this, arguments);
      }

      return getBocHash;
    }()
  }, {
    key: "parseMessage",
    value: function () {
      var _parseMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee24(params) {
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                return _context24.abrupt("return", this.requestCore('contracts.parse.message', params));

              case 1:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function parseMessage(_x34) {
        return _parseMessage.apply(this, arguments);
      }

      return parseMessage;
    }() // Message parsing

  }, {
    key: "decodeRunOutput",
    value: function () {
      var _decodeRunOutput = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee25(params) {
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                return _context25.abrupt("return", this.requestCore('contracts.run.output', params));

              case 1:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function decodeRunOutput(_x35) {
        return _decodeRunOutput.apply(this, arguments);
      }

      return decodeRunOutput;
    }()
  }, {
    key: "decodeInputMessageBody",
    value: function () {
      var _decodeInputMessageBody = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee26(params) {
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                return _context26.abrupt("return", this.requestCore('contracts.run.unknown.input', params));

              case 1:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function decodeInputMessageBody(_x36) {
        return _decodeInputMessageBody.apply(this, arguments);
      }

      return decodeInputMessageBody;
    }()
  }, {
    key: "decodeOutputMessageBody",
    value: function () {
      var _decodeOutputMessageBody = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee27(params) {
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                return _context27.abrupt("return", this.requestCore('contracts.run.unknown.output', params));

              case 1:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function decodeOutputMessageBody(_x37) {
        return _decodeOutputMessageBody.apply(this, arguments);
      }

      return decodeOutputMessageBody;
    }() // Message processing

  }, {
    key: "ensureMessageId",
    value: function () {
      var _ensureMessageId = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee29(message) {
        var _this6 = this;

        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.t0 = message.messageId;

                if (_context29.t0) {
                  _context29.next = 5;
                  break;
                }

                _context29.next = 4;
                return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee28() {
                  var id;
                  return _regenerator["default"].wrap(function _callee28$(_context28) {
                    while (1) {
                      switch (_context28.prev = _context28.next) {
                        case 0:
                          _context28.next = 2;
                          return _this6.getBocHash({
                            bocBase64: message.messageBodyBase64
                          });

                        case 2:
                          id = _context28.sent.hash;
                          message.messageId = id;
                          return _context28.abrupt("return", id);

                        case 5:
                        case "end":
                          return _context28.stop();
                      }
                    }
                  }, _callee28);
                }))();

              case 4:
                _context29.t0 = _context29.sent;

              case 5:
                return _context29.abrupt("return", _context29.t0);

              case 6:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29);
      }));

      function ensureMessageId(_x38) {
        return _ensureMessageId.apply(this, arguments);
      }

      return ensureMessageId;
    }()
  }, {
    key: "sendMessage",
    value: function () {
      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee30(params, parentSpan) {
        var expire, serverTimeDelta, lastBlockId, id, idBase64, messageSpan;
        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                expire = params.expire;

                if (!(expire && Date.now() > expire * 1000)) {
                  _context30.next = 7;
                  break;
                }

                _context30.t0 = _TONClientError.TONClientError;
                _context30.next = 5;
                return this.completeErrorData({
                  address: params.address,
                  message_id: params.messageId
                });

              case 5:
                _context30.t1 = _context30.sent;
                throw _context30.t0.sendNodeRequestFailed.call(_context30.t0, 'Message already expired', _context30.t1);

              case 7:
                _context30.t2 = Math;
                _context30.next = 10;
                return this.queries.serverTimeDelta(parentSpan);

              case 10:
                _context30.t3 = _context30.sent;
                serverTimeDelta = _context30.t2.abs.call(_context30.t2, _context30.t3);

                if (!(serverTimeDelta > this.config.outOfSyncThreshold())) {
                  _context30.next = 19;
                  break;
                }

                this.queries.dropServerTimeDelta();
                _context30.t4 = _TONClientError.TONClientError;
                _context30.next = 17;
                return this.completeErrorData();

              case 17:
                _context30.t5 = _context30.sent;
                throw _context30.t4.clockOutOfSync.call(_context30.t4, _context30.t5);

              case 19:
                _context30.next = 21;
                return this.findLastShardBlock(params.address);

              case 21:
                lastBlockId = _context30.sent;
                _context30.next = 24;
                return this.ensureMessageId(params);

              case 24:
                id = _context30.sent;
                idBase64 = Buffer.from(id, 'hex').toString('base64');
                messageSpan = this.context.startRootSpan(id.substr(0, 16), id.substr(16, 16), 'messageProcessing');
                messageSpan.addTags({
                  messageId: id,
                  messageSize: Math.ceil(params.messageBodyBase64.length * 3 / 4),
                  address: params.address,
                  expire: params.expire
                });
                _context30.next = 30;
                return this.queries.postRequests([{
                  id: idBase64,
                  body: params.messageBodyBase64
                }], parentSpan);

              case 30:
                messageSpan.finish();
                this.config.log('sendMessage. Request posted', id);
                return _context30.abrupt("return", {
                  lastBlockId: lastBlockId,
                  sendingTime: Math.round(Date.now() / 1000)
                });

              case 33:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function sendMessage(_x39, _x40) {
        return _sendMessage.apply(this, arguments);
      }

      return sendMessage;
    }()
  }, {
    key: "processMessage",
    value: function () {
      var _processMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee31(message, resultFields, parentSpan, retryIndex, address, abi, functionName) {
        var processing, _yield$this$waitForTr, transaction;

        return _regenerator["default"].wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return this.sendMessage(message, parentSpan);

              case 2:
                processing = _context31.sent;
                _context31.next = 5;
                return this.waitForTransaction({
                  message: message,
                  messageProcessingState: processing,
                  parentSpan: parentSpan,
                  abi: abi,
                  functionName: functionName
                });

              case 5:
                _yield$this$waitForTr = _context31.sent;
                transaction = _yield$this$waitForTr.transaction;
                return _context31.abrupt("return", transaction);

              case 8:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function processMessage(_x41, _x42, _x43, _x44, _x45, _x46, _x47) {
        return _processMessage.apply(this, arguments);
      }

      return processMessage;
    }()
  }, {
    key: "findLastBlock",
    value: function () {
      var _findLastBlock = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee32(chain, result, additionalFilter) {
        var blocks;
        return _regenerator["default"].wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.queries.blocks.query({
                  filter: _objectSpread({
                    workchain_id: {
                      eq: chain
                    }
                  }, additionalFilter || {}),
                  result: result,
                  orderBy: [{
                    path: 'seq_no',
                    direction: 'DESC'
                  }],
                  limit: 1
                });

              case 2:
                blocks = _context32.sent;
                return _context32.abrupt("return", blocks.length > 0 ? blocks[0] : null);

              case 4:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function findLastBlock(_x48, _x49, _x50) {
        return _findLastBlock.apply(this, arguments);
      }

      return findLastBlock;
    }()
  }, {
    key: "findMatchingShard",
    value: function () {
      var _findMatchingShard = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee33(shards, address) {
        return _regenerator["default"].wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                return _context33.abrupt("return", this.requestCore('contracts.find.shard', {
                  shards: shards,
                  address: address
                }));

              case 1:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function findMatchingShard(_x51, _x52) {
        return _findMatchingShard.apply(this, arguments);
      }

      return findMatchingShard;
    }()
  }, {
    key: "findLastShardBlock",
    value: function () {
      var _findLastShardBlock = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee34(address) {
        var _masterchainLastBlock, _shardBlock$descr;

        var addressParts, workchain, masterchainLastBlock, workchainLastBlock, shards, shardBlock, root_hash;
        return _regenerator["default"].wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                addressParts = address.split(':');
                workchain = addressParts.length > 1 ? Number.parseInt(addressParts[0], 10) : 0; // if account resides in master chain then starting point is last master chain block
                // generated before message was sent

                _context34.next = 4;
                return this.findLastBlock(MASTERCHAIN_ID, 'id master { shard_hashes { workchain_id shard descr { root_hash } } }');

              case 4:
                masterchainLastBlock = _context34.sent;

                if (!(workchain === MASTERCHAIN_ID)) {
                  _context34.next = 14;
                  break;
                }

                if (masterchainLastBlock) {
                  _context34.next = 13;
                  break;
                }

                _context34.t0 = _TONClientError.TONClientError;
                _context34.t1 = MASTERCHAIN_ID;
                _context34.next = 11;
                return this.completeErrorData({
                  address: address
                });

              case 11:
                _context34.t2 = _context34.sent;
                throw _context34.t0.noBlocks.call(_context34.t0, _context34.t1, _context34.t2);

              case 13:
                return _context34.abrupt("return", masterchainLastBlock.id);

              case 14:
                if (masterchainLastBlock) {
                  _context34.next = 42;
                  break;
                }

                _context34.next = 17;
                return this.findLastBlock(workchain, 'after_merge shard');

              case 17:
                workchainLastBlock = _context34.sent;

                if (workchainLastBlock) {
                  _context34.next = 25;
                  break;
                }

                _context34.t3 = _TONClientError.TONClientError;
                _context34.t4 = workchain;
                _context34.next = 23;
                return this.completeErrorData({
                  address: address
                });

              case 23:
                _context34.t5 = _context34.sent;
                throw _context34.t3.noBlocks.call(_context34.t3, _context34.t4, _context34.t5);

              case 25:
                if (!(workchainLastBlock.after_merge || workchainLastBlock.shard !== '8000000000000000')) {
                  _context34.next = 32;
                  break;
                }

                _context34.t6 = _TONClientError.TONClientError;
                _context34.t7 = MASTERCHAIN_ID;
                _context34.next = 30;
                return this.completeErrorData({
                  address: address
                });

              case 30:
                _context34.t8 = _context34.sent;
                throw _context34.t6.noBlocks.call(_context34.t6, _context34.t7, _context34.t8);

              case 32:
                _context34.next = 34;
                return this.findLastBlock(workchain, 'id', {
                  shard: {
                    eq: '8000000000000000'
                  }
                });

              case 34:
                workchainLastBlock = _context34.sent;

                if (workchainLastBlock) {
                  _context34.next = 41;
                  break;
                }

                _context34.t9 = _TONClientError.TONClientError;
                _context34.next = 39;
                return this.completeErrorData({
                  address: address
                });

              case 39:
                _context34.t10 = _context34.sent;
                throw _context34.t9.invalidBlockchain.call(_context34.t9, 'No starting Node SE block found', _context34.t10);

              case 41:
                return _context34.abrupt("return", workchainLastBlock.id);

              case 42:
                shards = masterchainLastBlock === null || masterchainLastBlock === void 0 ? void 0 : (_masterchainLastBlock = masterchainLastBlock.master) === null || _masterchainLastBlock === void 0 ? void 0 : _masterchainLastBlock.shard_hashes;

                if (!(!shards || shards.length === 0)) {
                  _context34.next = 49;
                  break;
                }

                _context34.t11 = _TONClientError.TONClientError;
                _context34.next = 47;
                return this.completeErrorData({
                  address: address
                });

              case 47:
                _context34.t12 = _context34.sent;
                throw _context34.t11.invalidBlockchain.call(_context34.t11, 'No `shard_hashes` field in masterchain block', _context34.t12);

              case 49:
                _context34.next = 51;
                return this.findMatchingShard(shards, address);

              case 51:
                shardBlock = _context34.sent;
                root_hash = shardBlock === null || shardBlock === void 0 ? void 0 : (_shardBlock$descr = shardBlock.descr) === null || _shardBlock$descr === void 0 ? void 0 : _shardBlock$descr.root_hash;

                if (root_hash) {
                  _context34.next = 59;
                  break;
                }

                _context34.t13 = _TONClientError.TONClientError;
                _context34.next = 57;
                return this.completeErrorData({
                  address: address
                });

              case 57:
                _context34.t14 = _context34.sent;
                throw _context34.t13.invalidBlockchain.call(_context34.t13, 'No `root_hash` field in shard descr', _context34.t14);

              case 59:
                return _context34.abrupt("return", root_hash);

              case 60:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function findLastShardBlock(_x53) {
        return _findLastShardBlock.apply(this, arguments);
      }

      return findLastShardBlock;
    }()
  }, {
    key: "checkShardMatch",
    value: function () {
      var _checkShardMatch = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee35(block, address) {
        return _regenerator["default"].wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return this.findMatchingShard([{
                  workchain_id: block.workchain_id || 0,
                  shard: block.shard || ''
                }], address);

              case 2:
                return _context35.abrupt("return", !!_context35.sent);

              case 3:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function checkShardMatch(_x54, _x55) {
        return _checkShardMatch.apply(this, arguments);
      }

      return checkShardMatch;
    }()
  }, {
    key: "waitNextBlock",
    value: function () {
      var _waitNextBlock = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee36(current, address, timeout) {
        var block;
        return _regenerator["default"].wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.queries.blocks.waitFor({
                  filter: {
                    prev_ref: {
                      root_hash: {
                        eq: current
                      }
                    },
                    OR: {
                      prev_alt_ref: {
                        root_hash: {
                          eq: current
                        }
                      }
                    }
                  },
                  result: BLOCK_FIELDS,
                  timeout: timeout
                });

              case 2:
                block = _context36.sent;
                _context36.t0 = block === null || block === void 0 ? void 0 : block.after_split;

                if (!_context36.t0) {
                  _context36.next = 8;
                  break;
                }

                _context36.next = 7;
                return this.checkShardMatch(block, address);

              case 7:
                _context36.t0 = !_context36.sent;

              case 8:
                if (!_context36.t0) {
                  _context36.next = 10;
                  break;
                }

                return _context36.abrupt("return", this.queries.blocks.waitFor({
                  filter: {
                    id: {
                      ne: block.id
                    },
                    prev_ref: {
                      root_hash: {
                        eq: current
                      }
                    }
                  },
                  result: BLOCK_FIELDS,
                  timeout: timeout
                }));

              case 10:
                return _context36.abrupt("return", block);

              case 11:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function waitNextBlock(_x56, _x57, _x58) {
        return _waitNextBlock.apply(this, arguments);
      }

      return waitNextBlock;
    }()
  }, {
    key: "waitForTransaction",
    value: function () {
      var _waitForTransaction = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee37(params) {
        var totalStart, expire, messageId, address, processing, transaction, timeReport, stopTime, infiniteWait, addTimeout, now, timeout, block, start, end, resolvedError, inMsg, transactionId, trStart;
        return _regenerator["default"].wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                totalStart = Date.now();
                expire = params.message.expire || 0;
                _context37.next = 4;
                return this.ensureMessageId(params.message);

              case 4:
                messageId = _context37.sent;
                address = params.message.address;
                processing = _objectSpread({}, params.messageProcessingState);
                transaction = null;
                _context37.prev = 8;
                timeReport = [];
                stopTime = expire || Math.round((Date.now() + this.config.messageProcessingTimeout()) / 1000);
                infiniteWait = params.infiniteWait !== false;
                addTimeout = this.config.messageProcessingTimeout();

              case 13:
                if (transaction) {
                  _context37.next = 73;
                  break;
                }

                now = Date.now();
                timeout = Math.max(stopTime, now) - now + addTimeout;
                block = null;
                _context37.prev = 17;
                start = Date.now();
                _context37.next = 21;
                return this.waitNextBlock(processing.lastBlockId, address, timeout);

              case 21:
                block = _context37.sent;
                end = Date.now();
                timeReport.push("Block [".concat(block.id || '', "] ") + "has been received: ".concat(end - start, " ms, ") + "client time: ".concat(Math.round(end / 1000), ", ") + "gen_utime: ".concat(block.gen_utime || 0));
                _context37.next = 39;
                break;

              case 26:
                _context37.prev = 26;
                _context37.t0 = _context37["catch"](17);
                this.config.log('Block waiting failed: ', _context37.t0);

                if (infiniteWait) {
                  _context37.next = 38;
                  break;
                }

                resolvedError = _context37.t0;

                if (!(_context37.t0.code === _TONClientError.TONErrorCode.WAIT_FOR_TIMEOUT)) {
                  _context37.next = 37;
                  break;
                }

                _context37.t1 = _TONClientError.TONClientError;
                _context37.next = 35;
                return this.completeErrorData({
                  address: address,
                  message_id: messageId,
                  block_id: processing.lastBlockId,
                  timeout: timeout,
                  message_processing_state: processing,
                  expire: expire,
                  sending_time: processing.sendingTime
                });

              case 35:
                _context37.t2 = _context37.sent;
                resolvedError = _context37.t1.networkSilent.call(_context37.t1, _context37.t2);

              case 37:
                throw resolvedError;

              case 38:
                this.config.log('Retry waiting.');

              case 39:
                if (!block) {
                  _context37.next = 71;
                  break;
                }

                processing.lastBlockId = block.id || '';
                inMsg = (block.in_msg_descr || []).find(function (x) {
                  return x.msg_id === messageId;
                });

                if (!inMsg) {
                  _context37.next = 58;
                  break;
                }

                transactionId = inMsg.transaction_id;

                if (transactionId) {
                  _context37.next = 50;
                  break;
                }

                _context37.t3 = _TONClientError.TONClientError;
                _context37.next = 48;
                return this.completeErrorData({
                  address: address,
                  message_id: messageId
                });

              case 48:
                _context37.t4 = _context37.sent;
                throw _context37.t3.invalidBlockchain.call(_context37.t3, 'No field `transaction_id` in block', _context37.t4);

              case 50:
                trStart = Date.now();
                _context37.next = 53;
                return this.queries.transactions.waitFor({
                  filter: {
                    id: {
                      eq: transactionId
                    }
                  },
                  result: TRANSACTION_FIELDS_ORDINARY,
                  timeout: _TONQueriesModule.MAX_TIMEOUT
                });

              case 53:
                transaction = _context37.sent;
                traceMessage(this.config.tracer, messageId, 'transactionReceived', {
                  transactionId: transactionId
                });
                timeReport.push("Transaction [".concat(transactionId, "] has been received: ").concat(Date.now() - trStart, " ms"));
                _context37.next = 71;
                break;

              case 58:
                if (!((block.gen_utime || 0) > stopTime)) {
                  _context37.next = 71;
                  break;
                }

                if (!expire) {
                  _context37.next = 66;
                  break;
                }

                traceMessage(this.config.tracer, messageId, 'messageExpired', {});
                _context37.t5 = _TONClientError.TONClientError;
                _context37.next = 64;
                return this.completeErrorData({
                  address: address,
                  message_id: messageId,
                  sending_time: processing.sendingTime,
                  expire: stopTime,
                  block_time: block.gen_utime,
                  block_id: processing.lastBlockId
                });

              case 64:
                _context37.t6 = _context37.sent;
                throw _context37.t5.messageExpired.call(_context37.t5, _context37.t6);

              case 66:
                _context37.t7 = _TONClientError.TONClientError;
                _context37.next = 69;
                return this.completeErrorData({
                  address: address,
                  message_id: messageId,
                  sending_time: processing.sendingTime,
                  timeout: timeout,
                  message_processing_state: processing
                });

              case 69:
                _context37.t8 = _context37.sent;
                throw _context37.t7.transactionWaitTimeout.call(_context37.t7, _context37.t8);

              case 71:
                _context37.next = 13;
                break;

              case 73:
                timeReport.splice(0, 0, "Transaction waiting time: ".concat(Date.now() - totalStart, " ms"));
                this.config.log(timeReport.join('\n'));
                _context37.next = 87;
                break;

              case 77:
                _context37.prev = 77;
                _context37.t9 = _context37["catch"](8);
                this.config.log('[waitForTransaction]', 'FAILED', _context37.t9);

                if (!(_context37.t9.code === _TONClientError.TONErrorCode.MESSAGE_EXPIRED || _context37.t9.code === _TONClientError.TONErrorCode.TRANSACTION_WAIT_TIMEOUT)) {
                  _context37.next = 86;
                  break;
                }

                _context37.next = 83;
                return this.resolveDetailedError(_context37.t9, params.message.messageBodyBase64, processing.sendingTime, address);

              case 83:
                throw _context37.sent;

              case 86:
                throw _context37.t9;

              case 87:
                return _context37.abrupt("return", this.processTransaction(address, transaction, params.abi, params.functionName));

              case 88:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this, [[8, 77], [17, 26]]);
      }));

      function waitForTransaction(_x59) {
        return _waitForTransaction.apply(this, arguments);
      }

      return waitForTransaction;
    }()
  }, {
    key: "processTransaction",
    value: function () {
      var _processTransaction = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee38(address, transaction, abi, functionName) {
        var result, accounts;
        return _regenerator["default"].wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.prev = 0;
                _context38.next = 3;
                return this.requestCore('contracts.process.transaction', {
                  transaction: transaction,
                  abi: abi,
                  functionName: functionName,
                  address: address
                });

              case 3:
                result = _context38.sent;
                return _context38.abrupt("return", _objectSpread({
                  transaction: transaction
                }, result));

              case 7:
                _context38.prev = 7;
                _context38.t0 = _context38["catch"](0);
                _context38.next = 11;
                return this.queries.accounts.query({
                  filter: {
                    id: {
                      eq: address
                    }
                  },
                  result: 'acc_type balance',
                  timeout: 1000
                });

              case 11:
                accounts = _context38.sent;

                if (!(accounts.length === 0)) {
                  _context38.next = 19;
                  break;
                }

                _context38.t1 = _TONClientError.TONClientError;
                _context38.t2 = address;
                _context38.next = 17;
                return this.completeErrorData({
                  original_error: _context38.t0,
                  address: address,
                  function_name: functionName
                });

              case 17:
                _context38.t3 = _context38.sent;
                throw _context38.t1.accountMissing.call(_context38.t1, _context38.t2, _context38.t3);

              case 19:
                throw _context38.t0;

              case 20:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this, [[0, 7]]);
      }));

      function processTransaction(_x60, _x61, _x62, _x63) {
        return _processTransaction.apply(this, arguments);
      }

      return processTransaction;
    }()
  }, {
    key: "resolveDetailedError",
    value: function () {
      var _resolveDetailedError = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee39(error, messageBase64, time, address) {
        var accounts, account;
        return _regenerator["default"].wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                _context39.next = 2;
                return this.queries.accounts.query({
                  filter: {
                    id: {
                      eq: address
                    }
                  },
                  result: 'id acc_type balance balance_other { currency value } boc code_hash data_hash last_paid',
                  timeout: 1000
                });

              case 2:
                accounts = _context39.sent;

                if (!(accounts.length === 0)) {
                  _context39.next = 10;
                  break;
                }

                _context39.t0 = _TONClientError.TONClientError;
                _context39.t1 = address;
                _context39.next = 8;
                return this.completeErrorData({
                  address: address,
                  original_error: error
                });

              case 8:
                _context39.t2 = _context39.sent;
                return _context39.abrupt("return", _context39.t0.accountMissing.call(_context39.t0, _context39.t1, _context39.t2));

              case 10:
                account = accounts[0];
                removeTypeName(account);
                _context39.prev = 12;
                _context39.next = 15;
                return this.requestCore('contracts.resolve.error', {
                  address: address,
                  account: account,
                  messageBase64: messageBase64,
                  time: time,
                  mainError: error
                });

              case 15:
                _context39.next = 20;
                break;

              case 17:
                _context39.prev = 17;
                _context39.t3 = _context39["catch"](12);
                return _context39.abrupt("return", _context39.t3);

              case 20:
                return _context39.abrupt("return", error);

              case 21:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this, [[12, 17]]);
      }));

      function resolveDetailedError(_x64, _x65, _x66, _x67) {
        return _resolveDetailedError.apply(this, arguments);
      }

      return resolveDetailedError;
    }()
  }, {
    key: "isDeployed",
    value: function () {
      var _isDeployed = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee40(address, parentSpan) {
        var account;
        return _regenerator["default"].wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.queries.accounts.query({
                  filter: {
                    id: {
                      eq: address
                    },
                    acc_type: {
                      eq: QAccountType.active
                    }
                  },
                  result: 'id',
                  parentSpan: parentSpan
                });

              case 2:
                account = _context40.sent;
                return _context40.abrupt("return", account.length > 0);

              case 4:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function isDeployed(_x68, _x69) {
        return _isDeployed.apply(this, arguments);
      }

      return isDeployed;
    }()
  }, {
    key: "processDeployMessage",
    value: function () {
      var _processDeployMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee41(message, parentSpan, retryIndex) {
        var processing;
        return _regenerator["default"].wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                this.config.log('processDeployMessage', message);
                _context41.next = 3;
                return this.isDeployed(message.address, parentSpan);

              case 3:
                if (!_context41.sent) {
                  _context41.next = 5;
                  break;
                }

                return _context41.abrupt("return", {
                  address: message.address,
                  alreadyDeployed: true
                });

              case 5:
                _context41.next = 7;
                return this.sendMessage(message.message, parentSpan);

              case 7:
                processing = _context41.sent;
                return _context41.abrupt("return", this.waitForDeployTransaction(message, processing, parentSpan));

              case 9:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function processDeployMessage(_x70, _x71, _x72) {
        return _processDeployMessage.apply(this, arguments);
      }

      return processDeployMessage;
    }()
  }, {
    key: "waitForDeployTransaction",
    value: function () {
      var _waitForDeployTransaction = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee42(deployMessage, messageProcessingState, parentSpan, infiniteWait) {
        var message, result;
        return _regenerator["default"].wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                message = deployMessage.message;
                _context42.next = 3;
                return this.waitForTransaction({
                  message: message,
                  messageProcessingState: messageProcessingState,
                  parentSpan: parentSpan,
                  infiniteWait: infiniteWait
                });

              case 3:
                result = _context42.sent;
                return _context42.abrupt("return", _objectSpread(_objectSpread({}, result), {}, {
                  address: message.address,
                  alreadyDeployed: false
                }));

              case 5:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function waitForDeployTransaction(_x73, _x74, _x75, _x76) {
        return _waitForDeployTransaction.apply(this, arguments);
      }

      return waitForDeployTransaction;
    }()
  }, {
    key: "processRunMessage",
    value: function () {
      var _processRunMessage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee43(runMessage, parentSpan) {
        var processing;
        return _regenerator["default"].wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                this.config.log('processRunMessage', runMessage);
                _context43.next = 3;
                return this.sendMessage(runMessage.message, parentSpan);

              case 3:
                processing = _context43.sent;
                return _context43.abrupt("return", this.waitForRunTransaction(runMessage, processing, parentSpan));

              case 5:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));

      function processRunMessage(_x77, _x78) {
        return _processRunMessage.apply(this, arguments);
      }

      return processRunMessage;
    }()
  }, {
    key: "waitForRunTransaction",
    value: function () {
      var _waitForRunTransaction = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee44(runMessage, messageProcessingState, parentSpan, infiniteWait) {
        return _regenerator["default"].wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                return _context44.abrupt("return", this.waitForTransaction({
                  message: runMessage.message,
                  messageProcessingState: messageProcessingState,
                  parentSpan: parentSpan,
                  infiniteWait: infiniteWait,
                  abi: runMessage.abi,
                  functionName: runMessage.functionName
                }));

              case 1:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));

      function waitForRunTransaction(_x79, _x80, _x81, _x82) {
        return _waitForRunTransaction.apply(this, arguments);
      }

      return waitForRunTransaction;
    }()
    /**
     * Deprecated. Use `runMessageLocal` instead.
     * @param params
     * @param waitParams
     * @param parentSpan
     * @returns {Promise<unknown>}
     */

  }, {
    key: "processRunMessageLocal",
    value: function () {
      var _processRunMessageLocal = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee45(params, waitParams, parentSpan) {
        var account;
        return _regenerator["default"].wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                this.config.log('processRunMessageLocal', params);
                _context45.next = 3;
                return this.getAccount(params.address, true, waitParams, parentSpan);

              case 3:
                account = _context45.sent;
                return _context45.abrupt("return", this.requestCore('contracts.run.local.msg', {
                  address: params.address,
                  account: account,
                  abi: params.abi,
                  functionName: params.functionName,
                  messageBase64: params.message.messageBodyBase64
                }));

              case 5:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));

      function processRunMessageLocal(_x83, _x84, _x85) {
        return _processRunMessageLocal.apply(this, arguments);
      }

      return processRunMessageLocal;
    }() // Fee calculation

  }, {
    key: "calcRunFees",
    value: function () {
      var _calcRunFees = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee46(params, parentSpan) {
        var account;
        return _regenerator["default"].wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                this.config.log('calcRunFees', params);
                _context46.next = 3;
                return this.getAccount(params.address, true, params.waitParams, parentSpan);

              case 3:
                account = _context46.sent;

                if (params.emulateBalance) {
                  account.balance = this.bigBalance;
                }

                return _context46.abrupt("return", this.requestCore('contracts.run.fee', {
                  address: params.address,
                  account: account,
                  abi: params.abi,
                  functionName: params.functionName,
                  input: params.input,
                  keyPair: params.keyPair
                }));

              case 6:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));

      function calcRunFees(_x86, _x87) {
        return _calcRunFees.apply(this, arguments);
      }

      return calcRunFees;
    }()
  }, {
    key: "calcDeployFees",
    value: function () {
      var _calcDeployFees = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee47(params, parentSpan) {
        var message;
        return _regenerator["default"].wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                this.config.log('calcDeployFees', params);
                _context47.next = 3;
                return this.createDeployMessage(params);

              case 3:
                message = _context47.sent;
                return _context47.abrupt("return", this.calcMsgProcessFees({
                  address: message.address,
                  message: message.message,
                  emulateBalance: params.emulateBalance,
                  newAccount: params.newAccount
                }, parentSpan));

              case 5:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));

      function calcDeployFees(_x88, _x89) {
        return _calcDeployFees.apply(this, arguments);
      }

      return calcDeployFees;
    }()
  }, {
    key: "calcMsgProcessFees",
    value: function () {
      var _calcMsgProcessFees = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee48(params, parentSpan) {
        var account;
        return _regenerator["default"].wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                this.config.log('calcMsgProcessFees', params);
                account = {
                  balance: this.bigBalance,
                  id: params.address,
                  last_paid: Math.floor(Date.now() / 1000)
                };

                if (params.newAccount) {
                  _context48.next = 6;
                  break;
                }

                _context48.next = 5;
                return this.getAccount(params.address, false, params.waitParams, parentSpan);

              case 5:
                account = _context48.sent;

              case 6:
                if (params.emulateBalance) {
                  account.balance = this.bigBalance;
                }

                return _context48.abrupt("return", this.requestCore('contracts.run.fee.msg', {
                  address: params.address,
                  account: account,
                  messageBase64: params.message.messageBodyBase64
                }));

              case 8:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));

      function calcMsgProcessFees(_x90, _x91) {
        return _calcMsgProcessFees.apply(this, arguments);
      }

      return calcMsgProcessFees;
    }() // Address processing

  }, {
    key: "convertAddress",
    value: function () {
      var _convertAddress = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee49(params) {
        return _regenerator["default"].wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                return _context49.abrupt("return", this.requestCore('contracts.address.convert', params));

              case 1:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));

      function convertAddress(_x92) {
        return _convertAddress.apply(this, arguments);
      }

      return convertAddress;
    }() // Internals

  }, {
    key: "internalDeployNative",
    value: function () {
      var _internalDeployNative = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee50(params) {
        return _regenerator["default"].wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                return _context50.abrupt("return", this.requestCore('contracts.deploy', {
                  abi: params["package"].abi,
                  constructorHeader: params.constructorHeader,
                  constructorParams: params.constructorParams,
                  initParams: params.initParams,
                  imageBase64: params["package"].imageBase64,
                  keyPair: params.keyPair
                }));

              case 1:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));

      function internalDeployNative(_x93) {
        return _internalDeployNative.apply(this, arguments);
      }

      return internalDeployNative;
    }()
  }, {
    key: "internalRunNative",
    value: function () {
      var _internalRunNative = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee51(params) {
        return _regenerator["default"].wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                return _context51.abrupt("return", this.requestCore('contracts.run', {
                  address: params.address,
                  abi: params.abi,
                  functionName: params.functionName,
                  header: params.header,
                  input: params.input,
                  keyPair: params.keyPair
                }));

              case 1:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));

      function internalRunNative(_x94) {
        return _internalRunNative.apply(this, arguments);
      }

      return internalRunNative;
    }()
  }, {
    key: "retryCall",
    value: function () {
      var _retryCall = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee52(call) {
        var retriesCount, i, isOriginalOrResolved, useRetry;
        return _regenerator["default"].wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                retriesCount = this.config.messageRetriesCount();
                i = 0;

              case 2:
                if (!(i <= retriesCount)) {
                  _context52.next = 19;
                  break;
                }

                if (i > 0) {
                  this.config.log("Retry #".concat(i));
                }

                _context52.prev = 4;
                _context52.next = 7;
                return call(i);

              case 7:
                return _context52.abrupt("return", _context52.sent);

              case 10:
                _context52.prev = 10;
                _context52.t0 = _context52["catch"](4);

                // retry if message expired or if resolving returned that message expired/replay
                // protection error or if transaction with message expired/replay protection error
                // returned
                isOriginalOrResolved = function isOriginalOrResolved(exitCode) {
                  return _TONClientError.TONClientError.isOriginalContractError(_context52.t0, exitCode) || _TONClientError.TONClientError.isResolvedContractErrorAfterExpire(_context52.t0, exitCode);
                };

                useRetry = _context52.t0.code === _TONClientError.TONErrorCode.MESSAGE_EXPIRED || isOriginalOrResolved(_TONClientError.TONContractExitCode.REPLAY_PROTECTION) || isOriginalOrResolved(_TONClientError.TONContractExitCode.MESSAGE_EXPIRED);

                if (!(!useRetry || i === retriesCount)) {
                  _context52.next = 16;
                  break;
                }

                throw _context52.t0;

              case 16:
                i += 1;
                _context52.next = 2;
                break;

              case 19:
                _context52.t1 = _TONClientError.TONClientError;
                _context52.next = 22;
                return this.completeErrorData();

              case 22:
                _context52.t2 = _context52.sent;
                throw _context52.t1.internalError.call(_context52.t1, 'All retry attempts failed', _context52.t2);

              case 24:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this, [[4, 10]]);
      }));

      function retryCall(_x95) {
        return _retryCall.apply(this, arguments);
      }

      return retryCall;
    }()
  }, {
    key: "internalDeployJs",
    value: function () {
      var _internalDeployJs = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee54(params, parentSpan) {
        var _this7 = this;

        return _regenerator["default"].wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                this.config.log('Deploy start');
                return _context54.abrupt("return", this.retryCall( /*#__PURE__*/function () {
                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee53(retryIndex) {
                    var deployMessage, processing;
                    return _regenerator["default"].wrap(function _callee53$(_context53) {
                      while (1) {
                        switch (_context53.prev = _context53.next) {
                          case 0:
                            _context53.next = 2;
                            return _this7.createDeployMessage(params, retryIndex);

                          case 2:
                            deployMessage = _context53.sent;
                            _context53.next = 5;
                            return _this7.isDeployed(deployMessage.address, parentSpan);

                          case 5:
                            if (!_context53.sent) {
                              _context53.next = 7;
                              break;
                            }

                            return _context53.abrupt("return", {
                              address: deployMessage.address,
                              alreadyDeployed: true
                            });

                          case 7:
                            _context53.next = 9;
                            return _this7.sendMessage(deployMessage.message, parentSpan);

                          case 9:
                            processing = _context53.sent;
                            return _context53.abrupt("return", _this7.waitForDeployTransaction(deployMessage, processing, parentSpan));

                          case 11:
                          case "end":
                            return _context53.stop();
                        }
                      }
                    }, _callee53);
                  }));

                  return function (_x98) {
                    return _ref6.apply(this, arguments);
                  };
                }()));

              case 2:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));

      function internalDeployJs(_x96, _x97) {
        return _internalDeployJs.apply(this, arguments);
      }

      return internalDeployJs;
    }()
  }, {
    key: "internalRunJs",
    value: function () {
      var _internalRunJs = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee56(params, parentSpan) {
        var _this8 = this;

        return _regenerator["default"].wrap(function _callee56$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                this.config.log('Run start');
                return _context56.abrupt("return", this.retryCall( /*#__PURE__*/function () {
                  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee55(retryIndex) {
                    var runMessage, processing;
                    return _regenerator["default"].wrap(function _callee55$(_context55) {
                      while (1) {
                        switch (_context55.prev = _context55.next) {
                          case 0:
                            _context55.next = 2;
                            return _this8.createRunMessage(params, retryIndex);

                          case 2:
                            runMessage = _context55.sent;
                            _context55.next = 5;
                            return _this8.sendMessage(runMessage.message, parentSpan);

                          case 5:
                            processing = _context55.sent;
                            return _context55.abrupt("return", _this8.waitForRunTransaction(runMessage, processing, parentSpan));

                          case 7:
                          case "end":
                            return _context55.stop();
                        }
                      }
                    }, _callee55);
                  }));

                  return function (_x101) {
                    return _ref7.apply(this, arguments);
                  };
                }()));

              case 2:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee56, this);
      }));

      function internalRunJs(_x99, _x100) {
        return _internalRunJs.apply(this, arguments);
      }

      return internalRunJs;
    }()
  }, {
    key: "getAccount",
    value: function () {
      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee57(address, active, waitParams, parentSpan) {
        var filter, accounts, account;
        return _regenerator["default"].wrap(function _callee57$(_context57) {
          while (1) {
            switch (_context57.prev = _context57.next) {
              case 0:
                filter = {
                  id: {
                    eq: address
                  }
                };

                if (waitParams && waitParams.transactionLt) {
                  filter.last_trans_lt = {
                    ge: waitParams.transactionLt
                  };
                }

                if (active) {
                  filter.acc_type = {
                    eq: QAccountType.active
                  };
                }

                this.config.log('getAccount. Filter', filter);
                _context57.next = 6;
                return this.queries.accounts.query(_objectSpread(_objectSpread({
                  filter: filter,
                  result: 'id acc_type boc code_hash data_hash balance balance_other { currency value } last_paid'
                }, waitParams && waitParams.timeout ? {
                  timeout: waitParams.timeout
                } : {}), {}, {
                  parentSpan: parentSpan
                }));

              case 6:
                accounts = _context57.sent;

                if (!(accounts.length === 0)) {
                  _context57.next = 14;
                  break;
                }

                _context57.t0 = _TONClientError.TONClientError;
                _context57.t1 = address;
                _context57.next = 12;
                return this.completeErrorData({
                  address: address
                });

              case 12:
                _context57.t2 = _context57.sent;
                throw _context57.t0.accountMissing.call(_context57.t0, _context57.t1, _context57.t2);

              case 14:
                account = accounts[0];
                removeTypeName(account);
                this.config.log('getAccount. Account received', account);
                return _context57.abrupt("return", account);

              case 18:
              case "end":
                return _context57.stop();
            }
          }
        }, _callee57, this);
      }));

      function getAccount(_x102, _x103, _x104, _x105) {
        return _getAccount.apply(this, arguments);
      }

      return getAccount;
    }()
  }, {
    key: "internalRunLocalJs",
    value: function () {
      var _internalRunLocalJs = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee58(params, parentSpan) {
        var address, account;
        return _regenerator["default"].wrap(function _callee58$(_context58) {
          while (1) {
            switch (_context58.prev = _context58.next) {
              case 0:
                address = params.address;

                if (address) {
                  _context58.next = 7;
                  break;
                }

                _context58.t0 = _TONClientError.TONClientError;
                _context58.next = 5;
                return this.completeErrorData({
                  address: address,
                  function_name: params.functionName
                });

              case 5:
                _context58.t1 = _context58.sent;

                _context58.t0.addressRequiredForRunLocal.call(_context58.t0, _context58.t1);

              case 7:
                _context58.t2 = params.account;

                if (_context58.t2) {
                  _context58.next = 12;
                  break;
                }

                _context58.next = 11;
                return this.getAccount(address, false, params.waitParams, parentSpan);

              case 11:
                _context58.t2 = _context58.sent;

              case 12:
                account = _context58.t2;

                if (account.code_hash) {
                  _context58.next = 21;
                  break;
                }

                _context58.t3 = _TONClientError.TONClientError;
                _context58.t4 = address;
                _context58.t5 = account.balance;
                _context58.next = 19;
                return this.completeErrorData({
                  address: address,
                  function_name: params.functionName
                });

              case 19:
                _context58.t6 = _context58.sent;
                throw _context58.t3.accountCodeMissing.call(_context58.t3, _context58.t4, _context58.t5, _context58.t6);

              case 21:
                return _context58.abrupt("return", this.requestCore('contracts.run.local', {
                  address: address,
                  account: account,
                  abi: params.abi,
                  functionName: params.functionName,
                  input: params.input,
                  keyPair: params.keyPair,
                  fullRun: params.fullRun
                }));

              case 22:
              case "end":
                return _context58.stop();
            }
          }
        }, _callee58, this);
      }));

      function internalRunLocalJs(_x106, _x107) {
        return _internalRunLocalJs.apply(this, arguments);
      }

      return internalRunLocalJs;
    }()
  }, {
    key: "internalRunMessageLocalJs",
    value: function () {
      var _internalRunMessageLocalJs = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee59(params, parentSpan) {
        var address, account;
        return _regenerator["default"].wrap(function _callee59$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                address = params.address;

                if (address) {
                  _context59.next = 7;
                  break;
                }

                _context59.t0 = _TONClientError.TONClientError;
                _context59.next = 5;
                return this.completeErrorData({
                  address: address,
                  function_name: params.functionName
                });

              case 5:
                _context59.t1 = _context59.sent;
                throw _context59.t0.addressRequiredForRunLocal.call(_context59.t0, _context59.t1);

              case 7:
                _context59.t2 = params.account;

                if (_context59.t2) {
                  _context59.next = 12;
                  break;
                }

                _context59.next = 11;
                return this.getAccount(address, false, params.waitParams, parentSpan);

              case 11:
                _context59.t2 = _context59.sent;

              case 12:
                account = _context59.t2;

                if (account.code_hash) {
                  _context59.next = 21;
                  break;
                }

                _context59.t3 = _TONClientError.TONClientError;
                _context59.t4 = address;
                _context59.t5 = account.balance;
                _context59.next = 19;
                return this.completeErrorData({
                  address: address,
                  function_name: params.functionName
                });

              case 19:
                _context59.t6 = _context59.sent;
                throw _context59.t3.accountCodeMissing.call(_context59.t3, _context59.t4, _context59.t5, _context59.t6);

              case 21:
                return _context59.abrupt("return", this.requestCore('contracts.run.local.msg', {
                  address: address,
                  account: account,
                  abi: params.abi,
                  functionName: params.functionName,
                  messageBase64: params.messageBodyBase64,
                  fullRun: params.fullRun
                }));

              case 22:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee59, this);
      }));

      function internalRunMessageLocalJs(_x108, _x109) {
        return _internalRunMessageLocalJs.apply(this, arguments);
      }

      return internalRunMessageLocalJs;
    }()
  }, {
    key: "internalSign",
    value: function () {
      var _internalSign = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee60(unsigned, source) {
        var message, box, keys, signKeys;
        return _regenerator["default"].wrap(function _callee60$(_context60) {
          while (1) {
            switch (_context60.prev = _context60.next) {
              case 0:
                message = {
                  base64: unsigned.bytesToSignBase64
                };
                box = source.box;

                if (!box) {
                  _context60.next = 10;
                  break;
                }

                _context60.next = 5;
                return box.sign(message, _TONCryptoModule.TONOutputEncoding.Base64);

              case 5:
                _context60.t0 = _context60.sent;
                _context60.next = 8;
                return box.getPublicKey();

              case 8:
                _context60.t1 = _context60.sent;
                return _context60.abrupt("return", {
                  signBytesBase64: _context60.t0,
                  publicKeyHex: _context60.t1
                });

              case 10:
                keys = source.keys;

                if (!keys) {
                  _context60.next = 20;
                  break;
                }

                _context60.next = 14;
                return this.crypto.naclSignKeypairFromSecretKey(keys.secret);

              case 14:
                signKeys = _context60.sent;
                _context60.next = 17;
                return this.crypto.naclSignDetached(message, signKeys.secret, _TONCryptoModule.TONOutputEncoding.Base64);

              case 17:
                _context60.t2 = _context60.sent;
                _context60.t3 = signKeys["public"];
                return _context60.abrupt("return", {
                  signBytesBase64: _context60.t2,
                  publicKeyHex: _context60.t3
                });

              case 20:
                throw _TONClientError.TONClientError.signingSourceIsNotSpecified();

              case 21:
              case "end":
                return _context60.stop();
            }
          }
        }, _callee60, this);
      }));

      function internalSign(_x110, _x111) {
        return _internalSign.apply(this, arguments);
      }

      return internalSign;
    }()
  }]);

  return TONContractsModule;
}(_TONModule2.TONModule);

exports.default = TONContractsModule;
TONContractsModule.moduleName = 'TONContractsModule';
var BLOCK_FIELDS = "\n    id\n    gen_utime\n    after_split\n    workchain_id\n    shard\n    in_msg_descr {\n        msg_id\n        transaction_id\n    }\n";
var TRANSACTION_FIELDS_ORDINARY = "\n    id\n    aborted\n    compute {\n        skipped_reason\n        exit_code\n        success\n        gas_fees\n    }\n    storage {\n       status_change\n       storage_fees_collected\n    }\n    action {\n        success\n        valid\n        no_funds\n        result_code\n        total_fwd_fees\n        total_action_fees\n    }\n    in_msg\n    now\n    out_msgs\n    out_messages {\n        id\n        body\n        msg_type\n        value\n    }\n    status\n    total_fees\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2R1bGVzL1RPTkNvbnRyYWN0c01vZHVsZS5qcyJdLCJuYW1lcyI6WyJUT05BZGRyZXNzU3RyaW5nVmFyaWFudCIsIkFjY291bnRJZCIsIkhleCIsIkJhc2U2NCIsIlRPTkNsaWVudFRyYW5zYWN0aW9uUGhhc2UiLCJzdG9yYWdlIiwiY29tcHV0ZVNraXBwZWQiLCJjb21wdXRlVm0iLCJhY3Rpb24iLCJ1bmtub3duIiwiVE9OQ2xpZW50Q29tcHV0ZVNraXBwZWRTdGF0dXMiLCJub1N0YXRlIiwiYmFkU3RhdGUiLCJub0dhcyIsIlRPTkNsaWVudFN0b3JhZ2VTdGF0dXMiLCJ1bmNoYW5nZWQiLCJmcm96ZW4iLCJkZWxldGVkIiwiUUluTXNnVHlwZSIsImV4dGVybmFsIiwiaWhyIiwiaW1tZWRpYXRlbHkiLCJ0cmFuc2l0IiwiZGlzY2FyZGVkRmluYWwiLCJkaXNjYXJkZWRUcmFuc2l0IiwiUU91dE1zZ1R5cGUiLCJvdXRNc2dOZXciLCJkZXF1ZXVlSW1tZWRpYXRlbHkiLCJkZXF1ZXVlIiwidHJhbnNpdFJlcXVpcmVkIiwibm9uZSIsIlFNZXNzYWdlVHlwZSIsImludGVybmFsIiwiZXh0SW4iLCJleHRPdXQiLCJRTWVzc2FnZVByb2Nlc3NpbmdTdGF0dXMiLCJxdWV1ZWQiLCJwcm9jZXNzaW5nIiwicHJlbGltaW5hcnkiLCJwcm9wb3NlZCIsImZpbmFsaXplZCIsInJlZnVzZWQiLCJ0cmFuc2l0aW5nIiwiUUJsb2NrUHJvY2Vzc2luZ1N0YXR1cyIsIlFTcGxpdFR5cGUiLCJzcGxpdCIsIm1lcmdlIiwiUUFjY291bnRUeXBlIiwidW5pbml0IiwiYWN0aXZlIiwiUVRyYW5zYWN0aW9uVHlwZSIsIm9yZGluYXJ5IiwidGljayIsInRvY2siLCJzcGxpdFByZXBhcmUiLCJzcGxpdEluc3RhbGwiLCJtZXJnZVByZXBhcmUiLCJtZXJnZUluc3RhbGwiLCJRVHJhbnNhY3Rpb25Qcm9jZXNzaW5nU3RhdHVzIiwiUUFjY291bnRTdGF0dXMiLCJub25FeGlzdCIsIlFBY2NvdW50U3RhdHVzQ2hhbmdlIiwiUUNvbXB1dGVUeXBlIiwic2tpcHBlZCIsInZtIiwiUVNraXBSZWFzb24iLCJRQm91bmNlVHlwZSIsIm5lZ0Z1bmRzIiwibm9GdW5kcyIsIm9rIiwiTUFTVEVSQ0hBSU5fSUQiLCJyZW1vdmVUeXBlTmFtZSIsIm9iaiIsIl9fdHlwZW5hbWUiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwidmFsdWUiLCJyZW1vdmVQcm9wcyIsInBhdGhzIiwicmVzdWx0IiwicGF0aCIsImRvdFBvcyIsImluZGV4T2YiLCJuYW1lIiwic3Vic3RyIiwiY2hpbGQiLCJyZWR1Y2VkQ2hpbGQiLCJzdGFydE1lc3NhZ2VUcmFjZVNwYW4iLCJ0cmFjZXIiLCJtZXNzYWdlSWQiLCJvcGVyYXRpb25OYW1lIiwidGFncyIsInRyYWNlSWQiLCJzcGFuSWQiLCJyb290Q29udGV4dCIsImV4dHJhY3QiLCJGT1JNQVRfVEVYVF9NQVAiLCJzdGFydFNwYW4iLCJjaGlsZE9mIiwidHJhY2VNZXNzYWdlIiwic3BhbiIsImZpbmlzaCIsImdldFNpZ25pbmdTb3VyY2UiLCJib3giLCJrZXlzIiwiZ2V0UHVibGljS2V5Iiwic2VjcmV0IiwiVE9OQ29udHJhY3RzTW9kdWxlIiwiY29uZmlnIiwiY29udGV4dCIsImdldE1vZHVsZSIsIlRPTkNvbmZpZ01vZHVsZSIsInF1ZXJpZXMiLCJUT05RdWVyaWVzTW9kdWxlIiwiY3J5cHRvIiwiVE9OQ3J5cHRvTW9kdWxlIiwicGFyYW1zIiwicGFyZW50U3BhbiIsImFjY291bnRzIiwicXVlcnkiLCJmaWx0ZXIiLCJpZCIsImVxIiwiYWRkcmVzcyIsImxlbmd0aCIsImJhbGFuY2VHcmFtcyIsImJhbGFuY2UiLCJ0cmFjZSIsInNldFRhZyIsImludGVybmFsRGVwbG95SnMiLCJpbnRlcm5hbFJ1bkpzIiwiaW50ZXJuYWxSdW5Mb2NhbEpzIiwiaW50ZXJuYWxSdW5NZXNzYWdlTG9jYWxKcyIsImNvcmVQYXJhbXMiLCJoYXNDb2RlIiwiYm9jQmFzZTY0IiwiY29kZUJhc2U2NCIsImRhdGFCYXNlNjQiLCJUT05DbGllbnRFcnJvciIsImNvbXBsZXRlRXJyb3JEYXRhIiwiYWRkcmVzc1JlcXVpcmVkRm9yUnVuTG9jYWwiLCJnZXRBY2NvdW50IiwidGltZW91dCIsIndhaXRGb3JUaW1lb3V0IiwiYWNjb3VudCIsImNvZGVfaGFzaCIsImFjY291bnRDb2RlTWlzc2luZyIsInBhcmFtc0Zyb21BY2NvdW50IiwiYm9jIiwibGFzdF9wYWlkIiwicmVxdWVzdENvcmUiLCJjb25zIiwiaXRlbSIsImludmFsaWRDb25zIiwiZW1wdHlUT05FcnJvckRhdGEiLCJwdXNoIiwicmV0cnlJbmRleCIsImxvZyIsInNpZ25pbmdCb3giLCJrZXlQYWlyIiwic291cmNlIiwiY3JlYXRlVW5zaWduZWREZXBsb3lNZXNzYWdlIiwidW5zaWduZWRNZXNzYWdlIiwiaW50ZXJuYWxTaWduIiwic2lnblBhcmFtcyIsImNyZWF0ZVNpZ25lZERlcGxveU1lc3NhZ2UiLCJhYmkiLCJjb25zdHJ1Y3RvckhlYWRlciIsImNvbnN0cnVjdG9yUGFyYW1zIiwiaW5pdFBhcmFtcyIsImltYWdlQmFzZTY0Iiwid29ya2NoYWluSWQiLCJtZXNzYWdlIiwiY3JlYXRlVW5zaWduZWRSdW5NZXNzYWdlIiwiY3JlYXRlU2lnbmVkUnVuTWVzc2FnZSIsImZ1bmN0aW9uTmFtZSIsImhlYWRlciIsInRyeUluZGV4IiwiaW5wdXQiLCJwdWJsaWNLZXlIZXgiLCJhZGRyZXNzSGV4IiwiZW5jb2RlZCIsImluY2x1ZGVzIiwicHVia2V5IiwiY3JlYXRlU2lnbmVkTWVzc2FnZSIsInVuc2lnbmVkQnl0ZXNCYXNlNjQiLCJzaWduQnl0ZXNCYXNlNjQiLCJleHBpcmUiLCJnZXRCb2NIYXNoIiwibWVzc2FnZUJvZHlCYXNlNjQiLCJoYXNoIiwiRGF0ZSIsIm5vdyIsIm1lc3NhZ2VfaWQiLCJzZW5kTm9kZVJlcXVlc3RGYWlsZWQiLCJNYXRoIiwic2VydmVyVGltZURlbHRhIiwiYWJzIiwib3V0T2ZTeW5jVGhyZXNob2xkIiwiZHJvcFNlcnZlclRpbWVEZWx0YSIsImNsb2NrT3V0T2ZTeW5jIiwiZmluZExhc3RTaGFyZEJsb2NrIiwibGFzdEJsb2NrSWQiLCJlbnN1cmVNZXNzYWdlSWQiLCJpZEJhc2U2NCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIm1lc3NhZ2VTcGFuIiwic3RhcnRSb290U3BhbiIsImFkZFRhZ3MiLCJtZXNzYWdlU2l6ZSIsImNlaWwiLCJwb3N0UmVxdWVzdHMiLCJib2R5Iiwic2VuZGluZ1RpbWUiLCJyb3VuZCIsInJlc3VsdEZpZWxkcyIsInNlbmRNZXNzYWdlIiwid2FpdEZvclRyYW5zYWN0aW9uIiwibWVzc2FnZVByb2Nlc3NpbmdTdGF0ZSIsInRyYW5zYWN0aW9uIiwiY2hhaW4iLCJhZGRpdGlvbmFsRmlsdGVyIiwiYmxvY2tzIiwid29ya2NoYWluX2lkIiwib3JkZXJCeSIsImRpcmVjdGlvbiIsImxpbWl0Iiwic2hhcmRzIiwiYWRkcmVzc1BhcnRzIiwid29ya2NoYWluIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJmaW5kTGFzdEJsb2NrIiwibWFzdGVyY2hhaW5MYXN0QmxvY2siLCJub0Jsb2NrcyIsIndvcmtjaGFpbkxhc3RCbG9jayIsImFmdGVyX21lcmdlIiwic2hhcmQiLCJpbnZhbGlkQmxvY2tjaGFpbiIsIm1hc3RlciIsInNoYXJkX2hhc2hlcyIsImZpbmRNYXRjaGluZ1NoYXJkIiwic2hhcmRCbG9jayIsInJvb3RfaGFzaCIsImRlc2NyIiwiYmxvY2siLCJjdXJyZW50Iiwid2FpdEZvciIsInByZXZfcmVmIiwiT1IiLCJwcmV2X2FsdF9yZWYiLCJCTE9DS19GSUVMRFMiLCJhZnRlcl9zcGxpdCIsImNoZWNrU2hhcmRNYXRjaCIsIm5lIiwidG90YWxTdGFydCIsInRpbWVSZXBvcnQiLCJzdG9wVGltZSIsIm1lc3NhZ2VQcm9jZXNzaW5nVGltZW91dCIsImluZmluaXRlV2FpdCIsImFkZFRpbWVvdXQiLCJtYXgiLCJzdGFydCIsIndhaXROZXh0QmxvY2siLCJlbmQiLCJnZW5fdXRpbWUiLCJyZXNvbHZlZEVycm9yIiwiY29kZSIsIlRPTkVycm9yQ29kZSIsIldBSVRfRk9SX1RJTUVPVVQiLCJibG9ja19pZCIsIm1lc3NhZ2VfcHJvY2Vzc2luZ19zdGF0ZSIsInNlbmRpbmdfdGltZSIsIm5ldHdvcmtTaWxlbnQiLCJpbk1zZyIsImluX21zZ19kZXNjciIsImZpbmQiLCJ4IiwibXNnX2lkIiwidHJhbnNhY3Rpb25JZCIsInRyYW5zYWN0aW9uX2lkIiwidHJTdGFydCIsInRyYW5zYWN0aW9ucyIsIlRSQU5TQUNUSU9OX0ZJRUxEU19PUkRJTkFSWSIsIk1BWF9USU1FT1VUIiwiYmxvY2tfdGltZSIsIm1lc3NhZ2VFeHBpcmVkIiwidHJhbnNhY3Rpb25XYWl0VGltZW91dCIsInNwbGljZSIsImpvaW4iLCJNRVNTQUdFX0VYUElSRUQiLCJUUkFOU0FDVElPTl9XQUlUX1RJTUVPVVQiLCJyZXNvbHZlRGV0YWlsZWRFcnJvciIsInByb2Nlc3NUcmFuc2FjdGlvbiIsIm9yaWdpbmFsX2Vycm9yIiwiZnVuY3Rpb25fbmFtZSIsImFjY291bnRNaXNzaW5nIiwiZXJyb3IiLCJtZXNzYWdlQmFzZTY0IiwidGltZSIsIm1haW5FcnJvciIsImFjY190eXBlIiwiaXNEZXBsb3llZCIsImFscmVhZHlEZXBsb3llZCIsIndhaXRGb3JEZXBsb3lUcmFuc2FjdGlvbiIsImRlcGxveU1lc3NhZ2UiLCJydW5NZXNzYWdlIiwid2FpdEZvclJ1blRyYW5zYWN0aW9uIiwid2FpdFBhcmFtcyIsImVtdWxhdGVCYWxhbmNlIiwiYmlnQmFsYW5jZSIsImNyZWF0ZURlcGxveU1lc3NhZ2UiLCJjYWxjTXNnUHJvY2Vzc0ZlZXMiLCJuZXdBY2NvdW50IiwiZmxvb3IiLCJjYWxsIiwicmV0cmllc0NvdW50IiwibWVzc2FnZVJldHJpZXNDb3VudCIsImkiLCJpc09yaWdpbmFsT3JSZXNvbHZlZCIsImV4aXRDb2RlIiwiaXNPcmlnaW5hbENvbnRyYWN0RXJyb3IiLCJpc1Jlc29sdmVkQ29udHJhY3RFcnJvckFmdGVyRXhwaXJlIiwidXNlUmV0cnkiLCJUT05Db250cmFjdEV4aXRDb2RlIiwiUkVQTEFZX1BST1RFQ1RJT04iLCJpbnRlcm5hbEVycm9yIiwicmV0cnlDYWxsIiwiY3JlYXRlUnVuTWVzc2FnZSIsInRyYW5zYWN0aW9uTHQiLCJsYXN0X3RyYW5zX2x0IiwiZ2UiLCJmdWxsUnVuIiwidW5zaWduZWQiLCJiYXNlNjQiLCJieXRlc1RvU2lnbkJhc2U2NCIsInNpZ24iLCJUT05PdXRwdXRFbmNvZGluZyIsIm5hY2xTaWduS2V5cGFpckZyb21TZWNyZXRLZXkiLCJzaWduS2V5cyIsIm5hY2xTaWduRGV0YWNoZWQiLCJzaWduaW5nU291cmNlSXNOb3RTcGVjaWZpZWQiLCJUT05Nb2R1bGUiLCJtb2R1bGVOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBS0E7O0FBeURBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRU8sSUFBTUEsdUJBQXVCLEdBQUc7QUFDbkNDLEVBQUFBLFNBQVMsRUFBRSxXQUR3QjtBQUVuQ0MsRUFBQUEsR0FBRyxFQUFFLEtBRjhCO0FBR25DQyxFQUFBQSxNQUFNLEVBQUU7QUFIMkIsQ0FBaEM7O0FBTUEsSUFBTUMseUJBQXlCLEdBQUc7QUFDckNDLEVBQUFBLE9BQU8sRUFBRSxTQUQ0QjtBQUVyQ0MsRUFBQUEsY0FBYyxFQUFFLGdCQUZxQjtBQUdyQ0MsRUFBQUEsU0FBUyxFQUFFLFdBSDBCO0FBSXJDQyxFQUFBQSxNQUFNLEVBQUUsUUFKNkI7QUFLckNDLEVBQUFBLE9BQU8sRUFBRTtBQUw0QixDQUFsQzs7QUFRQSxJQUFNQyw2QkFBNkIsR0FBRztBQUN6Q0MsRUFBQUEsT0FBTyxFQUFFLENBRGdDO0FBRXpDQyxFQUFBQSxRQUFRLEVBQUUsQ0FGK0I7QUFHekNDLEVBQUFBLEtBQUssRUFBRTtBQUhrQyxDQUF0Qzs7QUFNQSxJQUFNQyxzQkFBc0IsR0FBRztBQUNsQ0MsRUFBQUEsU0FBUyxFQUFFLENBRHVCO0FBRWxDQyxF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QUFDRTtBQURMLGlCO0FBR1YxTyxnQkFBQUEsRyxHQUFNeUQsTUFBTSxDQUFDekQsRzs7cUJBQ2ZBLEc7Ozs7Ozt1QkFFMkJBLEdBQUcsQ0FBQzJPLElBQUosQ0FBU3RLLE9BQVQsRUFBa0J1SyxtQ0FBa0JqVixNQUFwQyxDOzs7Ozt1QkFDSHFHLEdBQUcsQ0FBQ0UsWUFBSixFOzs7OztBQURwQmlGLGtCQUFBQSxlO0FBQ0FQLGtCQUFBQSxZOzs7O0FBR0YzRSxnQkFBQUEsSSxHQUFPd0QsTUFBTSxDQUFDeEQsSTs7cUJBQ2hCQSxJOzs7Ozs7dUJBQ3VCLEtBQUtVLE1BQUwsQ0FBWWtPLDRCQUFaLENBQXlDNU8sSUFBSSxDQUFDRSxNQUE5QyxDOzs7QUFBakIyTyxnQkFBQUEsUTs7dUJBRXFCLEtBQUtuTyxNQUFMLENBQVlvTyxnQkFBWixDQUNuQjFLLE9BRG1CLEVBRW5CeUssUUFBUSxDQUFDM08sTUFGVSxFQUduQnlPLG1DQUFrQmpWLE1BSEMsQzs7OztnQ0FLVG1WLFFBQVEsVTs7QUFMdEIzSixrQkFBQUEsZTtBQUtBUCxrQkFBQUEsWTs7OztzQkFHRnpDLCtCQUFlNk0sMkJBQWYsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTlwQ2tDQyxxQjs7O0FBa3FDaEQ3TyxrQkFBa0IsQ0FBQzhPLFVBQW5CLEdBQWdDLG9CQUFoQztBQUVBLElBQU01RixZQUFZLCtJQUFsQjtBQVlBLElBQU1nQywyQkFBMkIsK2VBQWpDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE4LTIwMjAgVE9OIERFViBTT0xVVElPTlMgTFRELlxuICovXG4vLyBAZmxvd1xuXG5pbXBvcnQge1xuICAgIFRyYWNlciwgRk9STUFUX1RFWFRfTUFQLCBTcGFuLCBTcGFuQ29udGV4dCxcbn0gZnJvbSAnb3BlbnRyYWNpbmcnO1xuaW1wb3J0IHR5cGUge1xuICAgIFFBY2NvdW50LFxuICAgIFFCbG9jayxcbiAgICBRTWVzc2FnZSxcbiAgICBRVHJhbnNhY3Rpb24sXG4gICAgVE9OQ29udHJhY3RBQkksXG4gICAgVE9OQ29udHJhY3RBY2NvdW50V2FpdFBhcmFtcyxcbiAgICBUT05Db250cmFjdENvbnZlcnRBZGRyZXNzUGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0Q29udmVydEFkZHJlc3NSZXN1bHQsXG4gICAgVE9OQ29udHJhY3RDcmVhdGVSdW5Cb2R5UGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0Q3JlYXRlUnVuQm9keVJlc3VsdCxcbiAgICBUT05Db250cmFjdENyZWF0ZVNpZ25lZERlcGxveU1lc3NhZ2VQYXJhbXMsXG4gICAgVE9OQ29udHJhY3RDcmVhdGVTaWduZWRNZXNzYWdlUGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0Q3JlYXRlU2lnbmVkUnVuTWVzc2FnZVBhcmFtcyxcbiAgICBUT05Db250cmFjdERlY29kZU1lc3NhZ2VCb2R5UGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0RGVjb2RlTWVzc2FnZUJvZHlSZXN1bHQsXG4gICAgVE9OQ29udHJhY3REZWNvZGVSdW5PdXRwdXRQYXJhbXMsXG4gICAgVE9OQ29udHJhY3REZXBsb3lNZXNzYWdlLFxuICAgIFRPTkNvbnRyYWN0RGVwbG95UGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0RGVwbG95UmVzdWx0LFxuICAgIFRPTkNvbnRyYWN0Q2FsY0RlcGxveUZlZVBhcmFtcyxcbiAgICBUT05Db250cmFjdEJvYyxcbiAgICBUT05Db250cmFjdEdldEJvY0hhc2hSZXN1bHQsXG4gICAgVE9OQ29udHJhY3RHZXRDb2RlRnJvbUltYWdlUGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0R2V0Q29kZUZyb21JbWFnZVJlc3VsdCxcbiAgICBUT05Db250cmFjdEdldERlcGxveURhdGFQYXJhbXMsXG4gICAgVE9OQ29udHJhY3RHZXREZXBsb3lEYXRhUmVzdWx0LFxuICAgIFRPTkNvbnRyYWN0R2V0RnVuY3Rpb25JZFBhcmFtcyxcbiAgICBUT05Db250cmFjdEdldEZ1bmN0aW9uSWRSZXN1bHQsXG4gICAgVE9OQ29udHJhY3RMb2FkUGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0TG9hZFJlc3VsdCxcbiAgICBUT05Db250cmFjdENhbGNSdW5GZWVQYXJhbXMsXG4gICAgVE9OQ29udHJhY3RDYWxjRmVlUmVzdWx0LFxuICAgIFRPTkNvbnRyYWN0Q2FsY01zZ1Byb2Nlc3NpbmdGZWVzUGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0TWVzc2FnZSxcbiAgICBUT05Db250cmFjdFJ1bkxvY2FsUGFyYW1zLFxuICAgIFRPTkNvbnRyYWN0UnVuTWVzc2FnZSxcbiAgICBUT05Db250cmFjdFJ1blBhcmFtcyxcbiAgICBUT05Db250cmFjdFJ1blJlc3VsdCxcbiAgICBUT05Db250cmFjdHMsXG4gICAgVE9OQ29udHJhY3RVbnNpZ25lZERlcGxveU1lc3NhZ2UsXG4gICAgVE9OQ29udHJhY3RVbnNpZ25lZE1lc3NhZ2UsXG4gICAgVE9OQ29udHJhY3RVbnNpZ25lZFJ1bk1lc3NhZ2UsXG4gICAgVE9OQ29udHJhY3RSdW5HZXRQYXJhbXMsXG4gICAgVE9OQ29udHJhY3RSdW5HZXRSZXN1bHQsXG4gICAgVE9OQ29udHJhY3RSdW5NZXNzYWdlTG9jYWxQYXJhbXMsXG4gICAgVE9OQ29udHJhY3RSdW5Mb2NhbFJlc3VsdCxcbiAgICBUT05XYWl0Rm9yVHJhbnNhY3Rpb25QYXJhbXMsXG4gICAgUVNoYXJkSGFzaCxcbiAgICBUT05NZXNzYWdlUHJvY2Vzc2luZ1N0YXRlLFxuICAgIFRPTlNpZ25pbmdCb3gsXG4gICAgVE9OS2V5UGFpckRhdGEsXG59IGZyb20gJy4uLy4uL3R5cGVzJztcblxuaW1wb3J0IHsgZW1wdHlUT05FcnJvckRhdGEsIFRPTkNsaWVudEVycm9yLCBUT05Db250cmFjdEV4aXRDb2RlLCBUT05FcnJvckNvZGUgfSBmcm9tICcuLi9UT05DbGllbnRFcnJvcic7XG5pbXBvcnQgeyBUT05Nb2R1bGUgfSBmcm9tICcuLi9UT05Nb2R1bGUnO1xuaW1wb3J0IFRPTkNvbmZpZ01vZHVsZSBmcm9tICcuL1RPTkNvbmZpZ01vZHVsZSc7XG5pbXBvcnQgVE9OQ3J5cHRvTW9kdWxlLCB7IFRPTk91dHB1dEVuY29kaW5nIH0gZnJvbSAnLi9UT05DcnlwdG9Nb2R1bGUnO1xuaW1wb3J0IFRPTlF1ZXJpZXNNb2R1bGUsIHsgTUFYX1RJTUVPVVQgfSBmcm9tICcuL1RPTlF1ZXJpZXNNb2R1bGUnO1xuXG5leHBvcnQgY29uc3QgVE9OQWRkcmVzc1N0cmluZ1ZhcmlhbnQgPSB7XG4gICAgQWNjb3VudElkOiAnQWNjb3VudElkJyxcbiAgICBIZXg6ICdIZXgnLFxuICAgIEJhc2U2NDogJ0Jhc2U2NCcsXG59O1xuXG5leHBvcnQgY29uc3QgVE9OQ2xpZW50VHJhbnNhY3Rpb25QaGFzZSA9IHtcbiAgICBzdG9yYWdlOiAnc3RvcmFnZScsXG4gICAgY29tcHV0ZVNraXBwZWQ6ICdjb21wdXRlU2tpcHBlZCcsXG4gICAgY29tcHV0ZVZtOiAnY29tcHV0ZVZtJyxcbiAgICBhY3Rpb246ICdhY3Rpb24nLFxuICAgIHVua25vd246ICd1bmtub3duJyxcbn07XG5cbmV4cG9ydCBjb25zdCBUT05DbGllbnRDb21wdXRlU2tpcHBlZFN0YXR1cyA9IHtcbiAgICBub1N0YXRlOiAwLFxuICAgIGJhZFN0YXRlOiAxLFxuICAgIG5vR2FzOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IFRPTkNsaWVudFN0b3JhZ2VTdGF0dXMgPSB7XG4gICAgdW5jaGFuZ2VkOiAwLFxuICAgIGZyb3plbjogMSxcbiAgICBkZWxldGVkOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IFFJbk1zZ1R5cGUgPSB7XG4gICAgZXh0ZXJuYWw6IDAsXG4gICAgaWhyOiAxLFxuICAgIGltbWVkaWF0ZWx5OiAyLFxuICAgIGZpbmFsOiAzLFxuICAgIHRyYW5zaXQ6IDQsXG4gICAgZGlzY2FyZGVkRmluYWw6IDUsXG4gICAgZGlzY2FyZGVkVHJhbnNpdDogNixcbn07XG5cbmV4cG9ydCBjb25zdCBRT3V0TXNnVHlwZSA9IHtcbiAgICBleHRlcm5hbDogMCxcbiAgICBpbW1lZGlhdGVseTogMSxcbiAgICBvdXRNc2dOZXc6IDIsXG4gICAgdHJhbnNpdDogMyxcbiAgICBkZXF1ZXVlSW1tZWRpYXRlbHk6IDQsXG4gICAgZGVxdWV1ZTogNSxcbiAgICB0cmFuc2l0UmVxdWlyZWQ6IDYsXG4gICAgbm9uZTogLTEsXG59O1xuXG5leHBvcnQgY29uc3QgUU1lc3NhZ2VUeXBlID0ge1xuICAgIGludGVybmFsOiAwLFxuICAgIGV4dEluOiAxLFxuICAgIGV4dE91dDogMixcbn07XG5cbmV4cG9ydCBjb25zdCBRTWVzc2FnZVByb2Nlc3NpbmdTdGF0dXMgPSB7XG4gICAgdW5rbm93bjogMCxcbiAgICBxdWV1ZWQ6IDEsXG4gICAgcHJvY2Vzc2luZzogMixcbiAgICBwcmVsaW1pbmFyeTogMyxcbiAgICBwcm9wb3NlZDogNCxcbiAgICBmaW5hbGl6ZWQ6IDUsXG4gICAgcmVmdXNlZDogNixcbiAgICB0cmFuc2l0aW5nOiA3LFxufTtcblxuZXhwb3J0IGNvbnN0IFFCbG9ja1Byb2Nlc3NpbmdTdGF0dXMgPSB7XG4gICAgdW5rbm93bjogMCxcbiAgICBwcm9wb3NlZDogMSxcbiAgICBmaW5hbGl6ZWQ6IDIsXG4gICAgcmVmdXNlZDogMyxcbn07XG5cbmV4cG9ydCBjb25zdCBRU3BsaXRUeXBlID0ge1xuICAgIG5vbmU6IDAsXG4gICAgc3BsaXQ6IDIsXG4gICAgbWVyZ2U6IDMsXG59O1xuXG5leHBvcnQgY29uc3QgUUFjY291bnRUeXBlID0ge1xuICAgIHVuaW5pdDogMCxcbiAgICBhY3RpdmU6IDEsXG4gICAgZnJvemVuOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IFFUcmFuc2FjdGlvblR5cGUgPSB7XG4gICAgb3JkaW5hcnk6IDAsXG4gICAgc3RvcmFnZTogMSxcbiAgICB0aWNrOiAyLFxuICAgIHRvY2s6IDMsXG4gICAgc3BsaXRQcmVwYXJlOiA0LFxuICAgIHNwbGl0SW5zdGFsbDogNSxcbiAgICBtZXJnZVByZXBhcmU6IDYsXG4gICAgbWVyZ2VJbnN0YWxsOiA3LFxufTtcblxuZXhwb3J0IGNvbnN0IFFUcmFuc2FjdGlvblByb2Nlc3NpbmdTdGF0dXMgPSB7XG4gICAgdW5rbm93bjogMCxcbiAgICBwcmVsaW1pbmFyeTogMSxcbiAgICBwcm9wb3NlZDogMixcbiAgICBmaW5hbGl6ZWQ6IDMsXG4gICAgcmVmdXNlZDogNCxcbn07XG5cbmV4cG9ydCBjb25zdCBRQWNjb3VudFN0YXR1cyA9IHtcbiAgICB1bmluaXQ6IDAsXG4gICAgYWN0aXZlOiAxLFxuICAgIGZyb3plbjogMixcbiAgICBub25FeGlzdDogMyxcbn07XG5cbmV4cG9ydCBjb25zdCBRQWNjb3VudFN0YXR1c0NoYW5nZSA9IHtcbiAgICB1bmNoYW5nZWQ6IDAsXG4gICAgZnJvemVuOiAxLFxuICAgIGRlbGV0ZWQ6IDIsXG59O1xuXG5leHBvcnQgY29uc3QgUUNvbXB1dGVUeXBlID0ge1xuICAgIHNraXBwZWQ6IDAsXG4gICAgdm06IDEsXG59O1xuXG5leHBvcnQgY29uc3QgUVNraXBSZWFzb24gPSB7XG4gICAgbm9TdGF0ZTogMCxcbiAgICBiYWRTdGF0ZTogMSxcbiAgICBub0dhczogMixcbn07XG5cbmV4cG9ydCBjb25zdCBRQm91bmNlVHlwZSA9IHtcbiAgICBuZWdGdW5kczogMCxcbiAgICBub0Z1bmRzOiAxLFxuICAgIG9rOiAyLFxufTtcblxuY29uc3QgTUFTVEVSQ0hBSU5fSUQgPSAtMTtcblxuZnVuY3Rpb24gcmVtb3ZlVHlwZU5hbWUob2JqOiBhbnkpIHtcbiAgICBpZiAob2JqLl9fdHlwZW5hbWUpIHtcbiAgICAgICAgZGVsZXRlIG9iai5fX3R5cGVuYW1lO1xuICAgIH1cbiAgICBPYmplY3QudmFsdWVzKG9iailcbiAgICAgICAgLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVHlwZU5hbWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVByb3BzKG9iajoge30sIHBhdGhzOiBzdHJpbmdbXSk6IHt9IHtcbiAgICBsZXQgcmVzdWx0ID0gb2JqO1xuICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgZG90UG9zID0gcGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3RQb3MgPCAwKSB7XG4gICAgICAgICAgICBpZiAocGF0aCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCB9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcGF0aC5zdWJzdHIoMCwgZG90UG9zKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcmVzdWx0W25hbWVdO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkdWNlZENoaWxkID0gcmVtb3ZlUHJvcHMoY2hpbGQsIFtwYXRoLnN1YnN0cihkb3RQb3MgKyAxKV0pO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VkQ2hpbGQgIT09IGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuYW1lXTogcmVkdWNlZENoaWxkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TWVzc2FnZVRyYWNlU3BhbihcbiAgICB0cmFjZXI6IFRyYWNlcixcbiAgICBtZXNzYWdlSWQ6IHN0cmluZyxcbiAgICBvcGVyYXRpb25OYW1lOiBzdHJpbmcsXG4gICAgdGFnczogeyBbc3RyaW5nXTogYW55IH0sXG4pOiA/U3BhbiB7XG4gICAgaWYgKCFtZXNzYWdlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNlSWQgPSBtZXNzYWdlSWQuc3Vic3RyKDAsIDE2KTtcbiAgICBjb25zdCBzcGFuSWQgPSBtZXNzYWdlSWQuc3Vic3RyKDE2LCAxNik7XG4gICAgbGV0IHJvb3RDb250ZXh0OiA/U3BhbkNvbnRleHQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHJvb3RDb250ZXh0ID0gdHJhY2VyLmV4dHJhY3QoRk9STUFUX1RFWFRfTUFQLCB7XG4gICAgICAgICAgICAndWJlci10cmFjZS1pZCc6IGAke3RyYWNlSWR9OiR7c3BhbklkfTowOjFgLFxuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gdHJhY2VyIGNhbid0IGNyZWF0ZSBqYWVnZXIgY29tcGF0aWJsZSBzcGFuLFxuICAgICAgICAvLyBzbyB3ZSBhcmUgZmFsbGJhY2sgdG8gcmV0dXJuIG51bGxcbiAgICB9XG4gICAgaWYgKCFyb290Q29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRyYWNlci5zdGFydFNwYW4ob3BlcmF0aW9uTmFtZSwge1xuICAgICAgICBjaGlsZE9mOiByb290Q29udGV4dCxcbiAgICAgICAgdGFncyxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhY2VNZXNzYWdlKFxuICAgIHRyYWNlcjogVHJhY2VyLFxuICAgIG1lc3NhZ2VJZDogc3RyaW5nLFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICB0YWdzOiB7IFtzdHJpbmddOiBhbnkgfSxcbikge1xuICAgIGNvbnN0IHNwYW4gPSBzdGFydE1lc3NhZ2VUcmFjZVNwYW4odHJhY2VyLCBtZXNzYWdlSWQsIG9wZXJhdGlvbk5hbWUsIHRhZ3MpO1xuICAgIGlmIChzcGFuKSB7XG4gICAgICAgIHNwYW4uZmluaXNoKCk7XG4gICAgfVxufVxuXG50eXBlIFNpZ25SZXN1bHQgPSB7XG4gICAgc2lnbkJ5dGVzQmFzZTY0OiBzdHJpbmcsXG4gICAgcHVibGljS2V5SGV4OiBzdHJpbmcsXG59O1xuXG50eXBlIFNpZ25pbmdTb3VyY2UgPSB7XG4gICAgYm94OiA/VE9OU2lnbmluZ0JveCxcbiAgICBrZXlzOiBUT05LZXlQYWlyRGF0YSxcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2lnbmluZ1NvdXJjZShcbiAgICBib3g/OiBUT05TaWduaW5nQm94LFxuICAgIGtleXM/OiBUT05LZXlQYWlyRGF0YSxcbik6IFByb21pc2U8P1NpZ25pbmdTb3VyY2U+IHtcbiAgICBpZiAoYm94KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3gsXG4gICAgICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICAgICAgc2VjcmV0OiAnJyxcbiAgICAgICAgICAgICAgICBwdWJsaWM6IGF3YWl0IGJveC5nZXRQdWJsaWNLZXkoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChrZXlzICYmIGtleXMuc2VjcmV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3g6IG51bGwsXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUT05Db250cmFjdHNNb2R1bGUgZXh0ZW5kcyBUT05Nb2R1bGUgaW1wbGVtZW50cyBUT05Db250cmFjdHMge1xuICAgIGNvbmZpZzogVE9OQ29uZmlnTW9kdWxlO1xuICAgIGNyeXB0bzogVE9OQ3J5cHRvTW9kdWxlO1xuICAgIHF1ZXJpZXM6IFRPTlF1ZXJpZXNNb2R1bGU7XG5cbiAgICBhc3luYyBzZXR1cCgpOiBQcm9taXNlPCo+IHtcbiAgICAgICAgdGhpcy5jb25maWcgPSB0aGlzLmNvbnRleHQuZ2V0TW9kdWxlKFRPTkNvbmZpZ01vZHVsZSk7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IHRoaXMuY29udGV4dC5nZXRNb2R1bGUoVE9OUXVlcmllc01vZHVsZSk7XG4gICAgICAgIHRoaXMuY3J5cHRvID0gdGhpcy5jb250ZXh0LmdldE1vZHVsZShUT05DcnlwdG9Nb2R1bGUpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWQoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RMb2FkUGFyYW1zLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdExvYWRSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudHM6IFFBY2NvdW50W10gPSBhd2FpdCB0aGlzLnF1ZXJpZXMuYWNjb3VudHMucXVlcnkoe1xuICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHsgZXE6IHBhcmFtcy5hZGRyZXNzIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdWx0OiAnYmFsYW5jZScsXG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFjY291bnRzICYmIGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGJhbGFuY2VHcmFtczogYWNjb3VudHNbMF0uYmFsYW5jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgICAgYmFsYW5jZUdyYW1zOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gRmFjYWRlIGZ1bmN0aW9uc1xuXG4gICAgYXN5bmMgZGVwbG95KFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0RGVwbG95UGFyYW1zLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdERlcGxveVJlc3VsdD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnRyYWNlKCdjb250cmFjdHMuZGVwbG95JywgYXN5bmMgKHNwYW46IFNwYW4pID0+IHtcbiAgICAgICAgICAgIHNwYW4uc2V0VGFnKCdwYXJhbXMnLCByZW1vdmVQcm9wcyhwYXJhbXMsIFsna2V5UGFpci5zZWNyZXQnXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxEZXBsb3lKcyhwYXJhbXMsIHNwYW4pO1xuICAgICAgICB9LCBwYXJlbnRTcGFuKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIHJ1bihcbiAgICAgICAgcGFyYW1zOiBUT05Db250cmFjdFJ1blBhcmFtcyxcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5SZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC50cmFjZSgnY29udHJhY3RzLnJ1bicsIGFzeW5jIChzcGFuOiBTcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuLnNldFRhZygncGFyYW1zJywgcmVtb3ZlUHJvcHMocGFyYW1zLCBbJ2tleVBhaXIuc2VjcmV0J10pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUnVuSnMocGFyYW1zLCBzcGFuKTtcbiAgICAgICAgfSwgcGFyZW50U3Bhbik7XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuTG9jYWwoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RSdW5Mb2NhbFBhcmFtcyxcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5Mb2NhbFJlc3VsdD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnRyYWNlKCdjb250cmFjdHMucnVuTG9jYWwnLCBhc3luYyAoc3BhbjogU3BhbikgPT4ge1xuICAgICAgICAgICAgc3Bhbi5zZXRUYWcoJ3BhcmFtcycsIHJlbW92ZVByb3BzKHBhcmFtcywgWydrZXlQYWlyLnNlY3JldCddKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJ1bkxvY2FsSnMocGFyYW1zLCBzcGFuKTtcbiAgICAgICAgfSwgcGFyZW50U3Bhbik7XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuTWVzc2FnZUxvY2FsKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0UnVuTWVzc2FnZUxvY2FsUGFyYW1zLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdFJ1bkxvY2FsUmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudHJhY2UoJ3J1bk1lc3NhZ2VMb2NhbCcsIGFzeW5jIChzcGFuOiBTcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuLnNldFRhZygncGFyYW1zJywgcmVtb3ZlUHJvcHMocGFyYW1zLCBbJ2tleVBhaXIuc2VjcmV0J10pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUnVuTWVzc2FnZUxvY2FsSnMocGFyYW1zLCBzcGFuKTtcbiAgICAgICAgfSwgcGFyZW50U3Bhbik7XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuR2V0KFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0UnVuR2V0UGFyYW1zLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5HZXRSZXN1bHQ+IHtcbiAgICAgICAgbGV0IGNvcmVQYXJhbXM6IFRPTkNvbnRyYWN0UnVuR2V0UGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBoYXNDb2RlID0gcGFyYW1zLmJvY0Jhc2U2NCB8fCAocGFyYW1zLmNvZGVCYXNlNjQgJiYgcGFyYW1zLmRhdGFCYXNlNjQpO1xuICAgICAgICBpZiAoIWhhc0NvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcztcbiAgICAgICAgICAgIGlmICghYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLmFkZHJlc3NSZXF1aXJlZEZvclJ1bkxvY2FsKGF3YWl0IHRoaXMuY29tcGxldGVFcnJvckRhdGEoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50OiBhbnkgPSBhd2FpdCB0aGlzLmdldEFjY291bnQoYWRkcmVzcywgZmFsc2UsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZy53YWl0Rm9yVGltZW91dCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnQuY29kZV9oYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3IuYWNjb3VudENvZGVNaXNzaW5nKFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50LmJhbGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcGxldGVFcnJvckRhdGEoKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyYW1zRnJvbUFjY291bnQ6ICRTaGFwZTxUT05Db250cmFjdFJ1bkdldFBhcmFtcz4gPSB7fTtcbiAgICAgICAgICAgIGlmIChhY2NvdW50LmJvYykge1xuICAgICAgICAgICAgICAgIHBhcmFtc0Zyb21BY2NvdW50LmJvY0Jhc2U2NCA9IGFjY291bnQuYm9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY291bnQubGFzdF9wYWlkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zRnJvbUFjY291bnQubGFzdF9wYWlkID0gYWNjb3VudC5sYXN0X3BhaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWNjb3VudC5iYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zRnJvbUFjY291bnQuYmFsYW5jZSA9IGFjY291bnQuYmFsYW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcmVQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zRnJvbUFjY291bnQsXG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgndHZtLmdldCcsIGNvcmVQYXJhbXMpO1xuICAgIH1cblxuICAgIGFycmF5RnJvbUNPTlMoY29uczogYW55W10pOiBhbnlbXSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaXRlbSA9IGNvbnM7XG4gICAgICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3IuaW52YWxpZENvbnMoZW1wdHlUT05FcnJvckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbVswXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuXG4gICAgLy8gTWVzc2FnZSBjcmVhdGlvblxuXG4gICAgYXN5bmMgY3JlYXRlRGVwbG95TWVzc2FnZShcbiAgICAgICAgcGFyYW1zOiBUT05Db250cmFjdERlcGxveVBhcmFtcyxcbiAgICAgICAgcmV0cnlJbmRleD86IG51bWJlcixcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0RGVwbG95TWVzc2FnZT4ge1xuICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ2NyZWF0ZURlcGxveU1lc3NhZ2UnLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBhd2FpdCBnZXRTaWduaW5nU291cmNlKHBhcmFtcy5zaWduaW5nQm94LCBwYXJhbXMua2V5UGFpcik7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkTWVzc2FnZSA9IGF3YWl0IHRoaXMuY3JlYXRlVW5zaWduZWREZXBsb3lNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAga2V5UGFpcjogc291cmNlLmtleXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpZ25lZERlcGxveU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLihhd2FpdCB0aGlzLmludGVybmFsU2lnbih1bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcywgc291cmNlKSksXG4gICAgICAgICAgICAgICAgdW5zaWduZWRNZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZTogVE9OQ29udHJhY3RNZXNzYWdlID0gYXdhaXQgdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmRlcGxveS5tZXNzYWdlJywge1xuICAgICAgICAgICAgYWJpOiBwYXJhbXMucGFja2FnZS5hYmksXG4gICAgICAgICAgICBjb25zdHJ1Y3RvckhlYWRlcjogcGFyYW1zLmNvbnN0cnVjdG9ySGVhZGVyLFxuICAgICAgICAgICAgY29uc3RydWN0b3JQYXJhbXM6IHBhcmFtcy5jb25zdHJ1Y3RvclBhcmFtcyxcbiAgICAgICAgICAgIGluaXRQYXJhbXM6IHBhcmFtcy5pbml0UGFyYW1zLFxuICAgICAgICAgICAgaW1hZ2VCYXNlNjQ6IHBhcmFtcy5wYWNrYWdlLmltYWdlQmFzZTY0LFxuICAgICAgICAgICAga2V5UGFpcjogcGFyYW1zLmtleVBhaXIsXG4gICAgICAgICAgICB3b3JrY2hhaW5JZDogcGFyYW1zLndvcmtjaGFpbklkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IG1lc3NhZ2UuYWRkcmVzcyxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICBhc3luYyBjcmVhdGVSdW5NZXNzYWdlKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0UnVuUGFyYW1zLFxuICAgICAgICByZXRyeUluZGV4PzogbnVtYmVyLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5NZXNzYWdlPiB7XG4gICAgICAgIHRoaXMuY29uZmlnLmxvZygnY3JlYXRlUnVuTWVzc2FnZScsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGF3YWl0IGdldFNpZ25pbmdTb3VyY2UocGFyYW1zLnNpZ25pbmdCb3gsIHBhcmFtcy5rZXlQYWlyKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5jcmVhdGVVbnNpZ25lZFJ1bk1lc3NhZ2UocGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpZ25lZFJ1bk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLihhd2FpdCB0aGlzLmludGVybmFsU2lnbih1bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcywgc291cmNlKSksXG4gICAgICAgICAgICAgICAgdW5zaWduZWRNZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4ubWVzc2FnZScsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgYWJpOiBwYXJhbXMuYWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgaGVhZGVyOiBwYXJhbXMuaGVhZGVyLFxuICAgICAgICAgICAgdHJ5SW5kZXg6IHJldHJ5SW5kZXgsXG4gICAgICAgICAgICBpbnB1dDogcGFyYW1zLmlucHV0LFxuICAgICAgICAgICAga2V5UGFpcjogcGFyYW1zLmtleVBhaXIsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICBhYmk6IHBhcmFtcy5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZVVuc2lnbmVkRGVwbG95TWVzc2FnZShcbiAgICAgICAgcGFyYW1zOiBUT05Db250cmFjdERlcGxveVBhcmFtcyxcbiAgICAgICAgcmV0cnlJbmRleD86IG51bWJlcixcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0VW5zaWduZWREZXBsb3lNZXNzYWdlPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDoge1xuICAgICAgICAgICAgZW5jb2RlZDogVE9OQ29udHJhY3RVbnNpZ25lZE1lc3NhZ2UsXG4gICAgICAgICAgICBhZGRyZXNzSGV4OiBzdHJpbmcsXG4gICAgICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMuZGVwbG95LmVuY29kZV91bnNpZ25lZF9tZXNzYWdlJywge1xuICAgICAgICAgICAgYWJpOiBwYXJhbXMucGFja2FnZS5hYmksXG4gICAgICAgICAgICBjb25zdHJ1Y3RvckhlYWRlcjogcGFyYW1zLmNvbnN0cnVjdG9ySGVhZGVyLFxuICAgICAgICAgICAgdHJ5SW5kZXg6IHJldHJ5SW5kZXgsXG4gICAgICAgICAgICBjb25zdHJ1Y3RvclBhcmFtczogcGFyYW1zLmNvbnN0cnVjdG9yUGFyYW1zLFxuICAgICAgICAgICAgaW5pdFBhcmFtczogcGFyYW1zLmluaXRQYXJhbXMsXG4gICAgICAgICAgICBpbWFnZUJhc2U2NDogcGFyYW1zLnBhY2thZ2UuaW1hZ2VCYXNlNjQsXG4gICAgICAgICAgICBwdWJsaWNLZXlIZXg6IHBhcmFtcy5rZXlQYWlyLnB1YmxpYyxcbiAgICAgICAgICAgIHdvcmtjaGFpbklkOiBwYXJhbXMud29ya2NoYWluSWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogcmVzdWx0LmFkZHJlc3NIZXgsXG4gICAgICAgICAgICBzaWduUGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LmVuY29kZWQsXG4gICAgICAgICAgICAgICAgYWJpOiBwYXJhbXMucGFja2FnZS5hYmksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgYXN5bmMgY3JlYXRlVW5zaWduZWRSdW5NZXNzYWdlKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0UnVuUGFyYW1zLFxuICAgICAgICByZXRyeUluZGV4PzogbnVtYmVyLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RVbnNpZ25lZFJ1bk1lc3NhZ2U+IHtcbiAgICAgICAgbGV0IGhlYWRlciA9IHBhcmFtcy5oZWFkZXI7XG4gICAgICAgIGlmICgocGFyYW1zLmFiaS5oZWFkZXIgfHwgW10pLmluY2x1ZGVzKCdwdWJrZXknKSAmJiAhaGVhZGVyPy5wdWJrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSAoYXdhaXQgZ2V0U2lnbmluZ1NvdXJjZShwYXJhbXMuc2lnbmluZ0JveCwgcGFyYW1zLmtleVBhaXIpKT8ua2V5cztcbiAgICAgICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5oZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHB1YmtleToga2V5cy5wdWJsaWMsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25QYXJhbXMgPSBhd2FpdCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLmVuY29kZV91bnNpZ25lZF9tZXNzYWdlJywge1xuICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICBhYmk6IHBhcmFtcy5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICAgIHRyeUluZGV4OiByZXRyeUluZGV4LFxuICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcy5pbnB1dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIHNpZ25QYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAuLi5zaWduUGFyYW1zLFxuICAgICAgICAgICAgICAgIGFiaTogcGFyYW1zLmFiaSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICBhc3luYyBjcmVhdGVTaWduZWRNZXNzYWdlKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0Q3JlYXRlU2lnbmVkTWVzc2FnZVBhcmFtcyxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0TWVzc2FnZT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmVuY29kZV9tZXNzYWdlX3dpdGhfc2lnbicsIHBhcmFtcyk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBjcmVhdGVTaWduZWREZXBsb3lNZXNzYWdlKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0Q3JlYXRlU2lnbmVkRGVwbG95TWVzc2FnZVBhcmFtcyxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0RGVwbG95TWVzc2FnZT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5jcmVhdGVTaWduZWRNZXNzYWdlKHtcbiAgICAgICAgICAgIGFiaTogcGFyYW1zLnVuc2lnbmVkTWVzc2FnZS5zaWduUGFyYW1zLmFiaSxcbiAgICAgICAgICAgIHVuc2lnbmVkQnl0ZXNCYXNlNjQ6IHBhcmFtcy51bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcy51bnNpZ25lZEJ5dGVzQmFzZTY0LFxuICAgICAgICAgICAgc2lnbkJ5dGVzQmFzZTY0OiBwYXJhbXMuc2lnbkJ5dGVzQmFzZTY0LFxuICAgICAgICAgICAgcHVibGljS2V5SGV4OiBwYXJhbXMucHVibGljS2V5SGV4LFxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZS5leHBpcmUgPSBwYXJhbXMudW5zaWduZWRNZXNzYWdlLnNpZ25QYXJhbXMuZXhwaXJlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLnVuc2lnbmVkTWVzc2FnZS5hZGRyZXNzLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGNyZWF0ZVNpZ25lZFJ1bk1lc3NhZ2UoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RDcmVhdGVTaWduZWRSdW5NZXNzYWdlUGFyYW1zLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5NZXNzYWdlPiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLmNyZWF0ZVNpZ25lZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWJpOiBwYXJhbXMudW5zaWduZWRNZXNzYWdlLnNpZ25QYXJhbXMuYWJpLFxuICAgICAgICAgICAgdW5zaWduZWRCeXRlc0Jhc2U2NDogcGFyYW1zLnVuc2lnbmVkTWVzc2FnZS5zaWduUGFyYW1zLnVuc2lnbmVkQnl0ZXNCYXNlNjQsXG4gICAgICAgICAgICBzaWduQnl0ZXNCYXNlNjQ6IHBhcmFtcy5zaWduQnl0ZXNCYXNlNjQsXG4gICAgICAgICAgICBwdWJsaWNLZXlIZXg6IHBhcmFtcy5wdWJsaWNLZXlIZXgsXG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlLmV4cGlyZSA9IHBhcmFtcy51bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcy5leHBpcmU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMudW5zaWduZWRNZXNzYWdlLmFkZHJlc3MsXG4gICAgICAgICAgICBhYmk6IHBhcmFtcy51bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcy5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHBhcmFtcy51bnNpZ25lZE1lc3NhZ2UuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRDb2RlRnJvbUltYWdlKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0R2V0Q29kZUZyb21JbWFnZVBhcmFtcyxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0R2V0Q29kZUZyb21JbWFnZVJlc3VsdD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmltYWdlLmNvZGUnLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldERlcGxveURhdGEoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RHZXREZXBsb3lEYXRhUGFyYW1zLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RHZXREZXBsb3lEYXRhUmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMuZGVwbG95LmRhdGEnLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZVJ1bkJvZHkoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RDcmVhdGVSdW5Cb2R5UGFyYW1zLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RDcmVhdGVSdW5Cb2R5UmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLmJvZHknLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEZ1bmN0aW9uSWQoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RHZXRGdW5jdGlvbklkUGFyYW1zLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RHZXRGdW5jdGlvbklkUmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMuZnVuY3Rpb24uaWQnLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJvY0hhc2goXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RCb2MsXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdEdldEJvY0hhc2hSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ib2MuaGFzaCcsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgcGFyc2VNZXNzYWdlKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0Qm9jLFxuICAgICk6IFByb21pc2U8UU1lc3NhZ2U+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5wYXJzZS5tZXNzYWdlJywgcGFyYW1zKTtcbiAgICB9XG5cbiAgICAvLyBNZXNzYWdlIHBhcnNpbmdcblxuICAgIGFzeW5jIGRlY29kZVJ1bk91dHB1dChcbiAgICAgICAgcGFyYW1zOiBUT05Db250cmFjdERlY29kZVJ1bk91dHB1dFBhcmFtcyxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0UnVuUmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLm91dHB1dCcsIHBhcmFtcyk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBkZWNvZGVJbnB1dE1lc3NhZ2VCb2R5KFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0RGVjb2RlTWVzc2FnZUJvZHlQYXJhbXMsXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdERlY29kZU1lc3NhZ2VCb2R5UmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLnVua25vd24uaW5wdXQnLCBwYXJhbXMpO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZGVjb2RlT3V0cHV0TWVzc2FnZUJvZHkoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3REZWNvZGVNZXNzYWdlQm9keVBhcmFtcyxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0RGVjb2RlTWVzc2FnZUJvZHlSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4udW5rbm93bi5vdXRwdXQnLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIE1lc3NhZ2UgcHJvY2Vzc2luZ1xuXG4gICAgYXN5bmMgZW5zdXJlTWVzc2FnZUlkKG1lc3NhZ2U6IFRPTkNvbnRyYWN0TWVzc2FnZSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLm1lc3NhZ2VJZCB8fCBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSAoYXdhaXQgdGhpcy5nZXRCb2NIYXNoKHtcbiAgICAgICAgICAgICAgICBib2NCYXNlNjQ6IG1lc3NhZ2UubWVzc2FnZUJvZHlCYXNlNjQsXG4gICAgICAgICAgICB9KSkuaGFzaDtcbiAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZUlkID0gaWQ7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RNZXNzYWdlLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05NZXNzYWdlUHJvY2Vzc2luZ1N0YXRlPiB7XG4gICAgICAgIGNvbnN0IGV4cGlyZSA9IHBhcmFtcy5leHBpcmU7XG4gICAgICAgIGlmIChleHBpcmUgJiYgKERhdGUubm93KCkgPiBleHBpcmUgKiAxMDAwKSkge1xuICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3Iuc2VuZE5vZGVSZXF1ZXN0RmFpbGVkKFxuICAgICAgICAgICAgICAgICdNZXNzYWdlIGFscmVhZHkgZXhwaXJlZCcsXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBwYXJhbXMubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2ZXJUaW1lRGVsdGEgPSBNYXRoLmFicyhhd2FpdCB0aGlzLnF1ZXJpZXMuc2VydmVyVGltZURlbHRhKHBhcmVudFNwYW4pKTtcbiAgICAgICAgaWYgKHNlcnZlclRpbWVEZWx0YSA+IHRoaXMuY29uZmlnLm91dE9mU3luY1RocmVzaG9sZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJpZXMuZHJvcFNlcnZlclRpbWVEZWx0YSgpO1xuICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3IuY2xvY2tPdXRPZlN5bmMoYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0QmxvY2tJZCA9IGF3YWl0IHRoaXMuZmluZExhc3RTaGFyZEJsb2NrKHBhcmFtcy5hZGRyZXNzKTtcbiAgICAgICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLmVuc3VyZU1lc3NhZ2VJZChwYXJhbXMpO1xuICAgICAgICBjb25zdCBpZEJhc2U2NCA9IEJ1ZmZlci5mcm9tKGlkLCAnaGV4JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBjb25zdCBtZXNzYWdlU3BhbiA9IHRoaXMuY29udGV4dC5zdGFydFJvb3RTcGFuKFxuICAgICAgICAgICAgaWQuc3Vic3RyKDAsIDE2KSxcbiAgICAgICAgICAgIGlkLnN1YnN0cigxNiwgMTYpLFxuICAgICAgICAgICAgJ21lc3NhZ2VQcm9jZXNzaW5nJyxcbiAgICAgICAgKTtcbiAgICAgICAgbWVzc2FnZVNwYW4uYWRkVGFncyh7XG4gICAgICAgICAgICBtZXNzYWdlSWQ6IGlkLFxuICAgICAgICAgICAgbWVzc2FnZVNpemU6IE1hdGguY2VpbChwYXJhbXMubWVzc2FnZUJvZHlCYXNlNjQubGVuZ3RoICogMyAvIDQpLFxuICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICBleHBpcmU6IHBhcmFtcy5leHBpcmUsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnF1ZXJpZXMucG9zdFJlcXVlc3RzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogaWRCYXNlNjQsXG4gICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLm1lc3NhZ2VCb2R5QmFzZTY0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSwgcGFyZW50U3Bhbik7XG4gICAgICAgIG1lc3NhZ2VTcGFuLmZpbmlzaCgpO1xuICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ3NlbmRNZXNzYWdlLiBSZXF1ZXN0IHBvc3RlZCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhc3RCbG9ja0lkLFxuICAgICAgICAgICAgc2VuZGluZ1RpbWU6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHByb2Nlc3NNZXNzYWdlKFxuICAgICAgICBtZXNzYWdlOiBUT05Db250cmFjdE1lc3NhZ2UsXG4gICAgICAgIHJlc3VsdEZpZWxkczogc3RyaW5nLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgICAgIHJldHJ5SW5kZXg/OiBudW1iZXIsXG4gICAgICAgIGFkZHJlc3M/OiBzdHJpbmcsXG4gICAgICAgIGFiaT86IFRPTkNvbnRyYWN0QUJJLFxuICAgICAgICBmdW5jdGlvbk5hbWU/OiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxRVHJhbnNhY3Rpb24+IHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2luZyA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UobWVzc2FnZSwgcGFyZW50U3Bhbik7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBtZXNzYWdlUHJvY2Vzc2luZ1N0YXRlOiBwcm9jZXNzaW5nLFxuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgICAgIGFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZpbmRMYXN0QmxvY2soY2hhaW46IG51bWJlciwgcmVzdWx0OiBzdHJpbmcsIGFkZGl0aW9uYWxGaWx0ZXI/OiBhbnkpOiBQcm9taXNlPD9hbnk+IHtcbiAgICAgICAgY29uc3QgYmxvY2tzID0gYXdhaXQgdGhpcy5xdWVyaWVzLmJsb2Nrcy5xdWVyeSh7XG4gICAgICAgICAgICBmaWx0ZXI6IHsgd29ya2NoYWluX2lkOiB7IGVxOiBjaGFpbiB9LCAuLi4oYWRkaXRpb25hbEZpbHRlciB8fCB7fSkgfSxcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIG9yZGVyQnk6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICdzZXFfbm8nLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdERVNDJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPiAwID8gYmxvY2tzWzBdIDogbnVsbDtcbiAgICB9XG5cbiAgICBhc3luYyBmaW5kTWF0Y2hpbmdTaGFyZChzaGFyZHM6IFFTaGFyZEhhc2hbXSwgYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTw/UVNoYXJkSGFzaD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmZpbmQuc2hhcmQnLCB7XG4gICAgICAgICAgICBzaGFyZHMsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmaW5kTGFzdFNoYXJkQmxvY2soYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgYWRkcmVzc1BhcnRzID0gYWRkcmVzcy5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCB3b3JrY2hhaW4gPSBhZGRyZXNzUGFydHMubGVuZ3RoID4gMSA/IE51bWJlci5wYXJzZUludChhZGRyZXNzUGFydHNbMF0sIDEwKSA6IDA7XG5cblxuICAgICAgICAvLyBpZiBhY2NvdW50IHJlc2lkZXMgaW4gbWFzdGVyIGNoYWluIHRoZW4gc3RhcnRpbmcgcG9pbnQgaXMgbGFzdCBtYXN0ZXIgY2hhaW4gYmxvY2tcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGJlZm9yZSBtZXNzYWdlIHdhcyBzZW50XG4gICAgICAgIGNvbnN0IG1hc3RlcmNoYWluTGFzdEJsb2NrID0gYXdhaXQgdGhpcy5maW5kTGFzdEJsb2NrKFxuICAgICAgICAgICAgTUFTVEVSQ0hBSU5fSUQsXG4gICAgICAgICAgICAnaWQgbWFzdGVyIHsgc2hhcmRfaGFzaGVzIHsgd29ya2NoYWluX2lkIHNoYXJkIGRlc2NyIHsgcm9vdF9oYXNoIH0gfSB9JyxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBpZiBhY2NvdW50IHJlc2lkZXMgaW4gbWFzdGVyY2hhaW4gdGhlbiBzdGFydGluZyBwb2ludCBpcyBsYXN0IG1hc3RlcmNoYWluIGJsb2NrXG4gICAgICAgIGlmICh3b3JrY2hhaW4gPT09IE1BU1RFUkNIQUlOX0lEKSB7XG4gICAgICAgICAgICBpZiAoIW1hc3RlcmNoYWluTGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3Iubm9CbG9ja3MoTUFTVEVSQ0hBSU5fSUQsIGF3YWl0IHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXN0ZXJjaGFpbkxhc3RCbG9jay5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGFjY291bnQgaXMgZnJvbSBvdGhlciBjaGFpbnMgdGhlbiBzdGFydGluZyBwb2ludCBpcyBsYXN0IGFjY291bnQncyBzaGFyZCBibG9ja1xuICAgICAgICAvLyBUbyBvYnRhaW4gaXQgd2UgdGFrZSBtYXN0ZXJjaGFpbiBibG9jayB0byBnZXQgc2hhcmRzIGNvbmZpZ3VyYXRpb24gYW5kIHNlbGVjdFxuICAgICAgICAvLyBtYXRjaGluZyBzaGFyZFxuICAgICAgICBpZiAoIW1hc3RlcmNoYWluTGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAvLyBOb2RlIFNFIGNhc2UgLSBubyBtYXN0ZXJjaGFpbiwgbm8gc2hhcmRpbmcuIENoZWNrIHRoYXQgb25seSBvbmUgc2hhcmRcbiAgICAgICAgICAgIGxldCB3b3JrY2hhaW5MYXN0QmxvY2sgPSBhd2FpdCB0aGlzLmZpbmRMYXN0QmxvY2sod29ya2NoYWluLCAnYWZ0ZXJfbWVyZ2Ugc2hhcmQnKTtcbiAgICAgICAgICAgIGlmICghd29ya2NoYWluTGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3Iubm9CbG9ja3Mod29ya2NoYWluLCBhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdvcmtjaGFpbiBpcyBzaGFyZGVkIHRoZW4gaXQgaXMgbm90IE5vZGUgU0UgYW5kIG1hc3RlcmNoYWluIGJsb2NrcyBtaXNzaW5nXG4gICAgICAgICAgICAvLyBpcyBlcnJvclxuICAgICAgICAgICAgaWYgKHdvcmtjaGFpbkxhc3RCbG9jay5hZnRlcl9tZXJnZSB8fCB3b3JrY2hhaW5MYXN0QmxvY2suc2hhcmQgIT09ICc4MDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLm5vQmxvY2tzKE1BU1RFUkNIQUlOX0lELCBhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRha2UgbGFzdCBibG9jayBieSBzZXFfbm9cbiAgICAgICAgICAgIHdvcmtjaGFpbkxhc3RCbG9jayA9IGF3YWl0IHRoaXMuZmluZExhc3RCbG9jayh3b3JrY2hhaW4sICdpZCcsIHtcbiAgICAgICAgICAgICAgICBzaGFyZDogeyBlcTogJzgwMDAwMDAwMDAwMDAwMDAnIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghd29ya2NoYWluTGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3IuaW52YWxpZEJsb2NrY2hhaW4oXG4gICAgICAgICAgICAgICAgICAgICdObyBzdGFydGluZyBOb2RlIFNFIGJsb2NrIGZvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdvcmtjaGFpbkxhc3RCbG9jay5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNoYXJkczogP1FTaGFyZEhhc2hbXSA9IG1hc3RlcmNoYWluTGFzdEJsb2NrPy5tYXN0ZXI/LnNoYXJkX2hhc2hlcztcbiAgICAgICAgaWYgKCFzaGFyZHMgfHwgc2hhcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3IuaW52YWxpZEJsb2NrY2hhaW4oXG4gICAgICAgICAgICAgICAgJ05vIGBzaGFyZF9oYXNoZXNgIGZpZWxkIGluIG1hc3RlcmNoYWluIGJsb2NrJyxcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhcmRCbG9jayA9IGF3YWl0IHRoaXMuZmluZE1hdGNoaW5nU2hhcmQoc2hhcmRzLCBhZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgcm9vdF9oYXNoID0gc2hhcmRCbG9jaz8uZGVzY3I/LnJvb3RfaGFzaDtcbiAgICAgICAgaWYgKCFyb290X2hhc2gpIHtcbiAgICAgICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLmludmFsaWRCbG9ja2NoYWluKFxuICAgICAgICAgICAgICAgICdObyBgcm9vdF9oYXNoYCBmaWVsZCBpbiBzaGFyZCBkZXNjcicsXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290X2hhc2g7XG4gICAgfVxuXG4gICAgYXN5bmMgY2hlY2tTaGFyZE1hdGNoKGJsb2NrOiBRQmxvY2ssIGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gISEoYXdhaXQgdGhpcy5maW5kTWF0Y2hpbmdTaGFyZChbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd29ya2NoYWluX2lkOiBibG9jay53b3JrY2hhaW5faWQgfHwgMCxcbiAgICAgICAgICAgICAgICBzaGFyZDogYmxvY2suc2hhcmQgfHwgJycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLCBhZGRyZXNzKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdE5leHRCbG9jayhjdXJyZW50OiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZywgdGltZW91dD86IG51bWJlcik6IFByb21pc2U8UUJsb2NrPiB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5xdWVyaWVzLmJsb2Nrcy53YWl0Rm9yKHtcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgIHByZXZfcmVmOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RfaGFzaDogeyBlcTogY3VycmVudCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgT1I6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldl9hbHRfcmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290X2hhc2g6IHsgZXE6IGN1cnJlbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VsdDogQkxPQ0tfRklFTERTLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJsb2NrPy5hZnRlcl9zcGxpdCAmJiAhKGF3YWl0IHRoaXMuY2hlY2tTaGFyZE1hdGNoKGJsb2NrLCBhZGRyZXNzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJpZXMuYmxvY2tzLndhaXRGb3Ioe1xuICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICBpZDogeyBuZTogYmxvY2suaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJldl9yZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RfaGFzaDogeyBlcTogY3VycmVudCB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBCTE9DS19GSUVMRFMsXG4gICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24ocGFyYW1zOiBUT05XYWl0Rm9yVHJhbnNhY3Rpb25QYXJhbXMpOiBQcm9taXNlPFRPTkNvbnRyYWN0UnVuUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBleHBpcmUgPSBwYXJhbXMubWVzc2FnZS5leHBpcmUgfHwgMDtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gYXdhaXQgdGhpcy5lbnN1cmVNZXNzYWdlSWQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gcGFyYW1zLm1lc3NhZ2UuYWRkcmVzcztcbiAgICAgICAgY29uc3QgcHJvY2Vzc2luZyA9IHsgLi4ucGFyYW1zLm1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUgfTtcbiAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVSZXBvcnQgPSBbXTtcblxuICAgICAgICAgICAgY29uc3Qgc3RvcFRpbWUgPSBleHBpcmVcbiAgICAgICAgICAgICAgICB8fCBNYXRoLnJvdW5kKChEYXRlLm5vdygpICsgdGhpcy5jb25maWcubWVzc2FnZVByb2Nlc3NpbmdUaW1lb3V0KCkpIC8gMTAwMCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGluZmluaXRlV2FpdCA9IHBhcmFtcy5pbmZpbml0ZVdhaXQgIT09IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgYWRkVGltZW91dCA9IHRoaXMuY29uZmlnLm1lc3NhZ2VQcm9jZXNzaW5nVGltZW91dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCF0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IE1hdGgubWF4KHN0b3BUaW1lLCBub3cpIC0gbm93ICsgYWRkVGltZW91dDtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2s6ID9RQmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBhd2FpdCB0aGlzLndhaXROZXh0QmxvY2socHJvY2Vzc2luZy5sYXN0QmxvY2tJZCwgYWRkcmVzcywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVSZXBvcnQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGBCbG9jayBbJHtibG9jay5pZCB8fCAnJ31dIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYGhhcyBiZWVuIHJlY2VpdmVkOiAke2VuZCAtIHN0YXJ0fSBtcywgYFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgY2xpZW50IHRpbWU6ICR7TWF0aC5yb3VuZChlbmQgLyAxMDAwKX0sIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYGdlbl91dGltZTogJHtibG9jay5nZW5fdXRpbWUgfHwgMH1gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZygnQmxvY2sgd2FpdGluZyBmYWlsZWQ6ICcsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmZpbml0ZVdhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXNvbHZlZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gVE9ORXJyb3JDb2RlLldBSVRfRk9SX1RJTUVPVVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEVycm9yID0gVE9OQ2xpZW50RXJyb3IubmV0d29ya1NpbGVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfaWQ6IHByb2Nlc3NpbmcubGFzdEJsb2NrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9wcm9jZXNzaW5nX3N0YXRlOiBwcm9jZXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGluZ190aW1lOiBwcm9jZXNzaW5nLnNlbmRpbmdUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzb2x2ZWRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ1JldHJ5IHdhaXRpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcubGFzdEJsb2NrSWQgPSBibG9jay5pZCB8fCAnJztcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbk1zZyA9IChibG9jay5pbl9tc2dfZGVzY3IgfHwgW10pLmZpbmQoeCA9PiB4Lm1zZ19pZCA9PT0gbWVzc2FnZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gaW5Nc2cudHJhbnNhY3Rpb25faWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUT05DbGllbnRFcnJvci5pbnZhbGlkQmxvY2tjaGFpbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIGZpZWxkIGB0cmFuc2FjdGlvbl9pZGAgaW4gYmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0clN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5xdWVyaWVzLnRyYW5zYWN0aW9ucy53YWl0Rm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHsgaWQ6IHsgZXE6IHRyYW5zYWN0aW9uSWQgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogVFJBTlNBQ1RJT05fRklFTERTX09SRElOQVJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IE1BWF9USU1FT1VULFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZU1lc3NhZ2UodGhpcy5jb25maWcudHJhY2VyLCBtZXNzYWdlSWQsICd0cmFuc2FjdGlvblJlY2VpdmVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVSZXBvcnQucHVzaChgVHJhbnNhY3Rpb24gWyR7dHJhbnNhY3Rpb25JZH1dIGhhcyBiZWVuIHJlY2VpdmVkOiAke0RhdGUubm93KCkgLSB0clN0YXJ0fSBtc2ApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChibG9jay5nZW5fdXRpbWUgfHwgMCkgPiBzdG9wVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlTWVzc2FnZSh0aGlzLmNvbmZpZy50cmFjZXIsIG1lc3NhZ2VJZCwgJ21lc3NhZ2VFeHBpcmVkJywge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLm1lc3NhZ2VFeHBpcmVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kaW5nX3RpbWU6IHByb2Nlc3Npbmcuc2VuZGluZ1RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmU6IHN0b3BUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfdGltZTogYmxvY2suZ2VuX3V0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfaWQ6IHByb2Nlc3NpbmcubGFzdEJsb2NrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUT05DbGllbnRFcnJvci50cmFuc2FjdGlvbldhaXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRpbmdfdGltZTogcHJvY2Vzc2luZy5zZW5kaW5nVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9wcm9jZXNzaW5nX3N0YXRlOiBwcm9jZXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGltZVJlcG9ydC5zcGxpY2UoMCwgMCwgYFRyYW5zYWN0aW9uIHdhaXRpbmcgdGltZTogJHtEYXRlLm5vdygpIC0gdG90YWxTdGFydH0gbXNgKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZyh0aW1lUmVwb3J0LmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZygnW3dhaXRGb3JUcmFuc2FjdGlvbl0nLCAnRkFJTEVEJywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFRPTkVycm9yQ29kZS5NRVNTQUdFX0VYUElSRURcbiAgICAgICAgICAgICAgICB8fCBlcnJvci5jb2RlID09PSBUT05FcnJvckNvZGUuVFJBTlNBQ1RJT05fV0FJVF9USU1FT1VUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5yZXNvbHZlRGV0YWlsZWRFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5tZXNzYWdlLm1lc3NhZ2VCb2R5QmFzZTY0LFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLnNlbmRpbmdUaW1lLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1RyYW5zYWN0aW9uKFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgcGFyYW1zLmFiaSxcbiAgICAgICAgICAgIHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBwcm9jZXNzVHJhbnNhY3Rpb24oXG4gICAgICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgdHJhbnNhY3Rpb246IFFUcmFuc2FjdGlvbixcbiAgICAgICAgYWJpOiA/VE9OQ29udHJhY3RBQkksXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogP3N0cmluZyxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0UnVuUmVzdWx0PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucHJvY2Vzcy50cmFuc2FjdGlvbicsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBhYmksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5xdWVyaWVzLmFjY291bnRzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHsgaWQ6IHsgZXE6IGFkZHJlc3MgfSB9LFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJ2FjY190eXBlIGJhbGFuY2UnLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDEwMDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUT05DbGllbnRFcnJvci5hY2NvdW50TWlzc2luZyhcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbF9lcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyByZXNvbHZlRGV0YWlsZWRFcnJvcihcbiAgICAgICAgZXJyb3I6IEVycm9yLFxuICAgICAgICBtZXNzYWdlQmFzZTY0OiBzdHJpbmcsXG4gICAgICAgIHRpbWU6IG51bWJlcixcbiAgICAgICAgYWRkcmVzczogc3RyaW5nLFxuICAgICkge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMucXVlcmllcy5hY2NvdW50cy5xdWVyeSh7XG4gICAgICAgICAgICBmaWx0ZXI6IHsgaWQ6IHsgZXE6IGFkZHJlc3MgfSB9LFxuICAgICAgICAgICAgcmVzdWx0OiAnaWQgYWNjX3R5cGUgYmFsYW5jZSBiYWxhbmNlX290aGVyIHsgY3VycmVuY3kgdmFsdWUgfSBib2MgY29kZV9oYXNoIGRhdGFfaGFzaCBsYXN0X3BhaWQnLFxuICAgICAgICAgICAgdGltZW91dDogMTAwMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBUT05DbGllbnRFcnJvci5hY2NvdW50TWlzc2luZyhcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbF9lcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50c1swXTtcbiAgICAgICAgcmVtb3ZlVHlwZU5hbWUoYWNjb3VudCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucmVzb2x2ZS5lcnJvcicsIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZUJhc2U2NCxcbiAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgIG1haW5FcnJvcjogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgYXN5bmMgaXNEZXBsb3llZChhZGRyZXNzOiBzdHJpbmcsIHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSk6IFByb21pc2U8Ym9vbD4ge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5xdWVyaWVzLmFjY291bnRzLnF1ZXJ5KHtcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGlkOiB7IGVxOiBhZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgYWNjX3R5cGU6IHsgZXE6IFFBY2NvdW50VHlwZS5hY3RpdmUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHQ6ICdpZCcsXG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFjY291bnQubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBhc3luYyBwcm9jZXNzRGVwbG95TWVzc2FnZShcbiAgICAgICAgbWVzc2FnZTogVE9OQ29udHJhY3REZXBsb3lNZXNzYWdlLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgICAgIHJldHJ5SW5kZXg/OiBudW1iZXIsXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdERlcGxveVJlc3VsdD4ge1xuICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ3Byb2Nlc3NEZXBsb3lNZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzRGVwbG95ZWQobWVzc2FnZS5hZGRyZXNzLCBwYXJlbnRTcGFuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBtZXNzYWdlLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWxyZWFkeURlcGxveWVkOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9jZXNzaW5nID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShtZXNzYWdlLm1lc3NhZ2UsIHBhcmVudFNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy53YWl0Rm9yRGVwbG95VHJhbnNhY3Rpb24obWVzc2FnZSwgcHJvY2Vzc2luZywgcGFyZW50U3Bhbik7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvckRlcGxveVRyYW5zYWN0aW9uKFxuICAgICAgICBkZXBsb3lNZXNzYWdlOiBUT05Db250cmFjdERlcGxveU1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VQcm9jZXNzaW5nU3RhdGU6IFRPTk1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUsXG4gICAgICAgIHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSxcbiAgICAgICAgaW5maW5pdGVXYWl0PzogYm9vbGVhbixcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0RGVwbG95UmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXBsb3lNZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBtZXNzYWdlUHJvY2Vzc2luZ1N0YXRlLFxuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgICAgIGluZmluaXRlV2FpdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBhZGRyZXNzOiBtZXNzYWdlLmFkZHJlc3MsXG4gICAgICAgICAgICBhbHJlYWR5RGVwbG95ZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgYXN5bmMgcHJvY2Vzc1J1bk1lc3NhZ2UoXG4gICAgICAgIHJ1bk1lc3NhZ2U6IFRPTkNvbnRyYWN0UnVuTWVzc2FnZSxcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5SZXN1bHQ+IHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nKCdwcm9jZXNzUnVuTWVzc2FnZScsIHJ1bk1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBwcm9jZXNzaW5nID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShydW5NZXNzYWdlLm1lc3NhZ2UsIHBhcmVudFNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy53YWl0Rm9yUnVuVHJhbnNhY3Rpb24ocnVuTWVzc2FnZSwgcHJvY2Vzc2luZywgcGFyZW50U3Bhbik7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclJ1blRyYW5zYWN0aW9uKFxuICAgICAgICBydW5NZXNzYWdlOiBUT05Db250cmFjdFJ1bk1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VQcm9jZXNzaW5nU3RhdGU6IFRPTk1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUsXG4gICAgICAgIHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSxcbiAgICAgICAgaW5maW5pdGVXYWl0PzogYm9vbGVhbixcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0UnVuUmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICBtZXNzYWdlOiBydW5NZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgICBtZXNzYWdlUHJvY2Vzc2luZ1N0YXRlLFxuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgICAgIGluZmluaXRlV2FpdCxcbiAgICAgICAgICAgIGFiaTogcnVuTWVzc2FnZS5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHJ1bk1lc3NhZ2UuZnVuY3Rpb25OYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkLiBVc2UgYHJ1bk1lc3NhZ2VMb2NhbGAgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICogQHBhcmFtIHdhaXRQYXJhbXNcbiAgICAgKiBAcGFyYW0gcGFyZW50U3BhblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd24+fVxuICAgICAqL1xuICAgIGFzeW5jIHByb2Nlc3NSdW5NZXNzYWdlTG9jYWwoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RSdW5NZXNzYWdlLFxuICAgICAgICB3YWl0UGFyYW1zPzogVE9OQ29udHJhY3RBY2NvdW50V2FpdFBhcmFtcyxcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5SZXN1bHQ+IHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nKCdwcm9jZXNzUnVuTWVzc2FnZUxvY2FsJywgcGFyYW1zKTtcblxuICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50KHBhcmFtcy5hZGRyZXNzLCB0cnVlLCB3YWl0UGFyYW1zLCBwYXJlbnRTcGFuKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLnJ1bi5sb2NhbC5tc2cnLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICBhYmk6IHBhcmFtcy5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlQmFzZTY0OiBwYXJhbXMubWVzc2FnZS5tZXNzYWdlQm9keUJhc2U2NCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmVlIGNhbGN1bGF0aW9uXG5cbiAgICBiaWdCYWxhbmNlID0gJzB4MTAwMDAwMDAwMDAwMDAnO1xuXG4gICAgYXN5bmMgY2FsY1J1bkZlZXMoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RDYWxjUnVuRmVlUGFyYW1zLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdENhbGNGZWVSZXN1bHQ+IHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nKCdjYWxjUnVuRmVlcycsIHBhcmFtcyk7XG5cbiAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudChwYXJhbXMuYWRkcmVzcywgdHJ1ZSwgcGFyYW1zLndhaXRQYXJhbXMsIHBhcmVudFNwYW4pO1xuXG4gICAgICAgIGlmIChwYXJhbXMuZW11bGF0ZUJhbGFuY2UpIHtcbiAgICAgICAgICAgIGFjY291bnQuYmFsYW5jZSA9IHRoaXMuYmlnQmFsYW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLmZlZScsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgIGFiaTogcGFyYW1zLmFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICBrZXlQYWlyOiBwYXJhbXMua2V5UGFpcixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FsY0RlcGxveUZlZXMoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RDYWxjRGVwbG95RmVlUGFyYW1zLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdENhbGNGZWVSZXN1bHQ+IHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nKCdjYWxjRGVwbG95RmVlcycsIHBhcmFtcyk7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMuY3JlYXRlRGVwbG95TWVzc2FnZShwYXJhbXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGNNc2dQcm9jZXNzRmVlcyh7XG4gICAgICAgICAgICBhZGRyZXNzOiBtZXNzYWdlLmFkZHJlc3MsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgICBlbXVsYXRlQmFsYW5jZTogcGFyYW1zLmVtdWxhdGVCYWxhbmNlLFxuICAgICAgICAgICAgbmV3QWNjb3VudDogcGFyYW1zLm5ld0FjY291bnQsXG4gICAgICAgIH0sIHBhcmVudFNwYW4pO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbGNNc2dQcm9jZXNzRmVlcyhcbiAgICAgICAgcGFyYW1zOiBUT05Db250cmFjdENhbGNNc2dQcm9jZXNzaW5nRmVlc1BhcmFtcyxcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RDYWxjRmVlUmVzdWx0PiB7XG4gICAgICAgIHRoaXMuY29uZmlnLmxvZygnY2FsY01zZ1Byb2Nlc3NGZWVzJywgcGFyYW1zKTtcblxuICAgICAgICBsZXQgYWNjb3VudDogUUFjY291bnQgPSB7XG4gICAgICAgICAgICBiYWxhbmNlOiB0aGlzLmJpZ0JhbGFuY2UsXG4gICAgICAgICAgICBpZDogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICBsYXN0X3BhaWQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghcGFyYW1zLm5ld0FjY291bnQpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSBhd2FpdCB0aGlzLmdldEFjY291bnQocGFyYW1zLmFkZHJlc3MsIGZhbHNlLCBwYXJhbXMud2FpdFBhcmFtcywgcGFyZW50U3Bhbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmVtdWxhdGVCYWxhbmNlKSB7XG4gICAgICAgICAgICBhY2NvdW50LmJhbGFuY2UgPSB0aGlzLmJpZ0JhbGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLnJ1bi5mZWUubXNnJywge1xuICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgbWVzc2FnZUJhc2U2NDogcGFyYW1zLm1lc3NhZ2UubWVzc2FnZUJvZHlCYXNlNjQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZHJlc3MgcHJvY2Vzc2luZ1xuXG4gICAgYXN5bmMgY29udmVydEFkZHJlc3MoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RDb252ZXJ0QWRkcmVzc1BhcmFtcyxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0Q29udmVydEFkZHJlc3NSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5hZGRyZXNzLmNvbnZlcnQnLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgYXN5bmMgaW50ZXJuYWxEZXBsb3lOYXRpdmUocGFyYW1zOiBUT05Db250cmFjdERlcGxveVBhcmFtcyk6IFByb21pc2U8VE9OQ29udHJhY3REZXBsb3lSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5kZXBsb3knLCB7XG4gICAgICAgICAgICBhYmk6IHBhcmFtcy5wYWNrYWdlLmFiaSxcbiAgICAgICAgICAgIGNvbnN0cnVjdG9ySGVhZGVyOiBwYXJhbXMuY29uc3RydWN0b3JIZWFkZXIsXG4gICAgICAgICAgICBjb25zdHJ1Y3RvclBhcmFtczogcGFyYW1zLmNvbnN0cnVjdG9yUGFyYW1zLFxuICAgICAgICAgICAgaW5pdFBhcmFtczogcGFyYW1zLmluaXRQYXJhbXMsXG4gICAgICAgICAgICBpbWFnZUJhc2U2NDogcGFyYW1zLnBhY2thZ2UuaW1hZ2VCYXNlNjQsXG4gICAgICAgICAgICBrZXlQYWlyOiBwYXJhbXMua2V5UGFpcixcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBpbnRlcm5hbFJ1bk5hdGl2ZShwYXJhbXM6IFRPTkNvbnRyYWN0UnVuUGFyYW1zKTogUHJvbWlzZTxUT05Db250cmFjdFJ1blJlc3VsdD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLnJ1bicsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgYWJpOiBwYXJhbXMuYWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgaGVhZGVyOiBwYXJhbXMuaGVhZGVyLFxuICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcy5pbnB1dCxcbiAgICAgICAgICAgIGtleVBhaXI6IHBhcmFtcy5rZXlQYWlyLFxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGFzeW5jIHJldHJ5Q2FsbChjYWxsOiAoaW5kZXg6IG51bWJlcikgPT4gUHJvbWlzZTxhbnk+KTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3QgcmV0cmllc0NvdW50ID0gdGhpcy5jb25maWcubWVzc2FnZVJldHJpZXNDb3VudCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByZXRyaWVzQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKGBSZXRyeSAjJHtpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY2FsbChpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgaWYgbWVzc2FnZSBleHBpcmVkIG9yIGlmIHJlc29sdmluZyByZXR1cm5lZCB0aGF0IG1lc3NhZ2UgZXhwaXJlZC9yZXBsYXlcbiAgICAgICAgICAgICAgICAvLyBwcm90ZWN0aW9uIGVycm9yIG9yIGlmIHRyYW5zYWN0aW9uIHdpdGggbWVzc2FnZSBleHBpcmVkL3JlcGxheSBwcm90ZWN0aW9uIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuZWRcbiAgICAgICAgICAgICAgICBjb25zdCBpc09yaWdpbmFsT3JSZXNvbHZlZCA9IGV4aXRDb2RlID0+IChcbiAgICAgICAgICAgICAgICAgICAgVE9OQ2xpZW50RXJyb3IuaXNPcmlnaW5hbENvbnRyYWN0RXJyb3IoZXJyb3IsIGV4aXRDb2RlKVxuICAgICAgICAgICAgICAgICAgICB8fCBUT05DbGllbnRFcnJvci5pc1Jlc29sdmVkQ29udHJhY3RFcnJvckFmdGVyRXhwaXJlKGVycm9yLCBleGl0Q29kZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZVJldHJ5ID0gZXJyb3IuY29kZSA9PT0gVE9ORXJyb3JDb2RlLk1FU1NBR0VfRVhQSVJFRFxuICAgICAgICAgICAgICAgICAgICB8fCBpc09yaWdpbmFsT3JSZXNvbHZlZChUT05Db250cmFjdEV4aXRDb2RlLlJFUExBWV9QUk9URUNUSU9OKVxuICAgICAgICAgICAgICAgICAgICB8fCBpc09yaWdpbmFsT3JSZXNvbHZlZChUT05Db250cmFjdEV4aXRDb2RlLk1FU1NBR0VfRVhQSVJFRCk7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VSZXRyeSB8fCBpID09PSByZXRyaWVzQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLmludGVybmFsRXJyb3IoXG4gICAgICAgICAgICAnQWxsIHJldHJ5IGF0dGVtcHRzIGZhaWxlZCcsXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKCksXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBpbnRlcm5hbERlcGxveUpzKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0RGVwbG95UGFyYW1zLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdERlcGxveVJlc3VsdD4ge1xuICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ0RlcGxveSBzdGFydCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeUNhbGwoYXN5bmMgKHJldHJ5SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlcGxveU1lc3NhZ2UgPSBhd2FpdCB0aGlzLmNyZWF0ZURlcGxveU1lc3NhZ2UocGFyYW1zLCByZXRyeUluZGV4KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLmlzRGVwbG95ZWQoZGVwbG95TWVzc2FnZS5hZGRyZXNzLCBwYXJlbnRTcGFuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGRlcGxveU1lc3NhZ2UuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeURlcGxveWVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzaW5nID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShkZXBsb3lNZXNzYWdlLm1lc3NhZ2UsIHBhcmVudFNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvckRlcGxveVRyYW5zYWN0aW9uKGRlcGxveU1lc3NhZ2UsIHByb2Nlc3NpbmcsIHBhcmVudFNwYW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGludGVybmFsUnVuSnMoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RSdW5QYXJhbXMsXG4gICAgICAgIHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSxcbiAgICApOiBQcm9taXNlPFRPTkNvbnRyYWN0UnVuUmVzdWx0PiB7XG4gICAgICAgIHRoaXMuY29uZmlnLmxvZygnUnVuIHN0YXJ0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJ5Q2FsbChhc3luYyAocmV0cnlJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVuTWVzc2FnZSA9IGF3YWl0IHRoaXMuY3JlYXRlUnVuTWVzc2FnZShwYXJhbXMsIHJldHJ5SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2luZyA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UocnVuTWVzc2FnZS5tZXNzYWdlLCBwYXJlbnRTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JSdW5UcmFuc2FjdGlvbihydW5NZXNzYWdlLCBwcm9jZXNzaW5nLCBwYXJlbnRTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBhc3luYyBnZXRBY2NvdW50KFxuICAgICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIGFjdGl2ZTogYm9vbGVhbixcbiAgICAgICAgd2FpdFBhcmFtcz86IFRPTkNvbnRyYWN0QWNjb3VudFdhaXRQYXJhbXMsXG4gICAgICAgIHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSxcbiAgICApOiBQcm9taXNlPFFBY2NvdW50PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcjogeyBbc3RyaW5nXTogYW55IH0gPSB7XG4gICAgICAgICAgICBpZDogeyBlcTogYWRkcmVzcyB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAod2FpdFBhcmFtcyAmJiB3YWl0UGFyYW1zLnRyYW5zYWN0aW9uTHQpIHtcbiAgICAgICAgICAgIGZpbHRlci5sYXN0X3RyYW5zX2x0ID0geyBnZTogd2FpdFBhcmFtcy50cmFuc2FjdGlvbkx0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgZmlsdGVyLmFjY190eXBlID0geyBlcTogUUFjY291bnRUeXBlLmFjdGl2ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25maWcubG9nKCdnZXRBY2NvdW50LiBGaWx0ZXInLCBmaWx0ZXIpO1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMucXVlcmllcy5hY2NvdW50cy5xdWVyeSh7XG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICByZXN1bHQ6ICdpZCBhY2NfdHlwZSBib2MgY29kZV9oYXNoIGRhdGFfaGFzaCBiYWxhbmNlIGJhbGFuY2Vfb3RoZXIgeyBjdXJyZW5jeSB2YWx1ZSB9IGxhc3RfcGFpZCcsXG4gICAgICAgICAgICAuLi4od2FpdFBhcmFtcyAmJiB3YWl0UGFyYW1zLnRpbWVvdXQgPyB7IHRpbWVvdXQ6IHdhaXRQYXJhbXMudGltZW91dCB9IDoge30pLFxuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLmFjY291bnRNaXNzaW5nKFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50c1swXTtcbiAgICAgICAgcmVtb3ZlVHlwZU5hbWUoYWNjb3VudCk7XG4gICAgICAgIHRoaXMuY29uZmlnLmxvZygnZ2V0QWNjb3VudC4gQWNjb3VudCByZWNlaXZlZCcsIGFjY291bnQpO1xuICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICB9XG5cbiAgICBhc3luYyBpbnRlcm5hbFJ1bkxvY2FsSnMoXG4gICAgICAgIHBhcmFtczogVE9OQ29udHJhY3RSdW5Mb2NhbFBhcmFtcyxcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpLFxuICAgICk6IFByb21pc2U8VE9OQ29udHJhY3RSdW5Mb2NhbFJlc3VsdD4ge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gcGFyYW1zLmFkZHJlc3M7XG4gICAgICAgIGlmICghYWRkcmVzcykge1xuICAgICAgICAgICAgVE9OQ2xpZW50RXJyb3IuYWRkcmVzc1JlcXVpcmVkRm9yUnVuTG9jYWwoXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBwYXJhbXMuYWNjb3VudCB8fCAoYXdhaXQgdGhpcy5nZXRBY2NvdW50KFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgcGFyYW1zLndhaXRQYXJhbXMsXG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICApKTtcbiAgICAgICAgaWYgKCFhY2NvdW50LmNvZGVfaGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3IuYWNjb3VudENvZGVNaXNzaW5nKFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgKGFjY291bnQ6IGFueSkuYmFsYW5jZSxcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fbmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4ubG9jYWwnLCB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgIGFiaTogcGFyYW1zLmFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICBrZXlQYWlyOiBwYXJhbXMua2V5UGFpcixcbiAgICAgICAgICAgIGZ1bGxSdW46IHBhcmFtcy5mdWxsUnVuLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnRlcm5hbFJ1bk1lc3NhZ2VMb2NhbEpzKFxuICAgICAgICBwYXJhbXM6IFRPTkNvbnRyYWN0UnVuTWVzc2FnZUxvY2FsUGFyYW1zLFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgKTogUHJvbWlzZTxUT05Db250cmFjdFJ1bkxvY2FsUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcztcbiAgICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBUT05DbGllbnRFcnJvci5hZGRyZXNzUmVxdWlyZWRGb3JSdW5Mb2NhbChhd2FpdCB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHBhcmFtcy5hY2NvdW50IHx8IChhd2FpdCB0aGlzLmdldEFjY291bnQoXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBwYXJhbXMud2FpdFBhcmFtcyxcbiAgICAgICAgICAgIHBhcmVudFNwYW4sXG4gICAgICAgICkpO1xuICAgICAgICBpZiAoIWFjY291bnQuY29kZV9oYXNoKSB7XG4gICAgICAgICAgICB0aHJvdyBUT05DbGllbnRFcnJvci5hY2NvdW50Q29kZU1pc3NpbmcoXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAoYWNjb3VudDogYW55KS5iYWxhbmNlLFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9uYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLnJ1bi5sb2NhbC5tc2cnLCB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgIGFiaTogcGFyYW1zLmFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2VCYXNlNjQ6IHBhcmFtcy5tZXNzYWdlQm9keUJhc2U2NCxcbiAgICAgICAgICAgIGZ1bGxSdW46IHBhcmFtcy5mdWxsUnVuLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnRlcm5hbFNpZ24oXG4gICAgICAgIHVuc2lnbmVkOiBUT05Db250cmFjdFVuc2lnbmVkTWVzc2FnZSxcbiAgICAgICAgc291cmNlOiBTaWduaW5nU291cmNlLFxuICAgICk6IFByb21pc2U8U2lnblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgYmFzZTY0OiB1bnNpZ25lZC5ieXRlc1RvU2lnbkJhc2U2NCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm94ID0gc291cmNlLmJveDtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaWduQnl0ZXNCYXNlNjQ6IGF3YWl0IGJveC5zaWduKG1lc3NhZ2UsIFRPTk91dHB1dEVuY29kaW5nLkJhc2U2NCksXG4gICAgICAgICAgICAgICAgcHVibGljS2V5SGV4OiBhd2FpdCBib3guZ2V0UHVibGljS2V5KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBzb3VyY2Uua2V5cztcbiAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25LZXlzID0gYXdhaXQgdGhpcy5jcnlwdG8ubmFjbFNpZ25LZXlwYWlyRnJvbVNlY3JldEtleShrZXlzLnNlY3JldCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpZ25CeXRlc0Jhc2U2NDogYXdhaXQgdGhpcy5jcnlwdG8ubmFjbFNpZ25EZXRhY2hlZChcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbktleXMuc2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICBUT05PdXRwdXRFbmNvZGluZy5CYXNlNjQsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXlIZXg6IHNpZ25LZXlzLnB1YmxpYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3Iuc2lnbmluZ1NvdXJjZUlzTm90U3BlY2lmaWVkKCk7XG4gICAgfVxufVxuXG5UT05Db250cmFjdHNNb2R1bGUubW9kdWxlTmFtZSA9ICdUT05Db250cmFjdHNNb2R1bGUnO1xuXG5jb25zdCBCTE9DS19GSUVMRFMgPSBgXG4gICAgaWRcbiAgICBnZW5fdXRpbWVcbiAgICBhZnRlcl9zcGxpdFxuICAgIHdvcmtjaGFpbl9pZFxuICAgIHNoYXJkXG4gICAgaW5fbXNnX2Rlc2NyIHtcbiAgICAgICAgbXNnX2lkXG4gICAgICAgIHRyYW5zYWN0aW9uX2lkXG4gICAgfVxuYDtcblxuY29uc3QgVFJBTlNBQ1RJT05fRklFTERTX09SRElOQVJZID0gYFxuICAgIGlkXG4gICAgYWJvcnRlZFxuICAgIGNvbXB1dGUge1xuICAgICAgICBza2lwcGVkX3JlYXNvblxuICAgICAgICBleGl0X2NvZGVcbiAgICAgICAgc3VjY2Vzc1xuICAgICAgICBnYXNfZmVlc1xuICAgIH1cbiAgICBzdG9yYWdlIHtcbiAgICAgICBzdGF0dXNfY2hhbmdlXG4gICAgICAgc3RvcmFnZV9mZWVzX2NvbGxlY3RlZFxuICAgIH1cbiAgICBhY3Rpb24ge1xuICAgICAgICBzdWNjZXNzXG4gICAgICAgIHZhbGlkXG4gICAgICAgIG5vX2Z1bmRzXG4gICAgICAgIHJlc3VsdF9jb2RlXG4gICAgICAgIHRvdGFsX2Z3ZF9mZWVzXG4gICAgICAgIHRvdGFsX2FjdGlvbl9mZWVzXG4gICAgfVxuICAgIGluX21zZ1xuICAgIG5vd1xuICAgIG91dF9tc2dzXG4gICAgb3V0X21lc3NhZ2VzIHtcbiAgICAgICAgaWRcbiAgICAgICAgYm9keVxuICAgICAgICBtc2dfdHlwZVxuICAgICAgICB2YWx1ZVxuICAgIH1cbiAgICBzdGF0dXNcbiAgICB0b3RhbF9mZWVzXG5gO1xuIl19

/***/ }),

/***/ "./node_modules/ton-client-js/dist/modules/TONCryptoModule.js":
/*!********************************************************************!*\
  !*** ./node_modules/ton-client-js/dist/modules/TONCryptoModule.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = exports.TONMnemonicDictionary = exports.TONOutputEncoding = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _TONClientError = __webpack_require__(/*! ../TONClientError */ "./node_modules/ton-client-js/dist/TONClientError.js");

var _TONModule2 = __webpack_require__(/*! ../TONModule */ "./node_modules/ton-client-js/dist/TONModule.js");

var _cryptoBox = __webpack_require__(/*! ./crypto-box */ "./node_modules/ton-client-js/dist/modules/crypto-box.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TONOutputEncoding = {
  Text: 'Text',
  Hex: 'Hex',
  HexUppercase: 'HexUppercase',
  Base64: 'Base64'
};
exports.TONOutputEncoding = TONOutputEncoding;
var TONMnemonicDictionary = {
  TON: 0,
  ENGLISH: 1,
  CHINESE_SIMPLIFIED: 2,
  CHINESE_TRADITIONAL: 3,
  FRENCH: 4,
  ITALIAN: 5,
  JAPANESE: 6,
  KOREAN: 7,
  SPANISH: 8
};
exports.TONMnemonicDictionary = TONMnemonicDictionary;

function fixInputMessage(message) {
  return message.text ? {
    base64: Buffer.from(message.text, 'utf8').toString('base64')
  } : message;
}

var TONCryptoModule = /*#__PURE__*/function (_TONModule) {
  _inherits(TONCryptoModule, _TONModule);

  var _super = _createSuper(TONCryptoModule);

  function TONCryptoModule(context) {
    var _this;

    _classCallCheck(this, TONCryptoModule);

    _this = _super.call(this, context);

    _defineProperty(_assertThisInitialized(_this), "cryptoBoxes", void 0);

    _this.cryptoBoxes = new Map();
    return _this;
  }

  _createClass(TONCryptoModule, [{
    key: "getCryptoBox",
    value: function getCryptoBox(params) {
      var key = params.encryptedSeedPhrase.text || params.encryptedSeedPhrase.base64 || params.encryptedSeedPhrase.hex || '';

      if (!key) {
        throw _TONClientError.TONClientError.invalidCryptoBoxParams(params.encryptedSeedPhrase);
      }

      var cryptoBox = this.cryptoBoxes.get(key);

      if (!cryptoBox) {
        cryptoBox = new _cryptoBox.CoreCryptoBox(this, params);
        this.cryptoBoxes.set(key, cryptoBox);
      }

      return Promise.resolve(cryptoBox);
    }
  }, {
    key: "factorize",
    value: function () {
      var _factorize = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(challengeHex) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.requestCore('crypto.math.factorize', challengeHex));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function factorize(_x) {
        return _factorize.apply(this, arguments);
      }

      return factorize;
    }()
  }, {
    key: "modularPower",
    value: function () {
      var _modularPower = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(baseHex, exponentHex, modulusHex) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.requestCore('crypto.math.modularPower', {
                  base: baseHex,
                  exponent: exponentHex,
                  modulus: modulusHex
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function modularPower(_x2, _x3, _x4) {
        return _modularPower.apply(this, arguments);
      }

      return modularPower;
    }()
  }, {
    key: "randomGenerateBytes",
    value: function () {
      var _randomGenerateBytes = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(length) {
        var outputEncoding,
            _args3 = arguments;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                outputEncoding = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : TONOutputEncoding.Hex;
                return _context3.abrupt("return", this.requestCore('crypto.random.generateBytes', {
                  length: length,
                  outputEncoding: outputEncoding
                }));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function randomGenerateBytes(_x5) {
        return _randomGenerateBytes.apply(this, arguments);
      }

      return randomGenerateBytes;
    }()
  }, {
    key: "ed25519Keypair",
    value: function () {
      var _ed25519Keypair = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.requestCore('crypto.ed25519.keypair'));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function ed25519Keypair() {
        return _ed25519Keypair.apply(this, arguments);
      }

      return ed25519Keypair;
    }()
  }, {
    key: "publicKeyToString",
    value: function () {
      var _publicKeyToString = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee5(key) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.requestCore('crypto.ton_public_key_string', key));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function publicKeyToString(_x6) {
        return _publicKeyToString.apply(this, arguments);
      }

      return publicKeyToString;
    }()
  }, {
    key: "sha512",
    value: function () {
      var _sha = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee6(message) {
        var outputEncoding,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                outputEncoding = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : TONOutputEncoding.Hex;
                return _context6.abrupt("return", this.requestCore('crypto.sha512', {
                  message: fixInputMessage(message),
                  outputEncoding: outputEncoding
                }));

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function sha512(_x7) {
        return _sha.apply(this, arguments);
      }

      return sha512;
    }()
  }, {
    key: "sha256",
    value: function () {
      var _sha2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee7(message) {
        var outputEncoding,
            _args7 = arguments;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                outputEncoding = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : TONOutputEncoding.Hex;
                return _context7.abrupt("return", this.requestCore('crypto.sha256', {
                  message: fixInputMessage(message),
                  outputEncoding: outputEncoding
                }));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function sha256(_x8) {
        return _sha2.apply(this, arguments);
      }

      return sha256;
    }()
  }, {
    key: "scrypt",
    value: function () {
      var _scrypt = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee8(params) {
        var fixed;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                fixed = Object.assign({}, params);
                fixed.password = fixInputMessage(params.password);
                fixed.salt = fixInputMessage(params.salt);
                return _context8.abrupt("return", this.requestCore('crypto.scrypt', fixed));

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function scrypt(_x9) {
        return _scrypt.apply(this, arguments);
      }

      return scrypt;
    }()
  }, {
    key: "naclBoxKeypair",
    value: function () {
      var _naclBoxKeypair = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", this.requestCore('crypto.nacl.box.keypair'));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function naclBoxKeypair() {
        return _naclBoxKeypair.apply(this, arguments);
      }

      return naclBoxKeypair;
    }()
  }, {
    key: "naclBoxKeypairFromSecretKey",
    value: function () {
      var _naclBoxKeypairFromSecretKey = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee10(secretKey) {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this.requestCore('crypto.nacl.box.keypair.fromSecretKey', secretKey));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function naclBoxKeypairFromSecretKey(_x10) {
        return _naclBoxKeypairFromSecretKey.apply(this, arguments);
      }

      return naclBoxKeypairFromSecretKey;
    }()
  }, {
    key: "naclSignKeypair",
    value: function () {
      var _naclSignKeypair = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee11() {
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", this.requestCore('crypto.nacl.sign.keypair'));

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function naclSignKeypair() {
        return _naclSignKeypair.apply(this, arguments);
      }

      return naclSignKeypair;
    }()
  }, {
    key: "naclSignKeypairFromSecretKey",
    value: function () {
      var _naclSignKeypairFromSecretKey = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee12(secretKey) {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                return _context12.abrupt("return", this.requestCore('crypto.nacl.sign.keypair.fromSecretKey', secretKey));

              case 1:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function naclSignKeypairFromSecretKey(_x11) {
        return _naclSignKeypairFromSecretKey.apply(this, arguments);
      }

      return naclSignKeypairFromSecretKey;
    }()
  }, {
    key: "naclBox",
    value: function () {
      var _naclBox = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee13(params) {
        var fixed;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                fixed = Object.assign({}, params);
                fixed.message = fixInputMessage(params.message);
                return _context13.abrupt("return", this.requestCore('crypto.nacl.box', fixed));

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function naclBox(_x12) {
        return _naclBox.apply(this, arguments);
      }

      return naclBox;
    }()
  }, {
    key: "naclBoxOpen",
    value: function () {
      var _naclBoxOpen = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee14(params) {
        var fixed;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                fixed = Object.assign({}, params);
                fixed.message = fixInputMessage(params.message);
                return _context14.abrupt("return", this.requestCore('crypto.nacl.box.open', fixed));

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function naclBoxOpen(_x13) {
        return _naclBoxOpen.apply(this, arguments);
      }

      return naclBoxOpen;
    }()
  }, {
    key: "naclSecretBox",
    value: function () {
      var _naclSecretBox = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee15(params) {
        var fixed;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                fixed = Object.assign({}, params);
                fixed.message = fixInputMessage(params.message);
                return _context15.abrupt("return", this.requestCore('crypto.nacl.secret.box', fixed));

              case 3:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function naclSecretBox(_x14) {
        return _naclSecretBox.apply(this, arguments);
      }

      return naclSecretBox;
    }()
  }, {
    key: "naclSecretBoxOpen",
    value: function () {
      var _naclSecretBoxOpen = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee16(params) {
        var fixed;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                fixed = Object.assign({}, params);
                fixed.message = fixInputMessage(params.message);
                return _context16.abrupt("return", this.requestCore('crypto.nacl.secret.box.open', fixed));

              case 3:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function naclSecretBoxOpen(_x15) {
        return _naclSecretBoxOpen.apply(this, arguments);
      }

      return naclSecretBoxOpen;
    }()
  }, {
    key: "naclSign",
    value: function () {
      var _naclSign = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee17(message, key) {
        var outputEncoding,
            _args17 = arguments;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                outputEncoding = _args17.length > 2 && _args17[2] !== undefined ? _args17[2] : TONOutputEncoding.Hex;
                return _context17.abrupt("return", this.requestCore('crypto.nacl.sign', {
                  message: fixInputMessage(message),
                  key: key,
                  outputEncoding: outputEncoding
                }));

              case 2:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function naclSign(_x16, _x17) {
        return _naclSign.apply(this, arguments);
      }

      return naclSign;
    }()
  }, {
    key: "naclSignOpen",
    value: function () {
      var _naclSignOpen = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee18(message, key) {
        var outputEncoding,
            _args18 = arguments;
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                outputEncoding = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : TONOutputEncoding.Hex;
                return _context18.abrupt("return", this.requestCore('crypto.nacl.sign.open', {
                  message: fixInputMessage(message),
                  key: key,
                  outputEncoding: outputEncoding
                }));

              case 2:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function naclSignOpen(_x18, _x19) {
        return _naclSignOpen.apply(this, arguments);
      }

      return naclSignOpen;
    }()
  }, {
    key: "naclSignDetached",
    value: function () {
      var _naclSignDetached = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee19(message, key) {
        var outputEncoding,
            _args19 = arguments;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                outputEncoding = _args19.length > 2 && _args19[2] !== undefined ? _args19[2] : TONOutputEncoding.Hex;
                return _context19.abrupt("return", this.requestCore('crypto.nacl.sign.detached', {
                  message: fixInputMessage(message),
                  key: key,
                  outputEncoding: outputEncoding
                }));

              case 2:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function naclSignDetached(_x20, _x21) {
        return _naclSignDetached.apply(this, arguments);
      }

      return naclSignDetached;
    }() // Mnemonic

  }, {
    key: "mnemonicWords",
    value: function () {
      var _mnemonicWords = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee20(params) {
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", this.requestCore('crypto.mnemonic.words', params || {}));

              case 1:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function mnemonicWords(_x22) {
        return _mnemonicWords.apply(this, arguments);
      }

      return mnemonicWords;
    }()
  }, {
    key: "mnemonicFromRandom",
    value: function () {
      var _mnemonicFromRandom = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee21(params) {
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                return _context21.abrupt("return", this.requestCore('crypto.mnemonic.from.random', params || {}));

              case 1:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function mnemonicFromRandom(_x23) {
        return _mnemonicFromRandom.apply(this, arguments);
      }

      return mnemonicFromRandom;
    }()
  }, {
    key: "mnemonicFromEntropy",
    value: function () {
      var _mnemonicFromEntropy = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee22(params) {
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                return _context22.abrupt("return", this.requestCore('crypto.mnemonic.from.entropy', params));

              case 1:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function mnemonicFromEntropy(_x24) {
        return _mnemonicFromEntropy.apply(this, arguments);
      }

      return mnemonicFromEntropy;
    }()
  }, {
    key: "mnemonicIsValid",
    value: function () {
      var _mnemonicIsValid = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee23(params) {
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                return _context23.abrupt("return", this.requestCore('crypto.mnemonic.verify', params));

              case 1:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function mnemonicIsValid(_x25) {
        return _mnemonicIsValid.apply(this, arguments);
      }

      return mnemonicIsValid;
    }()
  }, {
    key: "mnemonicDeriveSignKeys",
    value: function () {
      var _mnemonicDeriveSignKeys = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee24(params) {
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                return _context24.abrupt("return", this.requestCore('crypto.mnemonic.derive.sign.keys', params));

              case 1:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function mnemonicDeriveSignKeys(_x26) {
        return _mnemonicDeriveSignKeys.apply(this, arguments);
      }

      return mnemonicDeriveSignKeys;
    }() // HDKeys

  }, {
    key: "hdkeyXPrvFromMnemonic",
    value: function () {
      var _hdkeyXPrvFromMnemonic = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee25(params) {
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                return _context25.abrupt("return", this.requestCore('crypto.hdkey.xprv.from.mnemonic', params));

              case 1:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function hdkeyXPrvFromMnemonic(_x27) {
        return _hdkeyXPrvFromMnemonic.apply(this, arguments);
      }

      return hdkeyXPrvFromMnemonic;
    }()
  }, {
    key: "hdkeyXPrvDerive",
    value: function () {
      var _hdkeyXPrvDerive = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee26(serialized, index, hardened, compliant) {
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                return _context26.abrupt("return", this.requestCore('crypto.hdkey.xprv.derive', {
                  serialized: serialized,
                  index: index,
                  hardened: hardened,
                  compliant: compliant
                }));

              case 1:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function hdkeyXPrvDerive(_x28, _x29, _x30, _x31) {
        return _hdkeyXPrvDerive.apply(this, arguments);
      }

      return hdkeyXPrvDerive;
    }()
  }, {
    key: "hdkeyXPrvDerivePath",
    value: function () {
      var _hdkeyXPrvDerivePath = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee27(serialized, path, compliant) {
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                return _context27.abrupt("return", this.requestCore('crypto.hdkey.xprv.derive.path', {
                  serialized: serialized,
                  path: path,
                  compliant: compliant
                }));

              case 1:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function hdkeyXPrvDerivePath(_x32, _x33, _x34) {
        return _hdkeyXPrvDerivePath.apply(this, arguments);
      }

      return hdkeyXPrvDerivePath;
    }()
  }, {
    key: "hdkeyXPrvSecret",
    value: function () {
      var _hdkeyXPrvSecret = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee28(serialized) {
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                return _context28.abrupt("return", this.requestCore('crypto.hdkey.xprv.secret', {
                  serialized: serialized
                }));

              case 1:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function hdkeyXPrvSecret(_x35) {
        return _hdkeyXPrvSecret.apply(this, arguments);
      }

      return hdkeyXPrvSecret;
    }()
  }, {
    key: "hdkeyXPrvPublic",
    value: function () {
      var _hdkeyXPrvPublic = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee29(serialized) {
        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                return _context29.abrupt("return", this.requestCore('crypto.hdkey.xprv.public', {
                  serialized: serialized
                }));

              case 1:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function hdkeyXPrvPublic(_x36) {
        return _hdkeyXPrvPublic.apply(this, arguments);
      }

      return hdkeyXPrvPublic;
    }() // Encryption

  }, {
    key: "chacha20",
    value: function chacha20(params) {
      return this.requestCore('crypto.chacha20', params);
    }
  }]);

  return TONCryptoModule;
}(_TONModule2.TONModule);

exports.default = TONCryptoModule;
TONCryptoModule.moduleName = 'TONCryptoModule';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2R1bGVzL1RPTkNyeXB0b01vZHVsZS5qcyJdLCJuYW1lcyI6WyJUT05PdXRwdXRFbmNvZGluZyIsIlRleHQiLCJIZXgiLCJIZXhVcHBlcmNhc2UiLCJCYXNlNjQiLCJUT05NbmVtb25pY0RpY3Rpb25hcnkiLCJUT04iLCJFTkdMSVNIIiwiQ0hJTkVTRV9TSU1QTElGSUVEIiwiQ0hJTkVTRV9UUkFESVRJT05BTCIsIkZSRU5DSCIsIklUQUxJQU4iLCJKQVBBTkVTRSIsIktPUkVBTiIsIlNQQU5JU0giLCJmaXhJbnB1dE1lc3NhZ2UiLCJtZXNzYWdlIiwidGV4dCIsImJhc2U2NCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIlRPTkNyeXB0b01vZHVsZSIsImNvbnRleHQiLCJjcnlwdG9Cb3hlcyIsIk1hcCIsInBhcmFtcyIsImtleSIsImVuY3J5cHRlZFNlZWRQaHJhc2UiLCJoZXgiLCJUT05DbGllbnRFcnJvciIsImludmFsaWRDcnlwdG9Cb3hQYXJhbXMiLCJjcnlwdG9Cb3giLCJnZXQiLCJDb3JlQ3J5cHRvQm94Iiwic2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJjaGFsbGVuZ2VIZXgiLCJyZXF1ZXN0Q29yZSIsImJhc2VIZXgiLCJleHBvbmVudEhleCIsIm1vZHVsdXNIZXgiLCJiYXNlIiwiZXhwb25lbnQiLCJtb2R1bHVzIiwibGVuZ3RoIiwib3V0cHV0RW5jb2RpbmciLCJmaXhlZCIsIk9iamVjdCIsImFzc2lnbiIsInBhc3N3b3JkIiwic2FsdCIsInNlY3JldEtleSIsInNlcmlhbGl6ZWQiLCJpbmRleCIsImhhcmRlbmVkIiwiY29tcGxpYW50IiwicGF0aCIsIlRPTk1vZHVsZSIsIm1vZHVsZU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQXlCQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFTyxJQUFNQSxpQkFBaUIsR0FBRztBQUM3QkMsRUFBQUEsSUFBSSxFQUFFLE1BRHVC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NkJBRVM1QixNLEVBQW1FO0FBQ3hFLGFBQU8sS0FBS2EsV0FBTCxDQUFpQixpQkFBakIsRUFBb0NiLE1BQXBDLENBQVA7QUFDSDs7OztFQW5Qd0NpQyxxQjs7O0FBc1A3Q3JDLGVBQWUsQ0FBQ3NDLFVBQWhCLEdBQTZCLGlCQUE3QiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIwIFRPTiBERVYgU09MVVRJT05TIExURC5cbiAqL1xuXG4vLyBAZmxvd1xuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyxwcmVmZXItb2JqZWN0LXNwcmVhZCAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gICAgVE9ORmFjdG9yaXplUmVzdWx0LFxuICAgIFRPTklucHV0TWVzc2FnZSxcbiAgICBUT05LZXlQYWlyRGF0YSxcbiAgICBUT05PdXRwdXRFbmNvZGluZ1R5cGUsXG4gICAgVE9OU2NyeXB0UGFyYW1zLFxuICAgIFRPTk5hY2xCb3hQYXJhbXMsXG4gICAgVE9OTmFjbFNlY3JldEJveFBhcmFtcyxcbiAgICBUT05NbmVtb25pY1dvcmRzUGFyYW1zLFxuICAgIFRPTk1uZW1vbmljRnJvbVJhbmRvbVBhcmFtcyxcbiAgICBUT05NbmVtb25pY0Zyb21FbnRyb3B5UGFyYW1zLFxuICAgIFRPTk1uZW1vbmljSXNWYWxpZFBhcmFtcyxcbiAgICBUT05NbmVtb25pY0Rlcml2ZVNpZ25LZXlzUGFyYW1zLFxuICAgIFRPTkNyeXB0byxcbiAgICBUT05IREtleUZyb21NbmVtb25pY1BhcmFtcyxcbiAgICBUT05DcnlwdG9Cb3hQYXJhbXMsXG4gICAgVE9OQ3J5cHRvQm94LCBUT05DcnlwdG9DaGFDaGEyMFBhcmFtcywgVE9OQ3J5cHRvQ2hhQ2hhMjBSZXN1bHQsXG59IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFRPTkNsaWVudEVycm9yIH0gZnJvbSAnLi4vVE9OQ2xpZW50RXJyb3InO1xuaW1wb3J0IHR5cGUgeyBUT05Nb2R1bGVDb250ZXh0IH0gZnJvbSAnLi4vVE9OTW9kdWxlJztcbmltcG9ydCB7IFRPTk1vZHVsZSB9IGZyb20gJy4uL1RPTk1vZHVsZSc7XG5pbXBvcnQgeyBDb3JlQ3J5cHRvQm94IH0gZnJvbSAnLi9jcnlwdG8tYm94JztcblxuZXhwb3J0IGNvbnN0IFRPTk91dHB1dEVuY29kaW5nID0ge1xuICAgIFRleHQ6ICdUZXh0JyxcbiAgICBIZXg6ICdIZXgnLFxuICAgIEhleFVwcGVyY2FzZTogJ0hleFVwcGVyY2FzZScsXG4gICAgQmFzZTY0OiAnQmFzZTY0Jyxcbn07XG5cblxuZXhwb3J0IGNvbnN0IFRPTk1uZW1vbmljRGljdGlvbmFyeSA9IHtcbiAgICBUT046IDAsXG4gICAgRU5HTElTSDogMSxcbiAgICBDSElORVNFX1NJTVBMSUZJRUQ6IDIsXG4gICAgQ0hJTkVTRV9UUkFESVRJT05BTDogMyxcbiAgICBGUkVOQ0g6IDQsXG4gICAgSVRBTElBTjogNSxcbiAgICBKQVBBTkVTRTogNixcbiAgICBLT1JFQU46IDcsXG4gICAgU1BBTklTSDogOCxcbn07XG5cblxuZnVuY3Rpb24gZml4SW5wdXRNZXNzYWdlKG1lc3NhZ2U6IFRPTklucHV0TWVzc2FnZSk6IFRPTklucHV0TWVzc2FnZSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UudGV4dFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGJhc2U2NDogQnVmZmVyLmZyb20obWVzc2FnZS50ZXh0LCAndXRmOCcpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICAgICAgfVxuICAgICAgICA6IG1lc3NhZ2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRPTkNyeXB0b01vZHVsZSBleHRlbmRzIFRPTk1vZHVsZSBpbXBsZW1lbnRzIFRPTkNyeXB0byB7XG4gICAgY3J5cHRvQm94ZXM6IE1hcDxzdHJpbmcsIENvcmVDcnlwdG9Cb3g+O1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dDogVE9OTW9kdWxlQ29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5jcnlwdG9Cb3hlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBnZXRDcnlwdG9Cb3gocGFyYW1zOiBUT05DcnlwdG9Cb3hQYXJhbXMpOiBQcm9taXNlPFRPTkNyeXB0b0JveD4ge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJhbXMuZW5jcnlwdGVkU2VlZFBocmFzZS50ZXh0XG4gICAgICAgICAgICB8fCBwYXJhbXMuZW5jcnlwdGVkU2VlZFBocmFzZS5iYXNlNjRcbiAgICAgICAgICAgIHx8IHBhcmFtcy5lbmNyeXB0ZWRTZWVkUGhyYXNlLmhleFxuICAgICAgICAgICAgfHwgJyc7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBUT05DbGllbnRFcnJvci5pbnZhbGlkQ3J5cHRvQm94UGFyYW1zKHBhcmFtcy5lbmNyeXB0ZWRTZWVkUGhyYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3J5cHRvQm94ID0gdGhpcy5jcnlwdG9Cb3hlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjcnlwdG9Cb3gpIHtcbiAgICAgICAgICAgIGNyeXB0b0JveCA9IG5ldyBDb3JlQ3J5cHRvQm94KHRoaXMsIHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLmNyeXB0b0JveGVzLnNldChrZXksIGNyeXB0b0JveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcnlwdG9Cb3gpO1xuICAgIH1cblxuICAgIGFzeW5jIGZhY3Rvcml6ZShjaGFsbGVuZ2VIZXg6IHN0cmluZyk6IFByb21pc2U8VE9ORmFjdG9yaXplUmVzdWx0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubWF0aC5mYWN0b3JpemUnLCBjaGFsbGVuZ2VIZXgpO1xuICAgIH1cblxuICAgIGFzeW5jIG1vZHVsYXJQb3dlcihcbiAgICAgICAgYmFzZUhleDogc3RyaW5nLFxuICAgICAgICBleHBvbmVudEhleDogc3RyaW5nLFxuICAgICAgICBtb2R1bHVzSGV4OiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5tYXRoLm1vZHVsYXJQb3dlcicsIHtcbiAgICAgICAgICAgIGJhc2U6IGJhc2VIZXgsXG4gICAgICAgICAgICBleHBvbmVudDogZXhwb25lbnRIZXgsXG4gICAgICAgICAgICBtb2R1bHVzOiBtb2R1bHVzSGV4LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyByYW5kb21HZW5lcmF0ZUJ5dGVzKFxuICAgICAgICBsZW5ndGg6IG51bWJlcixcbiAgICAgICAgb3V0cHV0RW5jb2Rpbmc6IFRPTk91dHB1dEVuY29kaW5nVHlwZSA9IFRPTk91dHB1dEVuY29kaW5nLkhleCxcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLnJhbmRvbS5nZW5lcmF0ZUJ5dGVzJywge1xuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgb3V0cHV0RW5jb2RpbmcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZWQyNTUxOUtleXBhaXIoKTogUHJvbWlzZTxUT05LZXlQYWlyRGF0YT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLmVkMjU1MTkua2V5cGFpcicpO1xuICAgIH1cblxuICAgIGFzeW5jIHB1YmxpY0tleVRvU3RyaW5nKGtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by50b25fcHVibGljX2tleV9zdHJpbmcnLCBrZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNoYTUxMihcbiAgICAgICAgbWVzc2FnZTogVE9OSW5wdXRNZXNzYWdlLFxuICAgICAgICBvdXRwdXRFbmNvZGluZzogVE9OT3V0cHV0RW5jb2RpbmdUeXBlID0gVE9OT3V0cHV0RW5jb2RpbmcuSGV4LFxuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKFxuICAgICAgICAgICAgJ2NyeXB0by5zaGE1MTInLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZpeElucHV0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2hhMjU2KFxuICAgICAgICBtZXNzYWdlOiBUT05JbnB1dE1lc3NhZ2UsXG4gICAgICAgIG91dHB1dEVuY29kaW5nOiBUT05PdXRwdXRFbmNvZGluZ1R5cGUgPSBUT05PdXRwdXRFbmNvZGluZy5IZXgsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoXG4gICAgICAgICAgICAnY3J5cHRvLnNoYTI1NicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZml4SW5wdXRNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIG91dHB1dEVuY29kaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBzY3J5cHQocGFyYW1zOiBUT05TY3J5cHRQYXJhbXMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBmaXhlZDogVE9OU2NyeXB0UGFyYW1zID0gKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk6IGFueSk7XG4gICAgICAgIGZpeGVkLnBhc3N3b3JkID0gZml4SW5wdXRNZXNzYWdlKHBhcmFtcy5wYXNzd29yZCk7XG4gICAgICAgIGZpeGVkLnNhbHQgPSBmaXhJbnB1dE1lc3NhZ2UocGFyYW1zLnNhbHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLnNjcnlwdCcsIGZpeGVkKTtcbiAgICB9XG5cbiAgICBhc3luYyBuYWNsQm94S2V5cGFpcigpOiBQcm9taXNlPFRPTktleVBhaXJEYXRhPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5ib3gua2V5cGFpcicpO1xuICAgIH1cblxuICAgIGFzeW5jIG5hY2xCb3hLZXlwYWlyRnJvbVNlY3JldEtleShzZWNyZXRLZXk6IHN0cmluZyk6IFByb21pc2U8VE9OS2V5UGFpckRhdGE+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5uYWNsLmJveC5rZXlwYWlyLmZyb21TZWNyZXRLZXknLCBzZWNyZXRLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIG5hY2xTaWduS2V5cGFpcigpOiBQcm9taXNlPFRPTktleVBhaXJEYXRhPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5zaWduLmtleXBhaXInKTtcbiAgICB9XG5cbiAgICBhc3luYyBuYWNsU2lnbktleXBhaXJGcm9tU2VjcmV0S2V5KHNlY3JldEtleTogc3RyaW5nKTogUHJvbWlzZTxUT05LZXlQYWlyRGF0YT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm5hY2wuc2lnbi5rZXlwYWlyLmZyb21TZWNyZXRLZXknLCBzZWNyZXRLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIG5hY2xCb3gocGFyYW1zOiBUT05OYWNsQm94UGFyYW1zKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZml4ZWQ6IFRPTk5hY2xCb3hQYXJhbXMgPSAoT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTogYW55KTtcbiAgICAgICAgZml4ZWQubWVzc2FnZSA9IGZpeElucHV0TWVzc2FnZShwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5ib3gnLCBmaXhlZCk7XG4gICAgfVxuXG4gICAgYXN5bmMgbmFjbEJveE9wZW4ocGFyYW1zOiBUT05OYWNsQm94UGFyYW1zKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZml4ZWQ6IFRPTk5hY2xCb3hQYXJhbXMgPSAoT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTogYW55KTtcbiAgICAgICAgZml4ZWQubWVzc2FnZSA9IGZpeElucHV0TWVzc2FnZShwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5ib3gub3BlbicsIGZpeGVkKTtcbiAgICB9XG5cbiAgICBhc3luYyBuYWNsU2VjcmV0Qm94KHBhcmFtczogVE9OTmFjbFNlY3JldEJveFBhcmFtcyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGZpeGVkOiBUT05OYWNsQm94UGFyYW1zID0gKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk6IGFueSk7XG4gICAgICAgIGZpeGVkLm1lc3NhZ2UgPSBmaXhJbnB1dE1lc3NhZ2UocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm5hY2wuc2VjcmV0LmJveCcsIGZpeGVkKTtcbiAgICB9XG5cbiAgICBhc3luYyBuYWNsU2VjcmV0Qm94T3BlbihwYXJhbXM6IFRPTk5hY2xTZWNyZXRCb3hQYXJhbXMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBmaXhlZDogVE9OTmFjbEJveFBhcmFtcyA9IChPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpOiBhbnkpO1xuICAgICAgICBmaXhlZC5tZXNzYWdlID0gZml4SW5wdXRNZXNzYWdlKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5uYWNsLnNlY3JldC5ib3gub3BlbicsIGZpeGVkKTtcbiAgICB9XG5cbiAgICBhc3luYyBuYWNsU2lnbihcbiAgICAgICAgbWVzc2FnZTogVE9OSW5wdXRNZXNzYWdlLFxuICAgICAgICBrZXk6IHN0cmluZyxcbiAgICAgICAgb3V0cHV0RW5jb2Rpbmc6IFRPTk91dHB1dEVuY29kaW5nVHlwZSA9IFRPTk91dHB1dEVuY29kaW5nLkhleCxcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm5hY2wuc2lnbicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGZpeElucHV0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG91dHB1dEVuY29kaW5nLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBuYWNsU2lnbk9wZW4oXG4gICAgICAgIG1lc3NhZ2U6IFRPTklucHV0TWVzc2FnZSxcbiAgICAgICAga2V5OiBzdHJpbmcsXG4gICAgICAgIG91dHB1dEVuY29kaW5nOiBUT05PdXRwdXRFbmNvZGluZ1R5cGUgPSBUT05PdXRwdXRFbmNvZGluZy5IZXgsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5uYWNsLnNpZ24ub3BlbicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGZpeElucHV0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG91dHB1dEVuY29kaW5nLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBuYWNsU2lnbkRldGFjaGVkKFxuICAgICAgICBtZXNzYWdlOiBUT05JbnB1dE1lc3NhZ2UsXG4gICAgICAgIGtleTogc3RyaW5nLFxuICAgICAgICBvdXRwdXRFbmNvZGluZzogVE9OT3V0cHV0RW5jb2RpbmdUeXBlID0gVE9OT3V0cHV0RW5jb2RpbmcuSGV4LFxuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5zaWduLmRldGFjaGVkJywge1xuICAgICAgICAgICAgbWVzc2FnZTogZml4SW5wdXRNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgb3V0cHV0RW5jb2RpbmcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE1uZW1vbmljXG5cbiAgICBhc3luYyBtbmVtb25pY1dvcmRzKHBhcmFtcz86IFRPTk1uZW1vbmljV29yZHNQYXJhbXMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm1uZW1vbmljLndvcmRzJywgcGFyYW1zIHx8IHt9KTtcbiAgICB9XG5cbiAgICBhc3luYyBtbmVtb25pY0Zyb21SYW5kb20ocGFyYW1zPzogVE9OTW5lbW9uaWNGcm9tUmFuZG9tUGFyYW1zKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5tbmVtb25pYy5mcm9tLnJhbmRvbScsIHBhcmFtcyB8fCB7fSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbW5lbW9uaWNGcm9tRW50cm9weShwYXJhbXM6IFRPTk1uZW1vbmljRnJvbUVudHJvcHlQYXJhbXMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZShcbiAgICAgICAgICAgICdjcnlwdG8ubW5lbW9uaWMuZnJvbS5lbnRyb3B5JyxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBtbmVtb25pY0lzVmFsaWQocGFyYW1zOiBUT05NbmVtb25pY0lzVmFsaWRQYXJhbXMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5tbmVtb25pYy52ZXJpZnknLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGFzeW5jIG1uZW1vbmljRGVyaXZlU2lnbktleXMocGFyYW1zOiBUT05NbmVtb25pY0Rlcml2ZVNpZ25LZXlzUGFyYW1zKTogUHJvbWlzZTxUT05LZXlQYWlyRGF0YT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm1uZW1vbmljLmRlcml2ZS5zaWduLmtleXMnLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIEhES2V5c1xuXG4gICAgYXN5bmMgaGRrZXlYUHJ2RnJvbU1uZW1vbmljKHBhcmFtczogVE9OSERLZXlGcm9tTW5lbW9uaWNQYXJhbXMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLmhka2V5LnhwcnYuZnJvbS5tbmVtb25pYycsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgaGRrZXlYUHJ2RGVyaXZlKFxuICAgICAgICBzZXJpYWxpemVkOiBzdHJpbmcsXG4gICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgIGhhcmRlbmVkOiBib29sZWFuLFxuICAgICAgICBjb21wbGlhbnQ6IGJvb2xlYW4sXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoXG4gICAgICAgICAgICAnY3J5cHRvLmhka2V5LnhwcnYuZGVyaXZlJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGhhcmRlbmVkLFxuICAgICAgICAgICAgICAgIGNvbXBsaWFudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYXN5bmMgaGRrZXlYUHJ2RGVyaXZlUGF0aChcbiAgICAgICAgc2VyaWFsaXplZDogc3RyaW5nLFxuICAgICAgICBwYXRoOiBzdHJpbmcsXG4gICAgICAgIGNvbXBsaWFudDogYm9vbGVhbixcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZShcbiAgICAgICAgICAgICdjcnlwdG8uaGRrZXkueHBydi5kZXJpdmUucGF0aCcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIGNvbXBsaWFudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYXN5bmMgaGRrZXlYUHJ2U2VjcmV0KHNlcmlhbGl6ZWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8uaGRrZXkueHBydi5zZWNyZXQnLCB7IHNlcmlhbGl6ZWQgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgaGRrZXlYUHJ2UHVibGljKHNlcmlhbGl6ZWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8uaGRrZXkueHBydi5wdWJsaWMnLCB7IHNlcmlhbGl6ZWQgfSk7XG4gICAgfVxuXG4gICAgLy8gRW5jcnlwdGlvblxuXG4gICAgY2hhY2hhMjAocGFyYW1zOiBUT05DcnlwdG9DaGFDaGEyMFBhcmFtcyk6IFByb21pc2U8VE9OQ3J5cHRvQ2hhQ2hhMjBSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5jaGFjaGEyMCcsIHBhcmFtcyk7XG4gICAgfVxufVxuXG5UT05DcnlwdG9Nb2R1bGUubW9kdWxlTmFtZSA9ICdUT05DcnlwdG9Nb2R1bGUnO1xuIl19

/***/ }),

/***/ "./node_modules/ton-client-js/dist/modules/TONQueriesModule.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ton-client-js/dist/modules/TONQueriesModule.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = exports.MAX_TIMEOUT = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _apolloCacheInmemory = __webpack_require__(/*! apollo-cache-inmemory */ "./node_modules/apollo-cache-inmemory/lib/bundle.esm.js");

var _apolloClient = __webpack_require__(/*! apollo-client */ "./node_modules/apollo-client/bundle.esm.js");

var _apolloLink = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/bundle.esm.js");

var _apolloLinkHttp = __webpack_require__(/*! apollo-link-http */ "./node_modules/apollo-link-http/lib/bundle.esm.js");

var _apolloLinkWs = __webpack_require__(/*! apollo-link-ws */ "./node_modules/apollo-link-ws/lib/bundle.esm.js");

var _apolloUtilities = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/bundle.esm.js");

var _graphqlTag = _interopRequireDefault(__webpack_require__(/*! graphql-tag */ "./node_modules/graphql-tag/src/index.js"));

var _subscriptionsTransportWs = __webpack_require__(/*! subscriptions-transport-ws */ "./node_modules/subscriptions-transport-ws/dist/client.js");

var _apolloLinkContext = __webpack_require__(/*! apollo-link-context */ "./node_modules/apollo-link-context/lib/bundle.esm.js");

var _opentracing = __webpack_require__(/*! opentracing */ "./node_modules/opentracing/lib/index.js");

var _TONClient = __webpack_require__(/*! ../TONClient */ "./node_modules/ton-client-js/dist/TONClient.js");

var _TONClientError = __webpack_require__(/*! ../TONClientError */ "./node_modules/ton-client-js/dist/TONClientError.js");

var _TONModule2 = __webpack_require__(/*! ../TONModule */ "./node_modules/ton-client-js/dist/TONModule.js");

var _TONConfigModule = _interopRequireWildcard(__webpack_require__(/*! ./TONConfigModule */ "./node_modules/ton-client-js/dist/modules/TONConfigModule.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Keep-alive timeout used to support keep-alive connection checking:
// - Every 1 minute server sends GQL_CONNECTION_KEEP_ALIVE message.
// - Every 2 minutes client checks that GQL_CONNECTION_KEEP_ALIVE message was received
//   within last 2 minutes.
// - If client hadn't received keep alive message during last 2 minutes
//   it closes connection and goes to reconnect.
var KEEP_ALIVE_TIMEOUT = 2 * 60000;
var MAX_TIMEOUT = 2147483647;
exports.MAX_TIMEOUT = MAX_TIMEOUT;

function resolveParams(args, requiredParamName, resolveArgs) {
  return args.length === 1 && requiredParamName in args[0] ? args[0] : resolveArgs();
}

var MulticastPromise = /*#__PURE__*/function () {
  function MulticastPromise() {
    _classCallCheck(this, MulticastPromise);

    _defineProperty(this, "listeners", void 0);

    _defineProperty(this, "onComplete", void 0);

    this.listeners = [];
    this.onComplete = null;
  }

  _createClass(MulticastPromise, [{
    key: "listen",
    value: function listen() {
      var listener = {
        resolve: function resolve() {},
        reject: function reject() {}
      };
      this.listeners.push(listener);
      return new Promise(function (resolve, reject) {
        listener.resolve = resolve;
        listener.reject = reject;
      });
    }
  }, {
    key: "resolve",
    value: function resolve(value) {
      this.complete(function (listener) {
        return listener.resolve(value);
      });
    }
  }, {
    key: "reject",
    value: function reject(error) {
      this.complete(function (listener) {
        return listener.reject(error);
      });
    }
  }, {
    key: "complete",
    value: function complete(completeListener) {
      var listeners = this.listeners;
      this.listeners = [];

      if (this.onComplete) {
        this.onComplete();
      }

      listeners.forEach(function (listener) {
        return completeListener(listener);
      });
    }
  }]);

  return MulticastPromise;
}();

function versionToNumber(s) {
  var parts = "".concat(s || '').split('.').map(function (x) {
    return Number(x);
  }).slice(0, 3);

  while (parts.length < 3) {
    parts.push(0);
  }

  return parts[0] * 1000000 + parts[1] * 1000 + parts[2];
}

function resolveServerInfo(versionString) {
  var version = versionToNumber(versionString || '0.24.4');
  return {
    version: version,
    supportsOperationId: version > 24004,
    supportsAggregations: version >= 25000,
    supportsTime: version >= 26003,
    timeDelta: null
  };
}

function abortableFetch(fetch) {
  return function (input, options) {
    return new Promise(function (resolve, reject) {
      var queryTimeout = options.queryTimeout;
      var fetchOptions = options;

      if (queryTimeout) {
        var controller = __webpack_require__.g.AbortController ? new __webpack_require__.g.AbortController() : null;

        if (controller) {
          fetchOptions = _objectSpread(_objectSpread({}, options), {}, {
            signal: controller.signal
          });
        }

        setTimeout(function () {
          reject(_TONClientError.TONClientError.queryForciblyAborted(_TONClientError.emptyTONErrorData));

          if (controller) {
            controller.abort();
          }
        }, queryTimeout);
      }

      fetch(input, fetchOptions).then(resolve, reject);
    });
  };
}

var TONQueriesModule = /*#__PURE__*/function (_TONModule) {
  _inherits(TONQueriesModule, _TONModule);

  var _super = _createSuper(TONQueriesModule);

  function TONQueriesModule(context) {
    var _this;

    _classCallCheck(this, TONQueriesModule);

    _this = _super.call(this, context);

    _defineProperty(_assertThisInitialized(_this), "transactions", void 0);

    _defineProperty(_assertThisInitialized(_this), "messages", void 0);

    _defineProperty(_assertThisInitialized(_this), "blocks", void 0);

    _defineProperty(_assertThisInitialized(_this), "accounts", void 0);

    _defineProperty(_assertThisInitialized(_this), "blocks_signatures", void 0);

    _defineProperty(_assertThisInitialized(_this), "config", void 0);

    _defineProperty(_assertThisInitialized(_this), "graphqlClientCreation", void 0);

    _defineProperty(_assertThisInitialized(_this), "graphqlClient", void 0);

    _defineProperty(_assertThisInitialized(_this), "graphqlClientConfig", void 0);

    _defineProperty(_assertThisInitialized(_this), "wsLink", void 0);

    _defineProperty(_assertThisInitialized(_this), "httpLink", void 0);

    _defineProperty(_assertThisInitialized(_this), "overrideWsUrl", void 0);

    _defineProperty(_assertThisInitialized(_this), "operationIdPrefix", void 0);

    _defineProperty(_assertThisInitialized(_this), "operationIdSuffix", void 0);

    _defineProperty(_assertThisInitialized(_this), "serverInfo", void 0);

    _defineProperty(_assertThisInitialized(_this), "activeQueriesRejects", void 0);

    _this.graphqlClient = null;
    _this.graphqlClientCreation = null;
    _this.graphqlClientConfig = null;
    _this.wsLink = null;
    _this.httpLink = null;
    _this.overrideWsUrl = null;
    _this.operationIdPrefix = (Date.now() % 60000).toString(16);

    for (var i = 0; i < 10; i += 1) {
      var randomPart = Math.round(Math.random() * 256).toString(16);
      _this.operationIdPrefix = "".concat(_this.operationIdPrefix).concat(randomPart);
    }

    _this.operationIdSuffix = 1;
    _this.serverInfo = resolveServerInfo();
    _this.activeQueriesRejects = [];
    return _this;
  }

  _createClass(TONQueriesModule, [{
    key: "registerQueryReject",
    value: function registerQueryReject(reject) {
      this.activeQueriesRejects.push(reject);
    }
  }, {
    key: "unregisterQueryReject",
    value: function unregisterQueryReject(reject) {
      var index = this.activeQueriesRejects.indexOf(reject);

      if (index >= 0) {
        this.activeQueriesRejects.splice(index, 1);
      }
    }
  }, {
    key: "rejectActiveQueries",
    value: function rejectActiveQueries() {
      var rejects = this.activeQueriesRejects;
      this.activeQueriesRejects = [];

      var err = _TONClientError.TONClientError.queryForciblyAborted({});

      rejects.forEach(function (reject) {
        try {
          reject(err);
        } catch (_unused) {}
      });
    }
  }, {
    key: "setup",
    value: function () {
      var _setup = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.config = this.context.getModule(_TONConfigModule["default"]);
                this.transactions = new TONQueriesModuleCollection(this, 'transactions', 'Transaction');
                this.messages = new TONQueriesModuleCollection(this, 'messages', 'Message');
                this.blocks = new TONQueriesModuleCollection(this, 'blocks', 'Block');
                this.accounts = new TONQueriesModuleCollection(this, 'accounts', 'Account');
                this.blocks_signatures = new TONQueriesModuleCollection(this, 'blocks_signatures', 'BlockSignatures');

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }, {
    key: "getQueryUrl",
    value: function getQueryUrl() {
      var _this$graphqlClientCo;

      return ((_this$graphqlClientCo = this.graphqlClientConfig) === null || _this$graphqlClientCo === void 0 ? void 0 : _this$graphqlClientCo.httpUrl) || '';
    }
  }, {
    key: "detectRedirect",
    value: function () {
      var _detectRedirect = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(fetch, sourceUrl) {
        var response, responseText, responseJson, sourceLocation, responseLocation;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return fetch(sourceUrl);

              case 2:
                response = _context2.sent;
                _context2.prev = 3;
                _context2.next = 6;
                return response.text();

              case 6:
                responseText = _context2.sent;
                responseJson = JSON.parse(responseText);
                this.serverInfo = resolveServerInfo(responseJson.data.info.version);
                _context2.next = 13;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](3);

              case 13:
                if (!(response.redirected === true)) {
                  _context2.next = 15;
                  break;
                }

                return _context2.abrupt("return", response.url);

              case 15:
                if (!(response.redirected === false)) {
                  _context2.next = 17;
                  break;
                }

                return _context2.abrupt("return", '');

              case 17:
                sourceLocation = _TONConfigModule.URLParts.parse(sourceUrl).fixQuery(function () {
                  return '';
                }).toString().toLowerCase();
                responseLocation = _TONConfigModule.URLParts.parse(response.url).fixQuery(function () {
                  return '';
                }).toString().toLowerCase();
                return _context2.abrupt("return", responseLocation !== sourceLocation ? response.url : '');

              case 20:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 11]]);
      }));

      function detectRedirect(_x, _x2) {
        return _detectRedirect.apply(this, arguments);
      }

      return detectRedirect;
    }()
  }, {
    key: "getClientConfig",
    value: function () {
      var _getClientConfig = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        var config, clientPlatform, fetch, getConfigForServer, _iterator, _step, server, clientConfig, redirected, httpParts;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                getConfigForServer = function _getConfigForServer(server) {
                  var httpParts = _TONConfigModule.URLParts.parse(server).fixProtocol(function (x) {
                    return x === 'http://' ? x : 'https://';
                  }).fixPath(function (x) {
                    return "".concat(x, "/graphql");
                  });

                  var http = httpParts.toString();
                  var ws = httpParts.fixProtocol(function (x) {
                    return x === 'http://' ? 'ws://' : 'wss://';
                  }).toString();
                  return {
                    httpUrl: http,
                    wsUrl: ws,
                    fetch: clientPlatform.fetch,
                    WebSocket: clientPlatform.WebSocket
                  };
                };

                config = this.config;
                clientPlatform = _TONClient.TONClient.clientPlatform;

                if (clientPlatform) {
                  _context3.next = 5;
                  break;
                }

                throw Error('TON Client does not configured');

              case 5:
                fetch = clientPlatform.fetch;
                _iterator = _createForOfIteratorHelper(config.data.servers);
                _context3.prev = 7;

                _iterator.s();

              case 9:
                if ((_step = _iterator.n()).done) {
                  _context3.next = 25;
                  break;
                }

                server = _step.value;
                clientConfig = getConfigForServer(server);
                _context3.prev = 12;
                _context3.next = 15;
                return this.detectRedirect(fetch, "".concat(clientConfig.httpUrl, "?query=%7Binfo%7Bversion%7D%7D"));

              case 15:
                redirected = _context3.sent;

                if (redirected !== '') {
                  httpParts = _TONConfigModule.URLParts.parse(redirected).fixQuery(function (_) {
                    return '';
                  });
                  clientConfig.httpUrl = httpParts.toString();
                  clientConfig.wsUrl = httpParts.fixProtocol(function (x) {
                    return x === 'http://' ? 'ws://' : 'wss://';
                  }).toString();
                }

                return _context3.abrupt("return", clientConfig);

              case 20:
                _context3.prev = 20;
                _context3.t0 = _context3["catch"](12);
                if (config._errLogVerbose) console.log("[getClientConfig] for server \"".concat(server, "\" failed"), {
                  message: _context3.t0.message || _context3.t0.toString(),
                  data: {
                    http_url: clientConfig.httpUrl,
                    ws_url: clientConfig.wsUrl
                  }
                });

              case 23:
                _context3.next = 9;
                break;

              case 25:
                _context3.next = 30;
                break;

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](7);

                _iterator.e(_context3.t1);

              case 30:
                _context3.prev = 30;

                _iterator.f();

                return _context3.finish(30);

              case 33:
                return _context3.abrupt("return", getConfigForServer(config.data.servers[0]));

              case 34:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[7, 27, 30, 33], [12, 20]]);
      }));

      function getClientConfig() {
        return _getClientConfig.apply(this, arguments);
      }

      return getClientConfig;
    }()
  }, {
    key: "getServerInfo",
    value: function () {
      var _getServerInfo = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4(span) {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.graphqlClientRequired(span);

              case 2:
                return _context4.abrupt("return", this.serverInfo);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getServerInfo(_x3) {
        return _getServerInfo.apply(this, arguments);
      }

      return getServerInfo;
    }()
  }, {
    key: "serverTimeDelta",
    value: function () {
      var _serverTimeDelta = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee5(span) {
        var serverInfo, clientConfig, start, response, end, responseData, serverTime;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getServerInfo(span);

              case 2:
                serverInfo = _context5.sent;
                clientConfig = this.graphqlClientConfig;

                if (!(clientConfig && serverInfo.supportsTime && serverInfo.timeDelta === null)) {
                  _context5.next = 21;
                  break;
                }

                _context5.prev = 5;
                start = Date.now(); // noinspection SpellCheckingInspection

                _context5.next = 9;
                return clientConfig.fetch("".concat(clientConfig.httpUrl, "?query=%7Binfo%7Btime%7D%7D"));

              case 9:
                response = _context5.sent;
                end = Date.now();
                _context5.next = 13;
                return response.json();

              case 13:
                responseData = _context5.sent;
                serverTime = responseData.data.info.time;
                serverInfo.timeDelta = Math.round(serverTime - (start + (end - start) / 2));
                _context5.next = 21;
                break;

              case 18:
                _context5.prev = 18;
                _context5.t0 = _context5["catch"](5);
                if (config._errLogVerbose) console.log('>>>', _context5.t0);

              case 21:
                return _context5.abrupt("return", serverInfo.timeDelta || 0);

              case 22:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[5, 18]]);
      }));

      function serverTimeDelta(_x4) {
        return _serverTimeDelta.apply(this, arguments);
      }

      return serverTimeDelta;
    }()
  }, {
    key: "serverNow",
    value: function () {
      var _serverNow = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee6(span) {
        var timeDelta;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.serverTimeDelta(span);

              case 2:
                timeDelta = _context6.sent;
                return _context6.abrupt("return", Date.now() + timeDelta);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function serverNow(_x5) {
        return _serverNow.apply(this, arguments);
      }

      return serverNow;
    }()
  }, {
    key: "dropServerTimeDelta",
    value: function dropServerTimeDelta() {
      if (this.serverInfo) {
        this.serverInfo.timeDelta = null;
      }
    }
  }, {
    key: "generateOperationId",
    value: function generateOperationId() {
      this.operationIdSuffix += 1;
      return "".concat(this.operationIdPrefix).concat(this.operationIdSuffix.toString(16));
    }
  }, {
    key: "finishOperations",
    value: function () {
      var _finishOperations = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee7(operationIds) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(operationIds.length === 0)) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return");

              case 2:
                _context7.next = 4;
                return this.getServerInfo();

              case 4:
                if (_context7.sent.supportsOperationId) {
                  _context7.next = 6;
                  break;
                }

                return _context7.abrupt("return");

              case 6:
                _context7.next = 8;
                return this.graphqlMutation("mutation finishOperations($operationIds: [String]) {\n                finishOperations(operationIds: $operationIds)\n            }", {
                  operationIds: operationIds
                });

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function finishOperations(_x6) {
        return _finishOperations.apply(this, arguments);
      }

      return finishOperations;
    }()
  }, {
    key: "getAccountsCount",
    value: function () {
      var _getAccountsCount = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee8(parentSpan) {
        var result;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.query('query{getAccountsCount}', undefined, parentSpan);

              case 2:
                result = _context8.sent;
                return _context8.abrupt("return", result.data.getAccountsCount);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getAccountsCount(_x7) {
        return _getAccountsCount.apply(this, arguments);
      }

      return getAccountsCount;
    }()
  }, {
    key: "getTransactionsCount",
    value: function () {
      var _getTransactionsCount = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee9(parentSpan) {
        var result;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.query('query{getTransactionsCount}', undefined, parentSpan);

              case 2:
                result = _context9.sent;
                return _context9.abrupt("return", result.data.getTransactionsCount);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getTransactionsCount(_x8) {
        return _getTransactionsCount.apply(this, arguments);
      }

      return getTransactionsCount;
    }()
  }, {
    key: "getAccountsTotalBalance",
    value: function () {
      var _getAccountsTotalBalance = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee10(parentSpan) {
        var result;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.query('query{getAccountsTotalBalance}', undefined, parentSpan);

              case 2:
                result = _context10.sent;
                return _context10.abrupt("return", result.data.getAccountsTotalBalance);

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getAccountsTotalBalance(_x9) {
        return _getAccountsTotalBalance.apply(this, arguments);
      }

      return getAccountsTotalBalance;
    }()
  }, {
    key: "postRequests",
    value: function () {
      var _postRequests = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee12(requests, parentSpan) {
        var _this2 = this;

        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                return _context12.abrupt("return", this.context.trace('queries.postRequests', /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee11(span) {
                    return _regenerator["default"].wrap(function _callee11$(_context11) {
                      while (1) {
                        switch (_context11.prev = _context11.next) {
                          case 0:
                            return _context11.abrupt("return", _this2.graphqlMutation("mutation postRequests($requests: [Request]) {\n                postRequests(requests: $requests)\n            }", {
                              requests: requests
                            }, span));

                          case 1:
                          case "end":
                            return _context11.stop();
                        }
                      }
                    }, _callee11);
                  }));

                  return function (_x12) {
                    return _ref.apply(this, arguments);
                  };
                }(), parentSpan));

              case 1:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function postRequests(_x10, _x11) {
        return _postRequests.apply(this, arguments);
      }

      return postRequests;
    }()
  }, {
    key: "mutation",
    value: function () {
      var _mutation = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee14(ql) {
        var _this3 = this;

        var variables,
            parentSpan,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                variables = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
                parentSpan = _args14.length > 2 ? _args14[2] : undefined;
                return _context14.abrupt("return", this.context.trace('queries.mutation', /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee13(span) {
                    return _regenerator["default"].wrap(function _callee13$(_context13) {
                      while (1) {
                        switch (_context13.prev = _context13.next) {
                          case 0:
                            span.setTag('params', {
                              mutation: ql,
                              variables: variables
                            });
                            return _context13.abrupt("return", _this3.graphqlMutation(ql, variables, span));

                          case 2:
                          case "end":
                            return _context13.stop();
                        }
                      }
                    }, _callee13);
                  }));

                  return function (_x14) {
                    return _ref2.apply(this, arguments);
                  };
                }(), parentSpan));

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function mutation(_x13) {
        return _mutation.apply(this, arguments);
      }

      return mutation;
    }()
  }, {
    key: "query",
    value: function () {
      var _query = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee16(ql) {
        var _this4 = this;

        var variables,
            parentSpan,
            timeout,
            _args16 = arguments;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                variables = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};
                parentSpan = _args16.length > 2 ? _args16[2] : undefined;
                timeout = _args16.length > 3 ? _args16[3] : undefined;
                return _context16.abrupt("return", this.context.trace('queries.query', /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee15(span) {
                    return _regenerator["default"].wrap(function _callee15$(_context15) {
                      while (1) {
                        switch (_context15.prev = _context15.next) {
                          case 0:
                            span.setTag('params', {
                              query: ql,
                              variables: variables
                            });
                            return _context15.abrupt("return", _this4.graphqlQuery(ql, variables, span, timeout));

                          case 2:
                          case "end":
                            return _context15.stop();
                        }
                      }
                    }, _callee15);
                  }));

                  return function (_x16) {
                    return _ref3.apply(this, arguments);
                  };
                }(), parentSpan));

              case 4:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function query(_x15) {
        return _query.apply(this, arguments);
      }

      return query;
    }()
  }, {
    key: "graphqlMutation",
    value: function () {
      var _graphqlMutation = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee17(ql) {
        var variables,
            span,
            mutation,
            _args17 = arguments;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                variables = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : {};
                span = _args17.length > 2 ? _args17[2] : undefined;
                mutation = (0, _graphqlTag["default"])([ql]);
                return _context17.abrupt("return", this.graphQl(function (client) {
                  return client.mutate({
                    mutation: mutation,
                    variables: variables,
                    context: {
                      traceSpan: span
                    }
                  });
                }));

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function graphqlMutation(_x17) {
        return _graphqlMutation.apply(this, arguments);
      }

      return graphqlMutation;
    }()
  }, {
    key: "graphqlQuery",
    value: function () {
      var _graphqlQuery = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee21(ql) {
        var _this5 = this;

        var variables,
            span,
            timeout,
            query,
            nextTimeout,
            startTime,
            forceTerminateExtraTimeout,
            forceTerminateTimeout,
            _ret,
            resolvedError,
            _args21 = arguments;

        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                variables = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : {};
                span = _args21.length > 2 ? _args21[2] : undefined;
                timeout = _args21.length > 3 ? _args21[3] : undefined;
                query = (0, _graphqlTag["default"])([ql]);
                nextTimeout = 100;
                startTime = Date.now();
                forceTerminateExtraTimeout = 5000;
                forceTerminateTimeout = timeout || this.config.waitForTimeout();

              case 8:
                if (false) {}

                _context21.prev = 9;
                return _context21.delegateYield( /*#__PURE__*/_regenerator["default"].mark(function _callee19() {
                  var client, context;
                  return _regenerator["default"].wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          _context19.next = 2;
                          return _this5.graphqlClientRequired(span);

                        case 2:
                          client = _context19.sent;
                          context = {
                            traceSpan: span,
                            fetchOptions: {
                              queryTimeout: Math.min(forceTerminateTimeout + forceTerminateExtraTimeout, MAX_TIMEOUT)
                            }
                          };
                          _context19.next = 6;
                          return new Promise(function (resolve, reject) {
                            _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee18() {
                              var isActual, doResolve, doReject;
                              return _regenerator["default"].wrap(function _callee18$(_context18) {
                                while (1) {
                                  switch (_context18.prev = _context18.next) {
                                    case 0:
                                      isActual = true;

                                      doResolve = function doResolve(result) {
                                        if (isActual) {
                                          isActual = false;
                                          resolve(result);
                                        }
                                      };

                                      doReject = function doReject(error) {
                                        if (isActual) {
                                          isActual = false;
                                          reject(error);
                                        }
                                      };

                                      _this5.registerQueryReject(doReject);

                                      _context18.prev = 4;
                                      _context18.t0 = doResolve;
                                      _context18.next = 8;
                                      return client.query({
                                        query: query,
                                        variables: variables,
                                        context: context
                                      });

                                    case 8:
                                      _context18.t1 = _context18.sent;
                                      (0, _context18.t0)(_context18.t1);
                                      _context18.next = 15;
                                      break;

                                    case 12:
                                      _context18.prev = 12;
                                      _context18.t2 = _context18["catch"](4);
                                      doReject(_context18.t2);

                                    case 15:
                                      _context18.prev = 15;

                                      _this5.unregisterQueryReject(doReject);

                                      return _context18.finish(15);

                                    case 18:
                                    case "end":
                                      return _context18.stop();
                                  }
                                }
                              }, _callee18, null, [[4, 12, 15, 18]]);
                            }))();
                          });

                        case 6:
                          _context19.t0 = _context19.sent;
                          return _context19.abrupt("return", {
                            v: _context19.t0
                          });

                        case 8:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19);
                })(), "t0", 11);

              case 11:
                _ret = _context21.t0;

                if (!(_typeof(_ret) === "object")) {
                  _context21.next = 14;
                  break;
                }

                return _context21.abrupt("return", _ret.v);

              case 14:
                _context21.next = 26;
                break;

              case 16:
                _context21.prev = 16;
                _context21.t1 = _context21["catch"](9);
                _context21.next = 20;
                return this.resolveGraphQLError(_context21.t1);

              case 20:
                resolvedError = _context21.sent;

                if (!(TONQueriesModule.isNetworkError(resolvedError) && !this.config.isNetworkTimeoutExpiredSince(startTime))) {
                  _context21.next = 25;
                  break;
                }

                return _context21.delegateYield( /*#__PURE__*/_regenerator["default"].mark(function _callee20() {
                  var retryDelayTimeout;
                  return _regenerator["default"].wrap(function _callee20$(_context20) {
                    while (1) {
                      switch (_context20.prev = _context20.next) {
                        case 0:
                          _this5.config.log(resolvedError);

                          retryDelayTimeout = nextTimeout;
                          _context20.next = 4;
                          return new Promise(function (resolve) {
                            return setTimeout(resolve, retryDelayTimeout);
                          });

                        case 4:
                          if (nextTimeout < 3200) {
                            nextTimeout *= 2;
                          }

                          if (forceTerminateExtraTimeout < _this5.config.waitForTimeout()) {
                            forceTerminateExtraTimeout += 5000;
                          }

                        case 6:
                        case "end":
                          return _context20.stop();
                      }
                    }
                  }, _callee20);
                })(), "t2", 23);

              case 23:
                _context21.next = 26;
                break;

              case 25:
                throw resolvedError;

              case 26:
                _context21.next = 8;
                break;

              case 28:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this, [[9, 16]]);
      }));

      function graphqlQuery(_x18) {
        return _graphqlQuery.apply(this, arguments);
      }

      return graphqlQuery;
    }()
  }, {
    key: "resolveGraphQLError",
    value: function () {
      var _resolveGraphQLError = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee22(error) {
        var gqlErr, clientErr, gqlExc, errors;
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                gqlErr = error.graphQLErrors && error.graphQLErrors[0];

                if (!gqlErr) {
                  _context22.next = 8;
                  break;
                }

                clientErr = new Error(gqlErr.message);
                gqlExc = gqlErr.extensions && gqlErr.extensions.exception || {};
                clientErr.number = gqlExc.code || 0;
                clientErr.code = gqlExc.code || 0;
                clientErr.source = gqlExc.source || 'client';
                return _context22.abrupt("return", clientErr);

              case 8:
                errors = error && error.networkError && error.networkError.result && error.networkError.result.errors;

                if (!errors) {
                  _context22.next = 16;
                  break;
                }

                _context22.t0 = _TONClientError.TONClientError;
                _context22.t1 = errors;
                _context22.next = 14;
                return this.completeErrorData();

              case 14:
                _context22.t2 = _context22.sent;
                return _context22.abrupt("return", _context22.t0.queryFailed.call(_context22.t0, _context22.t1, _context22.t2));

              case 16:
                return _context22.abrupt("return", error);

              case 17:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function resolveGraphQLError(_x19) {
        return _resolveGraphQLError.apply(this, arguments);
      }

      return resolveGraphQLError;
    }()
  }, {
    key: "graphQl",
    value: function () {
      var _graphQl = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee23(request, span) {
        var client;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.graphqlClientRequired(span);

              case 2:
                client = _context23.sent;
                _context23.prev = 3;
                _context23.next = 6;
                return request(client);

              case 6:
                return _context23.abrupt("return", _context23.sent);

              case 9:
                _context23.prev = 9;
                _context23.t0 = _context23["catch"](3);
                _context23.next = 13;
                return this.resolveGraphQLError(_context23.t0);

              case 13:
                throw _context23.sent;

              case 14:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this, [[3, 9]]);
      }));

      function graphQl(_x20, _x21) {
        return _graphQl.apply(this, arguments);
      }

      return graphQl;
    }()
  }, {
    key: "graphqlClientRequired",
    value: function () {
      var _graphqlClientRequired = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee24(parentSpan) {
        var _this6 = this;

        var creation;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                if (!this.graphqlClient) {
                  _context24.next = 2;
                  break;
                }

                return _context24.abrupt("return", this.graphqlClient);

              case 2:
                if (!this.graphqlClientCreation) {
                  _context24.next = 7;
                  break;
                }

                _context24.next = 5;
                return this.graphqlClientCreation.listen();

              case 5:
                _context24.next = 21;
                break;

              case 7:
                creation = new MulticastPromise();
                this.graphqlClientCreation = creation;
                _context24.prev = 9;
                _context24.next = 12;
                return this.context.trace('setup client', function (span) {
                  return _this6.createGraphqlClient(span);
                }, parentSpan);

              case 12:
                this.graphqlClientCreation = null;
                creation.resolve(this.graphqlClient);
                _context24.next = 21;
                break;

              case 16:
                _context24.prev = 16;
                _context24.t0 = _context24["catch"](9);
                this.graphqlClientCreation = null;
                creation.reject(_context24.t0);
                throw _context24.t0;

              case 21:
                return _context24.abrupt("return", this.graphqlClient);

              case 22:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this, [[9, 16]]);
      }));

      function graphqlClientRequired(_x22) {
        return _graphqlClientRequired.apply(this, arguments);
      }

      return graphqlClientRequired;
    }()
  }, {
    key: "createGraphqlClient",
    value: function () {
      var _createGraphqlClient = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee26(span) {
        var _this7 = this;

        var useHttp, clientConfig, subsOptions, subscriptionClient, guard, tracerLink, wrapLink, isSubscription, link;
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                useHttp = !this.config.data.useWebSocketForQueries;
                _context26.next = 3;
                return this.getClientConfig();

              case 3:
                clientConfig = _context26.sent;
                subsOptions = this.config.tracer.inject(span, _opentracing.FORMAT_TEXT_MAP, {});
                subscriptionClient = new _subscriptionsTransportWs.SubscriptionClient(clientConfig.wsUrl, {
                  timeout: KEEP_ALIVE_TIMEOUT,
                  reconnect: true,
                  connectionParams: function connectionParams() {
                    return {
                      accessKey: _this7.config.data && _this7.config.data.accessKey,
                      headers: subsOptions
                    };
                  }
                }, clientConfig.WebSocket);
                subscriptionClient.onReconnected(function () {
                  if (_this7.config._errLogVerbose) console.log('[TONClient.queries]', 'WebSocket Reconnected');

                  _this7.rejectActiveQueries();
                });
                guard = {
                  detectingRedirection: false
                };
                subscriptionClient.onError(function () {
                  if (_this7.config._errLogVerbose) console.log('[TONClient.queries]', 'WebSocket Failed');

                  if (guard.detectingRedirection) {
                    return;
                  }

                  _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee25() {
                    var newConfig, configIsChanged;
                    return _regenerator["default"].wrap(function _callee25$(_context25) {
                      while (1) {
                        switch (_context25.prev = _context25.next) {
                          case 0:
                            guard.detectingRedirection = true;
                            _context25.prev = 1;
                            _context25.next = 4;
                            return _this7.getClientConfig();

                          case 4:
                            newConfig = _context25.sent;
                            configIsChanged = newConfig.httpUrl !== clientConfig.httpUrl || newConfig.wsUrl !== clientConfig.wsUrl;

                            if (configIsChanged) {
                              if (_this7.config._logVerbose) console.log('[TONClient.queries]', 'Client config changed');
                              clientConfig = newConfig;
                              _this7.graphqlClientConfig = clientConfig;
                              subscriptionClient.url = newConfig.wsUrl;

                              if (_this7.wsLink) {
                                _this7.wsLink.url = newConfig.wsUrl;
                              }

                              if (_this7.httpLink) {
                                _this7.httpLink.uri = newConfig.httpUrl;
                              }
                            }

                            _context25.next = 12;
                            break;

                          case 9:
                            _context25.prev = 9;
                            _context25.t0 = _context25["catch"](1);
                            if (_this7.config._errLogVerbose) console.log('[TONClient.queries] redirection detector failed', _context25.t0);

                          case 12:
                            guard.detectingRedirection = false;

                          case 13:
                          case "end":
                            return _context25.stop();
                        }
                      }
                    }, _callee25, null, [[1, 9]]);
                  }))();
                });

                subscriptionClient.maxConnectTimeGenerator.duration = function () {
                  return subscriptionClient.maxConnectTimeGenerator.max;
                };

                _context26.next = 12;
                return (0, _apolloLinkContext.setContext)(function (_, req) {
                  var resolvedSpan = req && req.traceSpan || span;
                  req.headers = {};

                  _this7.config.tracer.inject(resolvedSpan, _opentracing.FORMAT_TEXT_MAP, req.headers);

                  var accessKey = _this7.config.data && _this7.config.data.accessKey;

                  if (accessKey) {
                    req.headers.accessKey = accessKey;
                  }

                  return {
                    headers: req.headers
                  };
                });

              case 12:
                tracerLink = _context26.sent;

                wrapLink = function wrapLink(link) {
                  return tracerLink.concat(link);
                };

                isSubscription = function isSubscription(_ref6) {
                  var query = _ref6.query;
                  var definition = (0, _apolloUtilities.getMainDefinition)(query);
                  return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
                };

                this.wsLink = new _apolloLinkWs.WebSocketLink(subscriptionClient);
                this.httpLink = useHttp ? new _apolloLinkHttp.HttpLink({
                  uri: clientConfig.httpUrl,
                  fetch: abortableFetch(clientConfig.fetch)
                }) : null;
                link = this.httpLink ? (0, _apolloLink.split)(isSubscription, wrapLink(this.wsLink), wrapLink(this.httpLink)) : wrapLink(this.wsLink);
                this.graphqlClientConfig = clientConfig;
                this.graphqlClient = new _apolloClient.ApolloClient({
                  cache: new _apolloCacheInmemory.InMemoryCache({}),
                  link: link,
                  defaultOptions: {
                    watchQuery: {
                      fetchPolicy: 'no-cache'
                    },
                    query: {
                      fetchPolicy: 'no-cache'
                    }
                  }
                });

              case 20:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function createGraphqlClient(_x23) {
        return _createGraphqlClient.apply(this, arguments);
      }

      return createGraphqlClient;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee27() {
        var client;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!this.graphqlClient) {
                  _context27.next = 6;
                  break;
                }

                client = this.graphqlClient;
                this.graphqlClient = null;
                client.stop();
                _context27.next = 6;
                return client.clearStore();

              case 6:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }], [{
    key: "isNetworkError",
    value: function isNetworkError(error) {
      if (error.code === _TONClientError.TONErrorCode.QUERY_FORCIBLY_ABORTED) {
        return true;
      }

      var networkError = error.networkError;

      if (!networkError) {
        return false;
      }

      if ('errno' in networkError) {
        return true;
      }

      return !('response' in networkError || 'result' in networkError);
    }
  }]);

  return TONQueriesModule;
}(_TONModule2.TONModule);

exports.default = TONQueriesModule;

var TONQueriesModuleCollection = /*#__PURE__*/function () {
  function TONQueriesModuleCollection(module, collectionName, typeName) {
    _classCallCheck(this, TONQueriesModuleCollection);

    _defineProperty(this, "module", void 0);

    _defineProperty(this, "collectionName", void 0);

    _defineProperty(this, "typeName", void 0);

    this.module = module;
    this.collectionName = collectionName;
    this.typeName = typeName;
  }

  _createClass(TONQueriesModuleCollection, [{
    key: "query",
    value: function () {
      var _query2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee29() {
        var _this8 = this;

        var _len,
            args,
            _key,
            _resolveParams,
            filter,
            result,
            orderBy,
            limit,
            timeout,
            operationId,
            parentSpan,
            _args29 = arguments;

        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                for (_len = _args29.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = _args29[_key];
                }

                _resolveParams = resolveParams(args, 'filter', function () {
                  return {
                    filter: args[0],
                    result: args[1],
                    orderBy: args[2],
                    limit: args[3],
                    timeout: args[4],
                    parentSpan: args[5]
                  };
                }), filter = _resolveParams.filter, result = _resolveParams.result, orderBy = _resolveParams.orderBy, limit = _resolveParams.limit, timeout = _resolveParams.timeout, operationId = _resolveParams.operationId, parentSpan = _resolveParams.parentSpan;
                return _context29.abrupt("return", this.module.context.trace("".concat(this.collectionName, ".query"), /*#__PURE__*/function () {
                  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee28(span) {
                    var useOperationId, c, t, ql, variables;
                    return _regenerator["default"].wrap(function _callee28$(_context28) {
                      while (1) {
                        switch (_context28.prev = _context28.next) {
                          case 0:
                            span.setTag('params', {
                              filter: filter,
                              result: result,
                              orderBy: orderBy,
                              limit: limit,
                              timeout: timeout,
                              operationId: operationId
                            });
                            _context28.t0 = operationId;

                            if (!_context28.t0) {
                              _context28.next = 6;
                              break;
                            }

                            _context28.next = 5;
                            return _this8.module.getServerInfo(span);

                          case 5:
                            _context28.t0 = _context28.sent.supportsOperationId;

                          case 6:
                            useOperationId = _context28.t0;
                            c = _this8.collectionName;
                            t = _this8.typeName;
                            ql = "\n            query ".concat(c, "(\n                $filter: ").concat(t, "Filter,\n                $orderBy: [QueryOrderBy], \n                $limit: Int, \n                $timeout: Float\n                ").concat(useOperationId ? ', $operationId: String' : '', "\n             ) {\n                ").concat(c, "(\n                    filter: $filter, \n                    orderBy: $orderBy, \n                    limit: $limit, \n                    timeout: $timeout\n                    ").concat(useOperationId ? ', operationId: $operationId' : '', "\n                ) { ").concat(result, " }\n            }");
                            variables = {
                              filter: filter,
                              orderBy: orderBy,
                              limit: limit
                            };

                            if (useOperationId) {
                              variables.operationId = operationId;
                            }

                            if (timeout) {
                              variables.timeout = Math.min(MAX_TIMEOUT, timeout);
                            }

                            _context28.next = 15;
                            return _this8.module.graphqlQuery(ql, variables, span, timeout);

                          case 15:
                            _context28.t1 = c;
                            return _context28.abrupt("return", _context28.sent.data[_context28.t1]);

                          case 17:
                          case "end":
                            return _context28.stop();
                        }
                      }
                    }, _callee28);
                  }));

                  return function (_x24) {
                    return _ref7.apply(this, arguments);
                  };
                }(), parentSpan));

              case 3:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function query() {
        return _query2.apply(this, arguments);
      }

      return query;
    }()
  }, {
    key: "aggregate",
    value: function () {
      var _aggregate = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee31(params) {
        var _this9 = this;

        return _regenerator["default"].wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                return _context31.abrupt("return", this.module.context.trace("".concat(this.collectionName, ".aggregate"), /*#__PURE__*/function () {
                  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee30(span) {
                    var t, q, ql, variables;
                    return _regenerator["default"].wrap(function _callee30$(_context30) {
                      while (1) {
                        switch (_context30.prev = _context30.next) {
                          case 0:
                            span.setTag('params', {
                              filter: params.filter,
                              fields: params.fields
                            });
                            _context30.next = 3;
                            return _this9.module.getServerInfo(span);

                          case 3:
                            if (_context30.sent.supportsAggregations) {
                              _context30.next = 9;
                              break;
                            }

                            _context30.t0 = _TONClientError.TONClientError;
                            _context30.next = 7;
                            return _this9.module.completeErrorData();

                          case 7:
                            _context30.t1 = _context30.sent;
                            throw _context30.t0.serverDoesntSupportAggregations.call(_context30.t0, _context30.t1);

                          case 9:
                            t = _this9.typeName;
                            q = _this9.typeName.endsWith('s') ? "aggregate".concat(t) : "aggregate".concat(t, "s");
                            ql = "\n            query ".concat(q, "(\n                $filter: ").concat(t, "Filter,\n                $fields: [FieldAggregation] \n             ) {\n                ").concat(q, "(\n                    filter: $filter, \n                    fields: $fields \n                )\n            }");
                            variables = {
                              filter: params.filter,
                              fields: params.fields
                            };
                            _context30.next = 15;
                            return _this9.module.graphqlQuery(ql, variables, span);

                          case 15:
                            _context30.t2 = q;
                            return _context30.abrupt("return", _context30.sent.data[_context30.t2]);

                          case 17:
                          case "end":
                            return _context30.stop();
                        }
                      }
                    }, _callee30);
                  }));

                  return function (_x26) {
                    return _ref8.apply(this, arguments);
                  };
                }(), params.parentSpan));

              case 1:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function aggregate(_x25) {
        return _aggregate.apply(this, arguments);
      }

      return aggregate;
    }()
  }, {
    key: "subscribe",
    value: function subscribe() {
      var _this10 = this;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var _resolveParams2 = resolveParams(args, 'filter', function () {
        return {
          filter: args[0],
          result: args[1],
          onDocEvent: args[2],
          onError: args[3]
        };
      }),
          filter = _resolveParams2.filter,
          result = _resolveParams2.result,
          onDocEvent = _resolveParams2.onDocEvent,
          onError = _resolveParams2.onError;

      var span = this.module.config.tracer.startSpan('TONQueriesModule.js:subscribe ');
      span.setTag(_opentracing.Tags.SPAN_KIND, 'client');
      var text = "subscription ".concat(this.collectionName, "($filter: ").concat(this.typeName, "Filter) {\n            ").concat(this.collectionName, "(filter: $filter) { ").concat(result, " }\n        }");
      var query = (0, _graphqlTag["default"])([text]);
      var subscription = null;

      _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee32() {
        var client, observable;
        return _regenerator["default"].wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.prev = 0;
                _context32.next = 3;
                return _this10.module.graphqlClientRequired(span);

              case 3:
                client = _context32.sent;
                observable = client.subscribe({
                  query: query,
                  variables: {
                    filter: filter
                  }
                });
                subscription = observable.subscribe(function (message) {
                  onDocEvent('insert/update', message.data[_this10.collectionName]);
                });
                _context32.next = 12;
                break;

              case 8:
                _context32.prev = 8;
                _context32.t0 = _context32["catch"](0);
                span.log({
                  event: 'failed',
                  payload: _context32.t0
                });

                if (onError) {
                  onError(_context32.t0);
                } else {
                  if (config._errLogVerbose) console.log('TON Client subscription error', _context32.t0);
                }

              case 12:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, null, [[0, 8]]);
      }))();

      return {
        unsubscribe: function unsubscribe() {
          if (subscription) {
            subscription.unsubscribe();
            span.finish();
          }
        }
      };
    }
  }, {
    key: "waitFor",
    value: function () {
      var _waitFor = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee33() {
        var _len3,
            args,
            _key3,
            _resolveParams3,
            filter,
            result,
            paramsTimeout,
            parentSpan,
            operationId,
            timeout,
            docs,
            _args33 = arguments;

        return _regenerator["default"].wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                for (_len3 = _args33.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = _args33[_key3];
                }

                _resolveParams3 = resolveParams(args, 'filter', function () {
                  return {
                    filter: args[0],
                    result: args[1],
                    timeout: args[2],
                    parentSpan: args[3]
                  };
                }), filter = _resolveParams3.filter, result = _resolveParams3.result, paramsTimeout = _resolveParams3.timeout, parentSpan = _resolveParams3.parentSpan, operationId = _resolveParams3.operationId;
                timeout = paramsTimeout || this.module.config.waitForTimeout();
                _context33.next = 5;
                return this.query({
                  filter: filter,
                  result: result,
                  timeout: timeout,
                  parentSpan: parentSpan,
                  operationId: operationId
                });

              case 5:
                docs = _context33.sent;

                if (!(docs.length > 0)) {
                  _context33.next = 8;
                  break;
                }

                return _context33.abrupt("return", docs[0]);

              case 8:
                _context33.t0 = _TONClientError.TONClientError;
                _context33.next = 11;
                return this.module.completeErrorData({
                  collection: this.collectionName
                });

              case 11:
                _context33.t1 = _context33.sent;
                throw _context33.t0.waitForTimeout.call(_context33.t0, _context33.t1);

              case 13:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function waitFor() {
        return _waitFor.apply(this, arguments);
      }

      return waitFor;
    }()
  }]);

  return TONQueriesModuleCollection;
}();

TONQueriesModule.moduleName = 'TONQueriesModule';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2R1bGVzL1RPTlF1ZXJpZXNNb2R1bGUuanMiXSwibmFtZXMiOlsiS0VFUF9BTElWRV9USU1FT1VUIiwiTUFYX1RJTUVPVVQiLCJyZXNvbHZlUGFyYW1zIiwiYXJncyIsInJlcXVpcmVkUGFyYW1OYW1lIiwicmVzb2x2ZUFyZ3MiLCJsZW5ndGgiLCJNdWx0aWNhc3RQcm9taXNlIiwibGlzdGVuZXJzIiwib25Db21wbGV0ZSIsImxpc3RlbmVyIiwicmVzb2x2ZSIsInJlamVjdCIsInB1c2giLCJQcm9taXNlIiwidmFsdWUiLCJjb21wbGV0ZSIsImVycm9yIiwiY29tcGxldGVMaXN0ZW5lciIsImZvckVhY2giLCJ2ZXJzaW9uVG9OdW1iZXIiLCJzIiwicGFydHMiLCJzcGxpdCIsIm1hcCIsIngiLCJOdW1iZXIiLCJzbGljZSIsInJlc29sdmVTZXJ2ZXJJbmZvIiwidmVyc2lvblN0cmluZyIsInZlcnNpb24iLCJzdXBwb3J0c09wZXJhdGlvbklkIiwic3VwcG9ydHNBZ2dyZWdhdGlvbnMiLCJzdXBwb3J0c1RpbWUiLCJ0aW1lRGVsdGEiLCJhYm9ydGFibGVGZXRjaCIsImZldGNoIiwiaW5wdXQiLCJvcHRpb25zIiwicXVlcnlUaW1lb3V0IiwiZmV0Y2hPcHRpb25zIiwiY29udHJvbGxlciIsImdsb2JhbCIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsInNldFRpbWVvdXQiLCJUT05DbGllbnRFcnJvciIsInF1ZXJ5Rm9yY2libHlBYm9ydGVkIiwiZW1wdHlUT05FcnJvckRhdGEiLCJhYm9ydCIsInRoZW4iLCJUT05RdWVyaWVzTW9kdWxlIiwiY29udGV4dCIsImdyYXBocWxDbGllbnQiLCJncmFwaHFsQ2xpZW50Q3JlYXRpb24iLCJncmFwaHFsQ2xpZW50Q29uZmlnIiwid3NMaW5rIiwiaHR0cExpbmsiLCJvdmVycmlkZVdzVXJsIiwib3BlcmF0aW9uSWRQcmVmaXgiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJpIiwicmFuZG9tUGFydCIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsIm9wZXJhdGlvbklkU3VmZml4Iiwic2VydmVySW5mbyIsImFjdGl2ZVF1ZXJpZXNSZWplY3RzIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVqZWN0cyIsImVyciIsImNvbmZpZyIsImdldE1vZHVsZSIsIlRPTkNvbmZpZ01vZHVsZSIsInRyYW5zYWN0aW9ucyIsIlRPTlF1ZXJpZXNNb2R1bGVDb2xsZWN0aW9uIiwibWVzc2FnZXMiLCJibG9ja3MiLCJhY2NvdW50cyIsImJsb2Nrc19zaWduYXR1cmVzIiwiaHR0cFVybCIsInNvdXJjZVVybCIsInJlc3BvbnNlIiwidGV4dCIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlSnNvbiIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJpbmZvIiwicmVkaXJlY3RlZCIsInVybCIsInNvdXJjZUxvY2F0aW9uIiwiVVJMUGFydHMiLCJmaXhRdWVyeSIsInRvTG93ZXJDYXNlIiwicmVzcG9uc2VMb2NhdGlvbiIsImdldENvbmZpZ0ZvclNlcnZlciIsInNlcnZlciIsImh0dHBQYXJ0cyIsImZpeFByb3RvY29sIiwiZml4UGF0aCIsImh0dHAiLCJ3cyIsIndzVXJsIiwiY2xpZW50UGxhdGZvcm0iLCJXZWJTb2NrZXQiLCJUT05DbGllbnQiLCJFcnJvciIsInNlcnZlcnMiLCJjbGllbnRDb25maWciLCJkZXRlY3RSZWRpcmVjdCIsIl8iLCJfZXJyTG9nVmVyYm9zZSIsImNvbnNvbGUiLCJsb2ciLCJtZXNzYWdlIiwiaHR0cF91cmwiLCJ3c191cmwiLCJzcGFuIiwiZ3JhcGhxbENsaWVudFJlcXVpcmVkIiwiZ2V0U2VydmVySW5mbyIsInN0YXJ0IiwiZW5kIiwianNvbiIsInJlc3BvbnNlRGF0YSIsInNlcnZlclRpbWUiLCJ0aW1lIiwic2VydmVyVGltZURlbHRhIiwib3BlcmF0aW9uSWRzIiwiZ3JhcGhxbE11dGF0aW9uIiwicGFyZW50U3BhbiIsInF1ZXJ5IiwidW5kZWZpbmVkIiwicmVzdWx0IiwiZ2V0QWNjb3VudHNDb3VudCIsImdldFRyYW5zYWN0aW9uc0NvdW50IiwiZ2V0QWNjb3VudHNUb3RhbEJhbGFuY2UiLCJyZXF1ZXN0cyIsInRyYWNlIiwicWwiLCJ2YXJpYWJsZXMiLCJzZXRUYWciLCJtdXRhdGlvbiIsInRpbWVvdXQiLCJncmFwaHFsUXVlcnkiLCJncmFwaFFsIiwiY2xpZW50IiwibXV0YXRlIiwidHJhY2VTcGFuIiwibmV4dFRpbWVvdXQiLCJzdGFydFRpbWUiLCJmb3JjZVRlcm1pbmF0ZUV4dHJhVGltZW91dCIsImZvcmNlVGVybWluYXRlVGltZW91dCIsIndhaXRGb3JUaW1lb3V0IiwibWluIiwiaXNBY3R1YWwiLCJkb1Jlc29sdmUiLCJkb1JlamVjdCIsInJlZ2lzdGVyUXVlcnlSZWplY3QiLCJ1bnJlZ2lzdGVyUXVlcnlSZWplY3QiLCJyZXNvbHZlR3JhcGhRTEVycm9yIiwicmVzb2x2ZWRFcnJvciIsImlzTmV0d29ya0Vycm9yIiwiaXNOZXR3b3JrVGltZW91dEV4cGlyZWRTaW5jZSIsInJldHJ5RGVsYXlUaW1lb3V0IiwiZ3FsRXJyIiwiZ3JhcGhRTEVycm9ycyIsImNsaWVudEVyciIsImdxbEV4YyIsImV4dGVuc2lvbnMiLCJleGNlcHRpb24iLCJudW1iZXIiLCJjb2RlIiwic291cmNlIiwiZXJyb3JzIiwibmV0d29ya0Vycm9yIiwiY29tcGxldGVFcnJvckRhdGEiLCJxdWVyeUZhaWxlZCIsInJlcXVlc3QiLCJsaXN0ZW4iLCJjcmVhdGlvbiIsImNyZWF0ZUdyYXBocWxDbGllbnQiLCJ1c2VIdHRwIiwidXNlV2ViU29ja2V0Rm9yUXVlcmllcyIsImdldENsaWVudENvbmZpZyIsInN1YnNPcHRpb25zIiwidHJhY2VyIiwiaW5qZWN0IiwiRk9STUFUX1RFWFRfTUFQIiwic3Vic2NyaXB0aW9uQ2xpZW50IiwiU3Vic2NyaXB0aW9uQ2xpZW50IiwicmVjb25uZWN0IiwiY29ubmVjdGlvblBhcmFtcyIsImFjY2Vzc0tleSIsImhlYWRlcnMiLCJvblJlY29ubmVjdGVkIiwicmVqZWN0QWN0aXZlUXVlcmllcyIsImd1YXJkIiwiZGV0ZWN0aW5nUmVkaXJlY3Rpb24iLCJvbkVycm9yIiwibmV3Q29uZmlnIiwiY29uZmlnSXNDaGFuZ2VkIiwiX2xvZ1ZlcmJvc2UiLCJ1cmkiLCJtYXhDb25uZWN0VGltZUdlbmVyYXRvciIsImR1cmF0aW9uIiwibWF4IiwicmVxIiwicmVzb2x2ZWRTcGFuIiwidHJhY2VyTGluayIsIndyYXBMaW5rIiwibGluayIsImNvbmNhdCIsImlzU3Vic2NyaXB0aW9uIiwiZGVmaW5pdGlvbiIsImtpbmQiLCJvcGVyYXRpb24iLCJXZWJTb2NrZXRMaW5rIiwiSHR0cExpbmsiLCJBcG9sbG9DbGllbnQiLCJjYWNoZSIsIkluTWVtb3J5Q2FjaGUiLCJkZWZhdWx0T3B0aW9ucyIsIndhdGNoUXVlcnkiLCJmZXRjaFBvbGljeSIsInN0b3AiLCJjbGVhclN0b3JlIiwiVE9ORXJyb3JDb2RlIiwiUVVFUllfRk9SQ0lCTFlfQUJPUlRFRCIsIlRPTk1vZHVsZSIsIm1vZHVsZSIsImNvbGxlY3Rpb25OYW1lIiwidHlwZU5hbWUiLCJmaWx0ZXIiLCJvcmRlckJ5IiwibGltaXQiLCJvcGVyYXRpb25JZCIsInVzZU9wZXJhdGlvbklkIiwiYyIsInQiLCJwYXJhbXMiLCJmaWVsZHMiLCJzZXJ2ZXJEb2VzbnRTdXBwb3J0QWdncmVnYXRpb25zIiwicSIsImVuZHNXaXRoIiwib25Eb2NFdmVudCIsInN0YXJ0U3BhbiIsIlRhZ3MiLCJTUEFOX0tJTkQiLCJzdWJzY3JpcHRpb24iLCJvYnNlcnZhYmxlIiwic3Vic2NyaWJlIiwiZXZlbnQiLCJwYXlsb2FkIiwidW5zdWJzY3JpYmUiLCJmaW5pc2giLCJwYXJhbXNUaW1lb3V0IiwiZG9jcyIsImNvbGxlY3Rpb24iLCJtb2R1bGVOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFNQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFZQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7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cEcsTSxtQkFBQUEsTSxFQUNTMkgsYSxtQkFBVGpILE8sRUFDQWIsVSxtQkFBQUEsVSxFQUNBMEcsVyxtQkFBQUEsVztBQU9FN0YsZ0JBQUFBLE8sR0FBVWlILGFBQWEsSUFBSSxLQUFLMUIsTUFBTCxDQUFZaEssTUFBWixDQUFtQm1GLGNBQW5CLEU7O3VCQUNkLEtBQUt0QixLQUFMLENBQVc7QUFDMUJzRyxrQkFBQUEsTUFBTSxFQUFOQSxNQUQwQjtBQUUxQnBHLGtCQUFBQSxNQUFNLEVBQU5BLE1BRjBCO0FBRzFCVSxrQkFBQUEsT0FBTyxFQUFQQSxPQUgwQjtBQUkxQmIsa0JBQUFBLFVBQVUsRUFBVkEsVUFKMEI7QUFLMUIwRyxrQkFBQUEsV0FBVyxFQUFYQTtBQUwwQixpQkFBWCxDOzs7QUFBYnFCLGdCQUFBQSxJOztzQkFPRkEsSUFBSSxDQUFDalEsTUFBTCxHQUFjLEM7Ozs7O21EQUNQaVEsSUFBSSxDQUFDLENBQUQsQzs7O2dDQUVUek4sOEI7O3VCQUFvQyxLQUFLOEwsTUFBTCxDQUFZdEQsaUJBQVosQ0FBOEI7QUFDcEVrRixrQkFBQUEsVUFBVSxFQUFFLEtBQUszQjtBQURtRCxpQkFBOUIsQzs7OztvQ0FBckI5RSxjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNN0I1RyxnQkFBZ0IsQ0FBQ3NOLFVBQWpCLEdBQThCLGtCQUE5QiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIwIFRPTiBERVYgU09MVVRJT05TIExURC5cbiAqL1xuXG4vLyBAZmxvd1xuXG5pbXBvcnQgeyBJbk1lbW9yeUNhY2hlIH0gZnJvbSAnYXBvbGxvLWNhY2hlLWlubWVtb3J5JztcbmltcG9ydCB7IEFwb2xsb0NsaWVudCB9IGZyb20gJ2Fwb2xsby1jbGllbnQnO1xuaW1wb3J0IHsgQXBvbGxvTGluaywgc3BsaXQgfSBmcm9tICdhcG9sbG8tbGluayc7XG5pbXBvcnQgeyBIdHRwTGluayB9IGZyb20gJ2Fwb2xsby1saW5rLWh0dHAnO1xuaW1wb3J0IHsgV2ViU29ja2V0TGluayB9IGZyb20gJ2Fwb2xsby1saW5rLXdzJztcbmltcG9ydCB7IGdldE1haW5EZWZpbml0aW9uIH0gZnJvbSAnYXBvbGxvLXV0aWxpdGllcyc7XG5pbXBvcnQgZ3FsIGZyb20gJ2dyYXBocWwtdGFnJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbkNsaWVudCB9IGZyb20gJ3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzJztcbmltcG9ydCB7IHNldENvbnRleHQgfSBmcm9tICdhcG9sbG8tbGluay1jb250ZXh0JztcbmltcG9ydCB7XG4gICAgRk9STUFUX1RFWFRfTUFQLCBUYWdzLCBTcGFuLCBTcGFuQ29udGV4dCxcbn0gZnJvbSAnb3BlbnRyYWNpbmcnO1xuaW1wb3J0IHR5cGUge1xuICAgIFRPTlF1ZXJpZXMsXG4gICAgVE9OUUNvbGxlY3Rpb24sXG4gICAgU3Vic2NyaXB0aW9uLFxuICAgIFRPTlF1ZXJ5UGFyYW1zLFxuICAgIFRPTlN1YnNjcmliZVBhcmFtcyxcbiAgICBUT05XYWl0Rm9yUGFyYW1zLFxuICAgIFRPTlF1ZXJ5QWdncmVnYXRlUGFyYW1zLFxufSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBUT05DbGllbnQgfSBmcm9tICcuLi9UT05DbGllbnQnO1xuaW1wb3J0IHsgZW1wdHlUT05FcnJvckRhdGEsIFRPTkNsaWVudEVycm9yLCBUT05FcnJvckNvZGUgfSBmcm9tICcuLi9UT05DbGllbnRFcnJvcic7XG5pbXBvcnQgdHlwZSB7IFRPTk1vZHVsZUNvbnRleHQgfSBmcm9tICcuLi9UT05Nb2R1bGUnO1xuaW1wb3J0IHsgVE9OTW9kdWxlIH0gZnJvbSAnLi4vVE9OTW9kdWxlJztcbmltcG9ydCBUT05Db25maWdNb2R1bGUsIHsgVVJMUGFydHMgfSBmcm9tICcuL1RPTkNvbmZpZ01vZHVsZSc7XG5cblxuZXhwb3J0IHR5cGUgUmVxdWVzdCA9IHtcbiAgICBpZDogc3RyaW5nLFxuICAgIGJvZHk6IHN0cmluZyxcbn1cblxuZXhwb3J0IHR5cGUgU2VydmVySW5mbyA9IHtcbiAgICB2ZXJzaW9uOiBudW1iZXIsXG4gICAgc3VwcG9ydHNPcGVyYXRpb25JZDogYm9vbGVhbixcbiAgICBzdXBwb3J0c0FnZ3JlZ2F0aW9uczogYm9vbGVhbixcbiAgICBzdXBwb3J0c1RpbWU6IGJvb2xlYW4sXG4gICAgdGltZURlbHRhOiA/bnVtYmVyLFxufTtcblxuXG50eXBlIEdyYXBoUUxDbGllbnRDb25maWcgPSB7XG4gICAgaHR0cFVybDogc3RyaW5nLFxuICAgIHdzVXJsOiBzdHJpbmcsXG4gICAgZmV0Y2g6IGFueSxcbiAgICBXZWJTb2NrZXQ6IGFueSxcbn07XG5cbi8vIEtlZXAtYWxpdmUgdGltZW91dCB1c2VkIHRvIHN1cHBvcnQga2VlcC1hbGl2ZSBjb25uZWN0aW9uIGNoZWNraW5nOlxuLy8gLSBFdmVyeSAxIG1pbnV0ZSBzZXJ2ZXIgc2VuZHMgR1FMX0NPTk5FQ1RJT05fS0VFUF9BTElWRSBtZXNzYWdlLlxuLy8gLSBFdmVyeSAyIG1pbnV0ZXMgY2xpZW50IGNoZWNrcyB0aGF0IEdRTF9DT05ORUNUSU9OX0tFRVBfQUxJVkUgbWVzc2FnZSB3YXMgcmVjZWl2ZWRcbi8vICAgd2l0aGluIGxhc3QgMiBtaW51dGVzLlxuLy8gLSBJZiBjbGllbnQgaGFkbid0IHJlY2VpdmVkIGtlZXAgYWxpdmUgbWVzc2FnZSBkdXJpbmcgbGFzdCAyIG1pbnV0ZXNcbi8vICAgaXQgY2xvc2VzIGNvbm5lY3Rpb24gYW5kIGdvZXMgdG8gcmVjb25uZWN0LlxuY29uc3QgS0VFUF9BTElWRV9USU1FT1VUID0gMiAqIDYwMDAwO1xuXG5leHBvcnQgY29uc3QgTUFYX1RJTUVPVVQgPSAyMTQ3NDgzNjQ3O1xuXG5mdW5jdGlvbiByZXNvbHZlUGFyYW1zPFQ+KGFyZ3M6IGFueVtdLCByZXF1aXJlZFBhcmFtTmFtZTogc3RyaW5nLCByZXNvbHZlQXJnczogKCkgPT4gVCk6IFQge1xuICAgIHJldHVybiAoYXJncy5sZW5ndGggPT09IDEpICYmIChyZXF1aXJlZFBhcmFtTmFtZSBpbiBhcmdzWzBdKSA/IGFyZ3NbMF0gOiByZXNvbHZlQXJncygpO1xufVxuXG50eXBlIE11bHRpY2FzdExpc3RlbmVyPFZhbHVlPiA9IHtcbiAgICByZXNvbHZlOiAodmFsdWU6IFZhbHVlKSA9PiB2b2lkO1xuICAgIHJlamVjdDogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbn07XG5cbmNsYXNzIE11bHRpY2FzdFByb21pc2U8VmFsdWU+IHtcbiAgICBsaXN0ZW5lcnM6IE11bHRpY2FzdExpc3RlbmVyPFZhbHVlPltdO1xuICAgIG9uQ29tcGxldGU6ID8oKCkgPT4gdm9pZCk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBsaXN0ZW4oKTogUHJvbWlzZTxWYWx1ZT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcjogTXVsdGljYXN0TGlzdGVuZXI8VmFsdWU+ID0ge1xuICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4ge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lci5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSh2YWx1ZTogVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShsaXN0ZW5lciA9PiBsaXN0ZW5lci5yZXNvbHZlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmVqZWN0KGVycm9yOiBFcnJvcikge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKGxpc3RlbmVyID0+IGxpc3RlbmVyLnJlamVjdChlcnJvcikpO1xuICAgIH1cblxuICAgIGNvbXBsZXRlKGNvbXBsZXRlTGlzdGVuZXI6IChsaXN0ZW5lcjogTXVsdGljYXN0TGlzdGVuZXI8VmFsdWU+KSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdGVuZXJzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBjb21wbGV0ZUxpc3RlbmVyKGxpc3RlbmVyKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2ZXJzaW9uVG9OdW1iZXIoczogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBwYXJ0cyA9IGAke3MgfHwgJyd9YC5zcGxpdCgnLicpXG4gICAgICAgIC5tYXAoeCA9PiBOdW1iZXIoeCkpXG4gICAgICAgIC5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoIDwgMykge1xuICAgICAgICBwYXJ0cy5wdXNoKDApO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHNbMF0gKiAxMDAwMDAwICsgcGFydHNbMV0gKiAxMDAwICsgcGFydHNbMl07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTZXJ2ZXJJbmZvKHZlcnNpb25TdHJpbmc6IHN0cmluZyB8IG51bGwgfCB0eXBlb2YgdW5kZWZpbmVkKTogU2VydmVySW5mbyB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25Ub051bWJlcih2ZXJzaW9uU3RyaW5nIHx8ICcwLjI0LjQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBzdXBwb3J0c09wZXJhdGlvbklkOiB2ZXJzaW9uID4gMjQwMDQsXG4gICAgICAgIHN1cHBvcnRzQWdncmVnYXRpb25zOiB2ZXJzaW9uID49IDI1MDAwLFxuICAgICAgICBzdXBwb3J0c1RpbWU6IHZlcnNpb24gPj0gMjYwMDMsXG4gICAgICAgIHRpbWVEZWx0YTogbnVsbCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhYm9ydGFibGVGZXRjaChmZXRjaCkge1xuICAgIHJldHVybiAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VGltZW91dDogbnVtYmVyIHwgdHlwZW9mIHVuZGVmaW5lZCA9IG9wdGlvbnMucXVlcnlUaW1lb3V0O1xuICAgICAgICAgICAgbGV0IGZldGNoT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAocXVlcnlUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IGdsb2JhbC5BYm9ydENvbnRyb2xsZXIgPyBuZXcgZ2xvYmFsLkFib3J0Q29udHJvbGxlcigpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChUT05DbGllbnRFcnJvci5xdWVyeUZvcmNpYmx5QWJvcnRlZChlbXB0eVRPTkVycm9yRGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcXVlcnlUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZldGNoKGlucHV0LCBmZXRjaE9wdGlvbnMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUT05RdWVyaWVzTW9kdWxlIGV4dGVuZHMgVE9OTW9kdWxlIGltcGxlbWVudHMgVE9OUXVlcmllcyB7XG4gICAgdHJhbnNhY3Rpb25zOiBUT05RQ29sbGVjdGlvbjtcbiAgICBtZXNzYWdlczogVE9OUUNvbGxlY3Rpb247XG4gICAgYmxvY2tzOiBUT05RQ29sbGVjdGlvbjtcbiAgICBhY2NvdW50czogVE9OUUNvbGxlY3Rpb247XG4gICAgYmxvY2tzX3NpZ25hdHVyZXM6IFRPTlFDb2xsZWN0aW9uO1xuXG4gICAgY29uZmlnOiBUT05Db25maWdNb2R1bGU7XG5cbiAgICBncmFwaHFsQ2xpZW50Q3JlYXRpb246ID9NdWx0aWNhc3RQcm9taXNlPEFwb2xsb0NsaWVudD47XG4gICAgZ3JhcGhxbENsaWVudDogP0Fwb2xsb0NsaWVudDtcbiAgICBncmFwaHFsQ2xpZW50Q29uZmlnOiA/R3JhcGhRTENsaWVudENvbmZpZztcbiAgICB3c0xpbms6ID9XZWJTb2NrZXRMaW5rO1xuICAgIGh0dHBMaW5rOiA/SHR0cExpbms7XG5cbiAgICBvdmVycmlkZVdzVXJsOiA/c3RyaW5nO1xuICAgIG9wZXJhdGlvbklkUHJlZml4OiBzdHJpbmc7XG4gICAgb3BlcmF0aW9uSWRTdWZmaXg6IG51bWJlcjtcbiAgICBzZXJ2ZXJJbmZvOiBTZXJ2ZXJJbmZvO1xuICAgIGFjdGl2ZVF1ZXJpZXNSZWplY3RzOiAoKGFueSkgPT4gdm9pZClbXTtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQ6IFRPTk1vZHVsZUNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuZ3JhcGhxbENsaWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JhcGhxbENsaWVudENyZWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncmFwaHFsQ2xpZW50Q29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy53c0xpbmsgPSBudWxsO1xuICAgICAgICB0aGlzLmh0dHBMaW5rID0gbnVsbDtcbiAgICAgICAgdGhpcy5vdmVycmlkZVdzVXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25JZFByZWZpeCA9IChEYXRlLm5vdygpICUgNjAwMDApLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCByYW5kb21QYXJ0ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbklkUHJlZml4ID0gYCR7dGhpcy5vcGVyYXRpb25JZFByZWZpeH0ke3JhbmRvbVBhcnR9YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZXJhdGlvbklkU3VmZml4ID0gMTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJJbmZvID0gcmVzb2x2ZVNlcnZlckluZm8oKTtcbiAgICAgICAgdGhpcy5hY3RpdmVRdWVyaWVzUmVqZWN0cyA9IFtdO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyUXVlcnlSZWplY3QocmVqZWN0OiAoYW55KSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUXVlcmllc1JlamVjdHMucHVzaChyZWplY3QpO1xuICAgIH1cblxuICAgIHVucmVnaXN0ZXJRdWVyeVJlamVjdChyZWplY3Q6IChhbnkpID0+IHZvaWQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmFjdGl2ZVF1ZXJpZXNSZWplY3RzLmluZGV4T2YocmVqZWN0KTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUXVlcmllc1JlamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlamVjdEFjdGl2ZVF1ZXJpZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlamVjdHMgPSB0aGlzLmFjdGl2ZVF1ZXJpZXNSZWplY3RzO1xuICAgICAgICB0aGlzLmFjdGl2ZVF1ZXJpZXNSZWplY3RzID0gW107XG4gICAgICAgIGNvbnN0IGVyciA9IFRPTkNsaWVudEVycm9yLnF1ZXJ5Rm9yY2libHlBYm9ydGVkKHt9KTtcbiAgICAgICAgcmVqZWN0cy5mb3JFYWNoKChyZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBhc3luYyBzZXR1cCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSB0aGlzLmNvbnRleHQuZ2V0TW9kdWxlKFRPTkNvbmZpZ01vZHVsZSk7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gbmV3IFRPTlF1ZXJpZXNNb2R1bGVDb2xsZWN0aW9uKHRoaXMsICd0cmFuc2FjdGlvbnMnLCAnVHJhbnNhY3Rpb24nKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG5ldyBUT05RdWVyaWVzTW9kdWxlQ29sbGVjdGlvbih0aGlzLCAnbWVzc2FnZXMnLCAnTWVzc2FnZScpO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IG5ldyBUT05RdWVyaWVzTW9kdWxlQ29sbGVjdGlvbih0aGlzLCAnYmxvY2tzJywgJ0Jsb2NrJyk7XG4gICAgICAgIHRoaXMuYWNjb3VudHMgPSBuZXcgVE9OUXVlcmllc01vZHVsZUNvbGxlY3Rpb24odGhpcywgJ2FjY291bnRzJywgJ0FjY291bnQnKTtcbiAgICAgICAgdGhpcy5ibG9ja3Nfc2lnbmF0dXJlcyA9XG4gICAgICAgICAgICBuZXcgVE9OUXVlcmllc01vZHVsZUNvbGxlY3Rpb24odGhpcywgJ2Jsb2Nrc19zaWduYXR1cmVzJywgJ0Jsb2NrU2lnbmF0dXJlcycpO1xuICAgIH1cblxuICAgIGdldFF1ZXJ5VXJsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBocWxDbGllbnRDb25maWc/Lmh0dHBVcmwgfHwgJyc7XG4gICAgfVxuXG4gICAgYXN5bmMgZGV0ZWN0UmVkaXJlY3QoZmV0Y2g6IGFueSwgc291cmNlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNvdXJjZVVybCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUpzb24gPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlckluZm8gPSByZXNvbHZlU2VydmVySW5mbyhyZXNwb25zZUpzb24uZGF0YS5pbmZvLnZlcnNpb24pO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UucmVkaXJlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UucmVkaXJlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VMb2NhdGlvbiA9IFVSTFBhcnRzLnBhcnNlKHNvdXJjZVVybClcbiAgICAgICAgICAgIC5maXhRdWVyeSgoKSA9PiAnJylcbiAgICAgICAgICAgIC50b1N0cmluZygpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VMb2NhdGlvbiA9IFVSTFBhcnRzLnBhcnNlKHJlc3BvbnNlLnVybClcbiAgICAgICAgICAgIC5maXhRdWVyeSgoKSA9PiAnJylcbiAgICAgICAgICAgIC50b1N0cmluZygpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlTG9jYXRpb24gIT09IHNvdXJjZUxvY2F0aW9uID8gcmVzcG9uc2UudXJsIDogJyc7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0Q2xpZW50Q29uZmlnKCk6IFByb21pc2U8R3JhcGhRTENsaWVudENvbmZpZz4ge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgY2xpZW50UGxhdGZvcm0gPSBUT05DbGllbnQuY2xpZW50UGxhdGZvcm07XG4gICAgICAgIGlmICghY2xpZW50UGxhdGZvcm0pIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdUT04gQ2xpZW50IGRvZXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZXRjaCA9IGNsaWVudFBsYXRmb3JtLmZldGNoO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbmZpZ0ZvclNlcnZlcihzZXJ2ZXI6IHN0cmluZyk6IEdyYXBoUUxDbGllbnRDb25maWcge1xuICAgICAgICAgICAgY29uc3QgaHR0cFBhcnRzID0gVVJMUGFydHMucGFyc2Uoc2VydmVyKVxuICAgICAgICAgICAgICAgIC5maXhQcm90b2NvbCh4ID0+ICh4ID09PSAnaHR0cDovLycgPyB4IDogJ2h0dHBzOi8vJykpXG4gICAgICAgICAgICAgICAgLmZpeFBhdGgoeCA9PiBgJHt4fS9ncmFwaHFsYCk7XG4gICAgICAgICAgICBjb25zdCBodHRwID0gaHR0cFBhcnRzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB3cyA9IGh0dHBQYXJ0c1xuICAgICAgICAgICAgICAgIC5maXhQcm90b2NvbCh4ID0+ICh4ID09PSAnaHR0cDovLycgPyAnd3M6Ly8nIDogJ3dzczovLycpKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodHRwVXJsOiBodHRwLFxuICAgICAgICAgICAgICAgIHdzVXJsOiB3cyxcbiAgICAgICAgICAgICAgICBmZXRjaDogY2xpZW50UGxhdGZvcm0uZmV0Y2gsXG4gICAgICAgICAgICAgICAgV2ViU29ja2V0OiBjbGllbnRQbGF0Zm9ybS5XZWJTb2NrZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBzZXJ2ZXIgb2YgY29uZmlnLmRhdGEuc2VydmVycykge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50Q29uZmlnID0gZ2V0Q29uZmlnRm9yU2VydmVyKHNlcnZlcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFNwZWxsQ2hlY2tpbmdJbnNwZWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RlZCA9IGF3YWl0IHRoaXMuZGV0ZWN0UmVkaXJlY3QoXG4gICAgICAgICAgICAgICAgICAgIGZldGNoLFxuICAgICAgICAgICAgICAgICAgICBgJHtjbGllbnRDb25maWcuaHR0cFVybH0/cXVlcnk9JTdCaW5mbyU3QnZlcnNpb24lN0QlN0RgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0ZWQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0dHBQYXJ0cyA9IFVSTFBhcnRzLnBhcnNlKHJlZGlyZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZml4UXVlcnkoXyA9PiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZy5odHRwVXJsID0gaHR0cFBhcnRzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZy53c1VybCA9IGh0dHBQYXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpeFByb3RvY29sKHggPT4gKHggPT09ICdodHRwOi8vJyA/ICd3czovLycgOiAnd3NzOi8vJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudENvbmZpZztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYoY29uZmlnLl9lcnJMb2dWZXJib3NlKSBjb25zb2xlLmxvZyhgW2dldENsaWVudENvbmZpZ10gZm9yIHNlcnZlciBcIiR7c2VydmVyfVwiIGZhaWxlZGAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvci50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwX3VybDogY2xpZW50Q29uZmlnLmh0dHBVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB3c191cmw6IGNsaWVudENvbmZpZy53c1VybCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0Q29uZmlnRm9yU2VydmVyKGNvbmZpZy5kYXRhLnNlcnZlcnNbMF0pO1xuICAgIH1cblxuICAgIGFzeW5jIGdldFNlcnZlckluZm8oc3Bhbj86IFNwYW4gfCBTcGFuQ29udGV4dCk6IFByb21pc2U8U2VydmVySW5mbz4ge1xuICAgICAgICBhd2FpdCB0aGlzLmdyYXBocWxDbGllbnRSZXF1aXJlZChzcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVySW5mbztcbiAgICB9XG5cbiAgICBhc3luYyBzZXJ2ZXJUaW1lRGVsdGEoc3Bhbj86IFNwYW4gfCBTcGFuQ29udGV4dCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLmdldFNlcnZlckluZm8oc3Bhbik7XG4gICAgICAgIGNvbnN0IGNsaWVudENvbmZpZyA9IHRoaXMuZ3JhcGhxbENsaWVudENvbmZpZztcbiAgICAgICAgaWYgKGNsaWVudENvbmZpZyAmJiBzZXJ2ZXJJbmZvLnN1cHBvcnRzVGltZSAmJiBzZXJ2ZXJJbmZvLnRpbWVEZWx0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFNwZWxsQ2hlY2tpbmdJbnNwZWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnRDb25maWcuZmV0Y2goYCR7Y2xpZW50Q29uZmlnLmh0dHBVcmx9P3F1ZXJ5PSU3QmluZm8lN0J0aW1lJTdEJTdEYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyVGltZSA9IHJlc3BvbnNlRGF0YS5kYXRhLmluZm8udGltZTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJJbmZvLnRpbWVEZWx0YSA9IE1hdGgucm91bmQoc2VydmVyVGltZSAtIChzdGFydCArIChlbmQgLSBzdGFydCkgLyAyKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5fZXJyTG9nVmVyYm9zZSkgY29uc29sZS5sb2coJz4+PicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VydmVySW5mby50aW1lRGVsdGEgfHwgMDtcbiAgICB9XG5cbiAgICBhc3luYyBzZXJ2ZXJOb3coc3Bhbj86IFNwYW4gfCBTcGFuQ29udGV4dCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHRpbWVEZWx0YSA9IGF3YWl0IHRoaXMuc2VydmVyVGltZURlbHRhKHNwYW4pO1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSArIHRpbWVEZWx0YTtcbiAgICB9XG5cbiAgICBkcm9wU2VydmVyVGltZURlbHRhKCkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJJbmZvKSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlckluZm8udGltZURlbHRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdlbmVyYXRlT3BlcmF0aW9uSWQoKTogc3RyaW5nIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25JZFN1ZmZpeCArPSAxO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcGVyYXRpb25JZFByZWZpeH0ke3RoaXMub3BlcmF0aW9uSWRTdWZmaXgudG9TdHJpbmcoMTYpfWA7XG4gICAgfVxuXG4gICAgYXN5bmMgZmluaXNoT3BlcmF0aW9ucyhvcGVyYXRpb25JZHM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGlmIChvcGVyYXRpb25JZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5nZXRTZXJ2ZXJJbmZvKCkpLnN1cHBvcnRzT3BlcmF0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmdyYXBocWxNdXRhdGlvbihgbXV0YXRpb24gZmluaXNoT3BlcmF0aW9ucygkb3BlcmF0aW9uSWRzOiBbU3RyaW5nXSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaE9wZXJhdGlvbnMob3BlcmF0aW9uSWRzOiAkb3BlcmF0aW9uSWRzKVxuICAgICAgICAgICAgfWAsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWNjb3VudHNDb3VudChwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCkpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5KCdxdWVyeXtnZXRBY2NvdW50c0NvdW50fScsIHVuZGVmaW5lZCwgcGFyZW50U3Bhbik7XG4gICAgICAgIHJldHVybiByZXN1bHQuZGF0YS5nZXRBY2NvdW50c0NvdW50O1xuICAgIH1cblxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uc0NvdW50KHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnkoJ3F1ZXJ5e2dldFRyYW5zYWN0aW9uc0NvdW50fScsIHVuZGVmaW5lZCwgcGFyZW50U3Bhbik7XG4gICAgICAgIHJldHVybiByZXN1bHQuZGF0YS5nZXRUcmFuc2FjdGlvbnNDb3VudDtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRBY2NvdW50c1RvdGFsQmFsYW5jZShwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCkpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5KCdxdWVyeXtnZXRBY2NvdW50c1RvdGFsQmFsYW5jZX0nLCB1bmRlZmluZWQsIHBhcmVudFNwYW4pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGEuZ2V0QWNjb3VudHNUb3RhbEJhbGFuY2U7XG4gICAgfVxuXG4gICAgYXN5bmMgcG9zdFJlcXVlc3RzKHJlcXVlc3RzOiBSZXF1ZXN0W10sIHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudHJhY2UoJ3F1ZXJpZXMucG9zdFJlcXVlc3RzJywgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBocWxNdXRhdGlvbihgbXV0YXRpb24gcG9zdFJlcXVlc3RzKCRyZXF1ZXN0czogW1JlcXVlc3RdKSB7XG4gICAgICAgICAgICAgICAgcG9zdFJlcXVlc3RzKHJlcXVlc3RzOiAkcmVxdWVzdHMpXG4gICAgICAgICAgICB9YCwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RzLFxuICAgICAgICAgICAgfSwgc3Bhbik7XG4gICAgICAgIH0sIHBhcmVudFNwYW4pO1xuICAgIH1cblxuICAgIGFzeW5jIG11dGF0aW9uKFxuICAgICAgICBxbDogc3RyaW5nLFxuICAgICAgICB2YXJpYWJsZXM6IHsgW3N0cmluZ106IGFueSB9ID0ge30sXG4gICAgICAgIHBhcmVudFNwYW4/OiAoU3BhbiB8IFNwYW5Db250ZXh0KSxcbiAgICApOiBQcm9taXNlPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnRyYWNlKCdxdWVyaWVzLm11dGF0aW9uJywgYXN5bmMgKHNwYW46IFNwYW4pID0+IHtcbiAgICAgICAgICAgIHNwYW4uc2V0VGFnKCdwYXJhbXMnLCB7XG4gICAgICAgICAgICAgICAgbXV0YXRpb246IHFsLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGhxbE11dGF0aW9uKHFsLCB2YXJpYWJsZXMsIHNwYW4pO1xuICAgICAgICB9LCBwYXJlbnRTcGFuKTtcbiAgICB9XG5cbiAgICBhc3luYyBxdWVyeShcbiAgICAgICAgcWw6IHN0cmluZyxcbiAgICAgICAgdmFyaWFibGVzOiB7IFtzdHJpbmddOiBhbnkgfSA9IHt9LFxuICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dCksXG4gICAgICAgIHRpbWVvdXQ/OiBudW1iZXIsXG4gICAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC50cmFjZSgncXVlcmllcy5xdWVyeScsIGFzeW5jIChzcGFuOiBTcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuLnNldFRhZygncGFyYW1zJywge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxbCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBocWxRdWVyeShxbCwgdmFyaWFibGVzLCBzcGFuLCB0aW1lb3V0KTtcbiAgICAgICAgfSwgcGFyZW50U3Bhbik7XG4gICAgfVxuXG4gICAgYXN5bmMgZ3JhcGhxbE11dGF0aW9uKHFsOiBzdHJpbmcsIHZhcmlhYmxlczogeyBbc3RyaW5nXTogYW55IH0gPSB7fSwgc3BhbjogU3Bhbik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gZ3FsKFtxbF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaFFsKChjbGllbnQpID0+IGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgbXV0YXRpb24sXG4gICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgdHJhY2VTcGFuOiBzcGFuLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc05ldHdvcmtFcnJvcihlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBUT05FcnJvckNvZGUuUVVFUllfRk9SQ0lCTFlfQUJPUlRFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya0Vycm9yID0gZXJyb3IubmV0d29ya0Vycm9yO1xuICAgICAgICBpZiAoIW5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZXJybm8nIGluIG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEoJ3Jlc3BvbnNlJyBpbiBuZXR3b3JrRXJyb3IgfHwgJ3Jlc3VsdCcgaW4gbmV0d29ya0Vycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBncmFwaHFsUXVlcnkoXG4gICAgICAgIHFsOiBzdHJpbmcsXG4gICAgICAgIHZhcmlhYmxlczogeyBbc3RyaW5nXTogYW55IH0gPSB7fSxcbiAgICAgICAgc3BhbjogU3BhbixcbiAgICAgICAgdGltZW91dD86IG51bWJlcixcbiAgICApOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGdxbChbcWxdKTtcbiAgICAgICAgbGV0IG5leHRUaW1lb3V0ID0gMTAwO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgZm9yY2VUZXJtaW5hdGVFeHRyYVRpbWVvdXQgPSA1MDAwO1xuICAgICAgICBjb25zdCBmb3JjZVRlcm1pbmF0ZVRpbWVvdXQgPSB0aW1lb3V0IHx8IHRoaXMuY29uZmlnLndhaXRGb3JUaW1lb3V0KCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ3JhcGhxbENsaWVudFJlcXVpcmVkKHNwYW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQ6IGFueSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VTcGFuOiBzcGFuLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VGltZW91dDogTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VUZXJtaW5hdGVUaW1lb3V0ICsgZm9yY2VUZXJtaW5hdGVFeHRyYVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTUFYX1RJTUVPVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0FjdHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb1Jlc29sdmUgPSAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0dWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb1JlamVjdCA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FjdHVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FjdHVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJRdWVyeVJlamVjdChkb1JlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvUmVzb2x2ZShhd2FpdCBjbGllbnQucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9SZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJRdWVyeVJlamVjdChkb1JlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkRXJyb3IgPSBhd2FpdCB0aGlzLnJlc29sdmVHcmFwaFFMRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChUT05RdWVyaWVzTW9kdWxlLmlzTmV0d29ya0Vycm9yKHJlc29sdmVkRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmNvbmZpZy5pc05ldHdvcmtUaW1lb3V0RXhwaXJlZFNpbmNlKHN0YXJ0VGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKHJlc29sdmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeURlbGF5VGltZW91dCA9IG5leHRUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheVRpbWVvdXQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUaW1lb3V0IDwgMzIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFRpbWVvdXQgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VUZXJtaW5hdGVFeHRyYVRpbWVvdXQgPCB0aGlzLmNvbmZpZy53YWl0Rm9yVGltZW91dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVRlcm1pbmF0ZUV4dHJhVGltZW91dCArPSA1MDAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzb2x2ZWRFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyByZXNvbHZlR3JhcGhRTEVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc3QgZ3FsRXJyID0gZXJyb3IuZ3JhcGhRTEVycm9ycyAmJiBlcnJvci5ncmFwaFFMRXJyb3JzWzBdO1xuICAgICAgICBpZiAoZ3FsRXJyKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRFcnIgPSBuZXcgRXJyb3IoZ3FsRXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgZ3FsRXhjID0gKGdxbEVyci5leHRlbnNpb25zICYmIGdxbEVyci5leHRlbnNpb25zLmV4Y2VwdGlvbikgfHwge307XG4gICAgICAgICAgICAoY2xpZW50RXJyOiBhbnkpLm51bWJlciA9IGdxbEV4Yy5jb2RlIHx8IDA7XG4gICAgICAgICAgICAoY2xpZW50RXJyOiBhbnkpLmNvZGUgPSBncWxFeGMuY29kZSB8fCAwO1xuICAgICAgICAgICAgKGNsaWVudEVycjogYW55KS5zb3VyY2UgPSBncWxFeGMuc291cmNlIHx8ICdjbGllbnQnO1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudEVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBlcnJvclxuICAgICAgICAgICAgJiYgZXJyb3IubmV0d29ya0Vycm9yXG4gICAgICAgICAgICAmJiBlcnJvci5uZXR3b3JrRXJyb3IucmVzdWx0XG4gICAgICAgICAgICAmJiBlcnJvci5uZXR3b3JrRXJyb3IucmVzdWx0LmVycm9ycztcbiAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIFRPTkNsaWVudEVycm9yLnF1ZXJ5RmFpbGVkKGVycm9ycywgYXdhaXQgdGhpcy5jb21wbGV0ZUVycm9yRGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgYXN5bmMgZ3JhcGhRbChyZXF1ZXN0OiAoY2xpZW50OiBBcG9sbG9DbGllbnQpID0+IFByb21pc2U8YW55Piwgc3BhbjogU3Bhbik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ3JhcGhxbENsaWVudFJlcXVpcmVkKHNwYW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QoY2xpZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMucmVzb2x2ZUdyYXBoUUxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBncmFwaHFsQ2xpZW50UmVxdWlyZWQocGFyZW50U3Bhbj86IFNwYW4gfCBTcGFuQ29udGV4dCk6IFByb21pc2U8QXBvbGxvQ2xpZW50PiB7XG4gICAgICAgIGlmICh0aGlzLmdyYXBocWxDbGllbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBocWxDbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhxbENsaWVudENyZWF0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdyYXBocWxDbGllbnRDcmVhdGlvbi5saXN0ZW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0aW9uID0gbmV3IE11bHRpY2FzdFByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhxbENsaWVudENyZWF0aW9uID0gY3JlYXRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udGV4dC50cmFjZSgnc2V0dXAgY2xpZW50JywgKHNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlR3JhcGhxbENsaWVudChzcGFuKTtcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnRTcGFuKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocWxDbGllbnRDcmVhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3JlYXRpb24ucmVzb2x2ZSh0aGlzLmdyYXBocWxDbGllbnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocWxDbGllbnRDcmVhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3JlYXRpb24ucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaHFsQ2xpZW50O1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUdyYXBocWxDbGllbnQoc3BhbjogU3BhbiB8IFNwYW5Db250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHVzZUh0dHAgPSAhdGhpcy5jb25maWcuZGF0YS51c2VXZWJTb2NrZXRGb3JRdWVyaWVzO1xuICAgICAgICBsZXQgY2xpZW50Q29uZmlnID0gYXdhaXQgdGhpcy5nZXRDbGllbnRDb25maWcoKTtcblxuICAgICAgICBjb25zdCBzdWJzT3B0aW9ucyA9IHRoaXMuY29uZmlnLnRyYWNlci5pbmplY3Qoc3BhbiwgRk9STUFUX1RFWFRfTUFQLCB7fSk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbkNsaWVudDogU3Vic2NyaXB0aW9uQ2xpZW50ICYgeyB1cmw6IHN0cmluZyB9ID0gbmV3IFN1YnNjcmlwdGlvbkNsaWVudChcbiAgICAgICAgICAgIGNsaWVudENvbmZpZy53c1VybCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBLRUVQX0FMSVZFX1RJTUVPVVQsXG4gICAgICAgICAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25QYXJhbXM6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0tleTogdGhpcy5jb25maWcuZGF0YSAmJiB0aGlzLmNvbmZpZy5kYXRhLmFjY2Vzc0tleSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc3Vic09wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpZW50Q29uZmlnLldlYlNvY2tldCxcbiAgICAgICAgKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uQ2xpZW50Lm9uUmVjb25uZWN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5jb25maWcuX2VyckxvZ1ZlcmJvc2UpIGNvbnNvbGUubG9nKCdbVE9OQ2xpZW50LnF1ZXJpZXNdJywgJ1dlYlNvY2tldCBSZWNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgdGhpcy5yZWplY3RBY3RpdmVRdWVyaWVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBndWFyZCA9IHtcbiAgICAgICAgICAgIGRldGVjdGluZ1JlZGlyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgc3Vic2NyaXB0aW9uQ2xpZW50Lm9uRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5jb25maWcuX2VyckxvZ1ZlcmJvc2UpIGNvbnNvbGUubG9nKCdbVE9OQ2xpZW50LnF1ZXJpZXNdJywgJ1dlYlNvY2tldCBGYWlsZWQnKTtcbiAgICAgICAgICAgIGlmIChndWFyZC5kZXRlY3RpbmdSZWRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ3VhcmQuZGV0ZWN0aW5nUmVkaXJlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZ0lzQ2hhbmdlZCA9IG5ld0NvbmZpZy5odHRwVXJsICE9PSBjbGllbnRDb25maWcuaHR0cFVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgbmV3Q29uZmlnLndzVXJsICE9PSBjbGllbnRDb25maWcud3NVcmw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdJc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLl9sb2dWZXJib3NlKSBjb25zb2xlLmxvZygnW1RPTkNsaWVudC5xdWVyaWVzXScsICdDbGllbnQgY29uZmlnIGNoYW5nZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZyA9IG5ld0NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhxbENsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkNsaWVudC51cmwgPSBuZXdDb25maWcud3NVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53c0xpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndzTGluay51cmwgPSBuZXdDb25maWcud3NVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odHRwTGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cExpbmsudXJpID0gbmV3Q29uZmlnLmh0dHBVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcuX2VyckxvZ1ZlcmJvc2UpIGNvbnNvbGUubG9nKCdbVE9OQ2xpZW50LnF1ZXJpZXNdIHJlZGlyZWN0aW9uIGRldGVjdG9yIGZhaWxlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGd1YXJkLmRldGVjdGluZ1JlZGlyZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Vic2NyaXB0aW9uQ2xpZW50Lm1heENvbm5lY3RUaW1lR2VuZXJhdG9yLmR1cmF0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbkNsaWVudC5tYXhDb25uZWN0VGltZUdlbmVyYXRvci5tYXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdHJhY2VyTGluayA9IGF3YWl0IHNldENvbnRleHQoKF8sIHJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRTcGFuID0gKHJlcSAmJiByZXEudHJhY2VTcGFuKSB8fCBzcGFuO1xuICAgICAgICAgICAgcmVxLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnRyYWNlci5pbmplY3QocmVzb2x2ZWRTcGFuLCBGT1JNQVRfVEVYVF9NQVAsIHJlcS5oZWFkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IHRoaXMuY29uZmlnLmRhdGEgJiYgdGhpcy5jb25maWcuZGF0YS5hY2Nlc3NLZXk7XG4gICAgICAgICAgICBpZiAoYWNjZXNzS2V5KSB7XG4gICAgICAgICAgICAgICAgcmVxLmhlYWRlcnMuYWNjZXNzS2V5ID0gYWNjZXNzS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXEuaGVhZGVycyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB3cmFwTGluayA9IChsaW5rOiBBcG9sbG9MaW5rKTogQXBvbGxvTGluayA9PiB0cmFjZXJMaW5rLmNvbmNhdChsaW5rKTtcbiAgICAgICAgY29uc3QgaXNTdWJzY3JpcHRpb24gPSAoeyBxdWVyeSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZ2V0TWFpbkRlZmluaXRpb24ocXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJ1xuICAgICAgICAgICAgICAgICYmIGRlZmluaXRpb24ub3BlcmF0aW9uID09PSAnc3Vic2NyaXB0aW9uJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLndzTGluayA9IG5ldyBXZWJTb2NrZXRMaW5rKHN1YnNjcmlwdGlvbkNsaWVudCk7XG4gICAgICAgIHRoaXMuaHR0cExpbmsgPSB1c2VIdHRwXG4gICAgICAgICAgICA/IG5ldyBIdHRwTGluayh7XG4gICAgICAgICAgICAgICAgdXJpOiBjbGllbnRDb25maWcuaHR0cFVybCxcbiAgICAgICAgICAgICAgICBmZXRjaDogYWJvcnRhYmxlRmV0Y2goY2xpZW50Q29uZmlnLmZldGNoKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmh0dHBMaW5rXG4gICAgICAgICAgICA/IHNwbGl0KGlzU3Vic2NyaXB0aW9uLCB3cmFwTGluayh0aGlzLndzTGluayksIHdyYXBMaW5rKHRoaXMuaHR0cExpbmspKVxuICAgICAgICAgICAgOiB3cmFwTGluayh0aGlzLndzTGluayk7XG4gICAgICAgIHRoaXMuZ3JhcGhxbENsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZztcbiAgICAgICAgdGhpcy5ncmFwaHFsQ2xpZW50ID0gbmV3IEFwb2xsb0NsaWVudCh7XG4gICAgICAgICAgICBjYWNoZTogbmV3IEluTWVtb3J5Q2FjaGUoe30pLFxuICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd2F0Y2hRdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhxbENsaWVudCkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5ncmFwaHFsQ2xpZW50O1xuICAgICAgICAgICAgdGhpcy5ncmFwaHFsQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNsaWVudC5zdG9wKCk7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuY2xlYXJTdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbmNsYXNzIFRPTlF1ZXJpZXNNb2R1bGVDb2xsZWN0aW9uIGltcGxlbWVudHMgVE9OUUNvbGxlY3Rpb24ge1xuICAgIG1vZHVsZTogVE9OUXVlcmllc01vZHVsZTtcblxuICAgIGNvbGxlY3Rpb25OYW1lOiBzdHJpbmc7XG5cbiAgICB0eXBlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG1vZHVsZTogVE9OUXVlcmllc01vZHVsZSxcbiAgICAgICAgY29sbGVjdGlvbk5hbWU6IHN0cmluZyxcbiAgICAgICAgdHlwZU5hbWU6IHN0cmluZyxcbiAgICApIHtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBjb2xsZWN0aW9uTmFtZTtcbiAgICAgICAgdGhpcy50eXBlTmFtZSA9IHR5cGVOYW1lO1xuICAgIH1cblxuICAgIGFzeW5jIHF1ZXJ5KFxuICAgICAgICAuLi5hcmdzXG4gICAgICAgIC8qXG4gICAgICAgICAgICBmaWx0ZXJPclBhcmFtczogYW55IHwgVE9OUXVlcnlQYXJhbXMsXG4gICAgICAgICAgICByZXN1bHQ6IHN0cmluZyxcbiAgICAgICAgICAgIG9yZGVyQnk/OiBPcmRlckJ5W10sXG4gICAgICAgICAgICBsaW1pdD86IG51bWJlcixcbiAgICAgICAgICAgIHRpbWVvdXQ/OiBudW1iZXIsXG4gICAgICAgICAgICBwYXJlbnRTcGFuPzogKFNwYW4gfCBTcGFuQ29udGV4dClcbiAgICAgICAgICovXG4gICAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgb3JkZXJCeSxcbiAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIG9wZXJhdGlvbklkLFxuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgfSA9IHJlc29sdmVQYXJhbXM8VE9OUXVlcnlQYXJhbXM+KGFyZ3MsICdmaWx0ZXInLCAoKSA9PiAoe1xuICAgICAgICAgICAgZmlsdGVyOiBhcmdzWzBdLFxuICAgICAgICAgICAgcmVzdWx0OiAoYXJnc1sxXTogYW55KSxcbiAgICAgICAgICAgIG9yZGVyQnk6IChhcmdzWzJdOiBhbnkpLFxuICAgICAgICAgICAgbGltaXQ6IChhcmdzWzNdOiBhbnkpLFxuICAgICAgICAgICAgdGltZW91dDogKGFyZ3NbNF06IGFueSksXG4gICAgICAgICAgICBwYXJlbnRTcGFuOiBhcmdzWzVdLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5jb250ZXh0LnRyYWNlKGAke3RoaXMuY29sbGVjdGlvbk5hbWV9LnF1ZXJ5YCwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgIHNwYW4uc2V0VGFnKCdwYXJhbXMnLCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICBvcmRlckJ5LFxuICAgICAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZU9wZXJhdGlvbklkID0gb3BlcmF0aW9uSWRcbiAgICAgICAgICAgICAgICAmJiAoYXdhaXQgdGhpcy5tb2R1bGUuZ2V0U2VydmVySW5mbyhzcGFuKSkuc3VwcG9ydHNPcGVyYXRpb25JZDtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMudHlwZU5hbWU7XG4gICAgICAgICAgICBjb25zdCBxbCA9IGBcbiAgICAgICAgICAgIHF1ZXJ5ICR7Y30oXG4gICAgICAgICAgICAgICAgJGZpbHRlcjogJHt0fUZpbHRlcixcbiAgICAgICAgICAgICAgICAkb3JkZXJCeTogW1F1ZXJ5T3JkZXJCeV0sIFxuICAgICAgICAgICAgICAgICRsaW1pdDogSW50LCBcbiAgICAgICAgICAgICAgICAkdGltZW91dDogRmxvYXRcbiAgICAgICAgICAgICAgICAke3VzZU9wZXJhdGlvbklkID8gJywgJG9wZXJhdGlvbklkOiBTdHJpbmcnIDogJyd9XG4gICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgJHtjfShcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAkZmlsdGVyLCBcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJCeTogJG9yZGVyQnksIFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogJGxpbWl0LCBcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogJHRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgJHt1c2VPcGVyYXRpb25JZCA/ICcsIG9wZXJhdGlvbklkOiAkb3BlcmF0aW9uSWQnIDogJyd9XG4gICAgICAgICAgICAgICAgKSB7ICR7cmVzdWx0fSB9XG4gICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlczogeyBbc3RyaW5nXTogYW55IH0gPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIG9yZGVyQnksXG4gICAgICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHVzZU9wZXJhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzLm9wZXJhdGlvbklkID0gb3BlcmF0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcy50aW1lb3V0ID0gTWF0aC5taW4oTUFYX1RJTUVPVVQsIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLm1vZHVsZS5ncmFwaHFsUXVlcnkocWwsIHZhcmlhYmxlcywgc3BhbiwgdGltZW91dCkpLmRhdGFbY107XG4gICAgICAgIH0sIHBhcmVudFNwYW4pO1xuICAgIH1cblxuICAgIGFzeW5jIGFnZ3JlZ2F0ZShcbiAgICAgICAgcGFyYW1zOiBUT05RdWVyeUFnZ3JlZ2F0ZVBhcmFtcyxcbiAgICApOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5jb250ZXh0LnRyYWNlKGAke3RoaXMuY29sbGVjdGlvbk5hbWV9LmFnZ3JlZ2F0ZWAsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuLnNldFRhZygncGFyYW1zJywge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogcGFyYW1zLmZpbHRlcixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHBhcmFtcy5maWVsZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IHRoaXMubW9kdWxlLmdldFNlcnZlckluZm8oc3BhbikpLnN1cHBvcnRzQWdncmVnYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVE9OQ2xpZW50RXJyb3Iuc2VydmVyRG9lc250U3VwcG9ydEFnZ3JlZ2F0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb2R1bGUuY29tcGxldGVFcnJvckRhdGEoKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMudHlwZU5hbWU7XG4gICAgICAgICAgICBjb25zdCBxID0gdGhpcy50eXBlTmFtZS5lbmRzV2l0aCgncycpID8gYGFnZ3JlZ2F0ZSR7dH1gIDogYGFnZ3JlZ2F0ZSR7dH1zYDtcbiAgICAgICAgICAgIGNvbnN0IHFsID0gYFxuICAgICAgICAgICAgcXVlcnkgJHtxfShcbiAgICAgICAgICAgICAgICAkZmlsdGVyOiAke3R9RmlsdGVyLFxuICAgICAgICAgICAgICAgICRmaWVsZHM6IFtGaWVsZEFnZ3JlZ2F0aW9uXSBcbiAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAke3F9KFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6ICRmaWx0ZXIsIFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6ICRmaWVsZHMgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZXM6IHsgW3N0cmluZ106IGFueSB9ID0ge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogcGFyYW1zLmZpbHRlcixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHBhcmFtcy5maWVsZHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLm1vZHVsZS5ncmFwaHFsUXVlcnkocWwsIHZhcmlhYmxlcywgc3BhbikpLmRhdGFbcV07XG4gICAgICAgIH0sIHBhcmFtcy5wYXJlbnRTcGFuKTtcbiAgICB9XG5cbiAgICBzdWJzY3JpYmUoXG4gICAgICAgIC4uLmFyZ3NcbiAgICAgICAgLypcbiAgICAgICAgZmlsdGVyT3JQYXJhbXM6IGFueSB8IFRPTlN1YnNjcmliZVBhcmFtcyxcbiAgICAgICAgcmVzdWx0Pzogc3RyaW5nLFxuICAgICAgICBvbkRvY0V2ZW50PzogRG9jRXZlbnQsXG4gICAgICAgIG9uRXJyb3I/OiAoZXJyOiBFcnJvcikgPT4gdm9pZFxuICAgICAgICAgKi9cbiAgICApOiBTdWJzY3JpcHRpb24ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBvbkRvY0V2ZW50LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgfSA9IHJlc29sdmVQYXJhbXM8VE9OU3Vic2NyaWJlUGFyYW1zPihhcmdzLCAnZmlsdGVyJywgKCkgPT4gKHtcbiAgICAgICAgICAgIGZpbHRlcjogYXJnc1swXSxcbiAgICAgICAgICAgIHJlc3VsdDogKGFyZ3NbMV06IGFueSksXG4gICAgICAgICAgICBvbkRvY0V2ZW50OiAoYXJnc1syXTogYW55KSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChhcmdzWzNdOiBhbnkpLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLm1vZHVsZS5jb25maWcudHJhY2VyLnN0YXJ0U3BhbignVE9OUXVlcmllc01vZHVsZS5qczpzdWJzY3JpYmUgJyk7XG4gICAgICAgIHNwYW4uc2V0VGFnKFRhZ3MuU1BBTl9LSU5ELCAnY2xpZW50Jyk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBgc3Vic2NyaXB0aW9uICR7dGhpcy5jb2xsZWN0aW9uTmFtZX0oJGZpbHRlcjogJHt0aGlzLnR5cGVOYW1lfUZpbHRlcikge1xuICAgICAgICAgICAgJHt0aGlzLmNvbGxlY3Rpb25OYW1lfShmaWx0ZXI6ICRmaWx0ZXIpIHsgJHtyZXN1bHR9IH1cbiAgICAgICAgfWA7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gZ3FsKFt0ZXh0XSk7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLm1vZHVsZS5ncmFwaHFsQ2xpZW50UmVxdWlyZWQoc3Bhbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZSA9IGNsaWVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25Eb2NFdmVudCgnaW5zZXJ0L3VwZGF0ZScsIG1lc3NhZ2UuZGF0YVt0aGlzLmNvbGxlY3Rpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNwYW4ubG9nKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdmYWlsZWQnLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZihjb25maWcuX2VyckxvZ1ZlcmJvc2UpIGNvbnNvbGUubG9nKCdUT04gQ2xpZW50IHN1YnNjcmlwdGlvbiBlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyB3YWl0Rm9yKFxuICAgICAgICAuLi5hcmdzXG4gICAgICAgIC8qXG4gICAgICAgIGZpbHRlck9yUGFyYW1zOiBhbnkgfCBUT05XYWl0Rm9yUGFyYW1zLFxuICAgICAgICByZXN1bHQ6IHN0cmluZyxcbiAgICAgICAgdGltZW91dD86IG51bWJlcixcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpXG4gICAgICAgICAqL1xuICAgICk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHBhcmFtc1RpbWVvdXQsXG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICAgICAgb3BlcmF0aW9uSWQsXG4gICAgICAgIH0gPSByZXNvbHZlUGFyYW1zPFRPTldhaXRGb3JQYXJhbXM+KGFyZ3MsICdmaWx0ZXInLCAoKSA9PiAoe1xuICAgICAgICAgICAgZmlsdGVyOiBhcmdzWzBdLFxuICAgICAgICAgICAgcmVzdWx0OiAoYXJnc1sxXTogYW55KSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IChhcmdzWzJdOiBhbnkpLFxuICAgICAgICAgICAgcGFyZW50U3BhbjogYXJnc1szXSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gcGFyYW1zVGltZW91dCB8fCB0aGlzLm1vZHVsZS5jb25maWcud2FpdEZvclRpbWVvdXQoKTtcbiAgICAgICAgY29uc3QgZG9jcyA9IGF3YWl0IHRoaXMucXVlcnkoe1xuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIHBhcmVudFNwYW4sXG4gICAgICAgICAgICBvcGVyYXRpb25JZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2NzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkb2NzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFRPTkNsaWVudEVycm9yLndhaXRGb3JUaW1lb3V0KGF3YWl0IHRoaXMubW9kdWxlLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IHRoaXMuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5cblRPTlF1ZXJpZXNNb2R1bGUubW9kdWxlTmFtZSA9ICdUT05RdWVyaWVzTW9kdWxlJztcbiJdfQ==

/***/ }),

/***/ "./node_modules/ton-client-js/dist/modules/crypto-box.js":
/*!***************************************************************!*\
  !*** ./node_modules/ton-client-js/dist/modules/crypto-box.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodeMessage = decodeMessage;
exports.encodeOutput = encodeOutput;
exports.CoreCryptoBox = exports.DEFAULT_HD_PATH = exports.DEFAULT_MNEMONIC_WORD_COUNT = exports.DEFAULT_MNEMONIC_DICTIONARY = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function decodeMessage(message) {
  if (message.base64) {
    return Buffer.from(message.base64, 'base64');
  }

  if (message.hex) {
    return Buffer.from(message.hex, 'hex');
  }

  return Buffer.from(message.text || '', 'utf8');
}

function encodeOutput(buffer, encoding) {
  switch (encoding) {
    case 'Base64':
      return buffer.toString('base64');

    case 'Hex':
      return buffer.toString('hex');

    case 'HexUppercase':
      return buffer.toString('hex').toUpperCase();

    default:
      return buffer.toString('utf8');
  }
}

var notImplemented = new Error('Not implemented');

var CoreSigningBox = /*#__PURE__*/function () {
  function CoreSigningBox(cryptoBox, hdPath) {
    _classCallCheck(this, CoreSigningBox);

    _defineProperty(this, "cryptoBox", void 0);

    _defineProperty(this, "hdPath", void 0);

    _defineProperty(this, "publicKey", void 0);

    this.cryptoBox = cryptoBox;
    this.hdPath = hdPath;
    this.publicKey = null;
  }

  _createClass(CoreSigningBox, [{
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.publicKey) {
                  _context.next = 4;
                  break;
                }

                _context.next = 3;
                return this.cryptoBox.getSignKeys(this.hdPath);

              case 3:
                this.publicKey = _context.sent["public"];

              case 4:
                return _context.abrupt("return", this.publicKey);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPublicKey() {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(message, outputEncoding) {
        var keys;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.cryptoBox.getSignKeys(this.hdPath);

              case 2:
                keys = _context2.sent;
                return _context2.abrupt("return", this.cryptoBox.crypto.naclSignDetached(message, "".concat(keys.secret).concat(keys["public"]), outputEncoding));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sign(_x, _x2) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }]);

  return CoreSigningBox;
}();

var CoreEncryptionBox = /*#__PURE__*/function () {
  function CoreEncryptionBox() {
    _classCallCheck(this, CoreEncryptionBox);
  }

  _createClass(CoreEncryptionBox, [{
    key: "getPublicKey",
    // eslint-disable-next-line class-methods-use-this
    value: function getPublicKey() {
      throw notImplemented;
    } // eslint-disable-next-line class-methods-use-this,no-unused-vars

  }, {
    key: "encrypt",
    value: function encrypt(message, outputEncoding) {
      throw notImplemented;
    } // eslint-disable-next-line class-methods-use-this,no-unused-vars

  }, {
    key: "decrypt",
    value: function decrypt(message, outputEncoding) {
      throw notImplemented;
    }
  }]);

  return CoreEncryptionBox;
}();

var DEFAULT_MNEMONIC_DICTIONARY = 1;
exports.DEFAULT_MNEMONIC_DICTIONARY = DEFAULT_MNEMONIC_DICTIONARY;
var DEFAULT_MNEMONIC_WORD_COUNT = 12;
exports.DEFAULT_MNEMONIC_WORD_COUNT = DEFAULT_MNEMONIC_WORD_COUNT;
var DEFAULT_HD_PATH = 'm/44\'/396\'/0\'/0/0';
exports.DEFAULT_HD_PATH = DEFAULT_HD_PATH;

function resolveHDPath(path) {
  if (path === null || typeof path === 'undefined') {
    return DEFAULT_HD_PATH;
  }

  return path || 'm';
}

var CoreCryptoBox = /*#__PURE__*/function () {
  function CoreCryptoBox(crypto, params) {
    _classCallCheck(this, CoreCryptoBox);

    _defineProperty(this, "crypto", void 0);

    _defineProperty(this, "encryptedSeedPhrase", void 0);

    _defineProperty(this, "seedPhraseEncryptionBox", void 0);

    _defineProperty(this, "seedPhraseDictionary", void 0);

    _defineProperty(this, "seedPhraseWordCount", void 0);

    _defineProperty(this, "signingBoxes", void 0);

    _defineProperty(this, "encryptionBoxes", void 0);

    this.crypto = crypto;
    this.encryptedSeedPhrase = params.encryptedSeedPhrase;
    this.seedPhraseEncryptionBox = params.seedPhraseEncryptionBox;
    this.seedPhraseDictionary = params.seedPhraseDictionary || DEFAULT_MNEMONIC_DICTIONARY;
    this.seedPhraseWordCount = params.seedPhraseWordCount || DEFAULT_MNEMONIC_WORD_COUNT;
    this.signingBoxes = new Map();
    this.encryptionBoxes = new Map();
  }

  _createClass(CoreCryptoBox, [{
    key: "getSigningBox",
    value: function () {
      var _getSigningBox = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(params) {
        var hdPath, signingBox;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                hdPath = resolveHDPath(params === null || params === void 0 ? void 0 : params.hdPath);
                signingBox = this.signingBoxes.get(hdPath);

                if (!signingBox) {
                  signingBox = new CoreSigningBox(this, hdPath);
                  this.signingBoxes.set(hdPath, signingBox);
                }

                return _context3.abrupt("return", signingBox);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSigningBox(_x3) {
        return _getSigningBox.apply(this, arguments);
      }

      return getSigningBox;
    }() // eslint-disable-next-line class-methods-use-this,no-unused-vars

  }, {
    key: "getEncryptionBox",
    value: function getEncryptionBox(params) {
      throw notImplemented;
    }
  }, {
    key: "close",
    value: function close() {
      this.signingBoxes.clear();
      this.encryptionBoxes.clear();
      return Promise.resolve();
    } // Internals

  }, {
    key: "getSignKeys",
    value: function () {
      var _getSignKeys = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4(hdPath) {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.t0 = this.crypto;
                _context4.next = 3;
                return this.seedPhraseEncryptionBox.decrypt(this.encryptedSeedPhrase, 'Text');

              case 3:
                _context4.t1 = _context4.sent;
                _context4.t2 = hdPath;
                _context4.t3 = this.seedPhraseDictionary;
                _context4.t4 = this.seedPhraseWordCount;
                _context4.t5 = {
                  phrase: _context4.t1,
                  path: _context4.t2,
                  dictionary: _context4.t3,
                  wordCount: _context4.t4
                };
                return _context4.abrupt("return", _context4.t0.mnemonicDeriveSignKeys.call(_context4.t0, _context4.t5));

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getSignKeys(_x4) {
        return _getSignKeys.apply(this, arguments);
      }

      return getSignKeys;
    }()
  }]);

  return CoreCryptoBox;
}();

exports.CoreCryptoBox = CoreCryptoBox;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2R1bGVzL2NyeXB0by1ib3guanMiXSwibmFtZXMiOlsiZGVjb2RlTWVzc2FnZSIsIm1lc3NhZ2UiLCJiYXNlNjQiLCJCdWZmZXIiLCJmcm9tIiwiaGV4IiwidGV4dCIsImVuY29kZU91dHB1dCIsImJ1ZmZlciIsImVuY29kaW5nIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsIm5vdEltcGxlbWVudGVkIiwiRXJyb3IiLCJDb3JlU2lnbmluZ0JveCIsImNyeXB0b0JveCIsImhkUGF0aCIsInB1YmxpY0tleSIsImdldFNpZ25LZXlzIiwib3V0cHV0RW5jb2RpbmciLCJrZXlzIiwiY3J5cHRvIiwibmFjbFNpZ25EZXRhY2hlZCIsInNlY3JldCIsIkNvcmVFbmNyeXB0aW9uQm94IiwiREVGQVVMVF9NTkVNT05JQ19ESUNUSU9OQVJZIiwiREVGQVVMVF9NTkVNT05JQ19XT1JEX0NPVU5UIiwiREVGQVVMVF9IRF9QQVRIIiwicmVzb2x2ZUhEUGF0aCIsInBhdGgiLCJDb3JlQ3J5cHRvQm94IiwicGFyYW1zIiwiZW5jcnlwdGVkU2VlZFBocmFzZSIsInNlZWRQaHJhc2VFbmNyeXB0aW9uQm94Iiwic2VlZFBocmFzZURpY3Rpb25hcnkiLCJzZWVkUGhyYXNlV29yZENvdW50Iiwic2lnbmluZ0JveGVzIiwiTWFwIiwiZW5jcnlwdGlvbkJveGVzIiwic2lnbmluZ0JveCIsImdldCIsInNldCIsImNsZWFyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJkZWNyeXB0IiwicGhyYXNlIiwiZGljdGlvbmFyeSIsIndvcmRDb3VudCIsIm1uZW1vbmljRGVyaXZlU2lnbktleXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQk8sU0FBU0EsYUFBVCxDQUF1QkMsT0FBdkIsRUFBeUQ7QUFDNUQsTUFBSUEsT0FBTyxDQUFDQyxNQUFaLEVBQW9CO0FBQ2hCLFdBQU9DLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxPQUFPLENBQUNDLE1BQXBC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QVAsSUFBOEJULDJCQUF6RDtBQUNBLFNBQUtVLFlBQUwsR0FBb0IsSUFBSUMsR0FBSixFQUFwQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUIsSUFBSUQsR0FBSixFQUF2QjtBQUNIOzs7OzswR0FFbUJOLE07Ozs7OztBQUNWZixnQkFBQUEsTSxHQUFTWSxhQUFhLENBQUNHLE1BQUQsYUFBQ0EsTUFBRCx1QkFBQ0EsTUFBTSxDQUFFZixNQUFULEM7QUFDeEJ1QixnQkFBQUEsVSxHQUFhLEtBQUtILFlBQUwsQ0FBa0JJLEdBQWxCLENBQXNCeEIsTUFBdEIsQzs7QUFDakIsb0JBQUksQ0FBQ3VCLFVBQUwsRUFBaUI7QUFDYkEsa0JBQUFBLFVBQVUsR0FBRyxJQUFJekIsY0FBSixDQUFtQixJQUFuQixFQUF5QkUsTUFBekIsQ0FBYjtBQUNBLHVCQUFLb0IsWUFBTCxDQUFrQkssR0FBbEIsQ0FBc0J6QixNQUF0QixFQUE4QnVCLFVBQTlCO0FBQ0g7O2tEQUNNQSxVOzs7Ozs7Ozs7Ozs7Ozs7UUFHWDs7OztxQ0FDaUJSLE0sRUFJYTtBQUMxQixZQUFNbkIsY0FBTjtBQUNIOzs7NEJBRXNCO0FBQ25CLFdBQUt3QixZQUFMLENBQWtCTSxLQUFsQjtBQUNBLFdBQUtKLGVBQUwsQ0FBcUJJLEtBQXJCO0FBQ0EsYUFBT0MsT0FBTyxDQUFDQyxPQUFSLEVBQVA7QUFDSCxLLENBRUQ7Ozs7O3dHQUVrQjVCLE07Ozs7OytCQUNQLEtBQUtLLE07O3VCQUNNLEtBQUtZLHVCQUFMLENBQTZCWSxPQUE3QixDQUFxQyxLQUFLYixtQkFBMUMsRUFBK0QsTUFBL0QsQzs7OzsrQkFDUmhCLE07K0JBQ00sS0FBS2tCLG9COytCQUNOLEtBQUtDLG1COztBQUhoQlcsa0JBQUFBLE07QUFDQWpCLGtCQUFBQSxJO0FBQ0FrQixrQkFBQUEsVTtBQUNBQyxrQkFBQUEsUzs7K0RBSmVDLHNCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHR5cGUge1xuICAgIFRPTkNyeXB0byxcbiAgICBUT05DcnlwdG9Cb3gsXG4gICAgVE9OQ3J5cHRvQm94UGFyYW1zLFxuICAgIFRPTkVuY3J5cHRpb25BbGdvcml0aG0sXG4gICAgVE9ORW5jcnlwdGlvbkJveCxcbiAgICBUT05JbnB1dE1lc3NhZ2UsXG4gICAgVE9OS2V5UGFpckRhdGEsXG4gICAgVE9OTW5lbW9uaWNEaWN0aW9uYXJ5VHlwZSxcbiAgICBUT05NbmVtb25pY1dvcmRDb3VudFR5cGUsXG4gICAgVE9OT3V0cHV0RW5jb2RpbmdUeXBlLFxuICAgIFRPTlNpZ25pbmdCb3gsXG59IGZyb20gJy4uLy4uL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1lc3NhZ2UobWVzc2FnZTogVE9OSW5wdXRNZXNzYWdlKTogQnVmZmVyIHtcbiAgICBpZiAobWVzc2FnZS5iYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG1lc3NhZ2UuYmFzZTY0LCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmhleCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obWVzc2FnZS5oZXgsICdoZXgnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG1lc3NhZ2UudGV4dCB8fCAnJywgJ3V0ZjgnKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlT3V0cHV0KGJ1ZmZlcjogQnVmZmVyLCBlbmNvZGluZzogVE9OT3V0cHV0RW5jb2RpbmdUeXBlKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnQmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY2FzZSAnSGV4JzpcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gICAgY2FzZSAnSGV4VXBwZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxufVxuXG5jb25zdCBub3RJbXBsZW1lbnRlZCA9IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cblxuY2xhc3MgQ29yZVNpZ25pbmdCb3ggaW1wbGVtZW50cyBUT05TaWduaW5nQm94IHtcbiAgICBjcnlwdG9Cb3g6IENvcmVDcnlwdG9Cb3g7XG4gICAgaGRQYXRoOiBzdHJpbmc7XG4gICAgcHVibGljS2V5OiA/c3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoY3J5cHRvQm94OiBDb3JlQ3J5cHRvQm94LCBoZFBhdGg6IHN0cmluZykge1xuICAgICAgICB0aGlzLmNyeXB0b0JveCA9IGNyeXB0b0JveDtcbiAgICAgICAgdGhpcy5oZFBhdGggPSBoZFBhdGg7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbnVsbDtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRQdWJsaWNLZXkoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSAoYXdhaXQgdGhpcy5jcnlwdG9Cb3guZ2V0U2lnbktleXModGhpcy5oZFBhdGgpKS5wdWJsaWM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgIH1cblxuICAgIGFzeW5jIHNpZ24obWVzc2FnZTogVE9OSW5wdXRNZXNzYWdlLCBvdXRwdXRFbmNvZGluZzogVE9OT3V0cHV0RW5jb2RpbmdUeXBlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IHRoaXMuY3J5cHRvQm94LmdldFNpZ25LZXlzKHRoaXMuaGRQYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvQm94LmNyeXB0by5uYWNsU2lnbkRldGFjaGVkKG1lc3NhZ2UsIGAke2tleXMuc2VjcmV0fSR7a2V5cy5wdWJsaWN9YCwgb3V0cHV0RW5jb2RpbmcpO1xuICAgIH1cbn1cblxuXG5jbGFzcyBDb3JlRW5jcnlwdGlvbkJveCBpbXBsZW1lbnRzIFRPTkVuY3J5cHRpb25Cb3gge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgZ2V0UHVibGljS2V5KCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRocm93IG5vdEltcGxlbWVudGVkO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLG5vLXVudXNlZC12YXJzXG4gICAgZW5jcnlwdChtZXNzYWdlOiBUT05JbnB1dE1lc3NhZ2UsIG91dHB1dEVuY29kaW5nOiBUT05PdXRwdXRFbmNvZGluZ1R5cGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0aHJvdyBub3RJbXBsZW1lbnRlZDtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyxuby11bnVzZWQtdmFyc1xuICAgIGRlY3J5cHQobWVzc2FnZTogVE9OSW5wdXRNZXNzYWdlLCBvdXRwdXRFbmNvZGluZzogVE9OT3V0cHV0RW5jb2RpbmdUeXBlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhyb3cgbm90SW1wbGVtZW50ZWQ7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX01ORU1PTklDX0RJQ1RJT05BUlkgPSAxO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTU5FTU9OSUNfV09SRF9DT1VOVCA9IDEyO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSERfUEFUSCA9ICdtLzQ0XFwnLzM5NlxcJy8wXFwnLzAvMCc7XG5cbmZ1bmN0aW9uIHJlc29sdmVIRFBhdGgocGF0aD86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHBhdGggPT09IG51bGwgfHwgdHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0hEX1BBVEg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoIHx8ICdtJztcbn1cblxuZXhwb3J0IGNsYXNzIENvcmVDcnlwdG9Cb3ggaW1wbGVtZW50cyBUT05DcnlwdG9Cb3gge1xuICAgIGNyeXB0bzogVE9OQ3J5cHRvO1xuICAgIGVuY3J5cHRlZFNlZWRQaHJhc2U6IFRPTklucHV0TWVzc2FnZTtcbiAgICBzZWVkUGhyYXNlRW5jcnlwdGlvbkJveDogVE9ORW5jcnlwdGlvbkJveDtcbiAgICBzZWVkUGhyYXNlRGljdGlvbmFyeTogVE9OTW5lbW9uaWNEaWN0aW9uYXJ5VHlwZTtcbiAgICBzZWVkUGhyYXNlV29yZENvdW50OiBUT05NbmVtb25pY1dvcmRDb3VudFR5cGU7XG5cbiAgICBzaWduaW5nQm94ZXM6IE1hcDxzdHJpbmcsIENvcmVTaWduaW5nQm94PjtcbiAgICBlbmNyeXB0aW9uQm94ZXM6IE1hcDxzdHJpbmcsIENvcmVFbmNyeXB0aW9uQm94PjtcblxuICAgIGNvbnN0cnVjdG9yKGNyeXB0bzogVE9OQ3J5cHRvLCBwYXJhbXM6IFRPTkNyeXB0b0JveFBhcmFtcykge1xuICAgICAgICB0aGlzLmNyeXB0byA9IGNyeXB0bztcbiAgICAgICAgdGhpcy5lbmNyeXB0ZWRTZWVkUGhyYXNlID0gcGFyYW1zLmVuY3J5cHRlZFNlZWRQaHJhc2U7XG4gICAgICAgIHRoaXMuc2VlZFBocmFzZUVuY3J5cHRpb25Cb3ggPSBwYXJhbXMuc2VlZFBocmFzZUVuY3J5cHRpb25Cb3g7XG4gICAgICAgIHRoaXMuc2VlZFBocmFzZURpY3Rpb25hcnkgPSBwYXJhbXMuc2VlZFBocmFzZURpY3Rpb25hcnkgfHwgREVGQVVMVF9NTkVNT05JQ19ESUNUSU9OQVJZO1xuICAgICAgICB0aGlzLnNlZWRQaHJhc2VXb3JkQ291bnQgPSBwYXJhbXMuc2VlZFBocmFzZVdvcmRDb3VudCB8fCBERUZBVUxUX01ORU1PTklDX1dPUkRfQ09VTlQ7XG4gICAgICAgIHRoaXMuc2lnbmluZ0JveGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVuY3J5cHRpb25Cb3hlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRTaWduaW5nQm94KHBhcmFtcz86IHsgaGRQYXRoPzogc3RyaW5nIH0pOiBQcm9taXNlPFRPTlNpZ25pbmdCb3g+IHtcbiAgICAgICAgY29uc3QgaGRQYXRoID0gcmVzb2x2ZUhEUGF0aChwYXJhbXM/LmhkUGF0aCk7XG4gICAgICAgIGxldCBzaWduaW5nQm94ID0gdGhpcy5zaWduaW5nQm94ZXMuZ2V0KGhkUGF0aCk7XG4gICAgICAgIGlmICghc2lnbmluZ0JveCkge1xuICAgICAgICAgICAgc2lnbmluZ0JveCA9IG5ldyBDb3JlU2lnbmluZ0JveCh0aGlzLCBoZFBhdGgpO1xuICAgICAgICAgICAgdGhpcy5zaWduaW5nQm94ZXMuc2V0KGhkUGF0aCwgc2lnbmluZ0JveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25pbmdCb3g7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsbm8tdW51c2VkLXZhcnNcbiAgICBnZXRFbmNyeXB0aW9uQm94KHBhcmFtczoge1xuICAgICAgICBoZFBhdGg/OiBzdHJpbmcsXG4gICAgICAgIGFsZ29yaXRobTogVE9ORW5jcnlwdGlvbkFsZ29yaXRobSxcbiAgICAgICAgYWxnb3JpdGhtT3B0aW9uczogeyBbc3RyaW5nXTogYW55IH0sXG4gICAgfSk6IFByb21pc2U8VE9ORW5jcnlwdGlvbkJveD4ge1xuICAgICAgICB0aHJvdyBub3RJbXBsZW1lbnRlZDtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5zaWduaW5nQm94ZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5lbmNyeXB0aW9uQm94ZXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgYXN5bmMgZ2V0U2lnbktleXMoaGRQYXRoOiBzdHJpbmcpOiBQcm9taXNlPFRPTktleVBhaXJEYXRhPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyeXB0by5tbmVtb25pY0Rlcml2ZVNpZ25LZXlzKHtcbiAgICAgICAgICAgIHBocmFzZTogYXdhaXQgdGhpcy5zZWVkUGhyYXNlRW5jcnlwdGlvbkJveC5kZWNyeXB0KHRoaXMuZW5jcnlwdGVkU2VlZFBocmFzZSwgJ1RleHQnKSxcbiAgICAgICAgICAgIHBhdGg6IGhkUGF0aCxcbiAgICAgICAgICAgIGRpY3Rpb25hcnk6IHRoaXMuc2VlZFBocmFzZURpY3Rpb25hcnksXG4gICAgICAgICAgICB3b3JkQ291bnQ6IHRoaXMuc2VlZFBocmFzZVdvcmRDb3VudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19

/***/ }),

/***/ "./node_modules/ton-client-js/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ton-client-js/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright 2018-2020 TON DEV SOLUTIONS LTD.
 */

const { TONClient } = __webpack_require__(/*! ./dist/TONClient */ "./node_modules/ton-client-js/dist/TONClient.js");
const {
    TONAddressStringVariant,
    TONClientTransactionPhase,
    TONClientComputeSkippedStatus,
    TONClientStorageStatus,
    QInMsgType,
    QOutMsgType,
    QMessageType,
    QMessageProcessingStatus,
    QBlockProcessingStatus,
    QSplitType,
    QAccountType,
    QTransactionType,
    QTransactionProcessingStatus,
    QAccountStatus,
    QAccountStatusChange,
    QComputeType,
    QSkipReason,
    QBounceType,
} = __webpack_require__(/*! ./dist/modules/TONContractsModule */ "./node_modules/ton-client-js/dist/modules/TONContractsModule.js");

const {
    TONOutputEncoding,
    TONMnemonicDictionary,
} = __webpack_require__(/*! ./dist/modules/TONCryptoModule */ "./node_modules/ton-client-js/dist/modules/TONCryptoModule.js");

module.exports = {
    TONClient,
    TONAddressStringVariant,
    TONClientTransactionPhase,
    TONClientComputeSkippedStatus,
    TONClientStorageStatus,
    QInMsgType,
    QOutMsgType,
    QMessageType,
    QMessageProcessingStatus,
    QBlockProcessingStatus,
    QSplitType,
    QAccountType,
    QTransactionType,
    QTransactionProcessingStatus,
    QAccountStatus,
    QAccountStatusChange,
    QComputeType,
    QSkipReason,
    QBounceType,

    TONOutputEncoding,
    TONMnemonicDictionary,
};


/***/ }),

/***/ "./node_modules/ton-client-web-js/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ton-client-web-js/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLibrary": () => (/* binding */ createLibrary),
/* harmony export */   "setWasmOptions": () => (/* binding */ setWasmOptions),
/* harmony export */   "clientPlatform": () => (/* binding */ clientPlatform),
/* harmony export */   "initTONClient": () => (/* binding */ initTONClient),
/* harmony export */   "TONClient": () => (/* reexport safe */ ton_client_js__WEBPACK_IMPORTED_MODULE_0__.TONClient)
/* harmony export */ });
/* harmony import */ var ton_client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ton-client-js */ "./node_modules/ton-client-js/index.js");
/* harmony import */ var ton_client_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ton_client_js__WEBPACK_IMPORTED_MODULE_0__);

const workerScript = `

const wasmWrapper = (function() {
let wasm = null;
const result = {
    setup: (newWasm) => {
        wasm = newWasm;
    },
};


const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
/**
* @returns {number}
*/
result.core_create_context = function() {
    var ret = wasm.core_create_context();
    return ret >>> 0;
}

/**
* @param {number} context
*/
result.core_destroy_context = function(context) {
    wasm.core_destroy_context(context);
}

let WASM_VECTOR_LEN = 0;

let cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}
/**
* @param {number} context
* @param {string} method
* @param {string} params_json
* @returns {string}
*/
result.core_json_request = function(context, method, params_json) {
    try {
        var ptr0 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = passStringToWasm0(params_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        wasm.core_json_request(8, context, ptr0, len0, ptr1, len1);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function handleError(f) {
    return function () {
        try {
            return f.apply(this, arguments);

        } catch (e) {
            wasm.__wbindgen_exn_store(addHeapObject(e));
        }
    };
}

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
    result.wbg = {};
    result.wbg.__wbg_new0_8d817915cd890bd8 = function() {
        var ret = new Date();
        return addHeapObject(ret);
    };
    result.wbg.__wbg_getTime_8e7a0578598e5039 = function(arg0) {
        var ret = getObject(arg0).getTime();
        return ret;
    };
    result.wbg.__wbindgen_object_drop_ref = function(arg0) {
        takeObject(arg0);
    };
    result.wbg.__wbg_static_accessor_MODULE_abf5ae284bffdf45 = function() {
        var ret = module;
        return addHeapObject(ret);
    };
    result.wbg.__wbg_self_1c83eb4471d9eb9b = handleError(function() {
        var ret = self.self;
        return addHeapObject(ret);
    });
    result.wbg.__wbg_require_5b2b5b594d809d9f = function(arg0, arg1, arg2) {
        var ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));
        return addHeapObject(ret);
    };
    result.wbg.__wbg_crypto_c12f14e810edcaa2 = function(arg0) {
        var ret = getObject(arg0).crypto;
        return addHeapObject(ret);
    };
    result.wbg.__wbg_msCrypto_679be765111ba775 = function(arg0) {
        var ret = getObject(arg0).msCrypto;
        return addHeapObject(ret);
    };
    result.wbg.__wbindgen_is_undefined = function(arg0) {
        var ret = getObject(arg0) === undefined;
        return ret;
    };
    result.wbg.__wbg_getRandomValues_05a60bf171bfc2be = function(arg0) {
        var ret = getObject(arg0).getRandomValues;
        return addHeapObject(ret);
    };
    result.wbg.__wbg_getRandomValues_3ac1b33c90b52596 = function(arg0, arg1, arg2) {
        getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));
    };
    result.wbg.__wbg_randomFillSync_6f956029658662ec = function(arg0, arg1, arg2) {
        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
    };
    result.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };
   return result;
})()


self.onmessage = (e) => {
    const message = e.data;
    const setup = message.setup;
    if (setup) {
        (async () => {
            const instance = (await WebAssembly.instantiate(setup.wasmModule, {
                wbg: wasmWrapper.wbg
            })).exports;
            wasmWrapper.setup(instance);
            postMessage({
                setup: {}
            })
        })();
        return;
    }
    const request = message.request;
    if (request) {
        let result;
        try {
            if (request.method === 'context.create') {
                const context = wasmWrapper.core_create_context();
                result = JSON.stringify({result_json: JSON.stringify(context), error_json: ''});
            } else if (request.method === 'context.destroy') {
                wasmWrapper.core_destroy_context(request.context);
                result = JSON.stringify({result_json: '', error_json: ''});
            } else {
                result = wasmWrapper.core_json_request(request.context, request.method, request.params);
            }
        } catch (error) {
            result = JSON.stringify({
                result_json: '',
                error_json: JSON.stringify({
                    code: 6,
                    message: error.toString()
                })
            });
        }
        postMessage({
            response: {
                id: request.id,
                result,
            }
        });
    }
};
`;


const wasmOptions = {
    debugLog: null,
    binaryURL: '/tonclient.wasm',
};

function debugLog(message) {
    if (wasmOptions.debugLog) {
        wasmOptions.debugLog(message);
    }
}

const createLibrary = async () => {
    const workerBlob = new Blob(
        [workerScript],
        { type: 'application/javascript' }
    );
    const workerUrl = URL.createObjectURL(workerBlob);
    const worker = new Worker(workerUrl);

    const activeRequests = new Map();

    // Deferred requests are accumulated before WASM module have been loaded
    let deferredRequests = [];

    let nextActiveRequestId = 1;

    worker.onerror = (evt) => {
        console.log(`Error from Web Worker: ${evt.message}`);
    };

    const coreRequest = (context, method, params, callback) => {
        const id = nextActiveRequestId;
        nextActiveRequestId += 1;
        const request = {
            id,
            context,
            method,
            params,
        };
        const isDeferredSetup = (method === 'setup') && (deferredRequests !== null);
        activeRequests.set(id, {
            callback: isDeferredSetup ? () => {
            } : callback
        });
        if (deferredRequests !== null) {
            deferredRequests.push(request);
        } else {
            worker.postMessage({ request });
        }
        if (isDeferredSetup) {
            callback('', '');
        }
    }

    let legacyCoreContext = null;
    const library = {
        coreCreateContext: (callback) => {
            coreRequest(0, 'context.create', '', (resultJson) => {
                if (callback) {
                    const context = JSON.parse(resultJson);
                    callback(context);
                }
            });
        },
        coreDestroyContext: (context, callback) => {
            coreRequest(context, 'context.destroy', '', () => {
                if (callback) {
                    callback();
                }
            });
        },
        coreRequest,
        request: (method, params, callback) => {
            if (legacyCoreContext === null) {
                library.coreCreateContext((context) => {
                    legacyCoreContext = context;
                    coreRequest(legacyCoreContext, method, params, callback);
                });
            } else {
                coreRequest(legacyCoreContext, method, params, callback);
            }
        },
    };

    worker.onmessage = (evt) => {
        const setup = evt.data.setup;
        if (setup) {
            for (const request of deferredRequests) {
                worker.postMessage({ request });
            }
            deferredRequests = null;
            return;
        }

        const response = evt.data.response;
        if (response) {
            const activeRequest = activeRequests.get(response.id);
            if (!activeRequest) {
                return;
            }
            activeRequests.delete(response.id);
            if (activeRequest.callback) {
                let { result } = response;
                // Remove BOM from result
                result = result.charCodeAt(0) === 0xFEFF ? result.substr(1) : result;
                const { result_json, error_json } = JSON.parse(result);
                activeRequest.callback(result_json, error_json);
            }
        }
    };

    (async () => {
        const e = Date.now();
        let wasmModule;
        const fetched = fetch(wasmOptions.binaryURL);
        if (WebAssembly.compileStreaming) {
            debugLog('compileStreaming binary');
            wasmModule = await WebAssembly.compileStreaming(fetched);
        } else {
            debugLog('compile binary');
            wasmModule = await WebAssembly.compile(await (await fetched).arrayBuffer());
        }
        worker.postMessage({
            setup: {
                wasmModule,
            }
        });
        debugLog(`compile time ${Date.now() - e}`);
    })();

    return Promise.resolve(library);
};

function setWasmOptions(options) {
    Object.assign(wasmOptions, options);
}

const clientPlatform = {
    fetch: window ? window.fetch.bind(window) : fetch,
    WebSocket,
    createLibrary,
};

function initTONClient(tonClientClass) {
    tonClientClass.setLibrary(clientPlatform);
}

initTONClient(ton_client_js__WEBPACK_IMPORTED_MODULE_0__.TONClient);




/***/ }),

/***/ "./node_modules/ts-invariant/lib/invariant.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-invariant/lib/invariant.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "InvariantError": () => (/* binding */ InvariantError),
/* harmony export */   "invariant": () => (/* binding */ invariant),
/* harmony export */   "process": () => (/* binding */ processStub)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");


var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {
    obj.__proto__ = proto;
    return obj;
} : _a;
var InvariantError = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(InvariantError, _super);
    function InvariantError(message) {
        if (message === void 0) { message = genericMessage; }
        var _this = _super.call(this, typeof message === "number"
            ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)"
            : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError.prototype);
        return _this;
    }
    return InvariantError;
}(Error));
function invariant(condition, message) {
    if (!condition) {
        throw new InvariantError(message);
    }
}
function wrapConsoleMethod(method) {
    return function () {
        return console[method].apply(console, arguments);
    };
}
(function (invariant) {
    invariant.warn = wrapConsoleMethod("warn");
    invariant.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));
// Code that uses ts-invariant with rollup-plugin-invariant may want to
// import this process stub to avoid errors evaluating process.env.NODE_ENV.
// However, because most ESM-to-CJS compilers will rewrite the process import
// as tsInvariant.process, which prevents proper replacement by minifiers, we
// also attempt to define the stub globally when it is not already defined.
var processStub = { env: {} };
if (typeof process === "object") {
    processStub = process;
}
else
    try {
        // Using Function to evaluate this assignment in global scope also escapes
        // the strict mode of the current module, thereby allowing the assignment.
        // Inspired by https://github.com/facebook/regenerator/pull/369.
        Function("stub", "process = stub")(processStub);
    }
    catch (atLeastWeTried) {
        // The assignment can fail if a Content Security Policy heavy-handedly
        // forbids Function usage. In those environments, developers should take
        // extra care to replace process.env.NODE_ENV in their production builds,
        // or define an appropriate global.process polyfill.
    }
var invariant$1 = invariant;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (invariant$1);

//# sourceMappingURL=invariant.esm.js.map


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__values": () => (/* binding */ __values),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/zen-observable-ts/lib/bundle.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/zen-observable-ts/lib/bundle.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Observable": () => (/* binding */ Observable)
/* harmony export */ });
/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zen-observable */ "./node_modules/zen-observable/index.js");
/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zen_observable__WEBPACK_IMPORTED_MODULE_0__);


var Observable = (zen_observable__WEBPACK_IMPORTED_MODULE_0___default());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Observable);

//# sourceMappingURL=bundle.esm.js.map


/***/ }),

/***/ "./node_modules/zen-observable/index.js":
/*!**********************************************!*\
  !*** ./node_modules/zen-observable/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/Observable.js */ "./node_modules/zen-observable/lib/Observable.js").Observable;


/***/ }),

/***/ "./node_modules/zen-observable/lib/Observable.js":
/*!*******************************************************!*\
  !*** ./node_modules/zen-observable/lib/Observable.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Observable = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// === Symbol Support ===
var hasSymbols = function () {
  return typeof Symbol === 'function';
};

var hasSymbol = function (name) {
  return hasSymbols() && Boolean(Symbol[name]);
};

var getSymbol = function (name) {
  return hasSymbol(name) ? Symbol[name] : '@@' + name;
};

if (hasSymbols() && !hasSymbol('observable')) {
  Symbol.observable = Symbol('observable');
}

var SymbolIterator = getSymbol('iterator');
var SymbolObservable = getSymbol('observable');
var SymbolSpecies = getSymbol('species'); // === Abstract Operations ===

function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return undefined;
  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');
  return value;
}

function getSpecies(obj) {
  var ctor = obj.constructor;

  if (ctor !== undefined) {
    ctor = ctor[SymbolSpecies];

    if (ctor === null) {
      ctor = undefined;
    }
  }

  return ctor !== undefined ? ctor : Observable;
}

function isObservable(x) {
  return x instanceof Observable; // SPEC: Brand check
}

function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function () {
      throw e;
    });
  }
}

function enqueue(fn) {
  Promise.resolve().then(function () {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === undefined) return;
  subscription._cleanup = undefined;

  if (!cleanup) {
    return;
  }

  try {
    if (typeof cleanup === 'function') {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, 'unsubscribe');

      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}

function closeSubscription(subscription) {
  subscription._observer = undefined;
  subscription._queue = undefined;
  subscription._state = 'closed';
}

function flushSubscription(subscription) {
  var queue = subscription._queue;

  if (!queue) {
    return;
  }

  subscription._queue = undefined;
  subscription._state = 'ready';

  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === 'closed') break;
  }
}

function notifySubscription(subscription, type, value) {
  subscription._state = 'running';
  var observer = subscription._observer;

  try {
    var m = getMethod(observer, type);

    switch (type) {
      case 'next':
        if (m) m.call(observer, value);
        break;

      case 'error':
        closeSubscription(subscription);
        if (m) m.call(observer, value);else throw value;
        break;

      case 'complete':
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }

  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
}

function onNotify(subscription, type, value) {
  if (subscription._state === 'closed') return;

  if (subscription._state === 'buffering') {
    subscription._queue.push({
      type: type,
      value: value
    });

    return;
  }

  if (subscription._state !== 'ready') {
    subscription._state = 'buffering';
    subscription._queue = [{
      type: type,
      value: value
    }];
    enqueue(function () {
      return flushSubscription(subscription);
    });
    return;
  }

  notifySubscription(subscription, type, value);
}

var Subscription =
/*#__PURE__*/
function () {
  function Subscription(observer, subscriber) {
    _classCallCheck(this, Subscription);

    // ASSERT: observer is an object
    // ASSERT: subscriber is callable
    this._cleanup = undefined;
    this._observer = observer;
    this._queue = undefined;
    this._state = 'initializing';
    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      this._cleanup = subscriber.call(undefined, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }

    if (this._state === 'initializing') this._state = 'ready';
  }

  _createClass(Subscription, [{
    key: "unsubscribe",
    value: function unsubscribe() {
      if (this._state !== 'closed') {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    }
  }, {
    key: "closed",
    get: function () {
      return this._state === 'closed';
    }
  }]);

  return Subscription;
}();

var SubscriptionObserver =
/*#__PURE__*/
function () {
  function SubscriptionObserver(subscription) {
    _classCallCheck(this, SubscriptionObserver);

    this._subscription = subscription;
  }

  _createClass(SubscriptionObserver, [{
    key: "next",
    value: function next(value) {
      onNotify(this._subscription, 'next', value);
    }
  }, {
    key: "error",
    value: function error(value) {
      onNotify(this._subscription, 'error', value);
    }
  }, {
    key: "complete",
    value: function complete() {
      onNotify(this._subscription, 'complete');
    }
  }, {
    key: "closed",
    get: function () {
      return this._subscription._state === 'closed';
    }
  }]);

  return SubscriptionObserver;
}();

var Observable =
/*#__PURE__*/
function () {
  function Observable(subscriber) {
    _classCallCheck(this, Observable);

    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');
    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');
    this._subscriber = subscriber;
  }

  _createClass(Observable, [{
    key: "subscribe",
    value: function subscribe(observer) {
      if (typeof observer !== 'object' || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }

      return new Subscription(observer, this._subscriber);
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (typeof fn !== 'function') {
          reject(new TypeError(fn + ' is not a function'));
          return;
        }

        function done() {
          subscription.unsubscribe();
          resolve();
        }

        var subscription = _this.subscribe({
          next: function (value) {
            try {
              fn(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
      });
    }
  }, {
    key: "map",
    value: function map(fn) {
      var _this2 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        return _this2.subscribe({
          next: function (value) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }

            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "filter",
    value: function filter(fn) {
      var _this3 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        return _this3.subscribe({
          next: function (value) {
            try {
              if (!fn(value)) return;
            } catch (e) {
              return observer.error(e);
            }

            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "reduce",
    value: function reduce(fn) {
      var _this4 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;
      return new C(function (observer) {
        return _this4.subscribe({
          next: function (value) {
            var first = !hasValue;
            hasValue = true;

            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));
            observer.next(acc);
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "concat",
    value: function concat() {
      var _this5 = this;

      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }

      var C = getSpecies(this);
      return new C(function (observer) {
        var subscription;
        var index = 0;

        function startNext(next) {
          subscription = next.subscribe({
            next: function (v) {
              observer.next(v);
            },
            error: function (e) {
              observer.error(e);
            },
            complete: function () {
              if (index === sources.length) {
                subscription = undefined;
                observer.complete();
              } else {
                startNext(C.from(sources[index++]));
              }
            }
          });
        }

        startNext(_this5);
        return function () {
          if (subscription) {
            subscription.unsubscribe();
            subscription = undefined;
          }
        };
      });
    }
  }, {
    key: "flatMap",
    value: function flatMap(fn) {
      var _this6 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        var subscriptions = [];

        var outer = _this6.subscribe({
          next: function (value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
            }

            var inner = C.from(value).subscribe({
              next: function (value) {
                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                var i = subscriptions.indexOf(inner);
                if (i >= 0) subscriptions.splice(i, 1);
                completeIfDone();
              }
            });
            subscriptions.push(inner);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            completeIfDone();
          }
        });

        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0) observer.complete();
        }

        return function () {
          subscriptions.forEach(function (s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    }
  }, {
    key: SymbolObservable,
    value: function () {
      return this;
    }
  }], [{
    key: "from",
    value: function from(x) {
      var C = typeof this === 'function' ? this : Observable;
      if (x == null) throw new TypeError(x + ' is not an object');
      var method = getMethod(x, SymbolObservable);

      if (method) {
        var observable = method.call(x);
        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');
        if (isObservable(observable) && observable.constructor === C) return observable;
        return new C(function (observer) {
          return observable.subscribe(observer);
        });
      }

      if (hasSymbol('iterator')) {
        method = getMethod(x, SymbolIterator);

        if (method) {
          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var _item = _step.value;
                  observer.next(_item);
                  if (observer.closed) return;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              observer.complete();
            });
          });
        }
      }

      if (Array.isArray(x)) {
        return new C(function (observer) {
          enqueue(function () {
            if (observer.closed) return;

            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed) return;
            }

            observer.complete();
          });
        });
      }

      throw new TypeError(x + ' is not observable');
    }
  }, {
    key: "of",
    value: function of() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      var C = typeof this === 'function' ? this : Observable;
      return new C(function (observer) {
        enqueue(function () {
          if (observer.closed) return;

          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed) return;
          }

          observer.complete();
        });
      });
    }
  }, {
    key: SymbolSpecies,
    get: function () {
      return this;
    }
  }]);

  return Observable;
}();

exports.Observable = Observable;

if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol('extensions'), {
    value: {
      symbol: SymbolObservable,
      hostReportError: hostReportError
    },
    configurable: true
  });
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TonClientFacadeError": () => (/* binding */ TonClientFacadeError),
/* harmony export */   "TONClientFacade": () => (/* binding */ TONClientFacade)
/* harmony export */ });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a = __webpack_require__(/*! ton-client-web-js */ "./node_modules/ton-client-web-js/index.js"), TONClient = _a.TONClient, setWasmOptions = _a.setWasmOptions;
var TonClientFacadeError = /** @class */ (function (_super) {
    __extends(TonClientFacadeError, _super);
    function TonClientFacadeError(msg, innerException) {
        if (innerException === void 0) { innerException = undefined; }
        var _this = _super.call(this, msg) || this;
        _this.innerException = innerException;
        return _this;
    }
    return TonClientFacadeError;
}(Error));

var TONClientFacade = /** @class */ (function () {
    function TONClientFacade() {
        this.__tonClientInitializer = null;
    }
    TONClientFacade.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.__tonClientInitializer === null) {
                            console.log("TON Client initializing...");
                            this.__tonClientInitializer = TONClientFacade._createTONClient();
                        }
                        if (!(this.__tonClientInitializer instanceof Promise)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.__tonClientInitializer
                                .then(function (tonClient) {
                                _this.__tonClientInitializer = tonClient;
                                console.log("TON Client was initialized successfully.");
                            })];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    TONClientFacade.prototype.generateMnemonicPhraseSeed = function (wordsCount) {
        return __awaiter(this, void 0, void 0, function () {
            var SEED_PHRASE_DICTIONARY_ENGLISH, seed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        SEED_PHRASE_DICTIONARY_ENGLISH = 1;
                        return [4 /*yield*/, this._tonClient.crypto.mnemonicFromRandom({
                                dictionary: SEED_PHRASE_DICTIONARY_ENGLISH,
                                wordCount: wordsCount
                            })];
                    case 1:
                        seed = _a.sent();
                        return [2 /*return*/, seed];
                }
            });
        });
    };
    TONClientFacade.prototype.deriveKeyPair = function (seedMnemonicPhrase, wordsCount) {
        return __awaiter(this, void 0, void 0, function () {
            var SEED_PHRASE_DICTIONARY_ENGLISH, keyPair;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.error(seedMnemonicPhrase);
                        SEED_PHRASE_DICTIONARY_ENGLISH = 1;
                        return [4 /*yield*/, this._tonClient.crypto.mnemonicDeriveSignKeys({
                                dictionary: SEED_PHRASE_DICTIONARY_ENGLISH,
                                wordCount: wordsCount,
                                phrase: seedMnemonicPhrase,
                                path: "m/44'/396'/0'/0/0"
                            })];
                    case 1:
                        keyPair = _a.sent();
                        return [2 /*return*/, keyPair];
                }
            });
        });
    };
    TONClientFacade.prototype.getDeployData = function (publicKey, smartContractABI, smartContractTVCBase64) {
        return __awaiter(this, void 0, void 0, function () {
            var friendlySmartContractABI, param, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        friendlySmartContractABI = JSON.parse(smartContractABI);
                        param = {
                            abi: friendlySmartContractABI,
                            imageBase64: smartContractTVCBase64,
                            initParams: {},
                            publicKeyHex: publicKey,
                            workchainId: 0,
                        };
                        return [4 /*yield*/, this._tonClient.contracts.getDeployData(param)];
                    case 1:
                        result = _a.sent();
                        console.error(result);
                        return [2 /*return*/, result.address];
                }
            });
        });
    };
    // async calcDeployFees(key: KeyPair) {
    // 	if (!("public" in key && typeof key.public === "string")) {
    // 		throw new Error("Public key error");
    // 	}
    // 	const pkg = { abi: SmartContract.abi, imageBase64: SmartContract.image };
    // 	const constructorParams = { owners: [`0x${key.public}`], reqConfirms: 1 };
    // 	const param = {
    // 		package: pkg,
    // 		constructorParams,
    // 		initParams: {},
    // 		keyPair: {
    // 			"public": key.public,
    // 			"secret": key.secret
    // 		},
    // 		emulateBalance: true,
    // 		newaccount: true
    // 	};
    // 	return await this._tonClient.contracts.calcDeployFees(param);
    // }
    // async deployContract(key: KeyPair) {
    // 	const pkg = { abi: SmartContract.abi, imageBase64: SmartContract.image };
    // 	const constructorParams = { owners: [`0x${key.public}`], reqConfirms: 1 };
    // 	const param = {
    // 		package: pkg,
    // 		constructorParams,
    // 		initParams: {},
    // 		keyPair: {
    // 			"public": key.public,
    // 			"secret": key.secret
    // 		}
    // 	};
    // 	const deployMessage = await this._tonClient.contracts.createDeployMessage(param);
    // 	const processingState = await this._tonClient.contracts.sendMessage(deployMessage.message);
    // 	return "123";//await this._tonClient.contracts.waitForDeployTransaction(deployMessage, processingState);
    // };
    TONClientFacade.prototype.fetchAccountInformation = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var data, balance, code_hash, result, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this._tonClient.queries.accounts
                                .query({ id: { in: address } }, 'id, balance(format: DEC), code_hash')];
                    case 1:
                        data = _a.sent();
                        console.log("fetchAccountInformation", address, data);
                        if (!Array.isArray(data) || data.length === 0) {
                            return [2 /*return*/, null];
                        }
                        balance = data[0].balance;
                        code_hash = data[0].code_hash;
                        result = {
                            balance: balance,
                            codeHash: code_hash
                        };
                        return [2 /*return*/, Object.freeze(result)];
                    case 2:
                        e_1 = _a.sent();
                        console.error(e_1);
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    ;
    Object.defineProperty(TONClientFacade.prototype, "_tonClient", {
        get: function () {
            if (this.__tonClientInitializer === null || this.__tonClientInitializer instanceof Promise) {
                throw new Error("Invalid operation. Did you init()?.");
            }
            return this.__tonClientInitializer;
        },
        enumerable: false,
        configurable: true
    });
    TONClientFacade._createTONClient = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (rlv, rej) { return setTimeout(rlv, 250); })];
                    case 1:
                        _a.sent(); // Fake init deplay
                        return [4 /*yield*/, TONClient.create({
                                servers: ['net.ton.dev']
                            })];
                    case 2: // Fake init deplay
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return TONClientFacade;
}());

(function () {
    if (window.TONClientFacade === undefined) {
        window.TONClientFacade = TONClientFacade;
    }
    else {
        console.error("Failure. TONClientFacade already presented on window object.");
    }
})();
// // Adding an HTML update function
// setWasmOptions({
// 	addHTML,
// });
// let createStart = Date.now();
// // creating a TONClient wit a net.ton.dev connection
// const client = await TONClient.create({
// 	servers: ['net.ton.dev']
// });
// // requesting TONClient creation time stamp
// addHTML(`Client creation time: ${(Date.now() - createStart)}`);
// // displaying the current client version
// addHTML(`Client version: ${await client.config.getVersion()}`);
// addHTML(`Client connected to: ${await client.config.data.servers}`);
// const queryStart = Date.now();
// // requesting top 10 accounts sorted by balance from net.ton.dev/graphql
// const accounts = await client.queries.accounts.query({}, 'id balance', [{ path: 'balance', direction: 'DESC' }], 10);
// addHTML(`Query time: ${(Date.now() - queryStart)}`);
// // displaying the data
// addHTML(`<table>${accounts.map(x => `<tr><td>${x.id}</td><td>${BigInt(x.balance)}</td></tr>`).join('')}</table>`);
// // displaying the data received time stamp
// addHTML(`Now is: ${new Date()}`);
// const SEED_PHRASE_WORD_COUNT = 12;
// const SEED_PHRASE_DICTIONARY_ENGLISH = 1;
// const phrase = await client.crypto.mnemonicFromRandom({
// 	dictionary: SEED_PHRASE_DICTIONARY_ENGLISH,
// 	wordCount: SEED_PHRASE_WORD_COUNT
// });
// addHTML(`Menmonic phrase: ${phrase}`);
// return phrase;

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UT04gQ2xpZW50L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvQHdyeS9jb250ZXh0L2xpYi9jb250ZXh0LmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL0B3cnkvZXF1YWxpdHkvbGliL2VxdWFsaXR5LmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Fwb2xsby1jYWNoZS1pbm1lbW9yeS9saWIvYnVuZGxlLmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Fwb2xsby1jYWNoZS9saWIvYnVuZGxlLmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Fwb2xsby1jbGllbnQvYnVuZGxlLmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Fwb2xsby1saW5rLWNvbnRleHQvbGliL2J1bmRsZS5lc20uanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9hcG9sbG8tbGluay1odHRwLWNvbW1vbi9saWIvYnVuZGxlLmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Fwb2xsby1saW5rLWh0dHAvbGliL2J1bmRsZS5lc20uanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9hcG9sbG8tbGluay13cy9saWIvYnVuZGxlLmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Fwb2xsby1saW5rL2xpYi9idW5kbGUuZXNtLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvYXBvbGxvLXV0aWxpdGllcy9saWIvYnVuZGxlLmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9mYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwtdGFnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvZXJyb3IvR3JhcGhRTEVycm9yLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9lcnJvci9zeW50YXhFcnJvci5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9kZWZpbmVJbnNwZWN0LmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2RldkFzc2VydC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pbnNwZWN0LmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvYXN0LmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9ibG9ja1N0cmluZy5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvZGlyZWN0aXZlTG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2tpbmRzLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9sZXhlci5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvbG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3BhcnNlci5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRMb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRlci5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2Uvc291cmNlLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS90b2tlbktpbmQuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3IuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL3BvbHlmaWxscy9zeW1ib2xzLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC91dGlsaXRpZXMvZ2V0T3BlcmF0aW9uQVNULmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvb3BlbnRyYWNpbmcvbGliL2JpbmFyeV9jYXJyaWVyLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvb3BlbnRyYWNpbmcvbGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL29wZW50cmFjaW5nL2xpYi9leHQvdGFncy5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL29wZW50cmFjaW5nL2xpYi9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9vcGVudHJhY2luZy9saWIvZ2xvYmFsX3RyYWNlci5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL29wZW50cmFjaW5nL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL29wZW50cmFjaW5nL2xpYi9tb2NrX3RyYWNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL29wZW50cmFjaW5nL2xpYi9tb2NrX3RyYWNlci9tb2NrX2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9vcGVudHJhY2luZy9saWIvbW9ja190cmFjZXIvbW9ja19yZXBvcnQuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9vcGVudHJhY2luZy9saWIvbW9ja190cmFjZXIvbW9ja19zcGFuLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvb3BlbnRyYWNpbmcvbGliL21vY2tfdHJhY2VyL21vY2tfdHJhY2VyLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvb3BlbnRyYWNpbmcvbGliL25vb3AuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9vcGVudHJhY2luZy9saWIvcmVmZXJlbmNlLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvb3BlbnRyYWNpbmcvbGliL3NwYW4uanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9vcGVudHJhY2luZy9saWIvc3Bhbl9jb250ZXh0LmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvb3BlbnRyYWNpbmcvbGliL3RyYWNlci5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL29wdGltaXNtL2xpYi9idW5kbGUuZXNtLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3MvZGlzdC9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9zdWJzY3JpcHRpb25zLXRyYW5zcG9ydC13cy9kaXN0L2RlZmF1bHRzLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3MvZGlzdC9tZXNzYWdlLXR5cGVzLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3MvZGlzdC9wcm90b2NvbC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzL2Rpc3QvdXRpbHMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3MvZGlzdC91dGlscy9pcy1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL3BvbnlmaWxsLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvdG9uLWNsaWVudC1qcy9kaXN0L1RPTkNsaWVudC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Rvbi1jbGllbnQtanMvZGlzdC9UT05DbGllbnRFcnJvci5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Rvbi1jbGllbnQtanMvZGlzdC9UT05Nb2R1bGUuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy90b24tY2xpZW50LWpzL2Rpc3QvbW9kdWxlcy9UT05Db25maWdNb2R1bGUuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy90b24tY2xpZW50LWpzL2Rpc3QvbW9kdWxlcy9UT05Db250cmFjdHNNb2R1bGUuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy90b24tY2xpZW50LWpzL2Rpc3QvbW9kdWxlcy9UT05DcnlwdG9Nb2R1bGUuanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy90b24tY2xpZW50LWpzL2Rpc3QvbW9kdWxlcy9UT05RdWVyaWVzTW9kdWxlLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvdG9uLWNsaWVudC1qcy9kaXN0L21vZHVsZXMvY3J5cHRvLWJveC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Rvbi1jbGllbnQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy90b24tY2xpZW50LXdlYi1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3RzLWludmFyaWFudC9saWIvaW52YXJpYW50LmVzbS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL3plbi1vYnNlcnZhYmxlLXRzL2xpYi9idW5kbGUuZXNtLmpzIiwid2VicGFjazovL1RPTiBDbGllbnQvLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC8uL25vZGVfbW9kdWxlcy96ZW4tb2JzZXJ2YWJsZS9saWIvT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9UT04gQ2xpZW50L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL1RPTiBDbGllbnQvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL1RPTiBDbGllbnQvd2VicGFjay9ydW50aW1lL2hhcm1vbnkgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9UT04gQ2xpZW50L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vVE9OIENsaWVudC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL1RPTiBDbGllbnQvLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7O0FDZEEsZ0hBQStDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlDQUFpQztBQUNoRixnREFBZ0Qsa0NBQWtDO0FBQ2xGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RztBQUM5Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQztBQUNKO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qzs7QUFFdkMsNkdBQTZHOzs7QUFHN0c7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esb0JBQW9COztBQUVwQjtBQUNB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGtDQUFrQzs7O0FBR3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0bkJhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5QmE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixpQkFBaUI7O0FBRWpCLHNDQUFzQyxtQkFBTyxDQUFDLHFFQUFvQjs7QUFFbEUsd0NBQXdDLG1CQUFPLENBQUMseUVBQXNCOztBQUV0RSxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRWpELGFBQWEsbUJBQU8sQ0FBQyx5REFBUzs7QUFFOUIsV0FBVyxtQkFBTyxDQUFDLHFEQUFPOztBQUUxQixjQUFjLG1CQUFPLENBQUMsMkRBQVU7O0FBRWhDLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFhOztBQUV0Qyx5QkFBeUIsbUJBQU8sQ0FBQyxpRkFBcUI7O0FBRXRELGFBQWEsbUJBQU8sQ0FBQyx5REFBUzs7QUFFOUIsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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Q0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsOERBQThELDRCQUE0QjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBCQUEwQiw4Q0FBSTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3Q0FBd0MsRUFBRTtBQUN2RjtBQUNBO0FBQ0EsNkNBQTZDLHdDQUF3QyxFQUFFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQ0FBc0MsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtCQUErQjtBQUM1RCw0RUFBNEUsd0JBQXdCLEVBQUU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0JBQXNCLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThDO0FBQzlDOzs7Ozs7Ozs7OztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQiwwREFBMEQ7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLEdBQUc7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7O0FBRUE7QUFDQSxzRUFBc0UsZUFBZSwyQkFBMkIsWUFBWSxFQUFFLEVBQUU7O0FBRWhJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLGlGQUFpRixhQUFhO0FBQzlGO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixpQkFBaUI7QUFDdkcsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCLEtBQUssS0FBSztBQUMzQjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsZUFBa0I7QUFDbEI7QUFDQSw2R0FBNkcsK0NBQStDO0FBQzVKLHVFQUF1RSxxRkFBcUYsZUFBZSw0REFBNEQsY0FBYyxpSUFBaUksdURBQXVELGtFQUFrRTtBQUMvZSwyQ0FBMkMsY0FBYyxtcXJIOzs7Ozs7Ozs7OztBQ3ZzRzVDOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGVBQWtCLEdBQUcsNkJBQTZCLEdBQUcseUJBQXlCOztBQUU5RSwwQ0FBMEMsbUJBQU8sQ0FBQyxzRkFBNEI7O0FBRTlFLHNCQUFzQixtQkFBTyxDQUFDLDhFQUFtQjs7QUFFakQsa0JBQWtCLG1CQUFPLENBQUMsb0VBQWM7O0FBRXhDLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFjOztBQUV2QyxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLDRFQUE0RSxNQUFNLDBCQUEwQix3QkFBd0IsRUFBRSxnQkFBZ0IsZUFBZSxRQUFRLEVBQUUsaUJBQWlCLGdCQUFnQixFQUFFLE9BQU8sNENBQTRDLEVBQUU7O0FBRXZRLGdDQUFnQyxxQkFBcUIsbUNBQW1DLGdEQUFnRCxnQ0FBZ0Msd0JBQXdCLHdFQUF3RSxFQUFFLHVCQUF1Qix1RUFBdUUsRUFBRSxrQkFBa0IsRUFBRSxFQUFFLEdBQUc7O0FBRW5ZLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSwyQ0FBMkMsa0JBQWtCLGtDQUFrQyxxRUFBcUUsRUFBRSxFQUFFLE9BQU8sa0JBQWtCLEVBQUUsWUFBWTs7QUFFL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdD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QUFNOztBQUU1RDtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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S0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLEtBQUssRUFBRSxFQUdWOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsZUFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK1RBQStULHdTQUF3UyxzQkFBc0IsZUFBZTtBQUM1b0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0xBQW9MLGdKQUFnSjtBQUNwVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyR0FBMkcsaUVBQWlFLHNCQUFzQixXQUFXO0FBQzdNO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixlQUFlO0FBQy9GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDJDQUEyQyxjQUFjLHVuNkU7Ozs7Ozs7Ozs7O0FDeDdENUM7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixxQkFBcUIsR0FBRyx1QkFBdUIsR0FBRyxtQ0FBbUMsR0FBRyxtQ0FBbUM7O0FBRTNILDBDQUEwQyxtQkFBTyxDQUFDLHNGQUE0Qjs7QUFFOUUsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GLDRFQUE0RSxNQUFNLDBCQUEwQix3QkFBd0IsRUFBRSxnQkFBZ0IsZUFBZSxRQUFRLEVBQUUsaUJBQWlCLGdCQUFnQixFQUFFLE9BQU8sNENBQTRDLEVBQUU7O0FBRXZRLGdDQUFnQyxxQkFBcUIsbUNBQW1DLGdEQUFnRCxnQ0FBZ0Msd0JBQXdCLHdFQUF3RSxFQUFFLHVCQUF1Qix1RUFBdUUsRUFBRSxrQkFBa0IsRUFBRSxFQUFFLEdBQUc7O0FBRW5ZLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOLDJDQUEyQyxrQkFBa0Isa0NBQWtDLHFFQUFxRSxFQUFFLEVBQUUsT0FBTyxrQkFBa0IsRUFBRSxZQUFZOztBQUUvTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG1DQUFtQztBQUNuQztBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQscUJBQXFCO0FBQ3JCLDJDQUEyQyxjQUFjLHVoVzs7Ozs7Ozs7OztBQy9TekQ7QUFDQTtBQUNBOztBQUVBLE9BQU8sWUFBWSxHQUFHLG1CQUFPLENBQUMsd0VBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsMEdBQW1DOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQyxvR0FBZ0M7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEQwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTs7QUFFQSx5QkFBeUIsa0JBQWtCOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELCtCQUErQjs7QUFFakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSxnRUFBZ0U7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsQzs7Ozs7O1VDeG1CQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxnQ0FBZ0MsWUFBWTtXQUM1QztXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQSxDQUFDLEk7Ozs7O1dDUEQ7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBLEU7Ozs7O1dDVkEsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOTSxTQUFnQyxtQkFBTyxDQUFDLG9FQUFtQixDQUFDLEVBQTFELFNBQVMsaUJBQUUsY0FBYyxvQkFBaUMsQ0FBQztBQTBCbkU7SUFBMEMsd0NBQUs7SUFFOUMsOEJBQVksR0FBVyxFQUFFLGNBQStCO1FBQS9CLDJEQUErQjtRQUF4RCxZQUNDLGtCQUFNLEdBQUcsQ0FBQyxTQUVWO1FBREEsS0FBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7O0lBQ3RDLENBQUM7SUFDRiwyQkFBQztBQUFELENBQUMsQ0FOeUMsS0FBSyxHQU05Qzs7QUFNRDtJQUdDO1FBQ0MsSUFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQztJQUNwQyxDQUFDO0lBRUssOEJBQUksR0FBVjs7Ozs7O3dCQUNDLElBQUksSUFBSSxDQUFDLHNCQUFzQixLQUFLLElBQUksRUFBRTs0QkFDekMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDOzRCQUMxQyxJQUFJLENBQUMsc0JBQXNCLEdBQUcsZUFBZSxDQUFDLGdCQUFnQixFQUFFLENBQUM7eUJBQ2pFOzZCQUNHLEtBQUksQ0FBQyxzQkFBc0IsWUFBWSxPQUFPLEdBQTlDLHdCQUE4Qzt3QkFDakQscUJBQU0sSUFBSSxDQUFDLHNCQUFzQjtpQ0FDL0IsSUFBSSxDQUFDLG1CQUFTO2dDQUNkLEtBQUksQ0FBQyxzQkFBc0IsR0FBRyxTQUFTLENBQUM7Z0NBQ3hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsMENBQTBDLENBQUMsQ0FBQzs0QkFDekQsQ0FBQyxDQUFDOzt3QkFKSCxTQUlHLENBQUM7Ozs7OztLQUVMO0lBRUssb0RBQTBCLEdBQWhDLFVBQWlDLFVBQWtCOzs7Ozs7d0JBQzVDLDhCQUE4QixHQUFXLENBQUMsQ0FBQzt3QkFDNUIscUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUM7Z0NBQ3BFLFVBQVUsRUFBRSw4QkFBOEI7Z0NBQzFDLFNBQVMsRUFBRSxVQUFVOzZCQUNyQixDQUFDOzt3QkFISSxJQUFJLEdBQVcsU0FHbkI7d0JBQ0Ysc0JBQU8sSUFBSSxFQUFDOzs7O0tBQ1o7SUFFSyx1Q0FBYSxHQUFuQixVQUFvQixrQkFBMEIsRUFBRSxVQUFrQjs7Ozs7O3dCQUNqRSxPQUFPLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7d0JBQzVCLDhCQUE4QixHQUFXLENBQUMsQ0FBQzt3QkFDeEIscUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsc0JBQXNCLENBQUM7Z0NBQzVFLFVBQVUsRUFBRSw4QkFBOEI7Z0NBQzFDLFNBQVMsRUFBRSxVQUFVO2dDQUNyQixNQUFNLEVBQUUsa0JBQWtCO2dDQUMxQixJQUFJLEVBQUUsbUJBQW1COzZCQUN6QixDQUFDOzt3QkFMSSxPQUFPLEdBQVksU0FLdkI7d0JBQ0Ysc0JBQU8sT0FBTyxFQUFDOzs7O0tBQ2Y7SUFFSyx1Q0FBYSxHQUFuQixVQUNDLFNBQWlCLEVBQ2pCLGdCQUF3QixFQUN4QixzQkFBOEI7Ozs7Ozt3QkFHeEIsd0JBQXdCLEdBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUU3RCxLQUFLLEdBQUc7NEJBQ2IsR0FBRyxFQUFFLHdCQUF3Qjs0QkFDN0IsV0FBVyxFQUFFLHNCQUFzQjs0QkFDbkMsVUFBVSxFQUFFLEVBQUU7NEJBQ2QsWUFBWSxFQUFFLFNBQVM7NEJBQ3ZCLFdBQVcsRUFBRSxDQUFDO3lCQUNkLENBQUM7d0JBQ21DLHFCQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUM7O3dCQUFuRixNQUFNLEdBQXlCLFNBQW9EO3dCQUN6RixPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3dCQUN0QixzQkFBTyxNQUFNLENBQUMsT0FBTyxFQUFDOzs7O0tBQ3RCO0lBRUQsdUNBQXVDO0lBQ3ZDLCtEQUErRDtJQUMvRCx5Q0FBeUM7SUFDekMsS0FBSztJQUNMLDZFQUE2RTtJQUM3RSw4RUFBOEU7SUFDOUUsbUJBQW1CO0lBQ25CLGtCQUFrQjtJQUNsQix1QkFBdUI7SUFDdkIsb0JBQW9CO0lBQ3BCLGVBQWU7SUFDZiwyQkFBMkI7SUFDM0IsMEJBQTBCO0lBQzFCLE9BQU87SUFDUCwwQkFBMEI7SUFDMUIscUJBQXFCO0lBQ3JCLE1BQU07SUFDTixpRUFBaUU7SUFDakUsSUFBSTtJQUVKLHVDQUF1QztJQUN2Qyw2RUFBNkU7SUFDN0UsOEVBQThFO0lBQzlFLG1CQUFtQjtJQUNuQixrQkFBa0I7SUFDbEIsdUJBQXVCO0lBQ3ZCLG9CQUFvQjtJQUNwQixlQUFlO0lBQ2YsMkJBQTJCO0lBQzNCLDBCQUEwQjtJQUMxQixNQUFNO0lBQ04sTUFBTTtJQUNOLHFGQUFxRjtJQUNyRiwrRkFBK0Y7SUFDL0YsNEdBQTRHO0lBQzVHLEtBQUs7SUFFQyxpREFBdUIsR0FBN0IsVUFBOEIsT0FBZTs7Ozs7Ozt3QkFFOUIscUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUTtpQ0FDakQsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUscUNBQXFDLENBQUM7O3dCQURqRSxJQUFJLEdBQUcsU0FDMEQ7d0JBRXZFLE9BQU8sQ0FBQyxHQUFHLENBQUMseUJBQXlCLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO3dCQUV0RCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs0QkFDOUMsc0JBQU8sSUFBSSxFQUFDO3lCQUNaO3dCQUVLLE9BQU8sR0FBVyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO3dCQUNsQyxTQUFTLEdBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQzt3QkFFdEMsTUFBTSxHQUFnQjs0QkFDM0IsT0FBTzs0QkFDUCxRQUFRLEVBQUUsU0FBUzt5QkFDbkIsQ0FBQzt3QkFFRixzQkFBTyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFDOzs7d0JBRTdCLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBQyxDQUFDLENBQUM7d0JBQ2pCLE1BQU0sR0FBQyxDQUFDOzs7OztLQUVUO0lBQUEsQ0FBQztJQUVGLHNCQUFJLHVDQUFVO2FBQWQ7WUFDQyxJQUFJLElBQUksQ0FBQyxzQkFBc0IsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLHNCQUFzQixZQUFZLE9BQU8sRUFBRTtnQkFDM0YsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQzthQUN0RDtZQUNELE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDO1FBQ3BDLENBQUM7OztPQUFBO0lBRVksZ0NBQWdCLEdBQTdCOzs7OzRCQUNDLHFCQUFNLElBQUksT0FBTyxDQUFDLFVBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSyxpQkFBVSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBcEIsQ0FBb0IsQ0FBQzs7d0JBQXJELFNBQXFELENBQUMsQ0FBQyxtQkFBbUI7d0JBQ25FLHFCQUFNLFNBQVMsQ0FBQyxNQUFNLENBQUM7Z0NBQzdCLE9BQU8sRUFBRSxDQUFDLGFBQWEsQ0FBQzs2QkFDeEIsQ0FBQzs0QkFIcUQsbUJBQW1CO29CQUMxRSxzQkFBTyxTQUVMLEVBQUM7Ozs7S0FDSDtJQUNGLHNCQUFDO0FBQUQsQ0FBQzs7QUFLRCxDQUFDO0lBQ0EsSUFBSSxNQUFNLENBQUMsZUFBZSxLQUFLLFNBQVMsRUFBRTtRQUN6QyxNQUFNLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztLQUN6QztTQUFNO1FBQ04sT0FBTyxDQUFDLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0tBQzlFO0FBQ0YsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUdMLG9DQUFvQztBQUNwQyxtQkFBbUI7QUFDbkIsWUFBWTtBQUNaLE1BQU07QUFDTixnQ0FBZ0M7QUFDaEMsdURBQXVEO0FBQ3ZELDBDQUEwQztBQUMxQyw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOLDhDQUE4QztBQUM5QyxrRUFBa0U7QUFDbEUsMkNBQTJDO0FBQzNDLGtFQUFrRTtBQUNsRSx1RUFBdUU7QUFDdkUsaUNBQWlDO0FBQ2pDLDJFQUEyRTtBQUMzRSx3SEFBd0g7QUFDeEgsdURBQXVEO0FBQ3ZELHlCQUF5QjtBQUN6QixxSEFBcUg7QUFDckgsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUVwQyxxQ0FBcUM7QUFDckMsNENBQTRDO0FBQzVDLDBEQUEwRDtBQUMxRCwrQ0FBK0M7QUFDL0MscUNBQXFDO0FBQ3JDLE1BQU07QUFDTix5Q0FBeUM7QUFDekMsaUJBQWlCIiwiZmlsZSI6InRvbi1jbGllbnQtd2ViLWpzLXVtZC1mYWNhZGUuZGV2ZWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHQvL1RoaXMgaXMgVU1EIGZhY2FkZSBsaWJyYXJ5IG92ZXIgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdG9uLWNsaWVudC13ZWItanMgdG8gYmUgdXNlZCBpbnNpZGUgRGFydCBXZWIvRmx1dHRlciBXZWIgYXBwbGljYXRpb25zLlxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdC8vVGhpcyBpcyBVTUQgZmFjYWRlIGxpYnJhcnkgb3ZlciBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS90b24tY2xpZW50LXdlYi1qcyB0byBiZSB1c2VkIGluc2lkZSBEYXJ0IFdlYi9GbHV0dGVyIFdlYiBhcHBsaWNhdGlvbnMuXG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdC8vVGhpcyBpcyBVTUQgZmFjYWRlIGxpYnJhcnkgb3ZlciBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS90b24tY2xpZW50LXdlYi1qcyB0byBiZSB1c2VkIGluc2lkZSBEYXJ0IFdlYi9GbHV0dGVyIFdlYiBhcHBsaWNhdGlvbnMuXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJUT04gQ2xpZW50XCJdID0gZmFjdG9yeSgpO1xuXHQvL1RoaXMgaXMgVU1EIGZhY2FkZSBsaWJyYXJ5IG92ZXIgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdG9uLWNsaWVudC13ZWItanMgdG8gYmUgdXNlZCBpbnNpZGUgRGFydCBXZWIvRmx1dHRlciBXZWIgYXBwbGljYXRpb25zLlxuXHRlbHNlXG5cdFx0cm9vdFtcIlRPTiBDbGllbnRcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLy8gVGhpcyBjdXJyZW50Q29udGV4dCB2YXJpYWJsZSB3aWxsIG9ubHkgYmUgdXNlZCBpZiB0aGUgbWFrZVNsb3RDbGFzc1xyXG4vLyBmdW5jdGlvbiBpcyBjYWxsZWQsIHdoaWNoIGhhcHBlbnMgb25seSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBjb3B5IG9mIHRoZVxyXG4vLyBAd3J5L2NvbnRleHQgcGFja2FnZSB0byBiZSBpbXBvcnRlZC5cclxudmFyIGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcclxuLy8gVGhpcyB1bmlxdWUgaW50ZXJuYWwgb2JqZWN0IGlzIHVzZWQgdG8gZGVub3RlIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWVcclxuLy8gZm9yIGEgZ2l2ZW4gU2xvdCwgYW5kIGlzIG5ldmVyIGV4cG9zZWQgdG8gb3V0c2lkZSBjb2RlLlxyXG52YXIgTUlTU0lOR19WQUxVRSA9IHt9O1xyXG52YXIgaWRDb3VudGVyID0gMTtcclxuLy8gQWx0aG91Z2ggd2UgY2FuJ3QgZG8gYW55dGhpbmcgYWJvdXQgdGhlIGNvc3Qgb2YgZHVwbGljYXRlZCBjb2RlIGZyb21cclxuLy8gYWNjaWRlbnRhbGx5IGJ1bmRsaW5nIG11bHRpcGxlIGNvcGllcyBvZiB0aGUgQHdyeS9jb250ZXh0IHBhY2thZ2UsIHdlIGNhblxyXG4vLyBhdm9pZCBjcmVhdGluZyB0aGUgU2xvdCBjbGFzcyBtb3JlIHRoYW4gb25jZSB1c2luZyBtYWtlU2xvdENsYXNzLlxyXG52YXIgbWFrZVNsb3RDbGFzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNsb3QoKSB7XHJcbiAgICAgICAgLy8gSWYgeW91IGhhdmUgYSBTbG90IG9iamVjdCwgeW91IGNhbiBmaW5kIG91dCBpdHMgc2xvdC5pZCwgYnV0IHlvdSBjYW5ub3RcclxuICAgICAgICAvLyBndWVzcyB0aGUgc2xvdC5pZCBvZiBhIFNsb3QgeW91IGRvbid0IGhhdmUgYWNjZXNzIHRvLCB0aGFua3MgdG8gdGhlXHJcbiAgICAgICAgLy8gcmFuZG9taXplZCBzdWZmaXguXHJcbiAgICAgICAgdGhpcy5pZCA9IFtcclxuICAgICAgICAgICAgXCJzbG90XCIsXHJcbiAgICAgICAgICAgIGlkQ291bnRlcisrLFxyXG4gICAgICAgICAgICBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcclxuICAgICAgICBdLmpvaW4oXCI6XCIpO1xyXG4gICAgfVxyXG4gICAgU2xvdC5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY29udGV4dF8xID0gY3VycmVudENvbnRleHQ7IGNvbnRleHRfMTsgY29udGV4dF8xID0gY29udGV4dF8xLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIFNsb3Qgb2JqZWN0IGlzZWxmIGFzIGEga2V5IHRvIGl0cyB2YWx1ZSwgd2hpY2ggbWVhbnMgdGhlXHJcbiAgICAgICAgICAgIC8vIHZhbHVlIGNhbm5vdCBiZSBvYnRhaW5lZCB3aXRob3V0IGEgcmVmZXJlbmNlIHRvIHRoZSBTbG90IG9iamVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaWQgaW4gY29udGV4dF8xLnNsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0XzEuc2xvdHNbdGhpcy5pZF07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IE1JU1NJTkdfVkFMVUUpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dF8xICE9PSBjdXJyZW50Q29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSB2YWx1ZSBpbiBjdXJyZW50Q29udGV4dC5zbG90cyBzbyB0aGUgbmV4dCBsb29rdXAgd2lsbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGZhc3Rlci4gVGhpcyBjYWNoaW5nIGlzIHNhZmUgYmVjYXVzZSB0aGUgdHJlZSBvZiBjb250ZXh0cyBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWVzIG9mIHRoZSBzbG90cyBhcmUgbG9naWNhbGx5IGltbXV0YWJsZS5cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdmFsdWUgd2FzIG5vdCBmb3VuZCBmb3IgdGhpcyBTbG90LCBpdCdzIG5ldmVyIGdvaW5nIHRvIGJlIGZvdW5kXHJcbiAgICAgICAgICAgIC8vIG5vIG1hdHRlciBob3cgbWFueSB0aW1lcyB3ZSBsb29rIGl0IHVwLCBzbyB3ZSBtaWdodCBhcyB3ZWxsIGNhY2hlXHJcbiAgICAgICAgICAgIC8vIHRoZSBhYnNlbmNlIG9mIHRoZSB2YWx1ZSwgdG9vLlxyXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IE1JU1NJTkdfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBTbG90LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU2xvdC5wcm90b3R5cGUud2l0aFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaywgXHJcbiAgICAvLyBHaXZlbiB0aGUgcHJldmFsZW5jZSBvZiBhcnJvdyBmdW5jdGlvbnMsIHNwZWNpZnlpbmcgYXJndW1lbnRzIGlzIGxpa2VseVxyXG4gICAgLy8gdG8gYmUgbXVjaCBtb3JlIGNvbW1vbiB0aGFuIHNwZWNpZnlpbmcgYHRoaXNgLCBoZW5jZSB0aGlzIG9yZGVyaW5nOlxyXG4gICAgYXJncywgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgc2xvdHMgPSAoX2EgPSB7XHJcbiAgICAgICAgICAgICAgICBfX3Byb3RvX186IG51bGxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX2FbdGhpcy5pZF0gPSB2YWx1ZSxcclxuICAgICAgICAgICAgX2EpO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBjdXJyZW50Q29udGV4dDtcclxuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHsgcGFyZW50OiBwYXJlbnQsIHNsb3RzOiBzbG90cyB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSBhbGxvd3MgdGhlIGFyZ3VtZW50cyBhcnJheSBhcmd1bWVudCB0byBiZVxyXG4gICAgICAgICAgICAvLyBvbWl0dGVkIG9yIHVuZGVmaW5lZCwgc28gYXJncyEgaXMgZmluZSBoZXJlLlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FwdHVyZSB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB3cmFwIGEgY2FsbGJhY2sgZnVuY3Rpb24gc28gdGhhdCBpdFxyXG4gICAgLy8gcmVlc3RhYmxpc2hlcyB0aGUgY2FwdHVyZWQgY29udGV4dCB3aGVuIGNhbGxlZC5cclxuICAgIFNsb3QuYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY3VycmVudENvbnRleHQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNhdmVkID0gY3VycmVudENvbnRleHQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIEltbWVkaWF0ZWx5IHJ1biBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhvdXQgYW55IGNhcHR1cmVkIGNvbnRleHQuXHJcbiAgICBTbG90Lm5vQ29udGV4dCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgXHJcbiAgICAvLyBHaXZlbiB0aGUgcHJldmFsZW5jZSBvZiBhcnJvdyBmdW5jdGlvbnMsIHNwZWNpZnlpbmcgYXJndW1lbnRzIGlzIGxpa2VseVxyXG4gICAgLy8gdG8gYmUgbXVjaCBtb3JlIGNvbW1vbiB0aGFuIHNwZWNpZnlpbmcgYHRoaXNgLCBoZW5jZSB0aGlzIG9yZGVyaW5nOlxyXG4gICAgYXJncywgdGhpc0FyZykge1xyXG4gICAgICAgIGlmIChjdXJyZW50Q29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgc2F2ZWQgPSBjdXJyZW50Q29udGV4dDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSBhbGxvd3MgdGhlIGFyZ3VtZW50cyBhcnJheSBhcmd1bWVudCB0byBiZVxyXG4gICAgICAgICAgICAgICAgLy8gb21pdHRlZCBvciB1bmRlZmluZWQsIHNvIGFyZ3MhIGlzIGZpbmUgaGVyZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNsb3Q7XHJcbn0oKSk7IH07XHJcbi8vIFdlIHN0b3JlIGEgc2luZ2xlIGdsb2JhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2xvdCBjbGFzcyBhcyBhIHBlcm1hbmVudFxyXG4vLyBub24tZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydHkgb2YgdGhlIEFycmF5IGNvbnN0cnVjdG9yLiBUaGlzIG9iZnVzY2F0aW9uXHJcbi8vIGRvZXMgbm90aGluZyB0byBwcmV2ZW50IGFjY2VzcyB0byB0aGUgU2xvdCBjbGFzcywgYnV0IGF0IGxlYXN0IGl0IGVuc3VyZXNcclxuLy8gdGhlIGltcGxlbWVudGF0aW9uIChpLmUuIGN1cnJlbnRDb250ZXh0KSBjYW5ub3QgYmUgdGFtcGVyZWQgd2l0aCwgYW5kIGFsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlIChob3BlZnVsbHkganVzdCBvbmUpIHdpbGwgc2hhcmUgdGhlXHJcbi8vIHNhbWUgU2xvdCBpbXBsZW1lbnRhdGlvbi4gU2luY2UgdGhlIGZpcnN0IGNvcHkgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlXHJcbi8vIHRvIGJlIGltcG9ydGVkIHdpbnMsIHRoaXMgdGVjaG5pcXVlIGltcG9zZXMgYSB2ZXJ5IGhpZ2ggY29zdCBmb3IgYW55XHJcbi8vIGZ1dHVyZSBicmVha2luZyBjaGFuZ2VzIHRvIHRoZSBTbG90IGNsYXNzLlxyXG52YXIgZ2xvYmFsS2V5ID0gXCJAd3J5L2NvbnRleHQ6U2xvdFwiO1xyXG52YXIgaG9zdCA9IEFycmF5O1xyXG52YXIgU2xvdCA9IGhvc3RbZ2xvYmFsS2V5XSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgU2xvdCA9IG1ha2VTbG90Q2xhc3MoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QsIGdsb2JhbEtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogaG9zdFtnbG9iYWxLZXldID0gU2xvdCxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHJldHVybiBTbG90O1xyXG4gICAgfVxyXG59KCk7XG5cbnZhciBiaW5kID0gU2xvdC5iaW5kLCBub0NvbnRleHQgPSBTbG90Lm5vQ29udGV4dDtcclxuZnVuY3Rpb24gc2V0VGltZW91dFdpdGhDb250ZXh0KGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZChjYWxsYmFjayksIGRlbGF5KTtcclxufVxyXG4vLyBUdXJuIGFueSBnZW5lcmF0b3IgZnVuY3Rpb24gaW50byBhbiBhc3luYyBmdW5jdGlvbiAodXNpbmcgeWllbGQgaW5zdGVhZFxyXG4vLyBvZiBhd2FpdCksIHdpdGggY29udGV4dCBhdXRvbWF0aWNhbGx5IHByZXNlcnZlZCBhY3Jvc3MgeWllbGRzLlxyXG5mdW5jdGlvbiBhc3luY0Zyb21HZW4oZ2VuRm4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdlbiA9IGdlbkZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdmFyIGJvdW5kTmV4dCA9IGJpbmQoZ2VuLm5leHQpO1xyXG4gICAgICAgIHZhciBib3VuZFRocm93ID0gYmluZChnZW4udGhyb3cpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuY2FsbChnZW4sIGFyZ3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSByZXN1bHQuZG9uZSA/IHJlc29sdmUgOiBpbnZva2VOZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UocmVzdWx0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKG5leHQsIHJlc3VsdC5kb25lID8gcmVqZWN0IDogaW52b2tlVGhyb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dChyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbnZva2VOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpbnZva2UoYm91bmROZXh0LCB2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgIHZhciBpbnZva2VUaHJvdyA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKGJvdW5kVGhyb3csIGVycm9yKTsgfTtcclxuICAgICAgICAgICAgaW52b2tlTmV4dCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG4vLyBJZiB5b3UgdXNlIHRoZSBmaWJlcnMgbnBtIHBhY2thZ2UgdG8gaW1wbGVtZW50IGNvcm91dGluZXMgaW4gTm9kZS5qcyxcclxuLy8geW91IHNob3VsZCBjYWxsIHRoaXMgZnVuY3Rpb24gYXQgbGVhc3Qgb25jZSB0byBlbnN1cmUgY29udGV4dCBtYW5hZ2VtZW50XHJcbi8vIHJlbWFpbnMgY29oZXJlbnQgYWNyb3NzIGFueSB5aWVsZHMuXHJcbnZhciB3cmFwcGVkRmliZXJzID0gW107XHJcbmZ1bmN0aW9uIHdyYXBZaWVsZGluZ0ZpYmVyTWV0aG9kcyhGaWJlcikge1xyXG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGltcGxlbWVudGF0aW9uIG9mIEZpYmVyIHBlciBwcm9jZXNzLCBzbyB0aGlzIGFycmF5XHJcbiAgICAvLyBzaG91bGQgbmV2ZXIgZ3JvdyBsb25nZXIgdGhhbiBvbmUgZWxlbWVudC5cclxuICAgIGlmICh3cmFwcGVkRmliZXJzLmluZGV4T2YoRmliZXIpIDwgMCkge1xyXG4gICAgICAgIHZhciB3cmFwID0gZnVuY3Rpb24gKG9iaiwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IG9ialttZXRob2RdO1xyXG4gICAgICAgICAgICBvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub0NvbnRleHQoZm4sIGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUaGVzZSBtZXRob2RzIGNhbiB5aWVsZCwgYWNjb3JkaW5nIHRvXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xhdmVyZGV0L25vZGUtZmliZXJzL2Jsb2IvZGRlYmVkOWI4YWUzODgzZTU3ZjgyMmUyMTA4ZTY5NDNlNWM4ZDJhOC9maWJlcnMuanMjTDk3LUwxMDBcclxuICAgICAgICB3cmFwKEZpYmVyLCBcInlpZWxkXCIpO1xyXG4gICAgICAgIHdyYXAoRmliZXIucHJvdG90eXBlLCBcInJ1blwiKTtcclxuICAgICAgICB3cmFwKEZpYmVyLnByb3RvdHlwZSwgXCJ0aHJvd0ludG9cIik7XHJcbiAgICAgICAgd3JhcHBlZEZpYmVycy5wdXNoKEZpYmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBGaWJlcjtcclxufVxuXG5leHBvcnQgeyBTbG90LCBhc3luY0Zyb21HZW4sIGJpbmQsIG5vQ29udGV4dCwgc2V0VGltZW91dFdpdGhDb250ZXh0IGFzIHNldFRpbWVvdXQsIHdyYXBZaWVsZGluZ0ZpYmVyTWV0aG9kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5lc20uanMubWFwXG4iLCJ2YXIgX2EgPSBPYmplY3QucHJvdG90eXBlLCB0b1N0cmluZyA9IF9hLnRvU3RyaW5nLCBoYXNPd25Qcm9wZXJ0eSA9IF9hLmhhc093blByb3BlcnR5O1xyXG52YXIgcHJldmlvdXNDb21wYXJpc29ucyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgZGVlcCBlcXVhbGl0eSBjaGVjayBvbiB0d28gSmF2YVNjcmlwdCB2YWx1ZXMsIHRvbGVyYXRpbmcgY3ljbGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWwoYSwgYikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gY2hlY2soYSwgYik7XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBwcmV2aW91c0NvbXBhcmlzb25zLmNsZWFyKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2soYSwgYikge1xyXG4gICAgLy8gSWYgdGhlIHR3byB2YWx1ZXMgYXJlIHN0cmljdGx5IGVxdWFsLCBvdXIgam9iIGlzIGVhc3kuXHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyByZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bnRpbWUgdHlwZSBvZlxyXG4gICAgLy8gdGhlIGdpdmVuIHZhbHVlIHRoYXQgaXMgY29uc2lkZXJhYmx5IG1vcmUgcHJlY2lzZSB0aGFuIHR5cGVvZi5cclxuICAgIHZhciBhVGFnID0gdG9TdHJpbmcuY2FsbChhKTtcclxuICAgIHZhciBiVGFnID0gdG9TdHJpbmcuY2FsbChiKTtcclxuICAgIC8vIElmIHRoZSBydW50aW1lIHR5cGVzIG9mIGEgYW5kIGIgYXJlIGRpZmZlcmVudCwgdGhleSBjb3VsZCBtYXliZSBiZSBlcXVhbFxyXG4gICAgLy8gdW5kZXIgc29tZSBpbnRlcnByZXRhdGlvbiBvZiBlcXVhbGl0eSwgYnV0IGZvciBzaW1wbGljaXR5IGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gd2UganVzdCByZXR1cm4gZmFsc2UgaW5zdGVhZC5cclxuICAgIGlmIChhVGFnICE9PSBiVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChhVGFnKSB7XHJcbiAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxyXG4gICAgICAgICAgICAvLyBBcnJheXMgYXJlIGEgbG90IGxpa2Ugb3RoZXIgb2JqZWN0cywgYnV0IHdlIGNhbiBjaGVhcGx5IGNvbXBhcmUgdGhlaXJcclxuICAgICAgICAgICAgLy8gbGVuZ3RocyBhcyBhIHNob3J0LWN1dCBiZWZvcmUgY29tcGFyaW5nIHRoZWlyIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBvYmplY3QgY2FzZS4uLlxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6IHtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzbHlDb21wYXJlZChhLCBiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgICAgICAgICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICAgICAgICAgIC8vIElmIGBhYCBhbmQgYGJgIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudW1lcmFibGUga2V5cywgdGhleVxyXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGRpZmZlcmVudC5cclxuICAgICAgICAgICAgdmFyIGtleUNvdW50ID0gYUtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoa2V5Q291bnQgIT09IGJLZXlzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgLy8gTm93IG1ha2Ugc3VyZSB0aGV5IGhhdmUgdGhlIHNhbWUga2V5cy5cclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlDb3VudDsgKytrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoYiwgYUtleXNba10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGNoZWNrIGRlZXAgZXF1YWxpdHkgb2YgYWxsIGNoaWxkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5Q291bnQ7ICsraykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGFLZXlzW2tdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjayhhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzpcclxuICAgICAgICAgICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlO1xyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBOYU4sIHdoaWNoIGlzICE9PSBpdHNlbGYuXHJcbiAgICAgICAgICAgIGlmIChhICE9PSBhKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgIT09IGI7XHJcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIHNoYXJlZCArYSA9PT0gK2IgY2FzZS4uLlxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxyXG4gICAgICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XHJcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcclxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gXCJcIiArIGI7XHJcbiAgICAgICAgY2FzZSAnW29iamVjdCBNYXBdJzpcclxuICAgICAgICBjYXNlICdbb2JqZWN0IFNldF0nOiB7XHJcbiAgICAgICAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzbHlDb21wYXJlZChhLCBiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgYUl0ZXJhdG9yID0gYS5lbnRyaWVzKCk7XHJcbiAgICAgICAgICAgIHZhciBpc01hcCA9IGFUYWcgPT09ICdbb2JqZWN0IE1hcF0nO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBhSXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZG9uZSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIC8vIElmIGEgaW5zdGFuY2VvZiBTZXQsIGFWYWx1ZSA9PT0gYUtleS5cclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IGluZm8udmFsdWUsIGFLZXkgPSBfYVswXSwgYVZhbHVlID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGlzIHdvcmtzIHRoZSBzYW1lIHdheSBmb3IgYm90aCBTZXQgYW5kIE1hcC5cclxuICAgICAgICAgICAgICAgIGlmICghYi5oYXMoYUtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBjYXJlIGFib3V0IGRlZXAgZXF1YWxpdHkgb2YgdmFsdWVzIG9ubHkgd2hlbiBkZWFsaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB3aXRoIE1hcCBzdHJ1Y3R1cmVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTWFwICYmICFjaGVjayhhVmFsdWUsIGIuZ2V0KGFLZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlcndpc2UgdGhlIHZhbHVlcyBhcmUgbm90IGVxdWFsLlxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHByZXZpb3VzbHlDb21wYXJlZChhLCBiKSB7XHJcbiAgICAvLyBUaG91Z2ggY3ljbGljIHJlZmVyZW5jZXMgY2FuIG1ha2UgYW4gb2JqZWN0IGdyYXBoIGFwcGVhciBpbmZpbml0ZSBmcm9tIHRoZVxyXG4gICAgLy8gcGVyc3BlY3RpdmUgb2YgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwsIHRoZSBncmFwaCBzdGlsbCBjb250YWlucyBhIGZpbml0ZVxyXG4gICAgLy8gbnVtYmVyIG9mIGRpc3RpbmN0IG9iamVjdCByZWZlcmVuY2VzLiBXZSB1c2UgdGhlIHByZXZpb3VzQ29tcGFyaXNvbnMgY2FjaGVcclxuICAgIC8vIHRvIGF2b2lkIGNvbXBhcmluZyB0aGUgc2FtZSBwYWlyIG9mIG9iamVjdCByZWZlcmVuY2VzIG1vcmUgdGhhbiBvbmNlLCB3aGljaFxyXG4gICAgLy8gZ3VhcmFudGVlcyB0ZXJtaW5hdGlvbiAoZXZlbiBpZiB3ZSBlbmQgdXAgY29tcGFyaW5nIGV2ZXJ5IG9iamVjdCBpbiBvbmVcclxuICAgIC8vIGdyYXBoIHRvIGV2ZXJ5IG9iamVjdCBpbiB0aGUgb3RoZXIgZ3JhcGgsIHdoaWNoIGlzIGV4dHJlbWVseSB1bmxpa2VseSksXHJcbiAgICAvLyB3aGlsZSBzdGlsbCBhbGxvd2luZyB3ZWlyZCBpc29tb3JwaGljIHN0cnVjdHVyZXMgKGxpa2UgcmluZ3Mgd2l0aCBkaWZmZXJlbnRcclxuICAgIC8vIGxlbmd0aHMpIGEgY2hhbmNlIHRvIHBhc3MgdGhlIGVxdWFsaXR5IHRlc3QuXHJcbiAgICB2YXIgYlNldCA9IHByZXZpb3VzQ29tcGFyaXNvbnMuZ2V0KGEpO1xyXG4gICAgaWYgKGJTZXQpIHtcclxuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBoZXJlIGJlY2F1c2Ugd2UgY2FuIGJlIHN1cmUgZmFsc2Ugd2lsbCBiZSByZXR1cm5lZCBzb21ld2hlcmVcclxuICAgICAgICAvLyBlbHNlIGlmIHRoZSBvYmplY3RzIGFyZSBub3QgZXF1aXZhbGVudC5cclxuICAgICAgICBpZiAoYlNldC5oYXMoYikpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHJldmlvdXNDb21wYXJpc29ucy5zZXQoYSwgYlNldCA9IG5ldyBTZXQpO1xyXG4gICAgfVxyXG4gICAgYlNldC5hZGQoYik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWw7XG5leHBvcnQgeyBlcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWxpdHkuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fZXh0ZW5kcyB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEFwb2xsb0NhY2hlIH0gZnJvbSAnYXBvbGxvLWNhY2hlJztcbmltcG9ydCB7IGlzVGVzdCwgZ2V0UXVlcnlEZWZpbml0aW9uLCBhc3NpZ24sIGdldERlZmF1bHRWYWx1ZXMsIGlzRXF1YWwsIGdldE1haW5EZWZpbml0aW9uLCBnZXRGcmFnbWVudERlZmluaXRpb25zLCBjcmVhdGVGcmFnbWVudE1hcCwgc2hvdWxkSW5jbHVkZSwgaXNGaWVsZCwgcmVzdWx0S2V5TmFtZUZyb21GaWVsZCwgaXNJbmxpbmVGcmFnbWVudCwgbWVyZ2VEZWVwQXJyYXksIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZCwgZ2V0RGlyZWN0aXZlSW5mb0Zyb21GaWVsZCwgbWF5YmVEZWVwRnJlZXplLCBpc0lkVmFsdWUsIGdldFN0b3JlS2V5TmFtZSwgdG9JZFZhbHVlLCBpc0pzb25WYWx1ZSwgY2FuVXNlV2Vha01hcCwgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiwgaXNQcm9kdWN0aW9uLCBzdG9yZUtleU5hbWVGcm9tRmllbGQsIGFkZFR5cGVuYW1lVG9Eb2N1bWVudCB9IGZyb20gJ2Fwb2xsby11dGlsaXRpZXMnO1xuaW1wb3J0IHsgd3JhcCwgS2V5VHJpZSB9IGZyb20gJ29wdGltaXNtJztcbmltcG9ydCB7IGludmFyaWFudCwgSW52YXJpYW50RXJyb3IgfSBmcm9tICd0cy1pbnZhcmlhbnQnO1xuXG52YXIgaGF2ZVdhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2hvdWxkV2FybigpIHtcbiAgICB2YXIgYW5zd2VyID0gIWhhdmVXYXJuZWQ7XG4gICAgaWYgKCFpc1Rlc3QoKSkge1xuICAgICAgICBoYXZlV2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFuc3dlcjtcbn1cbnZhciBIZXVyaXN0aWNGcmFnbWVudE1hdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhldXJpc3RpY0ZyYWdtZW50TWF0Y2hlcigpIHtcbiAgICB9XG4gICAgSGV1cmlzdGljRnJhZ21lbnRNYXRjaGVyLnByb3RvdHlwZS5lbnN1cmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgSGV1cmlzdGljRnJhZ21lbnRNYXRjaGVyLnByb3RvdHlwZS5jYW5CeXBhc3NJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEhldXJpc3RpY0ZyYWdtZW50TWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoaWRWYWx1ZSwgdHlwZUNvbmRpdGlvbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgb2JqID0gY29udGV4dC5zdG9yZS5nZXQoaWRWYWx1ZS5pZCk7XG4gICAgICAgIHZhciBpc1Jvb3RRdWVyeSA9IGlkVmFsdWUuaWQgPT09ICdST09UX1FVRVJZJztcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBpc1Jvb3RRdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBvYmouX190eXBlbmFtZSwgX190eXBlbmFtZSA9IF9hID09PSB2b2lkIDAgPyBpc1Jvb3RRdWVyeSAmJiAnUXVlcnknIDogX2E7XG4gICAgICAgIGlmICghX190eXBlbmFtZSkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFdhcm4oKSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybihcIllvdSdyZSB1c2luZyBmcmFnbWVudHMgaW4geW91ciBxdWVyaWVzLCBidXQgZWl0aGVyIGRvbid0IGhhdmUgdGhlIGFkZFR5cGVuYW1lOlxcbiAgdHJ1ZSBvcHRpb24gc2V0IGluIEFwb2xsbyBDbGllbnQsIG9yIHlvdSBhcmUgdHJ5aW5nIHRvIHdyaXRlIGEgZnJhZ21lbnQgdG8gdGhlIHN0b3JlIHdpdGhvdXQgdGhlIF9fdHlwZW5hbWUuXFxuICAgUGxlYXNlIHR1cm4gb24gdGhlIGFkZFR5cGVuYW1lIG9wdGlvbiBhbmQgaW5jbHVkZSBfX3R5cGVuYW1lIHdoZW4gd3JpdGluZyBmcmFnbWVudHMgc28gdGhhdCBBcG9sbG8gQ2xpZW50XFxuICAgY2FuIGFjY3VyYXRlbHkgbWF0Y2ggZnJhZ21lbnRzLlwiKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oJ0NvdWxkIG5vdCBmaW5kIF9fdHlwZW5hbWUgb24gRnJhZ21lbnQgJywgdHlwZUNvbmRpdGlvbiwgb2JqKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oXCJERVBSRUNBVElPTiBXQVJOSU5HOiB1c2luZyBmcmFnbWVudHMgd2l0aG91dCBfX3R5cGVuYW1lIGlzIHVuc3VwcG9ydGVkIGJlaGF2aW9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBBcG9sbG8gY2xpZW50LiBZb3Ugc2hvdWxkIGZpeCB0aGlzIGFuZCBzZXQgYWRkVHlwZW5hbWUgdG8gdHJ1ZSBub3cuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdoZXVyaXN0aWMnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX3R5cGVuYW1lID09PSB0eXBlQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkV2FybigpKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50LmVycm9yKCdZb3UgYXJlIHVzaW5nIHRoZSBzaW1wbGUgKGhldXJpc3RpYykgZnJhZ21lbnQgbWF0Y2hlciwgYnV0IHlvdXIgJyArXG4gICAgICAgICAgICAgICAgJ3F1ZXJpZXMgY29udGFpbiB1bmlvbiBvciBpbnRlcmZhY2UgdHlwZXMuIEFwb2xsbyBDbGllbnQgd2lsbCBub3QgYmUgJyArXG4gICAgICAgICAgICAgICAgJ2FibGUgdG8gYWNjdXJhdGVseSBtYXAgZnJhZ21lbnRzLiBUbyBtYWtlIHRoaXMgZXJyb3IgZ28gYXdheSwgdXNlICcgK1xuICAgICAgICAgICAgICAgICd0aGUgYEludHJvc3BlY3Rpb25GcmFnbWVudE1hdGNoZXJgIGFzIGRlc2NyaWJlZCBpbiB0aGUgZG9jczogJyArXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmFwb2xsb2dyYXBocWwuY29tL2RvY3MvcmVhY3QvYWR2YW5jZWQvZnJhZ21lbnRzLmh0bWwjZnJhZ21lbnQtbWF0Y2hlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnaGV1cmlzdGljJztcbiAgICB9O1xuICAgIHJldHVybiBIZXVyaXN0aWNGcmFnbWVudE1hdGNoZXI7XG59KCkpO1xudmFyIEludHJvc3BlY3Rpb25GcmFnbWVudE1hdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludHJvc3BlY3Rpb25GcmFnbWVudE1hdGNoZXIob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmludHJvc3BlY3Rpb25RdWVyeVJlc3VsdERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVUeXBlc01hcCA9IHRoaXMucGFyc2VJbnRyb3NwZWN0aW9uUmVzdWx0KG9wdGlvbnMuaW50cm9zcGVjdGlvblF1ZXJ5UmVzdWx0RGF0YSk7XG4gICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guYmluZCh0aGlzKTtcbiAgICB9XG4gICAgSW50cm9zcGVjdGlvbkZyYWdtZW50TWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoaWRWYWx1ZSwgdHlwZUNvbmRpdGlvbiwgY29udGV4dCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQodGhpcy5pc1JlYWR5LCAxKSA6IGludmFyaWFudCh0aGlzLmlzUmVhZHksICdGcmFnbWVudE1hdGNoZXIubWF0Y2goKSB3YXMgY2FsbGVkIGJlZm9yZSBGcmFnbWVudE1hdGNoZXIuaW5pdCgpJyk7XG4gICAgICAgIHZhciBvYmogPSBjb250ZXh0LnN0b3JlLmdldChpZFZhbHVlLmlkKTtcbiAgICAgICAgdmFyIGlzUm9vdFF1ZXJ5ID0gaWRWYWx1ZS5pZCA9PT0gJ1JPT1RfUVVFUlknO1xuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGlzUm9vdFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IG9iai5fX3R5cGVuYW1lLCBfX3R5cGVuYW1lID0gX2EgPT09IHZvaWQgMCA/IGlzUm9vdFF1ZXJ5ICYmICdRdWVyeScgOiBfYTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KF9fdHlwZW5hbWUsIDIpIDogaW52YXJpYW50KF9fdHlwZW5hbWUsIFwiQ2Fubm90IG1hdGNoIGZyYWdtZW50IGJlY2F1c2UgX190eXBlbmFtZSBwcm9wZXJ0eSBpcyBtaXNzaW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICBpZiAoX190eXBlbmFtZSA9PT0gdHlwZUNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltcGxlbWVudGluZ1R5cGVzID0gdGhpcy5wb3NzaWJsZVR5cGVzTWFwW3R5cGVDb25kaXRpb25dO1xuICAgICAgICBpZiAoX190eXBlbmFtZSAmJlxuICAgICAgICAgICAgaW1wbGVtZW50aW5nVHlwZXMgJiZcbiAgICAgICAgICAgIGltcGxlbWVudGluZ1R5cGVzLmluZGV4T2YoX190eXBlbmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgSW50cm9zcGVjdGlvbkZyYWdtZW50TWF0Y2hlci5wcm90b3R5cGUucGFyc2VJbnRyb3NwZWN0aW9uUmVzdWx0ID0gZnVuY3Rpb24gKGludHJvc3BlY3Rpb25SZXN1bHREYXRhKSB7XG4gICAgICAgIHZhciB0eXBlTWFwID0ge307XG4gICAgICAgIGludHJvc3BlY3Rpb25SZXN1bHREYXRhLl9fc2NoZW1hLnR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlLmtpbmQgPT09ICdVTklPTicgfHwgdHlwZS5raW5kID09PSAnSU5URVJGQUNFJykge1xuICAgICAgICAgICAgICAgIHR5cGVNYXBbdHlwZS5uYW1lXSA9IHR5cGUucG9zc2libGVUeXBlcy5tYXAoZnVuY3Rpb24gKGltcGxlbWVudGluZ1R5cGUpIHsgcmV0dXJuIGltcGxlbWVudGluZ1R5cGUubmFtZTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZU1hcDtcbiAgICB9O1xuICAgIHJldHVybiBJbnRyb3NwZWN0aW9uRnJhZ21lbnRNYXRjaGVyO1xufSgpKTtcblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgRGVwVHJhY2tpbmdDYWNoZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVwVHJhY2tpbmdDYWNoZShkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5kZXBlbmQgPSB3cmFwKGZ1bmN0aW9uIChkYXRhSWQpIHsgcmV0dXJuIF90aGlzLmRhdGFbZGF0YUlkXTsgfSwge1xuICAgICAgICAgICAgZGlzcG9zYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgRGVwVHJhY2tpbmdDYWNoZS5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfTtcbiAgICBEZXBUcmFja2luZ0NhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICB9O1xuICAgIERlcFRyYWNraW5nQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChkYXRhSWQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbZGF0YUlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kZXBlbmQuZGlydHkoZGF0YUlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVwVHJhY2tpbmdDYWNoZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAoaGFzT3duLmNhbGwodGhpcy5kYXRhLCBkYXRhSWQpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2RhdGFJZF07XG4gICAgICAgICAgICB0aGlzLmRlcGVuZC5kaXJ0eShkYXRhSWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZXBUcmFja2luZ0NhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgIH07XG4gICAgRGVwVHJhY2tpbmdDYWNoZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChuZXdEYXRhKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXQoZGF0YUlkLCBuZXdEYXRhW2RhdGFJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwobmV3RGF0YSwgZGF0YUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxldGUoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlcFRyYWNraW5nQ2FjaGU7XG59KCkpO1xuZnVuY3Rpb24gZGVmYXVsdE5vcm1hbGl6ZWRDYWNoZUZhY3Rvcnkoc2VlZCkge1xuICAgIHJldHVybiBuZXcgRGVwVHJhY2tpbmdDYWNoZShzZWVkKTtcbn1cblxudmFyIFN0b3JlUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZVJlYWRlcihfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5jYWNoZUtleVJvb3QsIGNhY2hlS2V5Um9vdCA9IF9jID09PSB2b2lkIDAgPyBuZXcgS2V5VHJpZShjYW5Vc2VXZWFrTWFwKSA6IF9jLCBfZCA9IF9iLmZyZWV6ZVJlc3VsdHMsIGZyZWV6ZVJlc3VsdHMgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZDtcbiAgICAgICAgdmFyIF9lID0gdGhpcywgZXhlY3V0ZVN0b3JlUXVlcnkgPSBfZS5leGVjdXRlU3RvcmVRdWVyeSwgZXhlY3V0ZVNlbGVjdGlvblNldCA9IF9lLmV4ZWN1dGVTZWxlY3Rpb25TZXQsIGV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5ID0gX2UuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXk7XG4gICAgICAgIHRoaXMuZnJlZXplUmVzdWx0cyA9IGZyZWV6ZVJlc3VsdHM7XG4gICAgICAgIHRoaXMuZXhlY3V0ZVN0b3JlUXVlcnkgPSB3cmFwKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVN0b3JlUXVlcnkuY2FsbChfdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX2EucXVlcnksIHJvb3RWYWx1ZSA9IF9hLnJvb3RWYWx1ZSwgY29udGV4dFZhbHVlID0gX2EuY29udGV4dFZhbHVlLCB2YXJpYWJsZVZhbHVlcyA9IF9hLnZhcmlhYmxlVmFsdWVzLCBmcmFnbWVudE1hdGNoZXIgPSBfYS5mcmFnbWVudE1hdGNoZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRWYWx1ZS5zdG9yZSBpbnN0YW5jZW9mIERlcFRyYWNraW5nQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlS2V5Um9vdC5sb29rdXAoY29udGV4dFZhbHVlLnN0b3JlLCBxdWVyeSwgZnJhZ21lbnRNYXRjaGVyLCBKU09OLnN0cmluZ2lmeSh2YXJpYWJsZVZhbHVlcyksIHJvb3RWYWx1ZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leGVjdXRlU2VsZWN0aW9uU2V0ID0gd3JhcChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVTZWxlY3Rpb25TZXQuY2FsbChfdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvblNldCA9IF9hLnNlbGVjdGlvblNldCwgcm9vdFZhbHVlID0gX2Eucm9vdFZhbHVlLCBleGVjQ29udGV4dCA9IF9hLmV4ZWNDb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChleGVjQ29udGV4dC5jb250ZXh0VmFsdWUuc3RvcmUgaW5zdGFuY2VvZiBEZXBUcmFja2luZ0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUtleVJvb3QubG9va3VwKGV4ZWNDb250ZXh0LmNvbnRleHRWYWx1ZS5zdG9yZSwgc2VsZWN0aW9uU2V0LCBleGVjQ29udGV4dC5mcmFnbWVudE1hdGNoZXIsIEpTT04uc3RyaW5naWZ5KGV4ZWNDb250ZXh0LnZhcmlhYmxlVmFsdWVzKSwgcm9vdFZhbHVlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5ID0gd3JhcChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5LmNhbGwoX3RoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCBhcnJheSA9IF9hLmFycmF5LCBleGVjQ29udGV4dCA9IF9hLmV4ZWNDb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChleGVjQ29udGV4dC5jb250ZXh0VmFsdWUuc3RvcmUgaW5zdGFuY2VvZiBEZXBUcmFja2luZ0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUtleVJvb3QubG9va3VwKGV4ZWNDb250ZXh0LmNvbnRleHRWYWx1ZS5zdG9yZSwgZmllbGQsIGFycmF5LCBKU09OLnN0cmluZ2lmeShleGVjQ29udGV4dC52YXJpYWJsZVZhbHVlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5yZWFkUXVlcnlGcm9tU3RvcmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHJldHVyblBhcnRpYWxEYXRhOiBmYWxzZSB9KSkucmVzdWx0O1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmRpZmZRdWVyeUFnYWluc3RTdG9yZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3RvcmUgPSBfYS5zdG9yZSwgcXVlcnkgPSBfYS5xdWVyeSwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBwcmV2aW91c1Jlc3VsdCA9IF9hLnByZXZpb3VzUmVzdWx0LCBfYiA9IF9hLnJldHVyblBhcnRpYWxEYXRhLCByZXR1cm5QYXJ0aWFsRGF0YSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gX2Eucm9vdElkLCByb290SWQgPSBfYyA9PT0gdm9pZCAwID8gJ1JPT1RfUVVFUlknIDogX2MsIGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uID0gX2EuZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24sIGNvbmZpZyA9IF9hLmNvbmZpZztcbiAgICAgICAgdmFyIHF1ZXJ5RGVmaW5pdGlvbiA9IGdldFF1ZXJ5RGVmaW5pdGlvbihxdWVyeSk7XG4gICAgICAgIHZhcmlhYmxlcyA9IGFzc2lnbih7fSwgZ2V0RGVmYXVsdFZhbHVlcyhxdWVyeURlZmluaXRpb24pLCB2YXJpYWJsZXMpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICAgIGRhdGFJZEZyb21PYmplY3Q6IGNvbmZpZyAmJiBjb25maWcuZGF0YUlkRnJvbU9iamVjdCxcbiAgICAgICAgICAgIGNhY2hlUmVkaXJlY3RzOiAoY29uZmlnICYmIGNvbmZpZy5jYWNoZVJlZGlyZWN0cykgfHwge30sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBleGVjUmVzdWx0ID0gdGhpcy5leGVjdXRlU3RvcmVRdWVyeSh7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICByb290VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaWQnLFxuICAgICAgICAgICAgICAgIGlkOiByb290SWQsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGVuYW1lOiAnUXVlcnknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRleHRWYWx1ZTogY29udGV4dCxcbiAgICAgICAgICAgIHZhcmlhYmxlVmFsdWVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGhhc01pc3NpbmdGaWVsZHMgPSBleGVjUmVzdWx0Lm1pc3NpbmcgJiYgZXhlY1Jlc3VsdC5taXNzaW5nLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChoYXNNaXNzaW5nRmllbGRzICYmICFyZXR1cm5QYXJ0aWFsRGF0YSkge1xuICAgICAgICAgICAgZXhlY1Jlc3VsdC5taXNzaW5nLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby50b2xlcmFibGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoOCkgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJDYW4ndCBmaW5kIGZpZWxkIFwiICsgaW5mby5maWVsZE5hbWUgKyBcIiBvbiBvYmplY3QgXCIgKyBKU09OLnN0cmluZ2lmeShpbmZvLm9iamVjdCwgbnVsbCwgMikgKyBcIi5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChpc0VxdWFsKHByZXZpb3VzUmVzdWx0LCBleGVjUmVzdWx0LnJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBleGVjUmVzdWx0LnJlc3VsdCA9IHByZXZpb3VzUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGV4ZWNSZXN1bHQucmVzdWx0LFxuICAgICAgICAgICAgY29tcGxldGU6ICFoYXNNaXNzaW5nRmllbGRzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmV4ZWN1dGVTdG9yZVF1ZXJ5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCByb290VmFsdWUgPSBfYS5yb290VmFsdWUsIGNvbnRleHRWYWx1ZSA9IF9hLmNvbnRleHRWYWx1ZSwgdmFyaWFibGVWYWx1ZXMgPSBfYS52YXJpYWJsZVZhbHVlcywgX2IgPSBfYS5mcmFnbWVudE1hdGNoZXIsIGZyYWdtZW50TWF0Y2hlciA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0RnJhZ21lbnRNYXRjaGVyIDogX2I7XG4gICAgICAgIHZhciBtYWluRGVmaW5pdGlvbiA9IGdldE1haW5EZWZpbml0aW9uKHF1ZXJ5KTtcbiAgICAgICAgdmFyIGZyYWdtZW50cyA9IGdldEZyYWdtZW50RGVmaW5pdGlvbnMocXVlcnkpO1xuICAgICAgICB2YXIgZnJhZ21lbnRNYXAgPSBjcmVhdGVGcmFnbWVudE1hcChmcmFnbWVudHMpO1xuICAgICAgICB2YXIgZXhlY0NvbnRleHQgPSB7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICBmcmFnbWVudE1hcDogZnJhZ21lbnRNYXAsXG4gICAgICAgICAgICBjb250ZXh0VmFsdWU6IGNvbnRleHRWYWx1ZSxcbiAgICAgICAgICAgIHZhcmlhYmxlVmFsdWVzOiB2YXJpYWJsZVZhbHVlcyxcbiAgICAgICAgICAgIGZyYWdtZW50TWF0Y2hlcjogZnJhZ21lbnRNYXRjaGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlU2VsZWN0aW9uU2V0KHtcbiAgICAgICAgICAgIHNlbGVjdGlvblNldDogbWFpbkRlZmluaXRpb24uc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgcm9vdFZhbHVlOiByb290VmFsdWUsXG4gICAgICAgICAgICBleGVjQ29udGV4dDogZXhlY0NvbnRleHQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmV4ZWN1dGVTZWxlY3Rpb25TZXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGVjdGlvblNldCA9IF9hLnNlbGVjdGlvblNldCwgcm9vdFZhbHVlID0gX2Eucm9vdFZhbHVlLCBleGVjQ29udGV4dCA9IF9hLmV4ZWNDb250ZXh0O1xuICAgICAgICB2YXIgZnJhZ21lbnRNYXAgPSBleGVjQ29udGV4dC5mcmFnbWVudE1hcCwgY29udGV4dFZhbHVlID0gZXhlY0NvbnRleHQuY29udGV4dFZhbHVlLCB2YXJpYWJsZXMgPSBleGVjQ29udGV4dC52YXJpYWJsZVZhbHVlcztcbiAgICAgICAgdmFyIGZpbmFsUmVzdWx0ID0geyByZXN1bHQ6IG51bGwgfTtcbiAgICAgICAgdmFyIG9iamVjdHNUb01lcmdlID0gW107XG4gICAgICAgIHZhciBvYmplY3QgPSBjb250ZXh0VmFsdWUuc3RvcmUuZ2V0KHJvb3RWYWx1ZS5pZCk7XG4gICAgICAgIHZhciB0eXBlbmFtZSA9IChvYmplY3QgJiYgb2JqZWN0Ll9fdHlwZW5hbWUpIHx8XG4gICAgICAgICAgICAocm9vdFZhbHVlLmlkID09PSAnUk9PVF9RVUVSWScgJiYgJ1F1ZXJ5JykgfHxcbiAgICAgICAgICAgIHZvaWQgMDtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTWlzc2luZyhyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubWlzc2luZykge1xuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0Lm1pc3NpbmcgPSBmaW5hbFJlc3VsdC5taXNzaW5nIHx8IFtdO1xuICAgICAgICAgICAgICAgIChfYSA9IGZpbmFsUmVzdWx0Lm1pc3NpbmcpLnB1c2guYXBwbHkoX2EsIHJlc3VsdC5taXNzaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRSZXN1bHQgPSBoYW5kbGVNaXNzaW5nKF90aGlzLmV4ZWN1dGVGaWVsZChvYmplY3QsIHR5cGVuYW1lLCBzZWxlY3Rpb24sIGV4ZWNDb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0c1RvTWVyZ2UucHVzaCgoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hW3Jlc3VsdEtleU5hbWVGcm9tRmllbGQoc2VsZWN0aW9uKV0gPSBmaWVsZFJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChpc0lubGluZUZyYWdtZW50KHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50TWFwW3NlbGVjdGlvbi5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDkpIDogbmV3IEludmFyaWFudEVycm9yKFwiTm8gZnJhZ21lbnQgbmFtZWQgXCIgKyBzZWxlY3Rpb24ubmFtZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVDb25kaXRpb24gPSBmcmFnbWVudC50eXBlQ29uZGl0aW9uICYmIGZyYWdtZW50LnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSAhdHlwZUNvbmRpdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICBleGVjQ29udGV4dC5mcmFnbWVudE1hdGNoZXIocm9vdFZhbHVlLCB0eXBlQ29uZGl0aW9uLCBjb250ZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRFeGVjUmVzdWx0ID0gX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IGZyYWdtZW50LnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RWYWx1ZTogcm9vdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0NvbnRleHQ6IGV4ZWNDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAnaGV1cmlzdGljJyAmJiBmcmFnbWVudEV4ZWNSZXN1bHQubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRFeGVjUmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGZyYWdtZW50RXhlY1Jlc3VsdCksIHsgbWlzc2luZzogZnJhZ21lbnRFeGVjUmVzdWx0Lm1pc3NpbmcubWFwKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHsgdG9sZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHNUb01lcmdlLnB1c2goaGFuZGxlTWlzc2luZyhmcmFnbWVudEV4ZWNSZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbFJlc3VsdC5yZXN1bHQgPSBtZXJnZURlZXBBcnJheShvYmplY3RzVG9NZXJnZSk7XG4gICAgICAgIGlmICh0aGlzLmZyZWV6ZVJlc3VsdHMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShmaW5hbFJlc3VsdC5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbFJlc3VsdDtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5leGVjdXRlRmllbGQgPSBmdW5jdGlvbiAob2JqZWN0LCB0eXBlbmFtZSwgZmllbGQsIGV4ZWNDb250ZXh0KSB7XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBleGVjQ29udGV4dC52YXJpYWJsZVZhbHVlcywgY29udGV4dFZhbHVlID0gZXhlY0NvbnRleHQuY29udGV4dFZhbHVlO1xuICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGQubmFtZS52YWx1ZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcyk7XG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgcmVzdWx0S2V5OiByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGdldERpcmVjdGl2ZUluZm9Gcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcyksXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWFkU3RvcmVSZXN1bHQgPSByZWFkU3RvcmVSZXNvbHZlcihvYmplY3QsIHR5cGVuYW1lLCBmaWVsZE5hbWUsIGFyZ3MsIGNvbnRleHRWYWx1ZSwgaW5mbyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlYWRTdG9yZVJlc3VsdC5yZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5lRXhlY1Jlc3VsdHMocmVhZFN0b3JlUmVzdWx0LCB0aGlzLmV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5KHtcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgYXJyYXk6IHJlYWRTdG9yZVJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICAgICAgZXhlY0NvbnRleHQ6IGV4ZWNDb250ZXh0LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBhc3NlcnRTZWxlY3Rpb25TZXRGb3JJZFZhbHVlKGZpZWxkLCByZWFkU3RvcmVSZXN1bHQucmVzdWx0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyZWV6ZVJlc3VsdHMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1heWJlRGVlcEZyZWV6ZShyZWFkU3RvcmVSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlYWRTdG9yZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZFN0b3JlUmVzdWx0LnJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZFN0b3JlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbWJpbmVFeGVjUmVzdWx0cyhyZWFkU3RvcmVSZXN1bHQsIHRoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IGZpZWxkLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIHJvb3RWYWx1ZTogcmVhZFN0b3JlUmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgIGV4ZWNDb250ZXh0OiBleGVjQ29udGV4dCxcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmNvbWJpbmVFeGVjUmVzdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4ZWNSZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleGVjUmVzdWx0c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaXNzaW5nO1xuICAgICAgICBleGVjUmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChleGVjUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZXhlY1Jlc3VsdC5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmcgfHwgW107XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoLmFwcGx5KG1pc3NpbmcsIGV4ZWNSZXN1bHQubWlzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBleGVjUmVzdWx0cy5wb3AoKS5yZXN1bHQsXG4gICAgICAgICAgICBtaXNzaW5nOiBtaXNzaW5nLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCBhcnJheSA9IF9hLmFycmF5LCBleGVjQ29udGV4dCA9IF9hLmV4ZWNDb250ZXh0O1xuICAgICAgICB2YXIgbWlzc2luZztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTWlzc2luZyhjaGlsZFJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkUmVzdWx0Lm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nID0gbWlzc2luZyB8fCBbXTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2guYXBwbHkobWlzc2luZywgY2hpbGRSZXN1bHQubWlzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRSZXN1bHQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGFycmF5ID0gYXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlTWlzc2luZyhfdGhpcy5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheSh7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXk6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGV4ZWNDb250ZXh0OiBleGVjQ29udGV4dCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDogZmllbGQuc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgICAgICAgICByb290VmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGV4ZWNDb250ZXh0OiBleGVjQ29udGV4dCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRTZWxlY3Rpb25TZXRGb3JJZFZhbHVlKGZpZWxkLCBpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZnJlZXplUmVzdWx0cyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGFycmF5LCBtaXNzaW5nOiBtaXNzaW5nIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmVSZWFkZXI7XG59KCkpO1xuZnVuY3Rpb24gYXNzZXJ0U2VsZWN0aW9uU2V0Rm9ySWRWYWx1ZShmaWVsZCwgdmFsdWUpIHtcbiAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCAmJiBpc0lkVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcigxMCkgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJNaXNzaW5nIHNlbGVjdGlvbiBzZXQgZm9yIG9iamVjdCBvZiB0eXBlIFwiICsgdmFsdWUudHlwZW5hbWUgKyBcIiByZXR1cm5lZCBmb3IgcXVlcnkgZmllbGQgXCIgKyBmaWVsZC5uYW1lLnZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0RnJhZ21lbnRNYXRjaGVyKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0SWRWYWx1ZShpZFZhbHVlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGlzSWRWYWx1ZShpZFZhbHVlKSwgMTEpIDogaW52YXJpYW50KGlzSWRWYWx1ZShpZFZhbHVlKSwgXCJFbmNvdW50ZXJlZCBhIHN1Yi1zZWxlY3Rpb24gb24gdGhlIHF1ZXJ5LCBidXQgdGhlIHN0b3JlIGRvZXNuJ3QgaGF2ZSBhbiBvYmplY3QgcmVmZXJlbmNlLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gZHVyaW5nIG5vcm1hbCB1c2UgdW5sZXNzIHlvdSBoYXZlIGN1c3RvbSBjb2RlIHRoYXQgaXMgZGlyZWN0bHkgbWFuaXB1bGF0aW5nIHRoZSBzdG9yZTsgcGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xufVxuZnVuY3Rpb24gcmVhZFN0b3JlUmVzb2x2ZXIob2JqZWN0LCB0eXBlbmFtZSwgZmllbGROYW1lLCBhcmdzLCBjb250ZXh0LCBfYSkge1xuICAgIHZhciByZXN1bHRLZXkgPSBfYS5yZXN1bHRLZXksIGRpcmVjdGl2ZXMgPSBfYS5kaXJlY3RpdmVzO1xuICAgIHZhciBzdG9yZUtleU5hbWUgPSBmaWVsZE5hbWU7XG4gICAgaWYgKGFyZ3MgfHwgZGlyZWN0aXZlcykge1xuICAgICAgICBzdG9yZUtleU5hbWUgPSBnZXRTdG9yZUtleU5hbWUoc3RvcmVLZXlOYW1lLCBhcmdzLCBkaXJlY3RpdmVzKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkVmFsdWUgPSB2b2lkIDA7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgICBmaWVsZFZhbHVlID0gb2JqZWN0W3N0b3JlS2V5TmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbnRleHQuY2FjaGVSZWRpcmVjdHMgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gY29udGV4dC5jYWNoZVJlZGlyZWN0c1t0eXBlbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHR5cGVbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHJlc29sdmVyKG9iamVjdCwgYXJncywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2FjaGVLZXk6IGZ1bmN0aW9uIChzdG9yZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGNvbnRleHQuZGF0YUlkRnJvbU9iamVjdChzdG9yZU9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkICYmIHRvSWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW5hbWU6IHN0b3JlT2JqLl9fdHlwZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmaWVsZFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBmaWVsZFZhbHVlLFxuICAgICAgICAgICAgbWlzc2luZzogW3tcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogc3RvcmVLZXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0b2xlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNKc29uVmFsdWUoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWUuanNvbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBmaWVsZFZhbHVlLFxuICAgIH07XG59XG5cbnZhciBPYmplY3RDYWNoZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0Q2FjaGUoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIE9iamVjdENhY2hlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9O1xuICAgIE9iamVjdENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICB9O1xuICAgIE9iamVjdENhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFbZGF0YUlkXSA9IHZhbHVlO1xuICAgIH07XG4gICAgT2JqZWN0Q2FjaGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdGhpcy5kYXRhW2RhdGFJZF0gPSB2b2lkIDA7XG4gICAgfTtcbiAgICBPYmplY3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcbiAgICBPYmplY3RDYWNoZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGEgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3RDYWNoZTtcbn0oKSk7XG5mdW5jdGlvbiBkZWZhdWx0Tm9ybWFsaXplZENhY2hlRmFjdG9yeSQxKHNlZWQpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdENhY2hlKHNlZWQpO1xufVxuXG52YXIgV3JpdGVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdyaXRlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JpdGVFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnV3JpdGVFcnJvcic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFdyaXRlRXJyb3I7XG59KEVycm9yKSk7XG5mdW5jdGlvbiBlbmhhbmNlRXJyb3JXaXRoRG9jdW1lbnQoZXJyb3IsIGRvY3VtZW50KSB7XG4gICAgdmFyIGVuaGFuY2VkRXJyb3IgPSBuZXcgV3JpdGVFcnJvcihcIkVycm9yIHdyaXRpbmcgcmVzdWx0IHRvIHN0b3JlIGZvciBxdWVyeTpcXG4gXCIgKyBKU09OLnN0cmluZ2lmeShkb2N1bWVudCkpO1xuICAgIGVuaGFuY2VkRXJyb3IubWVzc2FnZSArPSAnXFxuJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgZW5oYW5jZWRFcnJvci5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHJldHVybiBlbmhhbmNlZEVycm9yO1xufVxudmFyIFN0b3JlV3JpdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZVdyaXRlcigpIHtcbiAgICB9XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLndyaXRlUXVlcnlUb1N0b3JlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCByZXN1bHQgPSBfYS5yZXN1bHQsIF9iID0gX2Euc3RvcmUsIHN0b3JlID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHROb3JtYWxpemVkQ2FjaGVGYWN0b3J5KCkgOiBfYiwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBkYXRhSWRGcm9tT2JqZWN0ID0gX2EuZGF0YUlkRnJvbU9iamVjdCwgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24gPSBfYS5mcmFnbWVudE1hdGNoZXJGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVSZXN1bHRUb1N0b3JlKHtcbiAgICAgICAgICAgIGRhdGFJZDogJ1JPT1RfUVVFUlknLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICBkb2N1bWVudDogcXVlcnksXG4gICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIGRhdGFJZEZyb21PYmplY3Q6IGRhdGFJZEZyb21PYmplY3QsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbjogZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLndyaXRlUmVzdWx0VG9TdG9yZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZGF0YUlkID0gX2EuZGF0YUlkLCByZXN1bHQgPSBfYS5yZXN1bHQsIGRvY3VtZW50ID0gX2EuZG9jdW1lbnQsIF9iID0gX2Euc3RvcmUsIHN0b3JlID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHROb3JtYWxpemVkQ2FjaGVGYWN0b3J5KCkgOiBfYiwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBkYXRhSWRGcm9tT2JqZWN0ID0gX2EuZGF0YUlkRnJvbU9iamVjdCwgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24gPSBfYS5mcmFnbWVudE1hdGNoZXJGdW5jdGlvbjtcbiAgICAgICAgdmFyIG9wZXJhdGlvbkRlZmluaXRpb24gPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlU2VsZWN0aW9uU2V0VG9TdG9yZSh7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgZGF0YUlkOiBkYXRhSWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBvcGVyYXRpb25EZWZpbml0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YToge30sXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogYXNzaWduKHt9LCBnZXREZWZhdWx0VmFsdWVzKG9wZXJhdGlvbkRlZmluaXRpb24pLCB2YXJpYWJsZXMpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhSWRGcm9tT2JqZWN0OiBkYXRhSWRGcm9tT2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudE1hcDogY3JlYXRlRnJhZ21lbnRNYXAoZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2N1bWVudCkpLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbjogZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlbmhhbmNlRXJyb3JXaXRoRG9jdW1lbnQoZSwgZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZVdyaXRlci5wcm90b3R5cGUud3JpdGVTZWxlY3Rpb25TZXRUb1N0b3JlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXN1bHQgPSBfYS5yZXN1bHQsIGRhdGFJZCA9IF9hLmRhdGFJZCwgc2VsZWN0aW9uU2V0ID0gX2Euc2VsZWN0aW9uU2V0LCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IGNvbnRleHQudmFyaWFibGVzLCBzdG9yZSA9IGNvbnRleHQuc3RvcmUsIGZyYWdtZW50TWFwID0gY29udGV4dC5mcmFnbWVudE1hcDtcbiAgICAgICAgc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRGaWVsZEtleSA9IHJlc3VsdEtleU5hbWVGcm9tRmllbGQoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHRbcmVzdWx0RmllbGRLZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLndyaXRlRmllbGRUb1N0b3JlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJZDogZGF0YUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRGVmZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDbGllbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5kaXJlY3RpdmVzICYmIHNlbGVjdGlvbi5kaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWZlcmVkID0gc2VsZWN0aW9uLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUubmFtZSAmJiBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gJ2RlZmVyJzsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NsaWVudCA9IHNlbGVjdGlvbi5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLm5hbWUgJiYgZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09ICdjbGllbnQnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGVmZXJlZCAmJiAhaXNDbGllbnQgJiYgY29udGV4dC5mcmFnbWVudE1hdGNoZXJGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKFwiTWlzc2luZyBmaWVsZCBcIiArIHJlc3VsdEZpZWxkS2V5ICsgXCIgaW4gXCIgKyBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpLnN1YnN0cmluZygwLCAxMDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmxpbmVGcmFnbWVudChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSAoZnJhZ21lbnRNYXAgfHwge30pW3NlbGVjdGlvbi5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZyYWdtZW50LCAzKSA6IGludmFyaWFudChmcmFnbWVudCwgXCJObyBmcmFnbWVudCBuYW1lZCBcIiArIHNlbGVjdGlvbi5uYW1lLnZhbHVlICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24gJiYgZnJhZ21lbnQudHlwZUNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBkYXRhSWQgfHwgJ3NlbGYnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWRWYWx1ZSA9IHRvSWRWYWx1ZSh7IGlkOiBpZCwgdHlwZW5hbWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZha2VDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IG5ldyBPYmplY3RDYWNoZSgoX2EgPSB7fSwgX2FbaWRdID0gcmVzdWx0LCBfYSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWRpcmVjdHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBjb250ZXh0LmZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uKGlkVmFsdWUsIGZyYWdtZW50LnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZSwgZmFrZUNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvZHVjdGlvbigpICYmIG1hdGNoID09PSAnaGV1cmlzdGljJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC5lcnJvcignV0FSTklORzogaGV1cmlzdGljIGZyYWdtZW50IG1hdGNoaW5nIGdvaW5nIG9uIScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSAhIW1hdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy53cml0ZVNlbGVjdGlvblNldFRvU3RvcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IGZyYWdtZW50LnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJZDogZGF0YUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLndyaXRlRmllbGRUb1N0b3JlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIGZpZWxkID0gX2EuZmllbGQsIHZhbHVlID0gX2EudmFsdWUsIGRhdGFJZCA9IF9hLmRhdGFJZCwgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBjb250ZXh0LnZhcmlhYmxlcywgZGF0YUlkRnJvbU9iamVjdCA9IGNvbnRleHQuZGF0YUlkRnJvbU9iamVjdCwgc3RvcmUgPSBjb250ZXh0LnN0b3JlO1xuICAgICAgICB2YXIgc3RvcmVWYWx1ZTtcbiAgICAgICAgdmFyIHN0b3JlT2JqZWN0O1xuICAgICAgICB2YXIgc3RvcmVGaWVsZE5hbWUgPSBzdG9yZUtleU5hbWVGcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcyk7XG4gICAgICAgIGlmICghZmllbGQuc2VsZWN0aW9uU2V0IHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9yZVZhbHVlID1cbiAgICAgICAgICAgICAgICB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnanNvbicsIGpzb246IHZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZWRJZCA9IGRhdGFJZCArIFwiLlwiICsgc3RvcmVGaWVsZE5hbWU7XG4gICAgICAgICAgICBzdG9yZVZhbHVlID0gdGhpcy5wcm9jZXNzQXJyYXlWYWx1ZSh2YWx1ZSwgZ2VuZXJhdGVkSWQsIGZpZWxkLnNlbGVjdGlvblNldCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVEYXRhSWQgPSBkYXRhSWQgKyBcIi5cIiArIHN0b3JlRmllbGROYW1lO1xuICAgICAgICAgICAgdmFyIGdlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWlzR2VuZXJhdGVkSWQodmFsdWVEYXRhSWQpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVEYXRhSWQgPSAnJCcgKyB2YWx1ZURhdGFJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhSWRGcm9tT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbWFudGljSWQgPSBkYXRhSWRGcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIXNlbWFudGljSWQgfHwgIWlzR2VuZXJhdGVkSWQoc2VtYW50aWNJZCksIDQpIDogaW52YXJpYW50KCFzZW1hbnRpY0lkIHx8ICFpc0dlbmVyYXRlZElkKHNlbWFudGljSWQpLCAnSURzIHJldHVybmVkIGJ5IGRhdGFJZEZyb21PYmplY3QgY2Fubm90IGJlZ2luIHdpdGggdGhlIFwiJFwiIGNoYXJhY3Rlci4nKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VtYW50aWNJZCB8fFxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHNlbWFudGljSWQgPT09ICdudW1iZXInICYmIHNlbWFudGljSWQgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRGF0YUlkID0gc2VtYW50aWNJZDtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0RhdGFQcm9jZXNzZWQodmFsdWVEYXRhSWQsIGZpZWxkLCBjb250ZXh0LnByb2Nlc3NlZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVNlbGVjdGlvblNldFRvU3RvcmUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSWQ6IHZhbHVlRGF0YUlkLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IGZpZWxkLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eXBlbmFtZSA9IHZhbHVlLl9fdHlwZW5hbWU7XG4gICAgICAgICAgICBzdG9yZVZhbHVlID0gdG9JZFZhbHVlKHsgaWQ6IHZhbHVlRGF0YUlkLCB0eXBlbmFtZTogdHlwZW5hbWUgfSwgZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgIHN0b3JlT2JqZWN0ID0gc3RvcmUuZ2V0KGRhdGFJZCk7XG4gICAgICAgICAgICB2YXIgZXNjYXBlZElkID0gc3RvcmVPYmplY3QgJiYgc3RvcmVPYmplY3Rbc3RvcmVGaWVsZE5hbWVdO1xuICAgICAgICAgICAgaWYgKGVzY2FwZWRJZCAhPT0gc3RvcmVWYWx1ZSAmJiBpc0lkVmFsdWUoZXNjYXBlZElkKSkge1xuICAgICAgICAgICAgICAgIHZhciBoYWRUeXBlbmFtZSA9IGVzY2FwZWRJZC50eXBlbmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBoYXNUeXBlbmFtZSA9IHR5cGVuYW1lICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVuYW1lQ2hhbmdlZCA9IGhhZFR5cGVuYW1lICYmIGhhc1R5cGVuYW1lICYmIGVzY2FwZWRJZC50eXBlbmFtZSAhPT0gdHlwZW5hbWU7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCFnZW5lcmF0ZWQgfHwgZXNjYXBlZElkLmdlbmVyYXRlZCB8fCB0eXBlbmFtZUNoYW5nZWQsIDUpIDogaW52YXJpYW50KCFnZW5lcmF0ZWQgfHwgZXNjYXBlZElkLmdlbmVyYXRlZCB8fCB0eXBlbmFtZUNoYW5nZWQsIFwiU3RvcmUgZXJyb3I6IHRoZSBhcHBsaWNhdGlvbiBhdHRlbXB0ZWQgdG8gd3JpdGUgYW4gb2JqZWN0IHdpdGggbm8gcHJvdmlkZWQgaWQgYnV0IHRoZSBzdG9yZSBhbHJlYWR5IGNvbnRhaW5zIGFuIGlkIG9mIFwiICsgZXNjYXBlZElkLmlkICsgXCIgZm9yIHRoaXMgb2JqZWN0LiBUaGUgc2VsZWN0aW9uU2V0IHRoYXQgd2FzIHRyeWluZyB0byBiZSB3cml0dGVuIGlzOlxcblwiICsgSlNPTi5zdHJpbmdpZnkoZmllbGQpKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIWhhZFR5cGVuYW1lIHx8IGhhc1R5cGVuYW1lLCA2KSA6IGludmFyaWFudCghaGFkVHlwZW5hbWUgfHwgaGFzVHlwZW5hbWUsIFwiU3RvcmUgZXJyb3I6IHRoZSBhcHBsaWNhdGlvbiBhdHRlbXB0ZWQgdG8gd3JpdGUgYW4gb2JqZWN0IHdpdGggbm8gcHJvdmlkZWQgdHlwZW5hbWUgYnV0IHRoZSBzdG9yZSBhbHJlYWR5IGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIHR5cGVuYW1lIG9mIFwiICsgZXNjYXBlZElkLnR5cGVuYW1lICsgXCIgZm9yIHRoZSBvYmplY3Qgb2YgaWQgXCIgKyBlc2NhcGVkSWQuaWQgKyBcIi4gVGhlIHNlbGVjdGlvblNldCB0aGF0IHdhcyB0cnlpbmcgdG8gYmUgd3JpdHRlbiBpczpcXG5cIiArIEpTT04uc3RyaW5naWZ5KGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRJZC5nZW5lcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVuYW1lQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnZW5lcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoZXNjYXBlZElkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlV2l0aEdlbmVyYXRlZChlc2NhcGVkSWQuaWQsIHN0b3JlVmFsdWUuaWQsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdG9yZU9iamVjdCA9IHN0b3JlLmdldChkYXRhSWQpO1xuICAgICAgICBpZiAoIXN0b3JlT2JqZWN0IHx8ICFpc0VxdWFsKHN0b3JlVmFsdWUsIHN0b3JlT2JqZWN0W3N0b3JlRmllbGROYW1lXSkpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldChkYXRhSWQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdG9yZU9iamVjdCksIChfYiA9IHt9LCBfYltzdG9yZUZpZWxkTmFtZV0gPSBzdG9yZVZhbHVlLCBfYikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLnByb2Nlc3NBcnJheVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBnZW5lcmF0ZWRJZCwgc2VsZWN0aW9uU2V0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGl0ZW1EYXRhSWQgPSBnZW5lcmF0ZWRJZCArIFwiLlwiICsgaW5kZXg7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9jZXNzQXJyYXlWYWx1ZShpdGVtLCBpdGVtRGF0YUlkLCBzZWxlY3Rpb25TZXQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kYXRhSWRGcm9tT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbWFudGljSWQgPSBjb250ZXh0LmRhdGFJZEZyb21PYmplY3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbWFudGljSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbURhdGFJZCA9IHNlbWFudGljSWQ7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNEYXRhUHJvY2Vzc2VkKGl0ZW1EYXRhSWQsIHNlbGVjdGlvblNldCwgY29udGV4dC5wcm9jZXNzZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndyaXRlU2VsZWN0aW9uU2V0VG9TdG9yZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJZDogaXRlbURhdGFJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHNlbGVjdGlvblNldCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b0lkVmFsdWUoeyBpZDogaXRlbURhdGFJZCwgdHlwZW5hbWU6IGl0ZW0uX190eXBlbmFtZSB9LCBnZW5lcmF0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTdG9yZVdyaXRlcjtcbn0oKSk7XG5mdW5jdGlvbiBpc0dlbmVyYXRlZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkWzBdID09PSAnJCc7XG59XG5mdW5jdGlvbiBtZXJnZVdpdGhHZW5lcmF0ZWQoZ2VuZXJhdGVkS2V5LCByZWFsS2V5LCBjYWNoZSkge1xuICAgIGlmIChnZW5lcmF0ZWRLZXkgPT09IHJlYWxLZXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2VuZXJhdGVkID0gY2FjaGUuZ2V0KGdlbmVyYXRlZEtleSk7XG4gICAgdmFyIHJlYWwgPSBjYWNoZS5nZXQocmVhbEtleSk7XG4gICAgdmFyIG1hZGVDaGFuZ2VzID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMoZ2VuZXJhdGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2VuZXJhdGVkW2tleV07XG4gICAgICAgIHZhciByZWFsVmFsdWUgPSByZWFsW2tleV07XG4gICAgICAgIGlmIChpc0lkVmFsdWUodmFsdWUpICYmXG4gICAgICAgICAgICBpc0dlbmVyYXRlZElkKHZhbHVlLmlkKSAmJlxuICAgICAgICAgICAgaXNJZFZhbHVlKHJlYWxWYWx1ZSkgJiZcbiAgICAgICAgICAgICFpc0VxdWFsKHZhbHVlLCByZWFsVmFsdWUpICYmXG4gICAgICAgICAgICBtZXJnZVdpdGhHZW5lcmF0ZWQodmFsdWUuaWQsIHJlYWxWYWx1ZS5pZCwgY2FjaGUpKSB7XG4gICAgICAgICAgICBtYWRlQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjYWNoZS5kZWxldGUoZ2VuZXJhdGVkS2V5KTtcbiAgICB2YXIgbmV3UmVhbFZhbHVlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdlbmVyYXRlZCksIHJlYWwpO1xuICAgIGlmIChpc0VxdWFsKG5ld1JlYWxWYWx1ZSwgcmVhbCkpIHtcbiAgICAgICAgcmV0dXJuIG1hZGVDaGFuZ2VzO1xuICAgIH1cbiAgICBjYWNoZS5zZXQocmVhbEtleSwgbmV3UmVhbFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzRGF0YVByb2Nlc3NlZChkYXRhSWQsIGZpZWxkLCBwcm9jZXNzZWREYXRhKSB7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3NlZERhdGFbZGF0YUlkXSkge1xuICAgICAgICBpZiAocHJvY2Vzc2VkRGF0YVtkYXRhSWRdLmluZGV4T2YoZmllbGQpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YVtkYXRhSWRdLnB1c2goZmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9jZXNzZWREYXRhW2RhdGFJZF0gPSBbZmllbGRdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgIGZyYWdtZW50TWF0Y2hlcjogbmV3IEhldXJpc3RpY0ZyYWdtZW50TWF0Y2hlcigpLFxuICAgIGRhdGFJZEZyb21PYmplY3Q6IGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0LFxuICAgIGFkZFR5cGVuYW1lOiB0cnVlLFxuICAgIHJlc3VsdENhY2hpbmc6IHRydWUsXG4gICAgZnJlZXplUmVzdWx0czogZmFsc2UsXG59O1xuZnVuY3Rpb24gZGVmYXVsdERhdGFJZEZyb21PYmplY3QocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5fX3R5cGVuYW1lKSB7XG4gICAgICAgIGlmIChyZXN1bHQuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5fX3R5cGVuYW1lICsgXCI6XCIgKyByZXN1bHQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5fX3R5cGVuYW1lICsgXCI6XCIgKyByZXN1bHQuX2lkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxudmFyIGhhc093biQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBPcHRpbWlzdGljQ2FjaGVMYXllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9wdGltaXN0aWNDYWNoZUxheWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9wdGltaXN0aWNDYWNoZUxheWVyKG9wdGltaXN0aWNJZCwgcGFyZW50LCB0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBPYmplY3QuY3JlYXRlKG51bGwpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpbWlzdGljSWQgPSBvcHRpbWlzdGljSWQ7XG4gICAgICAgIF90aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgX3RoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPcHRpbWlzdGljQ2FjaGVMYXllci5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wYXJlbnQudG9PYmplY3QoKSksIHRoaXMuZGF0YSk7XG4gICAgfTtcbiAgICBPcHRpbWlzdGljQ2FjaGVMYXllci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gaGFzT3duJDEuY2FsbCh0aGlzLmRhdGEsIGRhdGFJZClcbiAgICAgICAgICAgID8gdGhpcy5kYXRhW2RhdGFJZF1cbiAgICAgICAgICAgIDogdGhpcy5wYXJlbnQuZ2V0KGRhdGFJZCk7XG4gICAgfTtcbiAgICByZXR1cm4gT3B0aW1pc3RpY0NhY2hlTGF5ZXI7XG59KE9iamVjdENhY2hlKSk7XG52YXIgSW5NZW1vcnlDYWNoZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluTWVtb3J5Q2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5NZW1vcnlDYWNoZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndhdGNoZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLnR5cGVuYW1lRG9jdW1lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMuY2FjaGVLZXlSb290ID0gbmV3IEtleVRyaWUoY2FuVXNlV2Vha01hcCk7XG4gICAgICAgIF90aGlzLnNpbGVuY2VCcm9hZGNhc3QgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY29uZmlnID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCBjb25maWcpO1xuICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmN1c3RvbVJlc29sdmVycykge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKCdjdXN0b21SZXNvbHZlcnMgaGF2ZSBiZWVuIHJlbmFtZWQgdG8gY2FjaGVSZWRpcmVjdHMuIFBsZWFzZSB1cGRhdGUgeW91ciBjb25maWcgYXMgd2Ugd2lsbCBiZSBkZXByZWNhdGluZyBjdXN0b21SZXNvbHZlcnMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4nKTtcbiAgICAgICAgICAgIF90aGlzLmNvbmZpZy5jYWNoZVJlZGlyZWN0cyA9IF90aGlzLmNvbmZpZy5jdXN0b21SZXNvbHZlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5jYWNoZVJlc29sdmVycykge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKCdjYWNoZVJlc29sdmVycyBoYXZlIGJlZW4gcmVuYW1lZCB0byBjYWNoZVJlZGlyZWN0cy4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNvbmZpZyBhcyB3ZSB3aWxsIGJlIGRlcHJlY2F0aW5nIGNhY2hlUmVzb2x2ZXJzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uJyk7XG4gICAgICAgICAgICBfdGhpcy5jb25maWcuY2FjaGVSZWRpcmVjdHMgPSBfdGhpcy5jb25maWcuY2FjaGVSZXNvbHZlcnM7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYWRkVHlwZW5hbWUgPSAhIV90aGlzLmNvbmZpZy5hZGRUeXBlbmFtZTtcbiAgICAgICAgX3RoaXMuZGF0YSA9IF90aGlzLmNvbmZpZy5yZXN1bHRDYWNoaW5nXG4gICAgICAgICAgICA/IG5ldyBEZXBUcmFja2luZ0NhY2hlKClcbiAgICAgICAgICAgIDogbmV3IE9iamVjdENhY2hlKCk7XG4gICAgICAgIF90aGlzLm9wdGltaXN0aWNEYXRhID0gX3RoaXMuZGF0YTtcbiAgICAgICAgX3RoaXMuc3RvcmVXcml0ZXIgPSBuZXcgU3RvcmVXcml0ZXIoKTtcbiAgICAgICAgX3RoaXMuc3RvcmVSZWFkZXIgPSBuZXcgU3RvcmVSZWFkZXIoe1xuICAgICAgICAgICAgY2FjaGVLZXlSb290OiBfdGhpcy5jYWNoZUtleVJvb3QsXG4gICAgICAgICAgICBmcmVlemVSZXN1bHRzOiBjb25maWcuZnJlZXplUmVzdWx0cyxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYWNoZSA9IF90aGlzO1xuICAgICAgICB2YXIgbWF5YmVCcm9hZGNhc3RXYXRjaCA9IGNhY2hlLm1heWJlQnJvYWRjYXN0V2F0Y2g7XG4gICAgICAgIF90aGlzLm1heWJlQnJvYWRjYXN0V2F0Y2ggPSB3cmFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVCcm9hZGNhc3RXYXRjaC5jYWxsKF90aGlzLCBjKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFrZUNhY2hlS2V5OiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmIChjLm9wdGltaXN0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYy5wcmV2aW91c1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5kYXRhIGluc3RhbmNlb2YgRGVwVHJhY2tpbmdDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuY2FjaGVLZXlSb290Lmxvb2t1cChjLnF1ZXJ5LCBKU09OLnN0cmluZ2lmeShjLnZhcmlhYmxlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgdGhpcy5kYXRhLnJlcGxhY2UoZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChvcHRpbWlzdGljKSB7XG4gICAgICAgIGlmIChvcHRpbWlzdGljID09PSB2b2lkIDApIHsgb3B0aW1pc3RpYyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiAob3B0aW1pc3RpYyA/IHRoaXMub3B0aW1pc3RpY0RhdGEgOiB0aGlzLmRhdGEpLnRvT2JqZWN0KCk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJvb3RJZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmRhdGEuZ2V0KG9wdGlvbnMucm9vdElkKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcmFnbWVudE1hdGNoZXIgPSB0aGlzLmNvbmZpZy5mcmFnbWVudE1hdGNoZXI7XG4gICAgICAgIHZhciBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbiA9IGZyYWdtZW50TWF0Y2hlciAmJiBmcmFnbWVudE1hdGNoZXIubWF0Y2g7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlUmVhZGVyLnJlYWRRdWVyeUZyb21TdG9yZSh7XG4gICAgICAgICAgICBzdG9yZTogb3B0aW9ucy5vcHRpbWlzdGljID8gdGhpcy5vcHRpbWlzdGljRGF0YSA6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLnRyYW5zZm9ybURvY3VtZW50KG9wdGlvbnMucXVlcnkpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHJvb3RJZDogb3B0aW9ucy5yb290SWQsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbjogZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24sXG4gICAgICAgICAgICBwcmV2aW91c1Jlc3VsdDogb3B0aW9ucy5wcmV2aW91c1Jlc3VsdCxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH0pIHx8IG51bGw7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICh3cml0ZSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRNYXRjaGVyID0gdGhpcy5jb25maWcuZnJhZ21lbnRNYXRjaGVyO1xuICAgICAgICB2YXIgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24gPSBmcmFnbWVudE1hdGNoZXIgJiYgZnJhZ21lbnRNYXRjaGVyLm1hdGNoO1xuICAgICAgICB0aGlzLnN0b3JlV3JpdGVyLndyaXRlUmVzdWx0VG9TdG9yZSh7XG4gICAgICAgICAgICBkYXRhSWQ6IHdyaXRlLmRhdGFJZCxcbiAgICAgICAgICAgIHJlc3VsdDogd3JpdGUucmVzdWx0LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB3cml0ZS52YXJpYWJsZXMsXG4gICAgICAgICAgICBkb2N1bWVudDogdGhpcy50cmFuc2Zvcm1Eb2N1bWVudCh3cml0ZS5xdWVyeSksXG4gICAgICAgICAgICBzdG9yZTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgZGF0YUlkRnJvbU9iamVjdDogdGhpcy5jb25maWcuZGF0YUlkRnJvbU9iamVjdCxcbiAgICAgICAgICAgIGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uOiBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRNYXRjaGVyID0gdGhpcy5jb25maWcuZnJhZ21lbnRNYXRjaGVyO1xuICAgICAgICB2YXIgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24gPSBmcmFnbWVudE1hdGNoZXIgJiYgZnJhZ21lbnRNYXRjaGVyLm1hdGNoO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVJlYWRlci5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUoe1xuICAgICAgICAgICAgc3RvcmU6IHF1ZXJ5Lm9wdGltaXN0aWMgPyB0aGlzLm9wdGltaXN0aWNEYXRhIDogdGhpcy5kYXRhLFxuICAgICAgICAgICAgcXVlcnk6IHRoaXMudHJhbnNmb3JtRG9jdW1lbnQocXVlcnkucXVlcnkpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogcXVlcnkucmV0dXJuUGFydGlhbERhdGEsXG4gICAgICAgICAgICBwcmV2aW91c1Jlc3VsdDogcXVlcnkucHJldmlvdXNSZXN1bHQsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbjogZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24sXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKHdhdGNoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMud2F0Y2hlcy5hZGQod2F0Y2gpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMud2F0Y2hlcy5kZWxldGUod2F0Y2gpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuZXZpY3QgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDcpIDogbmV3IEludmFyaWFudEVycm9yKFwiZXZpY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIG9uIEluTWVtb3J5IENhY2hlXCIpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YS5jbGVhcigpO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVtb3ZlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChpZFRvUmVtb3ZlKSB7XG4gICAgICAgIHZhciB0b1JlYXBwbHkgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWRDb3VudCA9IDA7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMub3B0aW1pc3RpY0RhdGE7XG4gICAgICAgIHdoaWxlIChsYXllciBpbnN0YW5jZW9mIE9wdGltaXN0aWNDYWNoZUxheWVyKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIub3B0aW1pc3RpY0lkID09PSBpZFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgKytyZW1vdmVkQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b1JlYXBwbHkucHVzaChsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllciA9IGxheWVyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZENvdW50ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpbWlzdGljRGF0YSA9IGxheWVyO1xuICAgICAgICAgICAgd2hpbGUgKHRvUmVhcHBseS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyXzEgPSB0b1JlYXBwbHkucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtVHJhbnNhY3Rpb24obGF5ZXJfMS50cmFuc2FjdGlvbiwgbGF5ZXJfMS5vcHRpbWlzdGljSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnBlcmZvcm1UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgb3B0aW1pc3RpY0lkKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGRhdGEgPSBfYS5kYXRhLCBzaWxlbmNlQnJvYWRjYXN0ID0gX2Euc2lsZW5jZUJyb2FkY2FzdDtcbiAgICAgICAgdGhpcy5zaWxlbmNlQnJvYWRjYXN0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpbWlzdGljSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLm9wdGltaXN0aWNEYXRhID0gbmV3IE9wdGltaXN0aWNDYWNoZUxheWVyKG9wdGltaXN0aWNJZCwgdGhpcy5vcHRpbWlzdGljRGF0YSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc2lsZW5jZUJyb2FkY2FzdCA9IHNpbGVuY2VCcm9hZGNhc3Q7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVjb3JkT3B0aW1pc3RpY1RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGlkKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnRyYW5zZm9ybURvY3VtZW50ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmFkZFR5cGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50eXBlbmFtZURvY3VtZW50Q2FjaGUuZ2V0KGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYWRkVHlwZW5hbWVUb0RvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVuYW1lRG9jdW1lbnRDYWNoZS5zZXQoZG9jdW1lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlbmFtZURvY3VtZW50Q2FjaGUuc2V0KHJlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuYnJvYWRjYXN0V2F0Y2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNpbGVuY2VCcm9hZGNhc3QpIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoKGMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUubWF5YmVCcm9hZGNhc3RXYXRjaCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGMuY2FsbGJhY2sodGhpcy5kaWZmKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBjLnF1ZXJ5LFxuICAgICAgICAgICAgdmFyaWFibGVzOiBjLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0OiBjLnByZXZpb3VzUmVzdWx0ICYmIGMucHJldmlvdXNSZXN1bHQoKSxcbiAgICAgICAgICAgIG9wdGltaXN0aWM6IGMub3B0aW1pc3RpYyxcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEluTWVtb3J5Q2FjaGU7XG59KEFwb2xsb0NhY2hlKSk7XG5cbmV4cG9ydCB7IEhldXJpc3RpY0ZyYWdtZW50TWF0Y2hlciwgSW5NZW1vcnlDYWNoZSwgSW50cm9zcGVjdGlvbkZyYWdtZW50TWF0Y2hlciwgT2JqZWN0Q2FjaGUsIFN0b3JlUmVhZGVyLCBTdG9yZVdyaXRlciwgV3JpdGVFcnJvciwgYXNzZXJ0SWRWYWx1ZSwgZGVmYXVsdERhdGFJZEZyb21PYmplY3QsIGRlZmF1bHROb3JtYWxpemVkQ2FjaGVGYWN0b3J5JDEgYXMgZGVmYXVsdE5vcm1hbGl6ZWRDYWNoZUZhY3RvcnksIGVuaGFuY2VFcnJvcldpdGhEb2N1bWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IGdldEZyYWdtZW50UXVlcnlEb2N1bWVudCB9IGZyb20gJ2Fwb2xsby11dGlsaXRpZXMnO1xuXG5mdW5jdGlvbiBxdWVyeUZyb21Qb2pvKG9iaikge1xuICAgIHZhciBvcCA9IHtcbiAgICAgICAga2luZDogJ09wZXJhdGlvbkRlZmluaXRpb24nLFxuICAgICAgICBvcGVyYXRpb246ICdxdWVyeScsXG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIGtpbmQ6ICdOYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiAnR2VuZXJhdGVkQ2xpZW50UXVlcnknLFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Rpb25TZXQ6IHNlbGVjdGlvblNldEZyb21PYmoob2JqKSxcbiAgICB9O1xuICAgIHZhciBvdXQgPSB7XG4gICAgICAgIGtpbmQ6ICdEb2N1bWVudCcsXG4gICAgICAgIGRlZmluaXRpb25zOiBbb3BdLFxuICAgIH07XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGZyYWdtZW50RnJvbVBvam8ob2JqLCB0eXBlbmFtZSkge1xuICAgIHZhciBmcmFnID0ge1xuICAgICAgICBraW5kOiAnRnJhZ21lbnREZWZpbml0aW9uJyxcbiAgICAgICAgdHlwZUNvbmRpdGlvbjoge1xuICAgICAgICAgICAga2luZDogJ05hbWVkVHlwZScsXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlbmFtZSB8fCAnX19GYWtlVHlwZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBraW5kOiAnTmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogJ0dlbmVyYXRlZENsaWVudFF1ZXJ5JyxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0aW9uU2V0OiBzZWxlY3Rpb25TZXRGcm9tT2JqKG9iaiksXG4gICAgfTtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgICBraW5kOiAnRG9jdW1lbnQnLFxuICAgICAgICBkZWZpbml0aW9uczogW2ZyYWddLFxuICAgIH07XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblNldEZyb21PYmoob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvblNldEZyb21PYmoob2JqWzBdKTtcbiAgICB9XG4gICAgdmFyIHNlbGVjdGlvbnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgbmVzdGVkU2VsU2V0ID0gc2VsZWN0aW9uU2V0RnJvbU9iaihvYmpba2V5XSk7XG4gICAgICAgIHZhciBmaWVsZCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdGaWVsZCcsXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBuZXN0ZWRTZWxTZXQgfHwgdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBzZWxlY3Rpb25zLnB1c2goZmllbGQpO1xuICAgIH0pO1xuICAgIHZhciBzZWxlY3Rpb25TZXQgPSB7XG4gICAgICAgIGtpbmQ6ICdTZWxlY3Rpb25TZXQnLFxuICAgICAgICBzZWxlY3Rpb25zOiBzZWxlY3Rpb25zLFxuICAgIH07XG4gICAgcmV0dXJuIHNlbGVjdGlvblNldDtcbn1cbnZhciBqdXN0VHlwZW5hbWVRdWVyeSA9IHtcbiAgICBraW5kOiAnRG9jdW1lbnQnLFxuICAgIGRlZmluaXRpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtpbmQ6ICdPcGVyYXRpb25EZWZpbml0aW9uJyxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ3F1ZXJ5JyxcbiAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW10sXG4gICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnU2VsZWN0aW9uU2V0JyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdGaWVsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnTmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdfX3R5cGVuYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgXSxcbn07XG5cbnZhciBBcG9sbG9DYWNoZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBvbGxvQ2FjaGUoKSB7XG4gICAgfVxuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS50cmFuc2Zvcm1Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUudHJhbnNmb3JtRm9yTGluayA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUucmVhZFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZCh7XG4gICAgICAgICAgICBxdWVyeTogb3B0aW9ucy5xdWVyeSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBvcHRpbWlzdGljLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5yZWFkRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQob3B0aW9ucy5mcmFnbWVudCwgb3B0aW9ucy5mcmFnbWVudE5hbWUpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHJvb3RJZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWM6IG9wdGltaXN0aWMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLndyaXRlUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLndyaXRlKHtcbiAgICAgICAgICAgIGRhdGFJZDogJ1JPT1RfUVVFUlknLFxuICAgICAgICAgICAgcmVzdWx0OiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgICBxdWVyeTogb3B0aW9ucy5xdWVyeSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLndyaXRlRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLndyaXRlKHtcbiAgICAgICAgICAgIGRhdGFJZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIHJlc3VsdDogb3B0aW9ucy5kYXRhLFxuICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHF1ZXJ5OiBnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQob3B0aW9ucy5mcmFnbWVudCwgb3B0aW9ucy5mcmFnbWVudE5hbWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS53cml0ZURhdGEgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlkID0gX2EuaWQsIGRhdGEgPSBfYS5kYXRhO1xuICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHlwZW5hbWVSZXN1bHQgPSB0aGlzLnJlYWQoe1xuICAgICAgICAgICAgICAgICAgICByb290SWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGp1c3RUeXBlbmFtZVF1ZXJ5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfX3R5cGVuYW1lID0gKHR5cGVuYW1lUmVzdWx0ICYmIHR5cGVuYW1lUmVzdWx0Ll9fdHlwZW5hbWUpIHx8ICdfX0NsaWVudERhdGEnO1xuICAgICAgICAgICAgdmFyIGRhdGFUb1dyaXRlID0gT2JqZWN0LmFzc2lnbih7IF9fdHlwZW5hbWU6IF9fdHlwZW5hbWUgfSwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlRnJhZ21lbnQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnRGcm9tUG9qbyhkYXRhVG9Xcml0ZSwgX190eXBlbmFtZSksXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVRvV3JpdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVRdWVyeSh7IHF1ZXJ5OiBxdWVyeUZyb21Qb2pvKGRhdGEpLCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXBvbGxvQ2FjaGU7XG59KCkpO1xuXG52YXIgQ2FjaGU7XG4oZnVuY3Rpb24gKENhY2hlKSB7XG59KShDYWNoZSB8fCAoQ2FjaGUgPSB7fSkpO1xuXG5leHBvcnQgeyBBcG9sbG9DYWNoZSwgQ2FjaGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX2V4dGVuZHMsIF9fYXNzaWduLCBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiwgaXNFcXVhbCwgdHJ5RnVuY3Rpb25PckxvZ0Vycm9yLCBjbG9uZURlZXAsIG1lcmdlRGVlcCwgaGFzRGlyZWN0aXZlcywgcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCwgYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQsIGdldE1haW5EZWZpbml0aW9uLCBnZXRGcmFnbWVudERlZmluaXRpb25zLCBjcmVhdGVGcmFnbWVudE1hcCwgbWVyZ2VEZWVwQXJyYXksIHJlc3VsdEtleU5hbWVGcm9tRmllbGQsIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZCwgc2hvdWxkSW5jbHVkZSwgaXNGaWVsZCwgaXNJbmxpbmVGcmFnbWVudCwgY2FuVXNlV2Vha01hcCwgZ3JhcGhRTFJlc3VsdEhhc0Vycm9yLCByZW1vdmVDb25uZWN0aW9uRGlyZWN0aXZlRnJvbURvY3VtZW50LCBoYXNDbGllbnRFeHBvcnRzLCBnZXREZWZhdWx0VmFsdWVzLCBnZXRPcGVyYXRpb25OYW1lIH0gZnJvbSAnYXBvbGxvLXV0aWxpdGllcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIGFzIE9ic2VydmFibGUkMSwgZXhlY3V0ZSwgQXBvbGxvTGluayB9IGZyb20gJ2Fwb2xsby1saW5rJztcbmltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IsIGludmFyaWFudCB9IGZyb20gJ3RzLWludmFyaWFudCc7XG5pbXBvcnQgeyB2aXNpdCwgQlJFQUsgfSBmcm9tICdncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3InO1xuXG52YXIgTmV0d29ya1N0YXR1cztcbihmdW5jdGlvbiAoTmV0d29ya1N0YXR1cykge1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcImxvYWRpbmdcIl0gPSAxXSA9IFwibG9hZGluZ1wiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInNldFZhcmlhYmxlc1wiXSA9IDJdID0gXCJzZXRWYXJpYWJsZXNcIjtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJmZXRjaE1vcmVcIl0gPSAzXSA9IFwiZmV0Y2hNb3JlXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicmVmZXRjaFwiXSA9IDRdID0gXCJyZWZldGNoXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicG9sbFwiXSA9IDZdID0gXCJwb2xsXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicmVhZHlcIl0gPSA3XSA9IFwicmVhZHlcIjtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJlcnJvclwiXSA9IDhdID0gXCJlcnJvclwiO1xufSkoTmV0d29ya1N0YXR1cyB8fCAoTmV0d29ya1N0YXR1cyA9IHt9KSk7XG5mdW5jdGlvbiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cykge1xuICAgIHJldHVybiBuZXR3b3JrU3RhdHVzIDwgNztcbn1cblxudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVsnQEBvYnNlcnZhYmxlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KE9ic2VydmFibGUkMSkpO1xuXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cblxuZnVuY3Rpb24gaXNBcG9sbG9FcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyLmhhc093blByb3BlcnR5KCdncmFwaFFMRXJyb3JzJyk7XG59XG52YXIgZ2VuZXJhdGVFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICBpZiAoaXNOb25FbXB0eUFycmF5KGVyci5ncmFwaFFMRXJyb3JzKSkge1xuICAgICAgICBlcnIuZ3JhcGhRTEVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChncmFwaFFMRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBncmFwaFFMRXJyb3JcbiAgICAgICAgICAgICAgICA/IGdyYXBoUUxFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiAnRXJyb3IgbWVzc2FnZSBub3QgZm91bmQuJztcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCJHcmFwaFFMIGVycm9yOiBcIiArIGVycm9yTWVzc2FnZSArIFwiXFxuXCI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyLm5ldHdvcmtFcnJvcikge1xuICAgICAgICBtZXNzYWdlICs9ICdOZXR3b3JrIGVycm9yOiAnICsgZXJyLm5ldHdvcmtFcnJvci5tZXNzYWdlICsgJ1xcbic7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59O1xudmFyIEFwb2xsb0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXBvbGxvRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXBvbGxvRXJyb3IoX2EpIHtcbiAgICAgICAgdmFyIGdyYXBoUUxFcnJvcnMgPSBfYS5ncmFwaFFMRXJyb3JzLCBuZXR3b3JrRXJyb3IgPSBfYS5uZXR3b3JrRXJyb3IsIGVycm9yTWVzc2FnZSA9IF9hLmVycm9yTWVzc2FnZSwgZXh0cmFJbmZvID0gX2EuZXh0cmFJbmZvO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvck1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmdyYXBoUUxFcnJvcnMgPSBncmFwaFFMRXJyb3JzIHx8IFtdO1xuICAgICAgICBfdGhpcy5uZXR3b3JrRXJyb3IgPSBuZXR3b3JrRXJyb3IgfHwgbnVsbDtcbiAgICAgICAgaWYgKCFlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzLm1lc3NhZ2UgPSBnZW5lcmF0ZUVycm9yTWVzc2FnZShfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlID0gZXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmV4dHJhSW5mbyA9IGV4dHJhSW5mbztcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gQXBvbGxvRXJyb3IucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBcG9sbG9FcnJvcjtcbn0oRXJyb3IpKTtcblxudmFyIEZldGNoVHlwZTtcbihmdW5jdGlvbiAoRmV0Y2hUeXBlKSB7XG4gICAgRmV0Y2hUeXBlW0ZldGNoVHlwZVtcIm5vcm1hbFwiXSA9IDFdID0gXCJub3JtYWxcIjtcbiAgICBGZXRjaFR5cGVbRmV0Y2hUeXBlW1wicmVmZXRjaFwiXSA9IDJdID0gXCJyZWZldGNoXCI7XG4gICAgRmV0Y2hUeXBlW0ZldGNoVHlwZVtcInBvbGxcIl0gPSAzXSA9IFwicG9sbFwiO1xufSkoRmV0Y2hUeXBlIHx8IChGZXRjaFR5cGUgPSB7fSkpO1xuXG52YXIgaGFzRXJyb3IgPSBmdW5jdGlvbiAoc3RvcmVWYWx1ZSwgcG9saWN5KSB7XG4gICAgaWYgKHBvbGljeSA9PT0gdm9pZCAwKSB7IHBvbGljeSA9ICdub25lJzsgfVxuICAgIHJldHVybiBzdG9yZVZhbHVlICYmIChzdG9yZVZhbHVlLm5ldHdvcmtFcnJvciB8fFxuICAgICAgICAocG9saWN5ID09PSAnbm9uZScgJiYgaXNOb25FbXB0eUFycmF5KHN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycykpKTtcbn07XG52YXIgT2JzZXJ2YWJsZVF1ZXJ5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JzZXJ2YWJsZVF1ZXJ5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVRdWVyeShfYSkge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gX2EucXVlcnlNYW5hZ2VyLCBvcHRpb25zID0gX2Eub3B0aW9ucywgX2IgPSBfYS5zaG91bGRTdWJzY3JpYmUsIHNob3VsZFN1YnNjcmliZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uU3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICBfdGhpcy5pc1Rvcm5Eb3duID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy52YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcyB8fCB7fTtcbiAgICAgICAgX3RoaXMucXVlcnlJZCA9IHF1ZXJ5TWFuYWdlci5nZW5lcmF0ZVF1ZXJ5SWQoKTtcbiAgICAgICAgX3RoaXMuc2hvdWxkU3Vic2NyaWJlID0gc2hvdWxkU3Vic2NyaWJlO1xuICAgICAgICB2YXIgb3BEZWYgPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uKG9wdGlvbnMucXVlcnkpO1xuICAgICAgICBfdGhpcy5xdWVyeU5hbWUgPSBvcERlZiAmJiBvcERlZi5uYW1lICYmIG9wRGVmLm5hbWUudmFsdWU7XG4gICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlciA9IHF1ZXJ5TWFuYWdlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5yZW1vdmVRdWVyeShfdGhpcy5xdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5jdXJyZW50UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRDdXJyZW50UmVzdWx0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmdldEN1cnJlbnRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVG9ybkRvd24pIHtcbiAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gdGhpcy5sYXN0UmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiAhdGhpcy5sYXN0RXJyb3IgJiYgbGFzdFJlc3VsdCAmJiBsYXN0UmVzdWx0LmRhdGEgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmxhc3RFcnJvcixcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBOZXR3b3JrU3RhdHVzLmVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnF1ZXJ5TWFuYWdlci5nZXRDdXJyZW50UXVlcnlSZXN1bHQodGhpcyksIGRhdGEgPSBfYS5kYXRhLCBwYXJ0aWFsID0gX2EucGFydGlhbDtcbiAgICAgICAgdmFyIHF1ZXJ5U3RvcmVWYWx1ZSA9IHRoaXMucXVlcnlNYW5hZ2VyLnF1ZXJ5U3RvcmUuZ2V0KHRoaXMucXVlcnlJZCk7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBmZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgdmFyIGlzTmV0d29ya0ZldGNoUG9saWN5ID0gZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJztcbiAgICAgICAgaWYgKHF1ZXJ5U3RvcmVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXMgPSBxdWVyeVN0b3JlVmFsdWUubmV0d29ya1N0YXR1cztcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcihxdWVyeVN0b3JlVmFsdWUsIHRoaXMub3B0aW9ucy5lcnJvclBvbGljeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHF1ZXJ5U3RvcmVWYWx1ZS5ncmFwaFFMRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBxdWVyeVN0b3JlVmFsdWUubmV0d29ya0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1ZXJ5U3RvcmVWYWx1ZS52YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmFyaWFibGVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucy52YXJpYWJsZXMpLCBxdWVyeVN0b3JlVmFsdWUudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cyksXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogbmV0d29ya1N0YXR1cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocXVlcnlTdG9yZVZhbHVlLmdyYXBoUUxFcnJvcnMgJiYgdGhpcy5vcHRpb25zLmVycm9yUG9saWN5ID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBxdWVyeVN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsb2FkaW5nID0gaXNOZXR3b3JrRmV0Y2hQb2xpY3kgfHxcbiAgICAgICAgICAgICAgICAocGFydGlhbCAmJiBmZXRjaFBvbGljeSAhPT0gJ2NhY2hlLW9ubHknKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogbG9hZGluZyA/IE5ldHdvcmtTdGF0dXMubG9hZGluZyA6IE5ldHdvcmtTdGF0dXMucmVhZHksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFydGlhbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0UmVzdWx0KF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IHN0YWxlOiBmYWxzZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IHBhcnRpYWw6IHBhcnRpYWwgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmlzRGlmZmVyZW50RnJvbUxhc3RSZXN1bHQgPSBmdW5jdGlvbiAobmV3UmVzdWx0KSB7XG4gICAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMubGFzdFJlc3VsdFNuYXBzaG90O1xuICAgICAgICByZXR1cm4gIShzbmFwc2hvdCAmJlxuICAgICAgICAgICAgbmV3UmVzdWx0ICYmXG4gICAgICAgICAgICBzbmFwc2hvdC5uZXR3b3JrU3RhdHVzID09PSBuZXdSZXN1bHQubmV0d29ya1N0YXR1cyAmJlxuICAgICAgICAgICAgc25hcHNob3Quc3RhbGUgPT09IG5ld1Jlc3VsdC5zdGFsZSAmJlxuICAgICAgICAgICAgaXNFcXVhbChzbmFwc2hvdC5kYXRhLCBuZXdSZXN1bHQuZGF0YSkpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVzdWx0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RFcnJvcjtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzZXRMYXN0UmVzdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGFzdFJlc3VsdDtcbiAgICAgICAgZGVsZXRlIHRoaXMubGFzdFJlc3VsdFNuYXBzaG90O1xuICAgICAgICBkZWxldGUgdGhpcy5sYXN0RXJyb3I7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXNldFF1ZXJ5U3RvcmVFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeVN0b3JlID0gdGhpcy5xdWVyeU1hbmFnZXIucXVlcnlTdG9yZS5nZXQodGhpcy5xdWVyeUlkKTtcbiAgICAgICAgaWYgKHF1ZXJ5U3RvcmUpIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RvcmUubmV0d29ya0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHF1ZXJ5U3RvcmUuZ3JhcGhRTEVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBmZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgaWYgKGZldGNoUG9saWN5ID09PSAnY2FjaGUtb25seScpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMSkgOiBuZXcgSW52YXJpYW50RXJyb3IoJ2NhY2hlLW9ubHkgZmV0Y2hQb2xpY3kgb3B0aW9uIHNob3VsZCBub3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIHF1ZXJ5IHJlZmV0Y2guJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZXRjaFBvbGljeSAhPT0gJ25vLWNhY2hlJyAmJlxuICAgICAgICAgICAgZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1hbmQtbmV0d29yaycpIHtcbiAgICAgICAgICAgIGZldGNoUG9saWN5ID0gJ25ldHdvcmstb25seSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKHRoaXMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnZhcmlhYmxlcyksIHZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKHRoaXMub3B0aW9ucy52YXJpYWJsZXMsIHRoaXMudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgdGhpcy52YXJpYWJsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5mZXRjaFF1ZXJ5KHRoaXMucXVlcnlJZCwgX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5IH0pLCBGZXRjaFR5cGUucmVmZXRjaCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmZldGNoTW9yZSA9IGZ1bmN0aW9uIChmZXRjaE1vcmVPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmZXRjaE1vcmVPcHRpb25zLnVwZGF0ZVF1ZXJ5LCAyKSA6IGludmFyaWFudChmZXRjaE1vcmVPcHRpb25zLnVwZGF0ZVF1ZXJ5LCAndXBkYXRlUXVlcnkgb3B0aW9uIGlzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGRlZmluZXMgaG93IHRvIHVwZGF0ZSB0aGUgcXVlcnkgZGF0YSB3aXRoIHRoZSBuZXcgcmVzdWx0cy4nKTtcbiAgICAgICAgdmFyIGNvbWJpbmVkT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCAoZmV0Y2hNb3JlT3B0aW9ucy5xdWVyeSA/IGZldGNoTW9yZU9wdGlvbnMgOiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgZmV0Y2hNb3JlT3B0aW9ucyksIHsgdmFyaWFibGVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy52YXJpYWJsZXMpLCBmZXRjaE1vcmVPcHRpb25zLnZhcmlhYmxlcykgfSkpKSwgeyBmZXRjaFBvbGljeTogJ25ldHdvcmstb25seScgfSk7XG4gICAgICAgIHZhciBxaWQgPSB0aGlzLnF1ZXJ5TWFuYWdlci5nZW5lcmF0ZVF1ZXJ5SWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyXG4gICAgICAgICAgICAuZmV0Y2hRdWVyeShxaWQsIGNvbWJpbmVkT3B0aW9ucywgRmV0Y2hUeXBlLm5vcm1hbCwgdGhpcy5xdWVyeUlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZldGNoTW9yZVJlc3VsdCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlUXVlcnkoZnVuY3Rpb24gKHByZXZpb3VzUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoTW9yZU9wdGlvbnMudXBkYXRlUXVlcnkocHJldmlvdXNSZXN1bHQsIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hNb3JlUmVzdWx0OiBmZXRjaE1vcmVSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb21iaW5lZE9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIuc3RvcFF1ZXJ5KHFpZCk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hNb3JlUmVzdWx0O1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5zdG9wUXVlcnkocWlkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc3Vic2NyaWJlVG9Nb3JlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMucXVlcnlNYW5hZ2VyXG4gICAgICAgICAgICAuc3RhcnRHcmFwaFFMU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBvcHRpb25zLmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHN1YnNjcmlwdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUXVlcnkgPSBvcHRpb25zLnVwZGF0ZVF1ZXJ5O1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVRdWVyeShmdW5jdGlvbiAocHJldmlvdXMsIF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVzID0gX2EudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVF1ZXJ5KHByZXZpb3VzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uRGF0YTogc3Vic2NyaXB0aW9uRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQuZXJyb3IoJ1VuaGFuZGxlZCBHcmFwaFFMIHN1YnNjcmlwdGlvbiBlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHZhciBvbGRGZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdHMpO1xuICAgICAgICBpZiAob3B0cy5wb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb2xsaW5nKG9wdHMucG9sbEludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLnBvbGxJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmZXRjaFBvbGljeSA9IG9wdHMuZmV0Y2hQb2xpY3k7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFZhcmlhYmxlcyh0aGlzLm9wdGlvbnMudmFyaWFibGVzLCBvbGRGZXRjaFBvbGljeSAhPT0gZmV0Y2hQb2xpY3kgJiYgKG9sZEZldGNoUG9saWN5ID09PSAnY2FjaGUtb25seScgfHxcbiAgICAgICAgICAgIG9sZEZldGNoUG9saWN5ID09PSAnc3RhbmRieScgfHxcbiAgICAgICAgICAgIGZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyksIG9wdHMuZmV0Y2hSZXN1bHRzKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2V0VmFyaWFibGVzID0gZnVuY3Rpb24gKHZhcmlhYmxlcywgdHJ5RmV0Y2gsIGZldGNoUmVzdWx0cykge1xuICAgICAgICBpZiAodHJ5RmV0Y2ggPT09IHZvaWQgMCkgeyB0cnlGZXRjaCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChmZXRjaFJlc3VsdHMgPT09IHZvaWQgMCkgeyBmZXRjaFJlc3VsdHMgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgICAgICB2YXJpYWJsZXMgPSB2YXJpYWJsZXMgfHwgdGhpcy52YXJpYWJsZXM7XG4gICAgICAgIGlmICghdHJ5RmV0Y2ggJiYgaXNFcXVhbCh2YXJpYWJsZXMsIHRoaXMudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNpemUgJiYgZmV0Y2hSZXN1bHRzXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJlc3VsdCgpXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIGlmICghdGhpcy5vYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5mZXRjaFF1ZXJ5KHRoaXMucXVlcnlJZCwgdGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUudXBkYXRlUXVlcnkgPSBmdW5jdGlvbiAobWFwRm4pIHtcbiAgICAgICAgdmFyIHF1ZXJ5TWFuYWdlciA9IHRoaXMucXVlcnlNYW5hZ2VyO1xuICAgICAgICB2YXIgX2EgPSBxdWVyeU1hbmFnZXIuZ2V0UXVlcnlXaXRoUHJldmlvdXNSZXN1bHQodGhpcy5xdWVyeUlkKSwgcHJldmlvdXNSZXN1bHQgPSBfYS5wcmV2aW91c1Jlc3VsdCwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBkb2N1bWVudCA9IF9hLmRvY3VtZW50O1xuICAgICAgICB2YXIgbmV3UmVzdWx0ID0gdHJ5RnVuY3Rpb25PckxvZ0Vycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBGbihwcmV2aW91c1Jlc3VsdCwgeyB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdSZXN1bHQpIHtcbiAgICAgICAgICAgIHF1ZXJ5TWFuYWdlci5kYXRhU3RvcmUubWFya1VwZGF0ZVF1ZXJ5UmVzdWx0KGRvY3VtZW50LCB2YXJpYWJsZXMsIG5ld1Jlc3VsdCk7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0b3BQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5zdG9wUG9sbGluZ1F1ZXJ5KHRoaXMucXVlcnlJZCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wb2xsSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgYXNzZXJ0Tm90Q2FjaGVGaXJzdE9yT25seSh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvbGxJbnRlcnZhbCA9IHBvbGxJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuc3RhcnRQb2xsaW5nUXVlcnkodGhpcy5vcHRpb25zLCB0aGlzLnF1ZXJ5SWQpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVMYXN0UmVzdWx0ID0gZnVuY3Rpb24gKG5ld1Jlc3VsdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSB0aGlzLmxhc3RSZXN1bHQ7XG4gICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IG5ld1Jlc3VsdDtcbiAgICAgICAgdGhpcy5sYXN0UmVzdWx0U25hcHNob3QgPSB0aGlzLnF1ZXJ5TWFuYWdlci5hc3N1bWVJbW11dGFibGVSZXN1bHRzXG4gICAgICAgICAgICA/IG5ld1Jlc3VsdFxuICAgICAgICAgICAgOiBjbG9uZURlZXAobmV3UmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzUmVzdWx0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5vblN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHN1Yk9ic2VydmVyID0gb2JzZXJ2ZXIuX3N1YnNjcmlwdGlvbi5fb2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAoc3ViT2JzZXJ2ZXIgJiYgIXN1Yk9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3ViT2JzZXJ2ZXIuZXJyb3IgPSBkZWZhdWx0U3Vic2NyaXB0aW9uT2JzZXJ2ZXJFcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgIHZhciBmaXJzdCA9ICF0aGlzLm9ic2VydmVycy5zaXplO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCAmJiB0aGlzLmxhc3RSZXN1bHQpXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHRoaXMubGFzdFJlc3VsdCk7XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciAmJiB0aGlzLmxhc3RFcnJvcilcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMubGFzdEVycm9yKTtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFVwUXVlcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpICYmICFfdGhpcy5vYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRlYXJEb3duUXVlcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2V0VXBRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcXVlcnlNYW5hZ2VyID0gX2EucXVlcnlNYW5hZ2VyLCBxdWVyeUlkID0gX2EucXVlcnlJZDtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU3Vic2NyaWJlKSB7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXIuYWRkT2JzZXJ2YWJsZVF1ZXJ5KHF1ZXJ5SWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucG9sbEludGVydmFsKSB7XG4gICAgICAgICAgICBhc3NlcnROb3RDYWNoZUZpcnN0T3JPbmx5KHRoaXMpO1xuICAgICAgICAgICAgcXVlcnlNYW5hZ2VyLnN0YXJ0UG9sbGluZ1F1ZXJ5KHRoaXMub3B0aW9ucywgcXVlcnlJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxhc3RSZXN1bHQoX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLmxhc3RSZXN1bHQpLCB7IGVycm9yczogZXJyb3IuZ3JhcGhRTEVycm9ycywgbmV0d29ya1N0YXR1czogTmV0d29ya1N0YXR1cy5lcnJvciwgbG9hZGluZzogZmFsc2UgfSkpO1xuICAgICAgICAgICAgaXRlcmF0ZU9ic2VydmVyc1NhZmVseShfdGhpcy5vYnNlcnZlcnMsICdlcnJvcicsIF90aGlzLmxhc3RFcnJvciA9IGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXVlcnlNYW5hZ2VyLm9ic2VydmVRdWVyeShxdWVyeUlkLCB0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdEVycm9yIHx8IF90aGlzLmlzRGlmZmVyZW50RnJvbUxhc3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHRfMSA9IF90aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMub3B0aW9ucywgcXVlcnlfMSA9IF9hLnF1ZXJ5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIGZldGNoUG9saWN5XzEgPSBfYS5mZXRjaFBvbGljeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5TWFuYWdlci50cmFuc2Zvcm0ocXVlcnlfMSkuaGFzQ2xpZW50RXhwb3J0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlNYW5hZ2VyLmdldExvY2FsU3RhdGUoKS5hZGRFeHBvcnRlZFZhcmlhYmxlcyhxdWVyeV8xLCB2YXJpYWJsZXMpLnRoZW4oZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1ZhcmlhYmxlcyA9IF90aGlzLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXMgPSBfdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0XzEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3lfMSAhPT0gJ2NhY2hlLW9ubHknICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TWFuYWdlci50cmFuc2Zvcm0ocXVlcnlfMSkuc2VydmVyUXVlcnkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzRXF1YWwocHJldmlvdXNWYXJpYWJsZXMsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmZXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZU9ic2VydmVyc1NhZmVseShfdGhpcy5vYnNlcnZlcnMsICduZXh0JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkoX3RoaXMub2JzZXJ2ZXJzLCAnbmV4dCcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IG9uRXJyb3IsXG4gICAgICAgIH0pLmNhdGNoKG9uRXJyb3IpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS50ZWFyRG93blF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gdGhpcy5xdWVyeU1hbmFnZXI7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IHRydWU7XG4gICAgICAgIHF1ZXJ5TWFuYWdlci5zdG9wUG9sbGluZ1F1ZXJ5KHRoaXMucXVlcnlJZCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIHF1ZXJ5TWFuYWdlci5yZW1vdmVPYnNlcnZhYmxlUXVlcnkodGhpcy5xdWVyeUlkKTtcbiAgICAgICAgcXVlcnlNYW5hZ2VyLnN0b3BRdWVyeSh0aGlzLnF1ZXJ5SWQpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVRdWVyeTtcbn0oT2JzZXJ2YWJsZSkpO1xuZnVuY3Rpb24gZGVmYXVsdFN1YnNjcmlwdGlvbk9ic2VydmVyRXJyb3JDYWxsYmFjayhlcnJvcikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQuZXJyb3IoJ1VuaGFuZGxlZCBlcnJvcicsIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrKTtcbn1cbmZ1bmN0aW9uIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkob2JzZXJ2ZXJzLCBtZXRob2QsIGFyZ3VtZW50KSB7XG4gICAgdmFyIG9ic2VydmVyc1dpdGhNZXRob2QgPSBbXTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnNbbWV0aG9kXSAmJiBvYnNlcnZlcnNXaXRoTWV0aG9kLnB1c2gob2JzKTsgfSk7XG4gICAgb2JzZXJ2ZXJzV2l0aE1ldGhvZC5mb3JFYWNoKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9ic1ttZXRob2RdKGFyZ3VtZW50KTsgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnROb3RDYWNoZUZpcnN0T3JPbmx5KG9ic1F1ZXJ5KSB7XG4gICAgdmFyIGZldGNoUG9saWN5ID0gb2JzUXVlcnkub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1maXJzdCcgJiYgZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1vbmx5JywgMykgOiBpbnZhcmlhbnQoZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1maXJzdCcgJiYgZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1vbmx5JywgJ1F1ZXJpZXMgdGhhdCBzcGVjaWZ5IHRoZSBjYWNoZS1maXJzdCBhbmQgY2FjaGUtb25seSBmZXRjaFBvbGljaWVzIGNhbm5vdCBhbHNvIGJlIHBvbGxpbmcgcXVlcmllcy4nKTtcbn1cblxudmFyIE11dGF0aW9uU3RvcmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11dGF0aW9uU3RvcmUoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSB7fTtcbiAgICB9XG4gICAgTXV0YXRpb25TdG9yZS5wcm90b3R5cGUuZ2V0U3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlO1xuICAgIH07XG4gICAgTXV0YXRpb25TdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG11dGF0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVbbXV0YXRpb25JZF07XG4gICAgfTtcbiAgICBNdXRhdGlvblN0b3JlLnByb3RvdHlwZS5pbml0TXV0YXRpb24gPSBmdW5jdGlvbiAobXV0YXRpb25JZCwgbXV0YXRpb24sIHZhcmlhYmxlcykge1xuICAgICAgICB0aGlzLnN0b3JlW211dGF0aW9uSWRdID0ge1xuICAgICAgICAgICAgbXV0YXRpb246IG11dGF0aW9uLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMgfHwge30sXG4gICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNdXRhdGlvblN0b3JlLnByb3RvdHlwZS5tYXJrTXV0YXRpb25FcnJvciA9IGZ1bmN0aW9uIChtdXRhdGlvbklkLCBlcnJvcikge1xuICAgICAgICB2YXIgbXV0YXRpb24gPSB0aGlzLnN0b3JlW211dGF0aW9uSWRdO1xuICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIG11dGF0aW9uLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIG11dGF0aW9uLmVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE11dGF0aW9uU3RvcmUucHJvdG90eXBlLm1hcmtNdXRhdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChtdXRhdGlvbklkKSB7XG4gICAgICAgIHZhciBtdXRhdGlvbiA9IHRoaXMuc3RvcmVbbXV0YXRpb25JZF07XG4gICAgICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICAgICAgbXV0YXRpb24ubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbXV0YXRpb24uZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNdXRhdGlvblN0b3JlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuICAgIH07XG4gICAgcmV0dXJuIE11dGF0aW9uU3RvcmU7XG59KCkpO1xuXG52YXIgUXVlcnlTdG9yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVlcnlTdG9yZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuICAgIH1cbiAgICBRdWVyeVN0b3JlLnByb3RvdHlwZS5nZXRTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmU7XG4gICAgfTtcbiAgICBRdWVyeVN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVtxdWVyeUlkXTtcbiAgICB9O1xuICAgIFF1ZXJ5U3RvcmUucHJvdG90eXBlLmluaXRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgcHJldmlvdXNRdWVyeSA9IHRoaXMuc3RvcmVbcXVlcnkucXVlcnlJZF07XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCghcHJldmlvdXNRdWVyeSB8fFxuICAgICAgICAgICAgcHJldmlvdXNRdWVyeS5kb2N1bWVudCA9PT0gcXVlcnkuZG9jdW1lbnQgfHxcbiAgICAgICAgICAgIGlzRXF1YWwocHJldmlvdXNRdWVyeS5kb2N1bWVudCwgcXVlcnkuZG9jdW1lbnQpLCAxOSkgOiBpbnZhcmlhbnQoIXByZXZpb3VzUXVlcnkgfHxcbiAgICAgICAgICAgIHByZXZpb3VzUXVlcnkuZG9jdW1lbnQgPT09IHF1ZXJ5LmRvY3VtZW50IHx8XG4gICAgICAgICAgICBpc0VxdWFsKHByZXZpb3VzUXVlcnkuZG9jdW1lbnQsIHF1ZXJ5LmRvY3VtZW50KSwgJ0ludGVybmFsIEVycm9yOiBtYXkgbm90IHVwZGF0ZSBleGlzdGluZyBxdWVyeSBzdHJpbmcgaW4gc3RvcmUnKTtcbiAgICAgICAgdmFyIGlzU2V0VmFyaWFibGVzID0gZmFsc2U7XG4gICAgICAgIHZhciBwcmV2aW91c1ZhcmlhYmxlcyA9IG51bGw7XG4gICAgICAgIGlmIChxdWVyeS5zdG9yZVByZXZpb3VzVmFyaWFibGVzICYmXG4gICAgICAgICAgICBwcmV2aW91c1F1ZXJ5ICYmXG4gICAgICAgICAgICBwcmV2aW91c1F1ZXJ5Lm5ldHdvcmtTdGF0dXMgIT09IE5ldHdvcmtTdGF0dXMubG9hZGluZykge1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKHByZXZpb3VzUXVlcnkudmFyaWFibGVzLCBxdWVyeS52YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgaXNTZXRWYXJpYWJsZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFyaWFibGVzID0gcHJldmlvdXNRdWVyeS52YXJpYWJsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXM7XG4gICAgICAgIGlmIChpc1NldFZhcmlhYmxlcykge1xuICAgICAgICAgICAgbmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMuc2V0VmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHF1ZXJ5LmlzUG9sbCkge1xuICAgICAgICAgICAgbmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMucG9sbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWVyeS5pc1JlZmV0Y2gpIHtcbiAgICAgICAgICAgIG5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLnJlZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5sb2FkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncmFwaFFMRXJyb3JzID0gW107XG4gICAgICAgIGlmIChwcmV2aW91c1F1ZXJ5ICYmIHByZXZpb3VzUXVlcnkuZ3JhcGhRTEVycm9ycykge1xuICAgICAgICAgICAgZ3JhcGhRTEVycm9ycyA9IHByZXZpb3VzUXVlcnkuZ3JhcGhRTEVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5LnF1ZXJ5SWRdID0ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICBwcmV2aW91c1ZhcmlhYmxlczogcHJldmlvdXNWYXJpYWJsZXMsXG4gICAgICAgICAgICBuZXR3b3JrRXJyb3I6IG51bGwsXG4gICAgICAgICAgICBncmFwaFFMRXJyb3JzOiBncmFwaFFMRXJyb3JzLFxuICAgICAgICAgICAgbmV0d29ya1N0YXR1czogbmV0d29ya1N0YXR1cyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBxdWVyeS5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeS5mZXRjaE1vcmVGb3JRdWVyeUlkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdGhpcy5zdG9yZVtxdWVyeS5mZXRjaE1vcmVGb3JRdWVyeUlkXSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVtxdWVyeS5mZXRjaE1vcmVGb3JRdWVyeUlkXS5uZXR3b3JrU3RhdHVzID1cbiAgICAgICAgICAgICAgICBOZXR3b3JrU3RhdHVzLmZldGNoTW9yZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIHJlc3VsdCwgZmV0Y2hNb3JlRm9yUXVlcnlJZCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcmUgfHwgIXRoaXMuc3RvcmVbcXVlcnlJZF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc3RvcmVbcXVlcnlJZF0ubmV0d29ya0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yZVtxdWVyeUlkXS5ncmFwaFFMRXJyb3JzID0gaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpID8gcmVzdWx0LmVycm9ycyA6IFtdO1xuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5SWRdLnByZXZpb3VzVmFyaWFibGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yZVtxdWVyeUlkXS5uZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5yZWFkeTtcbiAgICAgICAgaWYgKHR5cGVvZiBmZXRjaE1vcmVGb3JRdWVyeUlkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdGhpcy5zdG9yZVtmZXRjaE1vcmVGb3JRdWVyeUlkXSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVtmZXRjaE1vcmVGb3JRdWVyeUlkXS5uZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5yZWFkeTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5RXJyb3IgPSBmdW5jdGlvbiAocXVlcnlJZCwgZXJyb3IsIGZldGNoTW9yZUZvclF1ZXJ5SWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3JlIHx8ICF0aGlzLnN0b3JlW3F1ZXJ5SWRdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5SWRdLm5ldHdvcmtFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5SWRdLm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLmVycm9yO1xuICAgICAgICBpZiAodHlwZW9mIGZldGNoTW9yZUZvclF1ZXJ5SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtRdWVyeVJlc3VsdENsaWVudChmZXRjaE1vcmVGb3JRdWVyeUlkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0Q2xpZW50ID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdG9yZVZhbHVlID0gdGhpcy5zdG9yZSAmJiB0aGlzLnN0b3JlW3F1ZXJ5SWRdO1xuICAgICAgICBpZiAoc3RvcmVWYWx1ZSkge1xuICAgICAgICAgICAgc3RvcmVWYWx1ZS5uZXR3b3JrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgc3RvcmVWYWx1ZS5wcmV2aW91c1ZhcmlhYmxlcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzdG9yZVZhbHVlLm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLnJlYWR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeVN0b3JlLnByb3RvdHlwZS5zdG9wUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5zdG9yZVtxdWVyeUlkXTtcbiAgICB9O1xuICAgIFF1ZXJ5U3RvcmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG9ic2VydmFibGVRdWVyeUlkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5SWRzLmluZGV4T2YocXVlcnlJZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RvcFF1ZXJ5KHF1ZXJ5SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RvcmVbcXVlcnlJZF0ubmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMubG9hZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVlcnlTdG9yZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG52YXIgTG9jYWxTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9jYWxTdGF0ZShfYSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBfYS5jYWNoZSwgY2xpZW50ID0gX2EuY2xpZW50LCByZXNvbHZlcnMgPSBfYS5yZXNvbHZlcnMsIGZyYWdtZW50TWF0Y2hlciA9IF9hLmZyYWdtZW50TWF0Y2hlcjtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJlc29sdmVycyhyZXNvbHZlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudE1hdGNoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RnJhZ21lbnRNYXRjaGVyKGZyYWdtZW50TWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuYWRkUmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc29sdmVycyA9IHRoaXMucmVzb2x2ZXJzIHx8IHt9O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNvbHZlcnMpKSB7XG4gICAgICAgICAgICByZXNvbHZlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZXJHcm91cCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmVycyA9IG1lcmdlRGVlcChfdGhpcy5yZXNvbHZlcnMsIHJlc29sdmVyR3JvdXApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVycyA9IG1lcmdlRGVlcCh0aGlzLnJlc29sdmVycywgcmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLnJlc29sdmVycyA9IHt9O1xuICAgICAgICB0aGlzLmFkZFJlc29sdmVycyhyZXNvbHZlcnMpO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcnMgfHwge307XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5ydW5SZXNvbHZlcnMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gX2EuZG9jdW1lbnQsIHJlbW90ZVJlc3VsdCA9IF9hLnJlbW90ZVJlc3VsdCwgY29udGV4dCA9IF9hLmNvbnRleHQsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgX2IgPSBfYS5vbmx5UnVuRm9yY2VkUmVzb2x2ZXJzLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnJlc29sdmVEb2N1bWVudChkb2N1bWVudCwgcmVtb3RlUmVzdWx0LmRhdGEsIGNvbnRleHQsIHZhcmlhYmxlcywgdGhpcy5mcmFnbWVudE1hdGNoZXIsIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMpLnRoZW4oZnVuY3Rpb24gKGxvY2FsUmVzdWx0KSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHJlbW90ZVJlc3VsdCksIHsgZGF0YTogbG9jYWxSZXN1bHQucmVzdWx0IH0pKTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlbW90ZVJlc3VsdF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zZXRGcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRNYXRjaGVyID0gZnJhZ21lbnRNYXRjaGVyO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0RnJhZ21lbnRNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudE1hdGNoZXI7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5jbGllbnRRdWVyeSA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAoaGFzRGlyZWN0aXZlcyhbJ2NsaWVudCddLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybignRm91bmQgQGNsaWVudCBkaXJlY3RpdmVzIGluIGEgcXVlcnkgYnV0IG5vIEFwb2xsb0NsaWVudCByZXNvbHZlcnMgJyArXG4gICAgICAgICAgICAgICAgJ3dlcmUgc3BlY2lmaWVkLiBUaGlzIG1lYW5zIEFwb2xsb0NsaWVudCBsb2NhbCByZXNvbHZlciBoYW5kbGluZyAnICtcbiAgICAgICAgICAgICAgICAnaGFzIGJlZW4gZGlzYWJsZWQsIGFuZCBAY2xpZW50IGRpcmVjdGl2ZXMgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCAnICtcbiAgICAgICAgICAgICAgICAndG8geW91ciBsaW5rIGNoYWluLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2VydmVyUXVlcnkgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJzID8gcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudChkb2N1bWVudCkgOiBkb2N1bWVudDtcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnByZXBhcmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgY2FjaGU6IGNhY2hlLCBnZXRDYWNoZUtleTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmNvbmZpZy5kYXRhSWRGcm9tT2JqZWN0KG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIDYpIDogaW52YXJpYW50KGZhbHNlLCAnVG8gdXNlIGNvbnRleHQuZ2V0Q2FjaGVLZXksIHlvdSBuZWVkIHRvIHVzZSBhIGNhY2hlIHRoYXQgaGFzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2EgY29uZmlndXJhYmxlIGRhdGFJZEZyb21PYmplY3QsIGxpa2UgYXBvbGxvLWNhY2hlLWlubWVtb3J5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIHJldHVybiBuZXdDb250ZXh0O1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuYWRkRXhwb3J0ZWRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHZhcmlhYmxlcywgY29udGV4dCkge1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0ge307IH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZURvY3VtZW50KGRvY3VtZW50LCB0aGlzLmJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlKGRvY3VtZW50LCB2YXJpYWJsZXMpIHx8IHt9LCB0aGlzLnByZXBhcmVDb250ZXh0KGNvbnRleHQpLCB2YXJpYWJsZXMpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdmFyaWFibGVzKSwgZGF0YS5leHBvcnRlZFZhcmlhYmxlcykpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgX19hc3NpZ24oe30sIHZhcmlhYmxlcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2hvdWxkRm9yY2VSZXNvbHZlcnMgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGZvcmNlUmVzb2x2ZXJzID0gZmFsc2U7XG4gICAgICAgIHZpc2l0KGRvY3VtZW50LCB7XG4gICAgICAgICAgICBEaXJlY3RpdmU6IHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZS52YWx1ZSA9PT0gJ2NsaWVudCcgJiYgbm9kZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlUmVzb2x2ZXJzID0gbm9kZS5hcmd1bWVudHMuc29tZShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5uYW1lLnZhbHVlID09PSAnYWx3YXlzJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudmFsdWUua2luZCA9PT0gJ0Jvb2xlYW5WYWx1ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnLnZhbHVlLnZhbHVlID09PSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VSZXNvbHZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JjZVJlc29sdmVycztcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQoZG9jdW1lbnQpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICB9KS5yZXN1bHQ7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5yZXNvbHZlRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHJvb3RWYWx1ZSwgY29udGV4dCwgdmFyaWFibGVzLCBmcmFnbWVudE1hdGNoZXIsIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgaWYgKHZhcmlhYmxlcyA9PT0gdm9pZCAwKSB7IHZhcmlhYmxlcyA9IHt9OyB9XG4gICAgICAgIGlmIChmcmFnbWVudE1hdGNoZXIgPT09IHZvaWQgMCkgeyBmcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9XG4gICAgICAgIGlmIChvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzID09PSB2b2lkIDApIHsgb25seVJ1bkZvcmNlZFJlc29sdmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYWluRGVmaW5pdGlvbiwgZnJhZ21lbnRzLCBmcmFnbWVudE1hcCwgZGVmaW5pdGlvbk9wZXJhdGlvbiwgZGVmYXVsdE9wZXJhdGlvblR5cGUsIF9hLCBjYWNoZSwgY2xpZW50LCBleGVjQ29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBtYWluRGVmaW5pdGlvbiA9IGdldE1haW5EZWZpbml0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudHMgPSBnZXRGcmFnbWVudERlZmluaXRpb25zKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IGNyZWF0ZUZyYWdtZW50TWFwKGZyYWdtZW50cyk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbk9wZXJhdGlvbiA9IG1haW5EZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5vcGVyYXRpb247XG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wZXJhdGlvblR5cGUgPSBkZWZpbml0aW9uT3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGRlZmluaXRpb25PcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIDogJ1F1ZXJ5JztcbiAgICAgICAgICAgICAgICBfYSA9IHRoaXMsIGNhY2hlID0gX2EuY2FjaGUsIGNsaWVudCA9IF9hLmNsaWVudDtcbiAgICAgICAgICAgICAgICBleGVjQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRNYXA6IGZyYWdtZW50TWFwLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQgfSksXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wZXJhdGlvblR5cGU6IGRlZmF1bHRPcGVyYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFZhcmlhYmxlczoge30sXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZVNlbGVjdGlvblNldChtYWluRGVmaW5pdGlvbi5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRWYXJpYWJsZXM6IGV4ZWNDb250ZXh0LmV4cG9ydGVkVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTsgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZVNlbGVjdGlvblNldCA9IGZ1bmN0aW9uIChzZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50TWFwLCBjb250ZXh0LCB2YXJpYWJsZXMsIHJlc3VsdHNUb01lcmdlLCBleGVjdXRlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IGV4ZWNDb250ZXh0LmZyYWdtZW50TWFwLCBjb250ZXh0ID0gZXhlY0NvbnRleHQuY29udGV4dCwgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNUb01lcmdlID0gW3Jvb3RWYWx1ZV07XG4gICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50LCB0eXBlQ29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZUZpZWxkKHNlbGVjdGlvbiwgcm9vdFZhbHVlLCBleGVjQ29udGV4dCkudGhlbihmdW5jdGlvbiAoZmllbGRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRSZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1RvTWVyZ2UucHVzaCgoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbcmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pXSA9IGZpZWxkUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmxpbmVGcmFnbWVudChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50TWFwW3NlbGVjdGlvbi5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZnJhZ21lbnQsIDcpIDogaW52YXJpYW50KGZyYWdtZW50LCBcIk5vIGZyYWdtZW50IG5hbWVkIFwiICsgc2VsZWN0aW9uLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnR5cGVDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlQ29uZGl0aW9uID0gZnJhZ21lbnQudHlwZUNvbmRpdGlvbi5uYW1lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGVjQ29udGV4dC5mcmFnbWVudE1hdGNoZXIocm9vdFZhbHVlLCB0eXBlQ29uZGl0aW9uLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZVNlbGVjdGlvblNldChmcmFnbWVudC5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZyYWdtZW50UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1RvTWVyZ2UucHVzaChmcmFnbWVudFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBQcm9taXNlLmFsbChzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5tYXAoZXhlY3V0ZSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcEFycmF5KHJlc3VsdHNUb01lcmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZUZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCByb290VmFsdWUsIGV4ZWNDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZXMsIGZpZWxkTmFtZSwgYWxpYXNlZEZpZWxkTmFtZSwgYWxpYXNVc2VkLCBkZWZhdWx0UmVzdWx0LCByZXN1bHRQcm9taXNlLCByZXNvbHZlclR5cGUsIHJlc29sdmVyTWFwLCByZXNvbHZlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSBleGVjQ29udGV4dC52YXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGQubmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkRmllbGROYW1lID0gcmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCk7XG4gICAgICAgICAgICAgICAgYWxpYXNVc2VkID0gZmllbGROYW1lICE9PSBhbGlhc2VkRmllbGROYW1lO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRSZXN1bHQgPSByb290VmFsdWVbYWxpYXNlZEZpZWxkTmFtZV0gfHwgcm9vdFZhbHVlW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShkZWZhdWx0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4ZWNDb250ZXh0Lm9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG91bGRGb3JjZVJlc29sdmVycyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXJUeXBlID0gcm9vdFZhbHVlLl9fdHlwZW5hbWUgfHwgZXhlY0NvbnRleHQuZGVmYXVsdE9wZXJhdGlvblR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyTWFwID0gdGhpcy5yZXNvbHZlcnMgJiYgdGhpcy5yZXNvbHZlcnNbcmVzb2x2ZXJUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzb2x2ZXJNYXBbYWxpYXNVc2VkID8gZmllbGROYW1lIDogYWxpYXNlZEZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocmVzb2x2ZShyb290VmFsdWUsIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSwgZXhlY0NvbnRleHQuY29udGV4dCwgeyBmaWVsZDogZmllbGQsIGZyYWdtZW50TWFwOiBleGVjQ29udGV4dC5mcmFnbWVudE1hcCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXN1bHRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IGRlZmF1bHRSZXN1bHQ7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5uYW1lLnZhbHVlID09PSAnZXhwb3J0JyAmJiBkaXJlY3RpdmUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcubmFtZS52YWx1ZSA9PT0gJ2FzJyAmJiBhcmcudmFsdWUua2luZCA9PT0gJ1N0cmluZ1ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjQ29udGV4dC5leHBvcnRlZFZhcmlhYmxlc1thcmcudmFsdWUudmFsdWVdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlU3ViU2VsZWN0ZWRBcnJheShmaWVsZCwgcmVzdWx0LCBleGVjQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVTZWxlY3Rpb25TZXQoZmllbGQuc2VsZWN0aW9uU2V0LCByZXN1bHQsIGV4ZWNDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZVN1YlNlbGVjdGVkQXJyYXkgPSBmdW5jdGlvbiAoZmllbGQsIHJlc3VsdCwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlU3ViU2VsZWN0ZWRBcnJheShmaWVsZCwgaXRlbSwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlU2VsZWN0aW9uU2V0KGZpZWxkLnNlbGVjdGlvblNldCwgaXRlbSwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxTdGF0ZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIG11bHRpcGxleChpbm5lcikge1xuICAgIHZhciBvYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHN1YiA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgICAgc3ViID0gc3ViIHx8IGlubmVyLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMubmV4dCAmJiBvYnMubmV4dCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IgJiYgb2JzLmVycm9yKGVycm9yKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuY29tcGxldGUgJiYgb2JzLmNvbXBsZXRlKCk7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcikgJiYgIW9ic2VydmVycy5zaXplICYmIHN1Yikge1xuICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhc3luY01hcChvYnNlcnZhYmxlLCBtYXBGbikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIG5leHQgPSBvYnNlcnZlci5uZXh0LCBlcnJvciA9IG9ic2VydmVyLmVycm9yLCBjb21wbGV0ZSA9IG9ic2VydmVyLmNvbXBsZXRlO1xuICAgICAgICB2YXIgYWN0aXZlTmV4dENvdW50ID0gMDtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICsrYWN0aXZlTmV4dENvdW50O1xuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWFwRm4odmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1hY3RpdmVOZXh0Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgJiYgbmV4dC5jYWxsKG9ic2VydmVyLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgJiYgaGFuZGxlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tYWN0aXZlTmV4dENvdW50O1xuICAgICAgICAgICAgICAgICAgICBlcnJvciAmJiBlcnJvci5jYWxsKG9ic2VydmVyLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciAmJiBlcnJvci5jYWxsKG9ic2VydmVyLCBlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVOZXh0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgJiYgY29tcGxldGUuY2FsbChvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN1YiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgfSk7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUXVlcnlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeU1hbmFnZXIoX2EpIHtcbiAgICAgICAgdmFyIGxpbmsgPSBfYS5saW5rLCBfYiA9IF9hLnF1ZXJ5RGVkdXBsaWNhdGlvbiwgcXVlcnlEZWR1cGxpY2F0aW9uID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIHN0b3JlID0gX2Euc3RvcmUsIF9jID0gX2Eub25Ccm9hZGNhc3QsIG9uQnJvYWRjYXN0ID0gX2MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSA6IF9jLCBfZCA9IF9hLnNzck1vZGUsIHNzck1vZGUgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYS5jbGllbnRBd2FyZW5lc3MsIGNsaWVudEF3YXJlbmVzcyA9IF9lID09PSB2b2lkIDAgPyB7fSA6IF9lLCBsb2NhbFN0YXRlID0gX2EubG9jYWxTdGF0ZSwgYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyA9IF9hLmFzc3VtZUltbXV0YWJsZVJlc3VsdHM7XG4gICAgICAgIHRoaXMubXV0YXRpb25TdG9yZSA9IG5ldyBNdXRhdGlvblN0b3JlKCk7XG4gICAgICAgIHRoaXMucXVlcnlTdG9yZSA9IG5ldyBRdWVyeVN0b3JlKCk7XG4gICAgICAgIHRoaXMuY2xpZW50QXdhcmVuZXNzID0ge307XG4gICAgICAgIHRoaXMuaWRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZldGNoUXVlcnlSZWplY3RGbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FjaGUgPSBuZXcgKGNhblVzZVdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuICAgICAgICB0aGlzLmluRmxpZ2h0TGlua09ic2VydmFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBvbGxpbmdJbmZvQnlRdWVyeUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgICB0aGlzLnF1ZXJ5RGVkdXBsaWNhdGlvbiA9IHF1ZXJ5RGVkdXBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kYXRhU3RvcmUgPSBzdG9yZTtcbiAgICAgICAgdGhpcy5vbkJyb2FkY2FzdCA9IG9uQnJvYWRjYXN0O1xuICAgICAgICB0aGlzLmNsaWVudEF3YXJlbmVzcyA9IGNsaWVudEF3YXJlbmVzcztcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbG9jYWxTdGF0ZSB8fCBuZXcgTG9jYWxTdGF0ZSh7IGNhY2hlOiBzdG9yZS5nZXRDYWNoZSgpIH0pO1xuICAgICAgICB0aGlzLnNzck1vZGUgPSBzc3JNb2RlO1xuICAgICAgICB0aGlzLmFzc3VtZUltbXV0YWJsZVJlc3VsdHMgPSAhIWFzc3VtZUltbXV0YWJsZVJlc3VsdHM7XG4gICAgfVxuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9pbmZvLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICBfdGhpcy5zdG9wUXVlcnlOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWplY3QpIHtcbiAgICAgICAgICAgIHJlamVjdChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoOCkgOiBuZXcgSW52YXJpYW50RXJyb3IoJ1F1ZXJ5TWFuYWdlciBzdG9wcGVkIHdoaWxlIHF1ZXJ5IHdhcyBpbiBmbGlnaHQnKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG11dGF0aW9uID0gX2EubXV0YXRpb24sIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgb3B0aW1pc3RpY1Jlc3BvbnNlID0gX2Eub3B0aW1pc3RpY1Jlc3BvbnNlLCB1cGRhdGVRdWVyaWVzQnlOYW1lID0gX2EudXBkYXRlUXVlcmllcywgX2IgPSBfYS5yZWZldGNoUXVlcmllcywgcmVmZXRjaFF1ZXJpZXMgPSBfYiA9PT0gdm9pZCAwID8gW10gOiBfYiwgX2MgPSBfYS5hd2FpdFJlZmV0Y2hRdWVyaWVzLCBhd2FpdFJlZmV0Y2hRdWVyaWVzID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIHVwZGF0ZVdpdGhQcm94eUZuID0gX2EudXBkYXRlLCBfZCA9IF9hLmVycm9yUG9saWN5LCBlcnJvclBvbGljeSA9IF9kID09PSB2b2lkIDAgPyAnbm9uZScgOiBfZCwgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeSwgX2UgPSBfYS5jb250ZXh0LCBjb250ZXh0ID0gX2UgPT09IHZvaWQgMCA/IHt9IDogX2U7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbklkLCBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvLCBzZWxmO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChtdXRhdGlvbiwgOSkgOiBpbnZhcmlhbnQobXV0YXRpb24sICdtdXRhdGlvbiBvcHRpb24gaXMgcmVxdWlyZWQuIFlvdSBtdXN0IHNwZWNpZnkgeW91ciBHcmFwaFFMIGRvY3VtZW50IGluIHRoZSBtdXRhdGlvbiBvcHRpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIWZldGNoUG9saWN5IHx8IGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnLCAxMCkgOiBpbnZhcmlhbnQoIWZldGNoUG9saWN5IHx8IGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnLCBcIk11dGF0aW9ucyBvbmx5IHN1cHBvcnQgYSAnbm8tY2FjaGUnIGZldGNoUG9saWN5LiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBkaXNhYmxlIHRoZSBjYWNoZSwgcmVtb3ZlIHlvdXIgZmV0Y2hQb2xpY3kgc2V0dGluZyB0byBwcm9jZWVkIHdpdGggdGhlIGRlZmF1bHQgbXV0YXRpb24gYmVoYXZpb3IuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JZCA9IHRoaXMuZ2VuZXJhdGVRdWVyeUlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IHRoaXMudHJhbnNmb3JtKG11dGF0aW9uKS5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UXVlcnkobXV0YXRpb25JZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgZG9jdW1lbnQ6IG11dGF0aW9uIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKG11dGF0aW9uLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybShtdXRhdGlvbikuaGFzQ2xpZW50RXhwb3J0cykgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5sb2NhbFN0YXRlLmFkZEV4cG9ydGVkVmFyaWFibGVzKG11dGF0aW9uLCB2YXJpYWJsZXMsIGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlUXVlcmllc0J5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5ID0gX2Eub2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmFibGVRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeU5hbWUgPSBvYnNlcnZhYmxlUXVlcnkucXVlcnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh1cGRhdGVRdWVyaWVzQnlOYW1lLCBxdWVyeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldFtxdWVyeUlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXI6IHVwZGF0ZVF1ZXJpZXNCeU5hbWVbcXVlcnlOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBfdGhpcy5xdWVyeVN0b3JlLmdldChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25TdG9yZS5pbml0TXV0YXRpb24obXV0YXRpb25JZCwgbXV0YXRpb24sIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTdG9yZS5tYXJrTXV0YXRpb25Jbml0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklkOiBtdXRhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBtdXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVRdWVyaWVzOiBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB1cGRhdGVXaXRoUHJveHlGbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRPYnNlcnZhYmxlRnJvbUxpbmsobXV0YXRpb24sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb250ZXh0KSwgeyBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSB9KSwgdmFyaWFibGVzLCBmYWxzZSkuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKHJlc3VsdCkgJiYgZXJyb3JQb2xpY3kgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBBcG9sbG9FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzOiByZXN1bHQuZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm11dGF0aW9uU3RvcmUubWFya011dGF0aW9uUmVzdWx0KG11dGF0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZXRjaFBvbGljeSAhPT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGFTdG9yZS5tYXJrTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JZDogbXV0YXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVRdWVyaWVzOiBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVdpdGhQcm94eUZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm11dGF0aW9uU3RvcmUubWFya011dGF0aW9uRXJyb3IobXV0YXRpb25JZCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGFTdG9yZS5tYXJrTXV0YXRpb25Db21wbGV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQ6IG11dGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNSZXNwb25zZTogb3B0aW1pc3RpY1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0UXVlcnkobXV0YXRpb25JZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgZG9jdW1lbnQ6IG51bGwgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tdXRhdGlvblN0b3JlLm1hcmtNdXRhdGlvbkVycm9yKG11dGF0aW9uSWQsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhU3RvcmUubWFya011dGF0aW9uQ29tcGxldGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklkOiBtdXRhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZmV0Y2hRdWVyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyaWVzID0gcmVmZXRjaFF1ZXJpZXMoc3RvcmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmZXRjaFF1ZXJ5UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb25FbXB0eUFycmF5KHJlZmV0Y2hRdWVyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZldGNoUXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZldGNoUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmZXRjaFF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5ID0gX2Eub2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlUXVlcnkucXVlcnlOYW1lID09PSByZWZldGNoUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyeVByb21pc2VzLnB1c2gob2JzZXJ2YWJsZVF1ZXJ5LnJlZmV0Y2goKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiByZWZldGNoUXVlcnkucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcmVmZXRjaFF1ZXJ5LnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3k6ICduZXR3b3JrLW9ubHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmV0Y2hRdWVyeS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5T3B0aW9ucy5jb250ZXh0ID0gcmVmZXRjaFF1ZXJ5LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyeVByb21pc2VzLnB1c2goc2VsZi5xdWVyeShxdWVyeU9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKGF3YWl0UmVmZXRjaFF1ZXJpZXMgPyByZWZldGNoUXVlcnlQcm9taXNlcyA6IFtdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRRdWVyeShtdXRhdGlvbklkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBkb2N1bWVudDogbnVsbCB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvclBvbGljeSA9PT0gJ2lnbm9yZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlUmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaFFMUmVzdWx0SGFzRXJyb3Ioc3RvcmVSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RvcmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZmV0Y2hRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkLCBvcHRpb25zLCBmZXRjaFR5cGUsIGZldGNoTW9yZUZvclF1ZXJ5SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBtZXRhZGF0YSwgX2IsIGZldGNoUG9saWN5LCBfYywgY29udGV4dCwgcXVlcnksIHZhcmlhYmxlcywgc3RvcmVSZXN1bHQsIGlzTmV0d29ya09ubHksIG5lZWRUb0ZldGNoLCBfZCwgY29tcGxldGUsIHJlc3VsdCwgc2hvdWxkRmV0Y2gsIHJlcXVlc3RJZCwgY2FuY2VsLCBuZXR3b3JrUmVzdWx0O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gb3B0aW9ucy5tZXRhZGF0YSwgbWV0YWRhdGEgPSBfYSA9PT0gdm9pZCAwID8gbnVsbCA6IF9hLCBfYiA9IG9wdGlvbnMuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2IgPT09IHZvaWQgMCA/ICdjYWNoZS1maXJzdCcgOiBfYiwgX2MgPSBvcHRpb25zLmNvbnRleHQsIGNvbnRleHQgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ob3B0aW9ucy5xdWVyeSkuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgb3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybShxdWVyeSkuaGFzQ2xpZW50RXhwb3J0cykgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5sb2NhbFN0YXRlLmFkZEV4cG9ydGVkVmFyaWFibGVzKHF1ZXJ5LCB2YXJpYWJsZXMsIGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHZhcmlhYmxlczogdmFyaWFibGVzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXR3b3JrT25seSA9IGZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyB8fCBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb0ZldGNoID0gaXNOZXR3b3JrT25seTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOZXR3b3JrT25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gdGhpcy5kYXRhU3RvcmUuZ2V0Q2FjaGUoKS5kaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjb21wbGV0ZSA9IF9kLmNvbXBsZXRlLCByZXN1bHQgPSBfZC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZFRvRmV0Y2ggPSAhY29tcGxldGUgfHwgZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRGZXRjaCA9IG5lZWRUb0ZldGNoICYmIGZldGNoUG9saWN5ICE9PSAnY2FjaGUtb25seScgJiYgZmV0Y2hQb2xpY3kgIT09ICdzdGFuZGJ5JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNEaXJlY3RpdmVzKFsnbGl2ZSddLCBxdWVyeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkRmV0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkID0gdGhpcy5pZENvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCA9IGZldGNoUG9saWN5ICE9PSAnbm8tY2FjaGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnVwZGF0ZVF1ZXJ5V2F0Y2gocXVlcnlJZCwgcXVlcnksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGNhbmNlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlTdG9yZS5pbml0UXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlUHJldmlvdXNWYXJpYWJsZXM6IHNob3VsZEZldGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUG9sbDogZmV0Y2hUeXBlID09PSBGZXRjaFR5cGUucG9sbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlZmV0Y2g6IGZldGNoVHlwZSA9PT0gRmV0Y2hUeXBlLnJlZmV0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTW9yZUZvclF1ZXJ5SWQ6IGZldGNoTW9yZUZvclF1ZXJ5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Jlc3VsdCA9IHRoaXMuZmV0Y2hSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hNb3JlRm9yUXVlcnlJZDogZmV0Y2hNb3JlRm9yUXVlcnlJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXBvbGxvRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SWQgPj0gX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCkubGFzdFJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5U3RvcmUubWFya1F1ZXJ5RXJyb3IocXVlcnlJZCwgZXJyb3IsIGZldGNoTW9yZUZvclF1ZXJ5SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBvbGxvRXJyb3IoeyBuZXR3b3JrRXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZldGNoUG9saWN5ICE9PSAnY2FjaGUtYW5kLW5ldHdvcmsnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV0d29ya1Jlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtSZXN1bHQuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlTdG9yZS5tYXJrUXVlcnlSZXN1bHRDbGllbnQocXVlcnlJZCwgIXNob3VsZEZldGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShxdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybShxdWVyeSkuaGFzRm9yY2VkUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmxvY2FsU3RhdGUucnVuUmVzb2x2ZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVJlc3VsdDogeyBkYXRhOiBzdG9yZVJlc3VsdCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25seVJ1bkZvcmNlZFJlc29sdmVyczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXJrUXVlcnlSZXN1bHQocXVlcnlJZCwgcmVzdWx0LCBvcHRpb25zLCBmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGRhdGE6IHN0b3JlUmVzdWx0IH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIHJlc3VsdCwgX2EsIGZldGNoTW9yZUZvclF1ZXJ5SWQpIHtcbiAgICAgICAgdmFyIGZldGNoUG9saWN5ID0gX2EuZmV0Y2hQb2xpY3ksIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgZXJyb3JQb2xpY3kgPSBfYS5lcnJvclBvbGljeTtcbiAgICAgICAgaWYgKGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgbmV3RGF0YTogeyByZXN1bHQ6IHJlc3VsdC5kYXRhLCBjb21wbGV0ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhU3RvcmUubWFya1F1ZXJ5UmVzdWx0KHJlc3VsdCwgdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5kb2N1bWVudCwgdmFyaWFibGVzLCBmZXRjaE1vcmVGb3JRdWVyeUlkLCBlcnJvclBvbGljeSA9PT0gJ2lnbm9yZScgfHwgZXJyb3JQb2xpY3kgPT09ICdhbGwnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5xdWVyeUxpc3RlbmVyRm9yT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlclttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJbbWV0aG9kXShhcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC5lcnJvcihhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChxdWVyeVN0b3JlVmFsdWUsIG5ld0RhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocXVlcnlJZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFxdWVyeVN0b3JlVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCksIG9ic2VydmFibGVRdWVyeSA9IF9hLm9ic2VydmFibGVRdWVyeSwgZG9jdW1lbnQgPSBfYS5kb2N1bWVudDtcbiAgICAgICAgICAgIHZhciBmZXRjaFBvbGljeSA9IG9ic2VydmFibGVRdWVyeVxuICAgICAgICAgICAgICAgID8gb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZmV0Y2hQb2xpY3lcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09ICdzdGFuZGJ5JylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbG9hZGluZyA9IGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodChxdWVyeVN0b3JlVmFsdWUubmV0d29ya1N0YXR1cyk7XG4gICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IG9ic2VydmFibGVRdWVyeSAmJiBvYnNlcnZhYmxlUXVlcnkuZ2V0TGFzdFJlc3VsdCgpO1xuICAgICAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXNDaGFuZ2VkID0gISEobGFzdFJlc3VsdCAmJlxuICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQubmV0d29ya1N0YXR1cyAhPT0gcXVlcnlTdG9yZVZhbHVlLm5ldHdvcmtTdGF0dXMpO1xuICAgICAgICAgICAgdmFyIHNob3VsZE5vdGlmeUlmTG9hZGluZyA9IG9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEgfHxcbiAgICAgICAgICAgICAgICAoIW5ld0RhdGEgJiYgcXVlcnlTdG9yZVZhbHVlLnByZXZpb3VzVmFyaWFibGVzKSB8fFxuICAgICAgICAgICAgICAgIChuZXR3b3JrU3RhdHVzQ2hhbmdlZCAmJiBvcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSkgfHxcbiAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ2NhY2hlLW9ubHknIHx8XG4gICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yayc7XG4gICAgICAgICAgICBpZiAobG9hZGluZyAmJiAhc2hvdWxkTm90aWZ5SWZMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhc0dyYXBoUUxFcnJvcnMgPSBpc05vbkVtcHR5QXJyYXkocXVlcnlTdG9yZVZhbHVlLmdyYXBoUUxFcnJvcnMpO1xuICAgICAgICAgICAgdmFyIGVycm9yUG9saWN5ID0gb2JzZXJ2YWJsZVF1ZXJ5XG4gICAgICAgICAgICAgICAgJiYgb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZXJyb3JQb2xpY3lcbiAgICAgICAgICAgICAgICB8fCBvcHRpb25zLmVycm9yUG9saWN5XG4gICAgICAgICAgICAgICAgfHwgJ25vbmUnO1xuICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSAnbm9uZScgJiYgaGFzR3JhcGhRTEVycm9ycyB8fCBxdWVyeVN0b3JlVmFsdWUubmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludm9rZSgnZXJyb3InLCBuZXcgQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzOiBxdWVyeVN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBxdWVyeVN0b3JlVmFsdWUubmV0d29ya0Vycm9yLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGlzTWlzc2luZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgIT09ICduby1jYWNoZScgJiYgZmV0Y2hQb2xpY3kgIT09ICduZXR3b3JrLW9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRRdWVyeShxdWVyeUlkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBuZXdEYXRhOiBudWxsIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3RGF0YS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlzTWlzc2luZyA9ICFuZXdEYXRhLmNvbXBsZXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RFcnJvciA9IG9ic2VydmFibGVRdWVyeSAmJiBvYnNlcnZhYmxlUXVlcnkuZ2V0TGFzdEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclN0YXR1c0NoYW5nZWQgPSBlcnJvclBvbGljeSAhPT0gJ25vbmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobGFzdEVycm9yICYmIGxhc3RFcnJvci5ncmFwaFFMRXJyb3JzKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RSZXN1bHQgJiYgbGFzdFJlc3VsdC5kYXRhICYmICFlcnJvclN0YXR1c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBsYXN0UmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc01pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmUmVzdWx0ID0gX3RoaXMuZGF0YVN0b3JlLmdldENhY2hlKCkuZGlmZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcXVlcnlTdG9yZVZhbHVlLnByZXZpb3VzVmFyaWFibGVzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RvcmVWYWx1ZS52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRpZmZSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNNaXNzaW5nID0gIWRpZmZSZXN1bHQuY29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0YWxlID0gaXNNaXNzaW5nICYmICEob3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSB8fFxuICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ2NhY2hlLW9ubHknKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0RnJvbVN0b3JlID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzdGFsZSA/IGxhc3RSZXN1bHQgJiYgbGFzdFJlc3VsdC5kYXRhIDogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogcXVlcnlTdG9yZVZhbHVlLm5ldHdvcmtTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YWxlOiBzdGFsZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvclBvbGljeSA9PT0gJ2FsbCcgJiYgaGFzR3JhcGhRTEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRGcm9tU3RvcmUuZXJyb3JzID0gcXVlcnlTdG9yZVZhbHVlLmdyYXBoUUxFcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludm9rZSgnbmV4dCcsIHJlc3VsdEZyb21TdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAobmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlKCdlcnJvcicsIG5ldyBBcG9sbG9FcnJvcih7IG5ldHdvcmtFcnJvcjogbmV0d29ya0Vycm9yIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1DYWNoZSA9IHRoaXMudHJhbnNmb3JtQ2FjaGU7XG4gICAgICAgIGlmICghdHJhbnNmb3JtQ2FjaGUuaGFzKGRvY3VtZW50KSkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5kYXRhU3RvcmUuZ2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IGNhY2hlLnRyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIHZhciBmb3JMaW5rID0gcmVtb3ZlQ29ubmVjdGlvbkRpcmVjdGl2ZUZyb21Eb2N1bWVudChjYWNoZS50cmFuc2Zvcm1Gb3JMaW5rKHRyYW5zZm9ybWVkKSk7XG4gICAgICAgICAgICB2YXIgY2xpZW50UXVlcnkgPSB0aGlzLmxvY2FsU3RhdGUuY2xpZW50UXVlcnkodHJhbnNmb3JtZWQpO1xuICAgICAgICAgICAgdmFyIHNlcnZlclF1ZXJ5ID0gdGhpcy5sb2NhbFN0YXRlLnNlcnZlclF1ZXJ5KGZvckxpbmspO1xuICAgICAgICAgICAgdmFyIGNhY2hlRW50cnlfMSA9IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDogdHJhbnNmb3JtZWQsXG4gICAgICAgICAgICAgICAgaGFzQ2xpZW50RXhwb3J0czogaGFzQ2xpZW50RXhwb3J0cyh0cmFuc2Zvcm1lZCksXG4gICAgICAgICAgICAgICAgaGFzRm9yY2VkUmVzb2x2ZXJzOiB0aGlzLmxvY2FsU3RhdGUuc2hvdWxkRm9yY2VSZXNvbHZlcnModHJhbnNmb3JtZWQpLFxuICAgICAgICAgICAgICAgIGNsaWVudFF1ZXJ5OiBjbGllbnRRdWVyeSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJRdWVyeTogc2VydmVyUXVlcnksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhcnM6IGdldERlZmF1bHRWYWx1ZXMoZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbih0cmFuc2Zvcm1lZCkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYyAmJiAhdHJhbnNmb3JtQ2FjaGUuaGFzKGRvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KGRvYywgY2FjaGVFbnRyeV8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkKGRvY3VtZW50KTtcbiAgICAgICAgICAgIGFkZCh0cmFuc2Zvcm1lZCk7XG4gICAgICAgICAgICBhZGQoY2xpZW50UXVlcnkpO1xuICAgICAgICAgICAgYWRkKHNlcnZlclF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KGRvY3VtZW50KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFibGVzID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnRyYW5zZm9ybShkb2N1bWVudCkuZGVmYXVsdFZhcnMpLCB2YXJpYWJsZXMpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS53YXRjaFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNob3VsZFN1YnNjcmliZSkge1xuICAgICAgICBpZiAoc2hvdWxkU3Vic2NyaWJlID09PSB2b2lkIDApIHsgc2hvdWxkU3Vic2NyaWJlID0gdHJ1ZTsgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ3N0YW5kYnknLCAxMSkgOiBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ3N0YW5kYnknLCAnY2xpZW50LndhdGNoUXVlcnkgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGZldGNoUG9saWN5IHNldCB0byBcInN0YW5kYnlcIicpO1xuICAgICAgICBvcHRpb25zLnZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKG9wdGlvbnMucXVlcnksIG9wdGlvbnMudmFyaWFibGVzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkT3B0aW9ucyA9IF9fYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUXVlcnkoe1xuICAgICAgICAgICAgcXVlcnlNYW5hZ2VyOiB0aGlzLFxuICAgICAgICAgICAgb3B0aW9uczogdHJhbnNmb3JtZWRPcHRpb25zLFxuICAgICAgICAgICAgc2hvdWxkU3Vic2NyaWJlOiBzaG91bGRTdWJzY3JpYmUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChvcHRpb25zLnF1ZXJ5LCAxMikgOiBpbnZhcmlhbnQob3B0aW9ucy5xdWVyeSwgJ3F1ZXJ5IG9wdGlvbiBpcyByZXF1aXJlZC4gWW91IG11c3Qgc3BlY2lmeSB5b3VyIEdyYXBoUUwgZG9jdW1lbnQgJyArXG4gICAgICAgICAgICAnaW4gdGhlIHF1ZXJ5IG9wdGlvbi4nKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KG9wdGlvbnMucXVlcnkua2luZCA9PT0gJ0RvY3VtZW50JywgMTMpIDogaW52YXJpYW50KG9wdGlvbnMucXVlcnkua2luZCA9PT0gJ0RvY3VtZW50JywgJ1lvdSBtdXN0IHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhIFwiZ3FsXCIgdGFnLicpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIW9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEsIDE0KSA6IGludmFyaWFudCghb3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSwgJ3JldHVyblBhcnRpYWxEYXRhIG9wdGlvbiBvbmx5IHN1cHBvcnRlZCBvbiB3YXRjaFF1ZXJ5LicpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIW9wdGlvbnMucG9sbEludGVydmFsLCAxNSkgOiBpbnZhcmlhbnQoIW9wdGlvbnMucG9sbEludGVydmFsLCAncG9sbEludGVydmFsIG9wdGlvbiBvbmx5IHN1cHBvcnRlZCBvbiB3YXRjaFF1ZXJ5LicpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHdhdGNoZWRRdWVyeSA9IF90aGlzLndhdGNoUXVlcnkob3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgX3RoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5zZXQoXCJxdWVyeTpcIiArIHdhdGNoZWRRdWVyeS5xdWVyeUlkLCByZWplY3QpO1xuICAgICAgICAgICAgd2F0Y2hlZFF1ZXJ5XG4gICAgICAgICAgICAgICAgLnJlc3VsdCgpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5kZWxldGUoXCJxdWVyeTpcIiArIHdhdGNoZWRRdWVyeS5xdWVyeUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVRdWVyeUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuaWRDb3VudGVyKyspO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nUXVlcnkocXVlcnlJZCk7XG4gICAgICAgIHRoaXMucXVlcnlTdG9yZS5zdG9wUXVlcnkocXVlcnlJZCk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShxdWVyeUlkKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuYWRkUXVlcnlMaXN0ZW5lciA9IGZ1bmN0aW9uIChxdWVyeUlkLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IF9hLmxpc3RlbmVycztcbiAgICAgICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgaW52YWxpZGF0ZWQ6IGZhbHNlIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVRdWVyeVdhdGNoID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYW5jZWwgPSB0aGlzLmdldFF1ZXJ5KHF1ZXJ5SWQpLmNhbmNlbDtcbiAgICAgICAgaWYgKGNhbmNlbClcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGVRdWVyeSA9IF90aGlzLmdldFF1ZXJ5KHF1ZXJ5SWQpLm9ic2VydmFibGVRdWVyeTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IG9ic2VydmFibGVRdWVyeS5nZXRMYXN0UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZXN1bHQgPSBsYXN0UmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzUmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3RvcmUuZ2V0Q2FjaGUoKS53YXRjaCh7XG4gICAgICAgICAgICBxdWVyeTogZG9jdW1lbnQsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgb3B0aW1pc3RpYzogdHJ1ZSxcbiAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0OiBwcmV2aW91c1Jlc3VsdCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IGludmFsaWRhdGVkOiB0cnVlLCBuZXdEYXRhOiBuZXdEYXRhIH0pOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5hZGRPYnNlcnZhYmxlUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb2JzZXJ2YWJsZVF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuc2V0UXVlcnkocXVlcnlJZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgb2JzZXJ2YWJsZVF1ZXJ5OiBvYnNlcnZhYmxlUXVlcnkgfSk7IH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZhYmxlUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB2YXIgY2FuY2VsID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5jYW5jZWw7XG4gICAgICAgIHRoaXMuc2V0UXVlcnkocXVlcnlJZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgb2JzZXJ2YWJsZVF1ZXJ5OiBudWxsIH0pOyB9KTtcbiAgICAgICAgaWYgKGNhbmNlbClcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5jbGVhclN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZldGNoUXVlcnlSZWplY3RGbnMuZm9yRWFjaChmdW5jdGlvbiAocmVqZWN0KSB7XG4gICAgICAgICAgICByZWplY3QocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDE2KSA6IG5ldyBJbnZhcmlhbnRFcnJvcignU3RvcmUgcmVzZXQgd2hpbGUgcXVlcnkgd2FzIGluIGZsaWdodCAobm90IGNvbXBsZXRlZCBpbiBsaW5rIGNoYWluKScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXNldElkcyA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnkgPSBfYS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5KVxuICAgICAgICAgICAgICAgIHJlc2V0SWRzLnB1c2gocXVlcnlJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXJ5U3RvcmUucmVzZXQocmVzZXRJZHMpO1xuICAgICAgICB0aGlzLm11dGF0aW9uU3RvcmUucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVN0b3JlLnJlc2V0KCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlc2V0U3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyU3RvcmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcyA9IGZ1bmN0aW9uIChpbmNsdWRlU3RhbmRieSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaW5jbHVkZVN0YW5kYnkgPT09IHZvaWQgMCkgeyBpbmNsdWRlU3RhbmRieSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnlQcm9taXNlcyA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnkgPSBfYS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZldGNoUG9saWN5ID0gb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVF1ZXJ5LnJlc2V0TGFzdFJlc3VsdHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1vbmx5JyAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5jbHVkZVN0YW5kYnkgfHwgZmV0Y2hQb2xpY3kgIT09ICdzdGFuZGJ5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZXMucHVzaChvYnNlcnZhYmxlUXVlcnkucmVmZXRjaCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0UXVlcnkocXVlcnlJZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgbmV3RGF0YTogbnVsbCB9KTsgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShxdWVyeUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZXMpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5vYnNlcnZlUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRRdWVyeUxpc3RlbmVyKHF1ZXJ5SWQsIHRoaXMucXVlcnlMaXN0ZW5lckZvck9ic2VydmVyKHF1ZXJ5SWQsIG9wdGlvbnMsIG9ic2VydmVyKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkocXVlcnlJZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0YXJ0UXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgbGlzdGVuZXIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKFwiVGhlIFF1ZXJ5TWFuYWdlci5zdGFydFF1ZXJ5IG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkXCIpO1xuICAgICAgICB0aGlzLmFkZFF1ZXJ5TGlzdGVuZXIocXVlcnlJZCwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmZldGNoUXVlcnkocXVlcnlJZCwgb3B0aW9ucylcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0pO1xuICAgICAgICByZXR1cm4gcXVlcnlJZDtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RhcnRHcmFwaFFMU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXM7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmRvY3VtZW50O1xuICAgICAgICB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgdmFyaWFibGVzKTtcbiAgICAgICAgdmFyIG1ha2VPYnNlcnZhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldE9ic2VydmFibGVGcm9tTGluayhxdWVyeSwge30sIHZhcmlhYmxlcywgZmFsc2UpLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmZXRjaFBvbGljeSB8fCBmZXRjaFBvbGljeSAhPT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhU3RvcmUubWFya1N1YnNjcmlwdGlvblJlc3VsdChyZXN1bHQsIHF1ZXJ5LCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogcmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtKHF1ZXJ5KS5oYXNDbGllbnRFeHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZVByb21pc2VfMSA9IHRoaXMubG9jYWxTdGF0ZS5hZGRFeHBvcnRlZFZhcmlhYmxlcyhxdWVyeSwgdmFyaWFibGVzKS50aGVuKG1ha2VPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlUHJvbWlzZV8xLnRoZW4oZnVuY3Rpb24gKG9ic2VydmFibGUpIHsgcmV0dXJuIHN1YiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTsgfSwgb2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWIgJiYgc3ViLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZU9ic2VydmFibGUodmFyaWFibGVzKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RvcFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0b3BRdWVyeU5vQnJvYWRjYXN0ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUXVlcnkocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5mZXRjaFF1ZXJ5UmVqZWN0Rm5zLmRlbGV0ZShcInF1ZXJ5OlwiICsgcXVlcnlJZCk7XG4gICAgICAgIHRoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5kZWxldGUoXCJmZXRjaFJlcXVlc3Q6XCIgKyBxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgIHRoaXMucXVlcmllcy5kZWxldGUocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldEN1cnJlbnRRdWVyeVJlc3VsdCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlUXVlcnksIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgX2EgPSBvYnNlcnZhYmxlUXVlcnkub3B0aW9ucywgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBxdWVyeSA9IF9hLnF1ZXJ5LCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCByZXR1cm5QYXJ0aWFsRGF0YSA9IF9hLnJldHVyblBhcnRpYWxEYXRhO1xuICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IG9ic2VydmFibGVRdWVyeS5nZXRMYXN0UmVzdWx0KCk7XG4gICAgICAgIHZhciBuZXdEYXRhID0gdGhpcy5nZXRRdWVyeShvYnNlcnZhYmxlUXVlcnkucXVlcnlJZCkubmV3RGF0YTtcbiAgICAgICAgaWYgKG5ld0RhdGEgJiYgbmV3RGF0YS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbmV3RGF0YS5yZXN1bHQsIHBhcnRpYWw6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnIHx8IGZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogdW5kZWZpbmVkLCBwYXJ0aWFsOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYiA9IHRoaXMuZGF0YVN0b3JlLmdldENhY2hlKCkuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0OiBsYXN0UmVzdWx0ID8gbGFzdFJlc3VsdC5kYXRhIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBvcHRpbWlzdGljLFxuICAgICAgICB9KSwgcmVzdWx0ID0gX2IucmVzdWx0LCBjb21wbGV0ZSA9IF9iLmNvbXBsZXRlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogKGNvbXBsZXRlIHx8IHJldHVyblBhcnRpYWxEYXRhKSA/IHJlc3VsdCA6IHZvaWQgMCxcbiAgICAgICAgICAgIHBhcnRpYWw6ICFjb21wbGV0ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0UXVlcnlXaXRoUHJldmlvdXNSZXN1bHQgPSBmdW5jdGlvbiAocXVlcnlJZE9yT2JzZXJ2YWJsZSkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5SWRPck9ic2VydmFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgZm91bmRPYnNlcnZlYWJsZVF1ZXJ5ID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkT3JPYnNlcnZhYmxlKS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZm91bmRPYnNlcnZlYWJsZVF1ZXJ5LCAxNykgOiBpbnZhcmlhbnQoZm91bmRPYnNlcnZlYWJsZVF1ZXJ5LCBcIk9ic2VydmFibGVRdWVyeSB3aXRoIHRoaXMgaWQgZG9lc24ndCBleGlzdDogXCIgKyBxdWVyeUlkT3JPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeSA9IGZvdW5kT2JzZXJ2ZWFibGVRdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeSA9IHF1ZXJ5SWRPck9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgcXVlcnkgPSBfYS5xdWVyeTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0OiB0aGlzLmdldEN1cnJlbnRRdWVyeVJlc3VsdChvYnNlcnZhYmxlUXVlcnksIGZhbHNlKS5kYXRhLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICBkb2N1bWVudDogcXVlcnksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmJyb2FkY2FzdFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub25Ccm9hZGNhc3QoKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8sIGlkKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgICAgIGluZm8ubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoX3RoaXMucXVlcnlTdG9yZS5nZXQoaWQpLCBpbmZvLm5ld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRMb2NhbFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRPYnNlcnZhYmxlRnJvbUxpbmsgPSBmdW5jdGlvbiAocXVlcnksIGNvbnRleHQsIHZhcmlhYmxlcywgZGVkdXBsaWNhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGVkdXBsaWNhdGlvbiA9PT0gdm9pZCAwKSB7IGRlZHVwbGljYXRpb24gPSB0aGlzLnF1ZXJ5RGVkdXBsaWNhdGlvbjsgfVxuICAgICAgICB2YXIgb2JzZXJ2YWJsZTtcbiAgICAgICAgdmFyIHNlcnZlclF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpLnNlcnZlclF1ZXJ5O1xuICAgICAgICBpZiAoc2VydmVyUXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEgPSBfYS5pbkZsaWdodExpbmtPYnNlcnZhYmxlcywgbGluayA9IF9hLmxpbms7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBzZXJ2ZXJRdWVyeSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBnZXRPcGVyYXRpb25OYW1lKHNlcnZlclF1ZXJ5KSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5wcmVwYXJlQ29udGV4dChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgZm9yY2VGZXRjaDogIWRlZHVwbGljYXRpb24gfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBvcGVyYXRpb24uY29udGV4dDtcbiAgICAgICAgICAgIGlmIChkZWR1cGxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5VmFyaWFibGVzXzEgPSBpbkZsaWdodExpbmtPYnNlcnZhYmxlc18xLmdldChzZXJ2ZXJRdWVyeSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEuc2V0KHNlcnZlclF1ZXJ5LCBieVZhcmlhYmxlc18xKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFySnNvbl8xID0gSlNPTi5zdHJpbmdpZnkodmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gYnlWYXJpYWJsZXNfMS5nZXQodmFySnNvbl8xKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnlWYXJpYWJsZXNfMS5zZXQodmFySnNvbl8xLCBvYnNlcnZhYmxlID0gbXVsdGlwbGV4KGV4ZWN1dGUobGluaywgb3BlcmF0aW9uKSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5VmFyaWFibGVzXzEuZGVsZXRlKHZhckpzb25fMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5VmFyaWFibGVzXzEuc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbkZsaWdodExpbmtPYnNlcnZhYmxlc18xLmRlbGV0ZShzZXJ2ZXJRdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3ViXzEudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsZWFudXBTdWJfMSA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IGNsZWFudXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY2xlYW51cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjbGVhbnVwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gbXVsdGlwbGV4KGV4ZWN1dGUobGluaywgb3BlcmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gT2JzZXJ2YWJsZS5vZih7IGRhdGE6IHt9IH0pO1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsaWVudFF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmNsaWVudFF1ZXJ5O1xuICAgICAgICBpZiAoY2xpZW50UXVlcnkpIHtcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSBhc3luY01hcChvYnNlcnZhYmxlLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmxvY2FsU3RhdGUucnVuUmVzb2x2ZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGNsaWVudFF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZmV0Y2hSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXF1ZXN0SWQgPSBfYS5yZXF1ZXN0SWQsIHF1ZXJ5SWQgPSBfYS5xdWVyeUlkLCBkb2N1bWVudCA9IF9hLmRvY3VtZW50LCBvcHRpb25zID0gX2Eub3B0aW9ucywgZmV0Y2hNb3JlRm9yUXVlcnlJZCA9IF9hLmZldGNoTW9yZUZvclF1ZXJ5SWQ7XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcywgX2IgPSBvcHRpb25zLmVycm9yUG9saWN5LCBlcnJvclBvbGljeSA9IF9iID09PSB2b2lkIDAgPyAnbm9uZScgOiBfYiwgZmV0Y2hQb2xpY3kgPSBvcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICB2YXIgcmVzdWx0RnJvbVN0b3JlO1xuICAgICAgICB2YXIgZXJyb3JzRnJvbVN0b3JlO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBfdGhpcy5nZXRPYnNlcnZhYmxlRnJvbUxpbmsoZG9jdW1lbnQsIG9wdGlvbnMuY29udGV4dCwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIHZhciBmcXJmSWQgPSBcImZldGNoUmVxdWVzdDpcIiArIHF1ZXJ5SWQ7XG4gICAgICAgICAgICBfdGhpcy5mZXRjaFF1ZXJ5UmVqZWN0Rm5zLnNldChmcXJmSWQsIHJlamVjdCk7XG4gICAgICAgICAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5mZXRjaFF1ZXJ5UmVqZWN0Rm5zLmRlbGV0ZShmcXJmSWQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IF9hLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdElkID49IF90aGlzLmdldFF1ZXJ5KHF1ZXJ5SWQpLmxhc3RSZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFya1F1ZXJ5UmVzdWx0KHF1ZXJ5SWQsIHJlc3VsdCwgb3B0aW9ucywgZmV0Y2hNb3JlRm9yUXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5U3RvcmUubWFya1F1ZXJ5UmVzdWx0KHF1ZXJ5SWQsIHJlc3VsdCwgZmV0Y2hNb3JlRm9yUXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUoZmV0Y2hNb3JlRm9yUXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSAnbm9uZScgJiYgaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnNGcm9tU3RvcmUgPSByZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hNb3JlRm9yUXVlcnlJZCB8fCBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRGcm9tU3RvcmUgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmRhdGFTdG9yZS5nZXRDYWNoZSgpLmRpZmYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVzdWx0XzEgPSBfYS5yZXN1bHQsIGNvbXBsZXRlID0gX2EuY29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSB8fCBvcHRpb25zLnJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGcm9tU3RvcmUgPSByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0RnJvbVN0b3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNGcm9tU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IE5ldHdvcmtTdGF0dXMucmVhZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gX2Euc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5xdWVyaWVzLmdldChxdWVyeUlkKSB8fCB7XG4gICAgICAgICAgICBsaXN0ZW5lcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGRvY3VtZW50OiBudWxsLFxuICAgICAgICAgICAgbmV3RGF0YTogbnVsbCxcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0SWQ6IDEsXG4gICAgICAgICAgICBvYnNlcnZhYmxlUXVlcnk6IG51bGwsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zOiBuZXcgU2V0KCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zZXRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkLCB1cGRhdGVyKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkKTtcbiAgICAgICAgdmFyIG5ld0luZm8gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHVwZGF0ZXIocHJldikpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuc2V0KHF1ZXJ5SWQsIG5ld0luZm8pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIGludmFsaWRhdGVkKSB7XG4gICAgICAgIGlmIChpbnZhbGlkYXRlZCA9PT0gdm9pZCAwKSB7IGludmFsaWRhdGVkID0gdHJ1ZTsgfVxuICAgICAgICBpZiAocXVlcnlJZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRRdWVyeShxdWVyeUlkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBpbnZhbGlkYXRlZDogaW52YWxpZGF0ZWQgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnByZXBhcmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmxvY2FsU3RhdGUucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbmV3Q29udGV4dCksIHsgY2xpZW50QXdhcmVuZXNzOiB0aGlzLmNsaWVudEF3YXJlbmVzcyB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuY2hlY2tJbkZsaWdodCA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnlTdG9yZS5nZXQocXVlcnlJZCk7XG4gICAgICAgIHJldHVybiAocXVlcnkgJiZcbiAgICAgICAgICAgIHF1ZXJ5Lm5ldHdvcmtTdGF0dXMgIT09IE5ldHdvcmtTdGF0dXMucmVhZHkgJiZcbiAgICAgICAgICAgIHF1ZXJ5Lm5ldHdvcmtTdGF0dXMgIT09IE5ldHdvcmtTdGF0dXMuZXJyb3IpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdGFydFBvbGxpbmdRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zLCBxdWVyeUlkLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcG9sbEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWw7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChwb2xsSW50ZXJ2YWwsIDE4KSA6IGludmFyaWFudChwb2xsSW50ZXJ2YWwsICdBdHRlbXB0ZWQgdG8gc3RhcnQgYSBwb2xsaW5nIHF1ZXJ5IHdpdGhvdXQgYSBwb2xsaW5nIGludGVydmFsLicpO1xuICAgICAgICBpZiAoIXRoaXMuc3NyTW9kZSkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLnBvbGxpbmdJbmZvQnlRdWVyeUlkLmdldChxdWVyeUlkKTtcbiAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbGluZ0luZm9CeVF1ZXJ5SWQuc2V0KHF1ZXJ5SWQsIChpbmZvID0ge30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZm8uaW50ZXJ2YWwgPSBwb2xsSW50ZXJ2YWw7XG4gICAgICAgICAgICBpbmZvLm9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6ICduZXR3b3JrLW9ubHknIH0pO1xuICAgICAgICAgICAgdmFyIG1heWJlRmV0Y2hfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IF90aGlzLnBvbGxpbmdJbmZvQnlRdWVyeUlkLmdldChxdWVyeUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2hlY2tJbkZsaWdodChxdWVyeUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9sbF8xKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5mZXRjaFF1ZXJ5KHF1ZXJ5SWQsIGluZm8ub3B0aW9ucywgRmV0Y2hUeXBlLnBvbGwpLnRoZW4ocG9sbF8xLCBwb2xsXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwb2xsXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBfdGhpcy5wb2xsaW5nSW5mb0J5UXVlcnlJZC5nZXQocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGluZm8udGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGluZm8udGltZW91dCA9IHNldFRpbWVvdXQobWF5YmVGZXRjaF8xLCBpbmZvLmludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRRdWVyeUxpc3RlbmVyKHF1ZXJ5SWQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvbGxfMSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeUlkO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUG9sbGluZ1F1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nSW5mb0J5UXVlcnlJZC5kZWxldGUocXVlcnlJZCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVlcnlNYW5hZ2VyO1xufSgpKTtcblxudmFyIERhdGFTdG9yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YVN0b3JlKGluaXRpYWxDYWNoZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gaW5pdGlhbENhY2hlO1xuICAgIH1cbiAgICBEYXRhU3RvcmUucHJvdG90eXBlLmdldENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCwgZG9jdW1lbnQsIHZhcmlhYmxlcywgZmV0Y2hNb3JlRm9yUXVlcnlJZCwgaWdub3JlRXJyb3JzKSB7XG4gICAgICAgIGlmIChpZ25vcmVFcnJvcnMgPT09IHZvaWQgMCkgeyBpZ25vcmVFcnJvcnMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgd3JpdGVXaXRoRXJyb3JzID0gIWdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpO1xuICAgICAgICBpZiAoaWdub3JlRXJyb3JzICYmIGdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICB3cml0ZVdpdGhFcnJvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmV0Y2hNb3JlRm9yUXVlcnlJZCAmJiB3cml0ZVdpdGhFcnJvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUud3JpdGUoe1xuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya1N1YnNjcmlwdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKCFncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS53cml0ZSh7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICBkYXRhSWQ6ICdST09UX1NVQlNDUklQVElPTicsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya011dGF0aW9uSW5pdCA9IGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobXV0YXRpb24ub3B0aW1pc3RpY1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW1pc3RpY18xO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtdXRhdGlvbi5vcHRpbWlzdGljUmVzcG9uc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljXzEgPSBtdXRhdGlvbi5vcHRpbWlzdGljUmVzcG9uc2UobXV0YXRpb24udmFyaWFibGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNfMSA9IG11dGF0aW9uLm9wdGltaXN0aWNSZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FjaGUucmVjb3JkT3B0aW1pc3RpY1RyYW5zYWN0aW9uKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBfdGhpcy5jYWNoZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWNoZSA9IGM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFya011dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQ6IG11dGF0aW9uLm11dGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHsgZGF0YTogb3B0aW1pc3RpY18xIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogbXV0YXRpb24uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJpZXM6IG11dGF0aW9uLnVwZGF0ZVF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IG11dGF0aW9uLnVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWNoZSA9IG9yaWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbXV0YXRpb24ubXV0YXRpb25JZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya011dGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKG11dGF0aW9uLnJlc3VsdCkpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZVdyaXRlc18xID0gW3tcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBtdXRhdGlvbi5yZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9NVVRBVElPTicsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBtdXRhdGlvbi5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBtdXRhdGlvbi52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVlcmllc18xID0gbXV0YXRpb24udXBkYXRlUXVlcmllcztcbiAgICAgICAgICAgIGlmICh1cGRhdGVRdWVyaWVzXzEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh1cGRhdGVRdWVyaWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHVwZGF0ZVF1ZXJpZXNfMVtpZF0sIHF1ZXJ5ID0gX2EucXVlcnksIHVwZGF0ZXIgPSBfYS51cGRhdGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5jYWNoZS5kaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeS5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcXVlcnkudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSksIGN1cnJlbnRRdWVyeVJlc3VsdCA9IF9iLnJlc3VsdCwgY29tcGxldGUgPSBfYi5jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFF1ZXJ5UmVzdWx0ID0gdHJ5RnVuY3Rpb25PckxvZ0Vycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlcihjdXJyZW50UXVlcnlSZXN1bHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25SZXN1bHQ6IG11dGF0aW9uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlOYW1lOiBnZXRPcGVyYXRpb25OYW1lKHF1ZXJ5LmRvY3VtZW50KSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UXVlcnlSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVdyaXRlc18xLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG5leHRRdWVyeVJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeS5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FjaGUucGVyZm9ybVRyYW5zYWN0aW9uKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVXcml0ZXNfMS5mb3JFYWNoKGZ1bmN0aW9uICh3cml0ZSkgeyByZXR1cm4gYy53cml0ZSh3cml0ZSk7IH0pO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBtdXRhdGlvbi51cGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnlGdW5jdGlvbk9yTG9nRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlKGMsIG11dGF0aW9uLnJlc3VsdCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhU3RvcmUucHJvdG90eXBlLm1hcmtNdXRhdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBtdXRhdGlvbklkID0gX2EubXV0YXRpb25JZCwgb3B0aW1pc3RpY1Jlc3BvbnNlID0gX2Eub3B0aW1pc3RpY1Jlc3BvbnNlO1xuICAgICAgICBpZiAob3B0aW1pc3RpY1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnJlbW92ZU9wdGltaXN0aWMobXV0YXRpb25JZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya1VwZGF0ZVF1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMsIG5ld1Jlc3VsdCkge1xuICAgICAgICB0aGlzLmNhY2hlLndyaXRlKHtcbiAgICAgICAgICAgIHJlc3VsdDogbmV3UmVzdWx0LFxuICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIHF1ZXJ5OiBkb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYXRhU3RvcmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5yZXNldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFTdG9yZTtcbn0oKSk7XG5cbnZhciB2ZXJzaW9uID0gXCIyLjYuMTBcIjtcblxudmFyIGhhc1N1Z2dlc3RlZERldnRvb2xzID0gZmFsc2U7XG52YXIgQXBvbGxvQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcG9sbG9DbGllbnQob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMucmVzZXRTdG9yZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIGNhY2hlID0gb3B0aW9ucy5jYWNoZSwgX2EgPSBvcHRpb25zLnNzck1vZGUsIHNzck1vZGUgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnNzckZvcmNlRmV0Y2hEZWxheSwgc3NyRm9yY2VGZXRjaERlbGF5ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgY29ubmVjdFRvRGV2VG9vbHMgPSBvcHRpb25zLmNvbm5lY3RUb0RldlRvb2xzLCBfYyA9IG9wdGlvbnMucXVlcnlEZWR1cGxpY2F0aW9uLCBxdWVyeURlZHVwbGljYXRpb24gPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsIF9kID0gb3B0aW9ucy5hc3N1bWVJbW11dGFibGVSZXN1bHRzLCBhc3N1bWVJbW11dGFibGVSZXN1bHRzID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIHJlc29sdmVycyA9IG9wdGlvbnMucmVzb2x2ZXJzLCB0eXBlRGVmcyA9IG9wdGlvbnMudHlwZURlZnMsIGZyYWdtZW50TWF0Y2hlciA9IG9wdGlvbnMuZnJhZ21lbnRNYXRjaGVyLCBjbGllbnRBd2FyZW5lc3NOYW1lID0gb3B0aW9ucy5uYW1lLCBjbGllbnRBd2FyZW5lc3NWZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgICAgICB2YXIgbGluayA9IG9wdGlvbnMubGluaztcbiAgICAgICAgaWYgKCFsaW5rICYmIHJlc29sdmVycykge1xuICAgICAgICAgICAgbGluayA9IEFwb2xsb0xpbmsuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmsgfHwgIWNhY2hlKSB7XG4gICAgICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoNCkgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJJbiBvcmRlciB0byBpbml0aWFsaXplIEFwb2xsbyBDbGllbnQsIHlvdSBtdXN0IHNwZWNpZnkgJ2xpbmsnIGFuZCAnY2FjaGUnIHByb3BlcnRpZXMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlRoZXNlIG9wdGlvbnMgYXJlIHBhcnQgb2YgdGhlIHVwZ3JhZGUgcmVxdWlyZW1lbnRzIHdoZW4gbWlncmF0aW5nIGZyb20gQXBvbGxvIENsaWVudCAxLnggdG8gQXBvbGxvIENsaWVudCAyLnguXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZSB2aXNpdDogaHR0cHM6Ly93d3cuYXBvbGxvZ3JhcGhxbC5jb20vZG9jcy90dXRvcmlhbC9jbGllbnQuaHRtbCNhcG9sbG8tY2xpZW50LXNldHVwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluayA9IGxpbms7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBEYXRhU3RvcmUoY2FjaGUpO1xuICAgICAgICB0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyA9IHNzck1vZGUgfHwgc3NyRm9yY2VGZXRjaERlbGF5ID4gMDtcbiAgICAgICAgdGhpcy5xdWVyeURlZHVwbGljYXRpb24gPSBxdWVyeURlZHVwbGljYXRpb247XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy50eXBlRGVmcyA9IHR5cGVEZWZzO1xuICAgICAgICBpZiAoc3NyRm9yY2VGZXRjaERlbGF5KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy5kaXNhYmxlTmV0d29ya0ZldGNoZXMgPSBmYWxzZSk7IH0sIHNzckZvcmNlRmV0Y2hEZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaFF1ZXJ5ID0gdGhpcy53YXRjaFF1ZXJ5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubXV0YXRlID0gdGhpcy5tdXRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNldFN0b3JlID0gdGhpcy5yZXNldFN0b3JlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVGZXRjaE9ic2VydmFibGVRdWVyaWVzID0gdGhpcy5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGRlZmF1bHRDb25uZWN0VG9EZXZUb29scyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAhd2luZG93Ll9fQVBPTExPX0NMSUVOVF9fO1xuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3RUb0RldlRvb2xzID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkZWZhdWx0Q29ubmVjdFRvRGV2VG9vbHNcbiAgICAgICAgICAgIDogY29ubmVjdFRvRGV2VG9vbHMgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5fX0FQT0xMT19DTElFTlRfXyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNTdWdnZXN0ZWREZXZ0b29scyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBoYXNTdWdnZXN0ZWREZXZ0b29scyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Ll9fQVBPTExPX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIEFwb2xsbyBEZXZUb29scyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC9hcG9sbG8tY2xpZW50LWRldmVsb3Blci10L2pka2tua2tiZWJiYXBpbGdvZWNjY2lnbGtmYm1ibmZtJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsU3RhdGUoe1xuICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLFxuICAgICAgICAgICAgcmVzb2x2ZXJzOiByZXNvbHZlcnMsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyID0gbmV3IFF1ZXJ5TWFuYWdlcih7XG4gICAgICAgICAgICBsaW5rOiB0aGlzLmxpbmssXG4gICAgICAgICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgICAgICAgIHF1ZXJ5RGVkdXBsaWNhdGlvbjogcXVlcnlEZWR1cGxpY2F0aW9uLFxuICAgICAgICAgICAgc3NyTW9kZTogc3NyTW9kZSxcbiAgICAgICAgICAgIGNsaWVudEF3YXJlbmVzczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IGNsaWVudEF3YXJlbmVzc05hbWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogY2xpZW50QXdhcmVuZXNzVmVyc2lvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2NhbFN0YXRlOiB0aGlzLmxvY2FsU3RhdGUsXG4gICAgICAgICAgICBhc3N1bWVJbW11dGFibGVSZXN1bHRzOiBhc3N1bWVJbW11dGFibGVSZXN1bHRzLFxuICAgICAgICAgICAgb25Ccm9hZGNhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGV2VG9vbHNIb29rQ2IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV2VG9vbHNIb29rQ2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllczogX3RoaXMucXVlcnlNYW5hZ2VyLnF1ZXJ5U3RvcmUuZ2V0U3RvcmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbnM6IF90aGlzLnF1ZXJ5TWFuYWdlci5tdXRhdGlvblN0b3JlLmdldFN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVdpdGhPcHRpbWlzdGljUmVzdWx0czogX3RoaXMuY2FjaGUuZXh0cmFjdCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuc3RvcCgpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS53YXRjaFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMud2F0Y2hRdWVyeSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnkpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlTmV0d29ya0ZldGNoZXMgJiZcbiAgICAgICAgICAgIChvcHRpb25zLmZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yaycpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZldGNoUG9saWN5OiAnY2FjaGUtZmlyc3QnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci53YXRjaFF1ZXJ5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRPcHRpb25zLnF1ZXJ5KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcnkpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ2NhY2hlLWFuZC1uZXR3b3JrJywgNSkgOiBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ2NhY2hlLWFuZC1uZXR3b3JrJywgJ1RoZSBjYWNoZS1hbmQtbmV0d29yayBmZXRjaFBvbGljeSBkb2VzIG5vdCB3b3JrIHdpdGggY2xpZW50LnF1ZXJ5LCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgJ2NsaWVudC5xdWVyeSBjYW4gb25seSByZXR1cm4gYSBzaW5nbGUgcmVzdWx0LiBQbGVhc2UgdXNlIGNsaWVudC53YXRjaFF1ZXJ5ICcgK1xuICAgICAgICAgICAgJ3RvIHJlY2VpdmUgbXVsdGlwbGUgcmVzdWx0cyBmcm9tIHRoZSBjYWNoZSBhbmQgdGhlIG5ldHdvcmssIG9yIGNvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3VzaW5nIGEgZGlmZmVyZW50IGZldGNoUG9saWN5LCBzdWNoIGFzIGNhY2hlLWZpcnN0IG9yIG5ldHdvcmstb25seS4nKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZU5ldHdvcmtGZXRjaGVzICYmIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZldGNoUG9saWN5OiAnY2FjaGUtZmlyc3QnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5xdWVyeShvcHRpb25zKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMubXV0YXRlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMubXV0YXRlKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLm11dGF0ZShvcHRpb25zKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLnN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbihvcHRpb25zKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVhZFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVhZFF1ZXJ5KG9wdGlvbnMsIG9wdGltaXN0aWMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZWFkRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5yZWFkRnJhZ21lbnQob3B0aW9ucywgb3B0aW1pc3RpYyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWNoZS53cml0ZVF1ZXJ5KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWNoZS53cml0ZUZyYWdtZW50KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlRGF0YSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNhY2hlLndyaXRlRGF0YShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5fX2FjdGlvbkhvb2tGb3JEZXZUb29scyA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0aGlzLmRldlRvb2xzSG9va0NiID0gY2I7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLl9fcmVxdWVzdFJhdyA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlKHRoaXMubGluaywgcGF5bG9hZCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLmluaXRRdWVyeU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybignQ2FsbGluZyB0aGUgaW5pdFF1ZXJ5TWFuYWdlciBtZXRob2QgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSwgJyArXG4gICAgICAgICAgICAnYW5kIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIEFwb2xsb0NsaWVudCBpbiB2ZXJzaW9uIDMuMC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZXNldFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnF1ZXJ5TWFuYWdlci5jbGVhclN0b3JlKCk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcygpOyB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuY2xlYXJTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5xdWVyeU1hbmFnZXIuY2xlYXJTdG9yZSgpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5hbGwoX3RoaXMuY2xlYXJTdG9yZUNhbGxiYWNrcy5tYXAoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KSk7IH0pO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5vblJlc2V0U3RvcmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRTdG9yZUNhbGxiYWNrcyA9IF90aGlzLnJlc2V0U3RvcmVDYWxsYmFja3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9PSBjYjsgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLm9uQ2xlYXJTdG9yZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhclN0b3JlQ2FsbGJhY2tzID0gX3RoaXMuY2xlYXJTdG9yZUNhbGxiYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT09IGNiOyB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVGZXRjaE9ic2VydmFibGVRdWVyaWVzID0gZnVuY3Rpb24gKGluY2x1ZGVTdGFuZGJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMoaW5jbHVkZVN0YW5kYnkpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG9wdGltaXN0aWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZXh0cmFjdChvcHRpbWlzdGljKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVzdG9yZShzZXJpYWxpemVkU3RhdGUpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5hZGRSZXNvbHZlcnMgPSBmdW5jdGlvbiAocmVzb2x2ZXJzKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZS5hZGRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuc2V0UmVzb2x2ZXJzKHJlc29sdmVycyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLmdldFJlc29sdmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdGF0ZS5nZXRSZXNvbHZlcnMoKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc2V0TG9jYWxTdGF0ZUZyYWdtZW50TWF0Y2hlciA9IGZ1bmN0aW9uIChmcmFnbWVudE1hdGNoZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnNldEZyYWdtZW50TWF0Y2hlcihmcmFnbWVudE1hdGNoZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEFwb2xsb0NsaWVudDtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwb2xsb0NsaWVudDtcbmV4cG9ydCB7IEFwb2xsb0NsaWVudCwgQXBvbGxvRXJyb3IsIEZldGNoVHlwZSwgTmV0d29ya1N0YXR1cywgT2JzZXJ2YWJsZVF1ZXJ5LCBpc0Fwb2xsb0Vycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgQXBvbGxvTGluaywgT2JzZXJ2YWJsZSB9IGZyb20gJ2Fwb2xsby1saW5rJztcblxuZnVuY3Rpb24gc2V0Q29udGV4dChzZXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IEFwb2xsb0xpbmsoZnVuY3Rpb24gKG9wZXJhdGlvbiwgZm9yd2FyZCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IF9fcmVzdChvcGVyYXRpb24sIFtdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZTtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShyZXF1ZXN0KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIHNldHRlcihyZXEsIG9wZXJhdGlvbi5nZXRDb250ZXh0KCkpOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKG9wZXJhdGlvbi5zZXRDb250ZXh0KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBmb3J3YXJkKG9wZXJhdGlvbikuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIpLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogb2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlciksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHNldENvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHByaW50IH0gZnJvbSAnZ3JhcGhxbC9sYW5ndWFnZS9wcmludGVyJztcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAndHMtaW52YXJpYW50JztcblxudmFyIGRlZmF1bHRIdHRwT3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlUXVlcnk6IHRydWUsXG4gICAgaW5jbHVkZUV4dGVuc2lvbnM6IGZhbHNlLFxufTtcbnZhciBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBhY2NlcHQ6ICcqLyonLFxuICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG59O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxufTtcbnZhciBmYWxsYmFja0h0dHBDb25maWcgPSB7XG4gICAgaHR0cDogZGVmYXVsdEh0dHBPcHRpb25zLFxuICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzLFxuICAgIG9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxufTtcbnZhciB0aHJvd1NlcnZlckVycm9yID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByZXN1bHQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IubmFtZSA9ICdTZXJ2ZXJFcnJvcic7XG4gICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGVycm9yLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aHJvdyBlcnJvcjtcbn07XG52YXIgcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZSA9IGZ1bmN0aW9uIChvcGVyYXRpb25zKSB7IHJldHVybiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKHJlc3BvbnNlXG4gICAgICAgIC50ZXh0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHlUZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFyIHBhcnNlRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICBwYXJzZUVycm9yLm5hbWUgPSAnU2VydmVyUGFyc2VFcnJvcic7XG4gICAgICAgICAgICBwYXJzZUVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBwYXJzZUVycm9yLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICBwYXJzZUVycm9yLmJvZHlUZXh0ID0gYm9keVRleHQ7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocGFyc2VFcnJvcik7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICAgICAgICB0aHJvd1NlcnZlckVycm9yKHJlc3BvbnNlLCByZXN1bHQsIFwiUmVzcG9uc2Ugbm90IHN1Y2Nlc3NmdWw6IFJlY2VpdmVkIHN0YXR1cyBjb2RlIFwiICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSAmJlxuICAgICAgICAgICAgIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpICYmXG4gICAgICAgICAgICAhcmVzdWx0Lmhhc093blByb3BlcnR5KCdlcnJvcnMnKSkge1xuICAgICAgICAgICAgdGhyb3dTZXJ2ZXJFcnJvcihyZXNwb25zZSwgcmVzdWx0LCBcIlNlcnZlciByZXNwb25zZSB3YXMgbWlzc2luZyBmb3IgcXVlcnkgJ1wiICsgKEFycmF5LmlzQXJyYXkob3BlcmF0aW9ucylcbiAgICAgICAgICAgICAgICA/IG9wZXJhdGlvbnMubWFwKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3Aub3BlcmF0aW9uTmFtZTsgfSlcbiAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbnMub3BlcmF0aW9uTmFtZSkgKyBcIicuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xufTsgfTtcbnZhciBjaGVja0ZldGNoZXIgPSBmdW5jdGlvbiAoZmV0Y2hlcikge1xuICAgIGlmICghZmV0Y2hlciAmJiB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBsaWJyYXJ5ID0gJ3VuZmV0Y2gnO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBsaWJyYXJ5ID0gJ25vZGUtZmV0Y2gnO1xuICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMSkgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJcXG5mZXRjaCBpcyBub3QgZm91bmQgZ2xvYmFsbHkgYW5kIG5vIGZldGNoZXIgcGFzc2VkLCB0byBmaXggcGFzcyBhIGZldGNoIGZvclxcbnlvdXIgZW52aXJvbm1lbnQgbGlrZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9cIiArIGxpYnJhcnkgKyBcIi5cXG5cXG5Gb3IgZXhhbXBsZTpcXG5pbXBvcnQgZmV0Y2ggZnJvbSAnXCIgKyBsaWJyYXJ5ICsgXCInO1xcbmltcG9ydCB7IGNyZWF0ZUh0dHBMaW5rIH0gZnJvbSAnYXBvbGxvLWxpbmstaHR0cCc7XFxuXFxuY29uc3QgbGluayA9IGNyZWF0ZUh0dHBMaW5rKHsgdXJpOiAnL2dyYXBocWwnLCBmZXRjaDogZmV0Y2ggfSk7XCIpO1xuICAgIH1cbn07XG52YXIgY3JlYXRlU2lnbmFsSWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4geyBjb250cm9sbGVyOiBmYWxzZSwgc2lnbmFsOiBmYWxzZSB9O1xuICAgIHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHZhciBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICByZXR1cm4geyBjb250cm9sbGVyOiBjb250cm9sbGVyLCBzaWduYWw6IHNpZ25hbCB9O1xufTtcbnZhciBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHkgPSBmdW5jdGlvbiAob3BlcmF0aW9uLCBmYWxsYmFja0NvbmZpZykge1xuICAgIHZhciBjb25maWdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY29uZmlnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgZmFsbGJhY2tDb25maWcub3B0aW9ucywgeyBoZWFkZXJzOiBmYWxsYmFja0NvbmZpZy5oZWFkZXJzLCBjcmVkZW50aWFsczogZmFsbGJhY2tDb25maWcuY3JlZGVudGlhbHMgfSk7XG4gICAgdmFyIGh0dHAgPSBmYWxsYmFja0NvbmZpZy5odHRwO1xuICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucywgY29uZmlnLm9wdGlvbnMsIHsgaGVhZGVyczogX19hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywgY29uZmlnLmhlYWRlcnMpIH0pO1xuICAgICAgICBpZiAoY29uZmlnLmNyZWRlbnRpYWxzKVxuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9IGNvbmZpZy5jcmVkZW50aWFscztcbiAgICAgICAgaHR0cCA9IF9fYXNzaWduKHt9LCBodHRwLCBjb25maWcuaHR0cCk7XG4gICAgfSk7XG4gICAgdmFyIG9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb24ub3BlcmF0aW9uTmFtZSwgZXh0ZW5zaW9ucyA9IG9wZXJhdGlvbi5leHRlbnNpb25zLCB2YXJpYWJsZXMgPSBvcGVyYXRpb24udmFyaWFibGVzLCBxdWVyeSA9IG9wZXJhdGlvbi5xdWVyeTtcbiAgICB2YXIgYm9keSA9IHsgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uTmFtZSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfTtcbiAgICBpZiAoaHR0cC5pbmNsdWRlRXh0ZW5zaW9ucylcbiAgICAgICAgYm9keS5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICBpZiAoaHR0cC5pbmNsdWRlUXVlcnkpXG4gICAgICAgIGJvZHkucXVlcnkgPSBwcmludChxdWVyeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgYm9keTogYm9keSxcbiAgICB9O1xufTtcbnZhciBzZXJpYWxpemVGZXRjaFBhcmFtZXRlciA9IGZ1bmN0aW9uIChwLCBsYWJlbCkge1xuICAgIHZhciBzZXJpYWxpemVkO1xuICAgIHRyeSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIHBhcnNlRXJyb3IgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMikgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkLiBcIiArIGxhYmVsICsgXCIgaXMgbm90IHNlcmlhbGl6YWJsZTogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICBwYXJzZUVycm9yLnBhcnNlRXJyb3IgPSBlO1xuICAgICAgICB0aHJvdyBwYXJzZUVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG52YXIgc2VsZWN0VVJJID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgZmFsbGJhY2tVUkkpIHtcbiAgICB2YXIgY29udGV4dCA9IG9wZXJhdGlvbi5nZXRDb250ZXh0KCk7XG4gICAgdmFyIGNvbnRleHRVUkkgPSBjb250ZXh0LnVyaTtcbiAgICBpZiAoY29udGV4dFVSSSkge1xuICAgICAgICByZXR1cm4gY29udGV4dFVSSTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrVVJJID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1VSSShvcGVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVVJJIHx8ICcvZ3JhcGhxbCc7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgY2hlY2tGZXRjaGVyLCBjcmVhdGVTaWduYWxJZlN1cHBvcnRlZCwgZmFsbGJhY2tIdHRwQ29uZmlnLCBwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlLCBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHksIHNlbGVjdFVSSSwgc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIsIHRocm93U2VydmVyRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBBcG9sbG9MaW5rLCBmcm9tRXJyb3IsIE9ic2VydmFibGUgfSBmcm9tICdhcG9sbG8tbGluayc7XG5pbXBvcnQgeyBjaGVja0ZldGNoZXIsIHNlbGVjdFVSSSwgc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5LCBmYWxsYmFja0h0dHBDb25maWcsIGNyZWF0ZVNpZ25hbElmU3VwcG9ydGVkLCBzZXJpYWxpemVGZXRjaFBhcmFtZXRlciwgcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZSB9IGZyb20gJ2Fwb2xsby1saW5rLWh0dHAtY29tbW9uJztcblxudmFyIGNyZWF0ZUh0dHBMaW5rID0gZnVuY3Rpb24gKGxpbmtPcHRpb25zKSB7XG4gICAgaWYgKGxpbmtPcHRpb25zID09PSB2b2lkIDApIHsgbGlua09wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IGxpbmtPcHRpb25zLnVyaSwgdXJpID0gX2EgPT09IHZvaWQgMCA/ICcvZ3JhcGhxbCcgOiBfYSwgZmV0Y2hlciA9IGxpbmtPcHRpb25zLmZldGNoLCBpbmNsdWRlRXh0ZW5zaW9ucyA9IGxpbmtPcHRpb25zLmluY2x1ZGVFeHRlbnNpb25zLCB1c2VHRVRGb3JRdWVyaWVzID0gbGlua09wdGlvbnMudXNlR0VURm9yUXVlcmllcywgcmVxdWVzdE9wdGlvbnMgPSBfX3Jlc3QobGlua09wdGlvbnMsIFtcInVyaVwiLCBcImZldGNoXCIsIFwiaW5jbHVkZUV4dGVuc2lvbnNcIiwgXCJ1c2VHRVRGb3JRdWVyaWVzXCJdKTtcbiAgICBjaGVja0ZldGNoZXIoZmV0Y2hlcik7XG4gICAgaWYgKCFmZXRjaGVyKSB7XG4gICAgICAgIGZldGNoZXIgPSBmZXRjaDtcbiAgICB9XG4gICAgdmFyIGxpbmtDb25maWcgPSB7XG4gICAgICAgIGh0dHA6IHsgaW5jbHVkZUV4dGVuc2lvbnM6IGluY2x1ZGVFeHRlbnNpb25zIH0sXG4gICAgICAgIG9wdGlvbnM6IHJlcXVlc3RPcHRpb25zLmZldGNoT3B0aW9ucyxcbiAgICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3RPcHRpb25zLmNyZWRlbnRpYWxzLFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgdmFyIGNob3NlblVSSSA9IHNlbGVjdFVSSShvcGVyYXRpb24sIHVyaSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gb3BlcmF0aW9uLmdldENvbnRleHQoKTtcbiAgICAgICAgdmFyIGNsaWVudEF3YXJlbmVzc0hlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKGNvbnRleHQuY2xpZW50QXdhcmVuZXNzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb250ZXh0LmNsaWVudEF3YXJlbmVzcywgbmFtZV8xID0gX2EubmFtZSwgdmVyc2lvbiA9IF9hLnZlcnNpb247XG4gICAgICAgICAgICBpZiAobmFtZV8xKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50QXdhcmVuZXNzSGVhZGVyc1snYXBvbGxvZ3JhcGhxbC1jbGllbnQtbmFtZSddID0gbmFtZV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRBd2FyZW5lc3NIZWFkZXJzWydhcG9sbG9ncmFwaHFsLWNsaWVudC12ZXJzaW9uJ10gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0SGVhZGVycyA9IF9fYXNzaWduKHt9LCBjbGllbnRBd2FyZW5lc3NIZWFkZXJzLCBjb250ZXh0LmhlYWRlcnMpO1xuICAgICAgICB2YXIgY29udGV4dENvbmZpZyA9IHtcbiAgICAgICAgICAgIGh0dHA6IGNvbnRleHQuaHR0cCxcbiAgICAgICAgICAgIG9wdGlvbnM6IGNvbnRleHQuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IGNvbnRleHQuY3JlZGVudGlhbHMsXG4gICAgICAgICAgICBoZWFkZXJzOiBjb250ZXh0SGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9iID0gc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5KG9wZXJhdGlvbiwgZmFsbGJhY2tIdHRwQ29uZmlnLCBsaW5rQ29uZmlnLCBjb250ZXh0Q29uZmlnKSwgb3B0aW9ucyA9IF9iLm9wdGlvbnMsIGJvZHkgPSBfYi5ib2R5O1xuICAgICAgICB2YXIgY29udHJvbGxlcjtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgdmFyIF9jID0gY3JlYXRlU2lnbmFsSWZTdXBwb3J0ZWQoKSwgX2NvbnRyb2xsZXIgPSBfYy5jb250cm9sbGVyLCBzaWduYWwgPSBfYy5zaWduYWw7XG4gICAgICAgICAgICBjb250cm9sbGVyID0gX2NvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlcilcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmaW5pdGlvbklzTXV0YXRpb24gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nICYmIGQub3BlcmF0aW9uID09PSAnbXV0YXRpb24nO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodXNlR0VURm9yUXVlcmllcyAmJlxuICAgICAgICAgICAgIW9wZXJhdGlvbi5xdWVyeS5kZWZpbml0aW9ucy5zb21lKGRlZmluaXRpb25Jc011dGF0aW9uKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICB2YXIgX2QgPSByZXdyaXRlVVJJRm9yR0VUKGNob3NlblVSSSwgYm9keSksIG5ld1VSSSA9IF9kLm5ld1VSSSwgcGFyc2VFcnJvciA9IF9kLnBhcnNlRXJyb3I7XG4gICAgICAgICAgICBpZiAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRXJyb3IocGFyc2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaG9zZW5VUkkgPSBuZXdVUkk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyKGJvZHksICdQYXlsb2FkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRXJyb3IocGFyc2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgZmV0Y2hlcihjaG9zZW5VUkksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnNldENvbnRleHQoeyByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlKG9wZXJhdGlvbikpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLnJlc3VsdCAmJiBlcnIucmVzdWx0LmVycm9ycyAmJiBlcnIucmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChlcnIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gcmV3cml0ZVVSSUZvckdFVChjaG9zZW5VUkksIGJvZHkpIHtcbiAgICB2YXIgcXVlcnlQYXJhbXMgPSBbXTtcbiAgICB2YXIgYWRkUXVlcnlQYXJhbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLnB1c2goa2V5ICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICB9O1xuICAgIGlmICgncXVlcnknIGluIGJvZHkpIHtcbiAgICAgICAgYWRkUXVlcnlQYXJhbSgncXVlcnknLCBib2R5LnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGJvZHkub3BlcmF0aW9uTmFtZSkge1xuICAgICAgICBhZGRRdWVyeVBhcmFtKCdvcGVyYXRpb25OYW1lJywgYm9keS5vcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgaWYgKGJvZHkudmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkVmFyaWFibGVzID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZFZhcmlhYmxlcyA9IHNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyKGJvZHkudmFyaWFibGVzLCAnVmFyaWFibGVzIG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJzZUVycm9yOiBwYXJzZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRkUXVlcnlQYXJhbSgndmFyaWFibGVzJywgc2VyaWFsaXplZFZhcmlhYmxlcyk7XG4gICAgfVxuICAgIGlmIChib2R5LmV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRFeHRlbnNpb25zID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZEV4dGVuc2lvbnMgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcihib2R5LmV4dGVuc2lvbnMsICdFeHRlbnNpb25zIG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJzZUVycm9yOiBwYXJzZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRkUXVlcnlQYXJhbSgnZXh0ZW5zaW9ucycsIHNlcmlhbGl6ZWRFeHRlbnNpb25zKTtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50ID0gJycsIHByZUZyYWdtZW50ID0gY2hvc2VuVVJJO1xuICAgIHZhciBmcmFnbWVudFN0YXJ0ID0gY2hvc2VuVVJJLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoZnJhZ21lbnRTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgZnJhZ21lbnQgPSBjaG9zZW5VUkkuc3Vic3RyKGZyYWdtZW50U3RhcnQpO1xuICAgICAgICBwcmVGcmFnbWVudCA9IGNob3NlblVSSS5zdWJzdHIoMCwgZnJhZ21lbnRTdGFydCk7XG4gICAgfVxuICAgIHZhciBxdWVyeVBhcmFtc1ByZWZpeCA9IHByZUZyYWdtZW50LmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJic7XG4gICAgdmFyIG5ld1VSSSA9IHByZUZyYWdtZW50ICsgcXVlcnlQYXJhbXNQcmVmaXggKyBxdWVyeVBhcmFtcy5qb2luKCcmJykgKyBmcmFnbWVudDtcbiAgICByZXR1cm4geyBuZXdVUkk6IG5ld1VSSSB9O1xufVxudmFyIEh0dHBMaW5rID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHR0cExpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHR0cExpbmsob3B0cykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY3JlYXRlSHR0cExpbmsob3B0cykucmVxdWVzdCkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBMaW5rO1xufShBcG9sbG9MaW5rKSk7XG5cbmV4cG9ydCB7IEh0dHBMaW5rLCBjcmVhdGVIdHRwTGluayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEFwb2xsb0xpbmsgfSBmcm9tICdhcG9sbG8tbGluayc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25DbGllbnQgfSBmcm9tICdzdWJzY3JpcHRpb25zLXRyYW5zcG9ydC13cyc7XG5cbnZhciBXZWJTb2NrZXRMaW5rID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2ViU29ja2V0TGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRMaW5rKHBhcmFtc09yQ2xpZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChwYXJhbXNPckNsaWVudCBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbkNsaWVudCkge1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uQ2xpZW50ID0gcGFyYW1zT3JDbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25DbGllbnQgPSBuZXcgU3Vic2NyaXB0aW9uQ2xpZW50KHBhcmFtc09yQ2xpZW50LnVyaSwgcGFyYW1zT3JDbGllbnQub3B0aW9ucywgcGFyYW1zT3JDbGllbnQud2ViU29ja2V0SW1wbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXZWJTb2NrZXRMaW5rLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25DbGllbnQucmVxdWVzdChvcGVyYXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYlNvY2tldExpbms7XG59KEFwb2xsb0xpbmspKTtcblxuZXhwb3J0IHsgV2ViU29ja2V0TGluayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmVzbS5qcy5tYXBcbiIsImltcG9ydCBPYnNlcnZhYmxlIGZyb20gJ3plbi1vYnNlcnZhYmxlLXRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT2JzZXJ2YWJsZSB9IGZyb20gJ3plbi1vYnNlcnZhYmxlLXRzJztcbmltcG9ydCB7IGludmFyaWFudCwgSW52YXJpYW50RXJyb3IgfSBmcm9tICd0cy1pbnZhcmlhbnQnO1xuaW1wb3J0IHsgX19leHRlbmRzLCBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGdldE9wZXJhdGlvbk5hbWUgfSBmcm9tICdhcG9sbG8tdXRpbGl0aWVzJztcbmV4cG9ydCB7IGdldE9wZXJhdGlvbk5hbWUgfSBmcm9tICdhcG9sbG8tdXRpbGl0aWVzJztcblxuZnVuY3Rpb24gdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgdmFyIE9QRVJBVElPTl9GSUVMRFMgPSBbXG4gICAgICAgICdxdWVyeScsXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICAgICAgJ3ZhcmlhYmxlcycsXG4gICAgICAgICdleHRlbnNpb25zJyxcbiAgICAgICAgJ2NvbnRleHQnLFxuICAgIF07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG9wZXJhdGlvbik7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgIGlmIChPUEVSQVRJT05fRklFTERTLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcigyKSA6IG5ldyBJbnZhcmlhbnRFcnJvcihcImlsbGVnYWwgYXJndW1lbnQ6IFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uO1xufVxudmFyIExpbmtFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmtFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rRXJyb3IobWVzc2FnZSwgbGluaykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlua0Vycm9yO1xufShFcnJvcikpO1xuZnVuY3Rpb24gaXNUZXJtaW5hdGluZyhsaW5rKSB7XG4gICAgcmV0dXJuIGxpbmsucmVxdWVzdC5sZW5ndGggPD0gMTtcbn1cbmZ1bmN0aW9uIHRvUHJvbWlzZShvYnNlcnZhYmxlKSB7XG4gICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oXCJQcm9taXNlIFdyYXBwZXIgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSByZXN1bHRzIGZyb20gT2JzZXJ2YWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxudmFyIG1ha2VQcm9taXNlID0gdG9Qcm9taXNlO1xuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gob2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlcikpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZnJvbUVycm9yKGVycm9yVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yVmFsdWUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgIHZhciB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9IHtcbiAgICAgICAgdmFyaWFibGVzOiBvcGVyYXRpb24udmFyaWFibGVzIHx8IHt9LFxuICAgICAgICBleHRlbnNpb25zOiBvcGVyYXRpb24uZXh0ZW5zaW9ucyB8fCB7fSxcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUsXG4gICAgICAgIHF1ZXJ5OiBvcGVyYXRpb24ucXVlcnksXG4gICAgfTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkT3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb24ub3BlcmF0aW9uTmFtZSA9XG4gICAgICAgICAgICB0eXBlb2YgdHJhbnNmb3JtZWRPcGVyYXRpb24ucXVlcnkgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBnZXRPcGVyYXRpb25OYW1lKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnF1ZXJ5KVxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9wZXJhdGlvbihzdGFydGluZywgb3BlcmF0aW9uKSB7XG4gICAgdmFyIGNvbnRleHQgPSBfX2Fzc2lnbih7fSwgc3RhcnRpbmcpO1xuICAgIHZhciBzZXRDb250ZXh0ID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gX19hc3NpZ24oe30sIGNvbnRleHQsIG5leHQoY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dCA9IF9fYXNzaWduKHt9LCBjb250ZXh0LCBuZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oe30sIGNvbnRleHQpKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3BlcmF0aW9uLCAnc2V0Q29udGV4dCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZXRDb250ZXh0LFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcGVyYXRpb24sICdnZXRDb250ZXh0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGdldENvbnRleHQsXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wZXJhdGlvbiwgJ3RvS2V5Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEtleShvcGVyYXRpb24pOyB9LFxuICAgIH0pO1xuICAgIHJldHVybiBvcGVyYXRpb247XG59XG5mdW5jdGlvbiBnZXRLZXkob3BlcmF0aW9uKSB7XG4gICAgdmFyIHF1ZXJ5ID0gb3BlcmF0aW9uLnF1ZXJ5LCB2YXJpYWJsZXMgPSBvcGVyYXRpb24udmFyaWFibGVzLCBvcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uLm9wZXJhdGlvbk5hbWU7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtvcGVyYXRpb25OYW1lLCBxdWVyeSwgdmFyaWFibGVzXSk7XG59XG5cbmZ1bmN0aW9uIHBhc3N0aHJvdWdoKG9wLCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGZvcndhcmQgPyBmb3J3YXJkKG9wKSA6IE9ic2VydmFibGUub2YoKTtcbn1cbmZ1bmN0aW9uIHRvTGluayhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nID8gbmV3IEFwb2xsb0xpbmsoaGFuZGxlcikgOiBoYW5kbGVyO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9ic2VydmFibGUub2YoKTsgfSk7XG59XG5mdW5jdGlvbiBmcm9tKGxpbmtzKSB7XG4gICAgaWYgKGxpbmtzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgcmV0dXJuIGxpbmtzLm1hcCh0b0xpbmspLnJlZHVjZShmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geC5jb25jYXQoeSk7IH0pO1xufVxuZnVuY3Rpb24gc3BsaXQodGVzdCwgbGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgbGVmdExpbmsgPSB0b0xpbmsobGVmdCk7XG4gICAgdmFyIHJpZ2h0TGluayA9IHRvTGluayhyaWdodCB8fCBuZXcgQXBvbGxvTGluayhwYXNzdGhyb3VnaCkpO1xuICAgIGlmIChpc1Rlcm1pbmF0aW5nKGxlZnRMaW5rKSAmJiBpc1Rlcm1pbmF0aW5nKHJpZ2h0TGluaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0KG9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICA/IGxlZnRMaW5rLnJlcXVlc3Qob3BlcmF0aW9uKSB8fCBPYnNlcnZhYmxlLm9mKClcbiAgICAgICAgICAgICAgICA6IHJpZ2h0TGluay5yZXF1ZXN0KG9wZXJhdGlvbikgfHwgT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdChvcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgPyBsZWZ0TGluay5yZXF1ZXN0KG9wZXJhdGlvbiwgZm9yd2FyZCkgfHwgT2JzZXJ2YWJsZS5vZigpXG4gICAgICAgICAgICAgICAgOiByaWdodExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZvcndhcmQpIHx8IE9ic2VydmFibGUub2YoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxudmFyIGNvbmNhdCA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgdmFyIGZpcnN0TGluayA9IHRvTGluayhmaXJzdCk7XG4gICAgaWYgKGlzVGVybWluYXRpbmcoZmlyc3RMaW5rKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4obmV3IExpbmtFcnJvcihcIllvdSBhcmUgY2FsbGluZyBjb25jYXQgb24gYSB0ZXJtaW5hdGluZyBsaW5rLCB3aGljaCB3aWxsIGhhdmUgbm8gZWZmZWN0XCIsIGZpcnN0TGluaykpO1xuICAgICAgICByZXR1cm4gZmlyc3RMaW5rO1xuICAgIH1cbiAgICB2YXIgbmV4dExpbmsgPSB0b0xpbmsoc2Vjb25kKTtcbiAgICBpZiAoaXNUZXJtaW5hdGluZyhuZXh0TGluaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gbmV4dExpbmsucmVxdWVzdChvcCkgfHwgT2JzZXJ2YWJsZS5vZigpOyB9KSB8fCBPYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24sIGZvcndhcmQpIHtcbiAgICAgICAgICAgIHJldHVybiAoZmlyc3RMaW5rLnJlcXVlc3Qob3BlcmF0aW9uLCBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dExpbmsucmVxdWVzdChvcCwgZm9yd2FyZCkgfHwgT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICAgICAgfSkgfHwgT2JzZXJ2YWJsZS5vZigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBBcG9sbG9MaW5rID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcG9sbG9MaW5rKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH1cbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICh0ZXN0LCBsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoc3BsaXQodGVzdCwgbGVmdCwgcmlnaHQgfHwgbmV3IEFwb2xsb0xpbmsocGFzc3Rocm91Z2gpKSk7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMsIG5leHQpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIGZvcndhcmQpIHtcbiAgICAgICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDEpIDogbmV3IEludmFyaWFudEVycm9yKCdyZXF1ZXN0IGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5lbXB0eSA9IGVtcHR5O1xuICAgIEFwb2xsb0xpbmsuZnJvbSA9IGZyb207XG4gICAgQXBvbGxvTGluay5zcGxpdCA9IHNwbGl0O1xuICAgIEFwb2xsb0xpbmsuZXhlY3V0ZSA9IGV4ZWN1dGU7XG4gICAgcmV0dXJuIEFwb2xsb0xpbms7XG59KCkpO1xuZnVuY3Rpb24gZXhlY3V0ZShsaW5rLCBvcGVyYXRpb24pIHtcbiAgICByZXR1cm4gKGxpbmsucmVxdWVzdChjcmVhdGVPcGVyYXRpb24ob3BlcmF0aW9uLmNvbnRleHQsIHRyYW5zZm9ybU9wZXJhdGlvbih2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24pKSkpIHx8IE9ic2VydmFibGUub2YoKSk7XG59XG5cbmV4cG9ydCB7IEFwb2xsb0xpbmssIGNvbmNhdCwgY3JlYXRlT3BlcmF0aW9uLCBlbXB0eSwgZXhlY3V0ZSwgZnJvbSwgZnJvbUVycm9yLCBmcm9tUHJvbWlzZSwgbWFrZVByb21pc2UsIHNwbGl0LCB0b1Byb21pc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyB2aXNpdCB9IGZyb20gJ2dyYXBocWwvbGFuZ3VhZ2UvdmlzaXRvcic7XG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciwgaW52YXJpYW50IH0gZnJvbSAndHMtaW52YXJpYW50JztcbmltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5cyB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnknO1xuZXhwb3J0IHsgZXF1YWwgYXMgaXNFcXVhbCB9IGZyb20gJ0B3cnkvZXF1YWxpdHknO1xuXG5mdW5jdGlvbiBpc1NjYWxhclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFsnU3RyaW5nVmFsdWUnLCAnQm9vbGVhblZhbHVlJywgJ0VudW1WYWx1ZSddLmluZGV4T2YodmFsdWUua2luZCkgPiAtMTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gWydJbnRWYWx1ZScsICdGbG9hdFZhbHVlJ10uaW5kZXhPZih2YWx1ZS5raW5kKSA+IC0xO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnU3RyaW5nVmFsdWUnO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0Jvb2xlYW5WYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0ludFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdJbnRWYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0Zsb2F0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0Zsb2F0VmFsdWUnO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnVmFyaWFibGUnO1xufVxuZnVuY3Rpb24gaXNPYmplY3RWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnT2JqZWN0VmFsdWUnO1xufVxuZnVuY3Rpb24gaXNMaXN0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0xpc3RWYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0VudW1WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnRW51bVZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzTnVsbFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdOdWxsVmFsdWUnO1xufVxuZnVuY3Rpb24gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGFyZ09iaiwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcykge1xuICAgIGlmIChpc0ludFZhbHVlKHZhbHVlKSB8fCBpc0Zsb2F0VmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IE51bWJlcih2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQm9vbGVhblZhbHVlKHZhbHVlKSB8fCBpc1N0cmluZ1ZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3RWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG5lc3RlZEFyZ09ial8xID0ge307XG4gICAgICAgIHZhbHVlLmZpZWxkcy5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihuZXN0ZWRBcmdPYmpfMSwgb2JqLm5hbWUsIG9iai52YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IG5lc3RlZEFyZ09ial8xO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZhcmlhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YXIgdmFyaWFibGVWYWx1ZSA9ICh2YXJpYWJsZXMgfHwge30pW3ZhbHVlLm5hbWUudmFsdWVdO1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YXJpYWJsZVZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0xpc3RWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gdmFsdWUudmFsdWVzLm1hcChmdW5jdGlvbiAobGlzdFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkQXJnQXJyYXlPYmogPSB7fTtcbiAgICAgICAgICAgIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihuZXN0ZWRBcmdBcnJheU9iaiwgbmFtZSwgbGlzdFZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5lc3RlZEFyZ0FycmF5T2JqW25hbWUudmFsdWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFbnVtVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc051bGxWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcigxNykgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJUaGUgaW5saW5lIGFyZ3VtZW50IFxcXCJcIiArIG5hbWUudmFsdWUgKyBcIlxcXCIgb2Yga2luZCBcXFwiXCIgKyB2YWx1ZS5raW5kICsgXCJcXFwiXCIgK1xuICAgICAgICAgICAgJ2lzIG5vdCBzdXBwb3J0ZWQuIFVzZSB2YXJpYWJsZXMgaW5zdGVhZCBvZiBpbmxpbmUgYXJndW1lbnRzIHRvICcgK1xuICAgICAgICAgICAgJ292ZXJjb21lIHRoaXMgbGltaXRhdGlvbi4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdG9yZUtleU5hbWVGcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcykge1xuICAgIHZhciBkaXJlY3RpdmVzT2JqID0gbnVsbDtcbiAgICBpZiAoZmllbGQuZGlyZWN0aXZlcykge1xuICAgICAgICBkaXJlY3RpdmVzT2JqID0ge307XG4gICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzT2JqW2RpcmVjdGl2ZS5uYW1lLnZhbHVlXSA9IHt9O1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihkaXJlY3RpdmVzT2JqW2RpcmVjdGl2ZS5uYW1lLnZhbHVlXSwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgYXJnT2JqID0gbnVsbDtcbiAgICBpZiAoZmllbGQuYXJndW1lbnRzICYmIGZpZWxkLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXJnT2JqID0ge307XG4gICAgICAgIGZpZWxkLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihhcmdPYmosIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFN0b3JlS2V5TmFtZShmaWVsZC5uYW1lLnZhbHVlLCBhcmdPYmosIGRpcmVjdGl2ZXNPYmopO1xufVxudmFyIEtOT1dOX0RJUkVDVElWRVMgPSBbXG4gICAgJ2Nvbm5lY3Rpb24nLFxuICAgICdpbmNsdWRlJyxcbiAgICAnc2tpcCcsXG4gICAgJ2NsaWVudCcsXG4gICAgJ3Jlc3QnLFxuICAgICdleHBvcnQnLFxuXTtcbmZ1bmN0aW9uIGdldFN0b3JlS2V5TmFtZShmaWVsZE5hbWUsIGFyZ3MsIGRpcmVjdGl2ZXMpIHtcbiAgICBpZiAoZGlyZWN0aXZlcyAmJlxuICAgICAgICBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ10gJiZcbiAgICAgICAgZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydrZXknXSkge1xuICAgICAgICBpZiAoZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydmaWx0ZXInXSAmJlxuICAgICAgICAgICAgZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydmaWx0ZXInXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyS2V5cyA9IGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsnZmlsdGVyJ11cbiAgICAgICAgICAgICAgICA/IGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsnZmlsdGVyJ11cbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgZmlsdGVyS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICB2YXIgcXVlcnlBcmdzXzEgPSBhcmdzO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkQXJnc18xID0ge307XG4gICAgICAgICAgICBmaWx0ZXJLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQXJnc18xW2tleV0gPSBxdWVyeUFyZ3NfMVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydrZXknXSArIFwiKFwiICsgSlNPTi5zdHJpbmdpZnkoZmlsdGVyZWRBcmdzXzEpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydrZXknXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29tcGxldGVGaWVsZE5hbWUgPSBmaWVsZE5hbWU7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgdmFyIHN0cmluZ2lmaWVkQXJncyA9IHN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCIoXCIgKyBzdHJpbmdpZmllZEFyZ3MgKyBcIilcIjtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGlyZWN0aXZlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoS05PV05fRElSRUNUSVZFUy5pbmRleE9mKGtleSkgIT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmVzW2tleV0gJiYgT2JqZWN0LmtleXMoZGlyZWN0aXZlc1trZXldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUZpZWxkTmFtZSArPSBcIkBcIiArIGtleSArIFwiKFwiICsgSlNPTi5zdHJpbmdpZnkoZGlyZWN0aXZlc1trZXldKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCJAXCIgKyBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGxldGVGaWVsZE5hbWU7XG59XG5mdW5jdGlvbiBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcykge1xuICAgIGlmIChmaWVsZC5hcmd1bWVudHMgJiYgZmllbGQuYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXJnT2JqXzEgPSB7fTtcbiAgICAgICAgZmllbGQuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGFyZ09ial8xLCBuYW1lLCB2YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcmdPYmpfMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKSB7XG4gICAgcmV0dXJuIGZpZWxkLmFsaWFzID8gZmllbGQuYWxpYXMudmFsdWUgOiBmaWVsZC5uYW1lLnZhbHVlO1xufVxuZnVuY3Rpb24gaXNGaWVsZChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uLmtpbmQgPT09ICdGaWVsZCc7XG59XG5mdW5jdGlvbiBpc0lubGluZUZyYWdtZW50KHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzZWxlY3Rpb24ua2luZCA9PT0gJ0lubGluZUZyYWdtZW50Jztcbn1cbmZ1bmN0aW9uIGlzSWRWYWx1ZShpZE9iamVjdCkge1xuICAgIHJldHVybiBpZE9iamVjdCAmJlxuICAgICAgICBpZE9iamVjdC50eXBlID09PSAnaWQnICYmXG4gICAgICAgIHR5cGVvZiBpZE9iamVjdC5nZW5lcmF0ZWQgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIHRvSWRWYWx1ZShpZENvbmZpZywgZ2VuZXJhdGVkKSB7XG4gICAgaWYgKGdlbmVyYXRlZCA9PT0gdm9pZCAwKSB7IGdlbmVyYXRlZCA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIF9fYXNzaWduKHsgdHlwZTogJ2lkJywgZ2VuZXJhdGVkOiBnZW5lcmF0ZWQgfSwgKHR5cGVvZiBpZENvbmZpZyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IGlkOiBpZENvbmZpZywgdHlwZW5hbWU6IHVuZGVmaW5lZCB9XG4gICAgICAgIDogaWRDb25maWcpKTtcbn1cbmZ1bmN0aW9uIGlzSnNvblZhbHVlKGpzb25PYmplY3QpIHtcbiAgICByZXR1cm4gKGpzb25PYmplY3QgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YganNvbk9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAganNvbk9iamVjdC50eXBlID09PSAnanNvbicpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFZhbHVlRnJvbVZhcmlhYmxlKG5vZGUpIHtcbiAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMTgpIDogbmV3IEludmFyaWFudEVycm9yKFwiVmFyaWFibGUgbm9kZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdmFsdWVGcm9tTm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHZhbHVlRnJvbU5vZGUobm9kZSwgb25WYXJpYWJsZSkge1xuICAgIGlmIChvblZhcmlhYmxlID09PSB2b2lkIDApIHsgb25WYXJpYWJsZSA9IGRlZmF1bHRWYWx1ZUZyb21WYXJpYWJsZTsgfVxuICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgIGNhc2UgJ1ZhcmlhYmxlJzpcbiAgICAgICAgICAgIHJldHVybiBvblZhcmlhYmxlKG5vZGUpO1xuICAgICAgICBjYXNlICdOdWxsVmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ0ludFZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChub2RlLnZhbHVlLCAxMCk7XG4gICAgICAgIGNhc2UgJ0Zsb2F0VmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobm9kZS52YWx1ZSk7XG4gICAgICAgIGNhc2UgJ0xpc3RWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2YWx1ZUZyb21Ob2RlKHYsIG9uVmFyaWFibGUpOyB9KTtcbiAgICAgICAgY2FzZSAnT2JqZWN0VmFsdWUnOiB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBub2RlLmZpZWxkczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFsdWVbZmllbGQubmFtZS52YWx1ZV0gPSB2YWx1ZUZyb21Ob2RlKGZpZWxkLnZhbHVlLCBvblZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREaXJlY3RpdmVJbmZvRnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpIHtcbiAgICBpZiAoZmllbGQuZGlyZWN0aXZlcyAmJiBmaWVsZC5kaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZGlyZWN0aXZlT2JqXzEgPSB7fTtcbiAgICAgICAgZmllbGQuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZU9ial8xW2RpcmVjdGl2ZS5uYW1lLnZhbHVlXSA9IGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChkaXJlY3RpdmUsIHZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlT2JqXzE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2hvdWxkSW5jbHVkZShzZWxlY3Rpb24sIHZhcmlhYmxlcykge1xuICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB7fTsgfVxuICAgIHJldHVybiBnZXRJbmNsdXNpb25EaXJlY3RpdmVzKHNlbGVjdGlvbi5kaXJlY3RpdmVzKS5ldmVyeShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IF9hLmRpcmVjdGl2ZSwgaWZBcmd1bWVudCA9IF9hLmlmQXJndW1lbnQ7XG4gICAgICAgIHZhciBldmFsZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaWZBcmd1bWVudC52YWx1ZS5raW5kID09PSAnVmFyaWFibGUnKSB7XG4gICAgICAgICAgICBldmFsZWRWYWx1ZSA9IHZhcmlhYmxlc1tpZkFyZ3VtZW50LnZhbHVlLm5hbWUudmFsdWVdO1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGV2YWxlZFZhbHVlICE9PSB2b2lkIDAsIDEzKSA6IGludmFyaWFudChldmFsZWRWYWx1ZSAhPT0gdm9pZCAwLCBcIkludmFsaWQgdmFyaWFibGUgcmVmZXJlbmNlZCBpbiBAXCIgKyBkaXJlY3RpdmUubmFtZS52YWx1ZSArIFwiIGRpcmVjdGl2ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmFsZWRWYWx1ZSA9IGlmQXJndW1lbnQudmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZS5uYW1lLnZhbHVlID09PSAnc2tpcCcgPyAhZXZhbGVkVmFsdWUgOiBldmFsZWRWYWx1ZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZU5hbWVzKGRvYykge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIHZpc2l0KGRvYywge1xuICAgICAgICBEaXJlY3RpdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKG5vZGUubmFtZS52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG5hbWVzO1xufVxuZnVuY3Rpb24gaGFzRGlyZWN0aXZlcyhuYW1lcywgZG9jKSB7XG4gICAgcmV0dXJuIGdldERpcmVjdGl2ZU5hbWVzKGRvYykuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xOyB9KTtcbn1cbmZ1bmN0aW9uIGhhc0NsaWVudEV4cG9ydHMoZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gKGRvY3VtZW50ICYmXG4gICAgICAgIGhhc0RpcmVjdGl2ZXMoWydjbGllbnQnXSwgZG9jdW1lbnQpICYmXG4gICAgICAgIGhhc0RpcmVjdGl2ZXMoWydleHBvcnQnXSwgZG9jdW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzSW5jbHVzaW9uRGlyZWN0aXZlKF9hKSB7XG4gICAgdmFyIHZhbHVlID0gX2EubmFtZS52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgPT09ICdza2lwJyB8fCB2YWx1ZSA9PT0gJ2luY2x1ZGUnO1xufVxuZnVuY3Rpb24gZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcyhkaXJlY3RpdmVzKSB7XG4gICAgcmV0dXJuIGRpcmVjdGl2ZXMgPyBkaXJlY3RpdmVzLmZpbHRlcihpc0luY2x1c2lvbkRpcmVjdGl2ZSkubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUFyZ3VtZW50cyA9IGRpcmVjdGl2ZS5hcmd1bWVudHM7XG4gICAgICAgIHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm5hbWUudmFsdWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChkaXJlY3RpdmVBcmd1bWVudHMgJiYgZGlyZWN0aXZlQXJndW1lbnRzLmxlbmd0aCA9PT0gMSwgMTQpIDogaW52YXJpYW50KGRpcmVjdGl2ZUFyZ3VtZW50cyAmJiBkaXJlY3RpdmVBcmd1bWVudHMubGVuZ3RoID09PSAxLCBcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciB0aGUgQFwiICsgZGlyZWN0aXZlTmFtZSArIFwiIGRpcmVjdGl2ZS5cIik7XG4gICAgICAgIHZhciBpZkFyZ3VtZW50ID0gZGlyZWN0aXZlQXJndW1lbnRzWzBdO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoaWZBcmd1bWVudC5uYW1lICYmIGlmQXJndW1lbnQubmFtZS52YWx1ZSA9PT0gJ2lmJywgMTUpIDogaW52YXJpYW50KGlmQXJndW1lbnQubmFtZSAmJiBpZkFyZ3VtZW50Lm5hbWUudmFsdWUgPT09ICdpZicsIFwiSW52YWxpZCBhcmd1bWVudCBmb3IgdGhlIEBcIiArIGRpcmVjdGl2ZU5hbWUgKyBcIiBkaXJlY3RpdmUuXCIpO1xuICAgICAgICB2YXIgaWZWYWx1ZSA9IGlmQXJndW1lbnQudmFsdWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChpZlZhbHVlICYmXG4gICAgICAgICAgICAoaWZWYWx1ZS5raW5kID09PSAnVmFyaWFibGUnIHx8IGlmVmFsdWUua2luZCA9PT0gJ0Jvb2xlYW5WYWx1ZScpLCAxNikgOiBpbnZhcmlhbnQoaWZWYWx1ZSAmJlxuICAgICAgICAgICAgKGlmVmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJyB8fCBpZlZhbHVlLmtpbmQgPT09ICdCb29sZWFuVmFsdWUnKSwgXCJBcmd1bWVudCBmb3IgdGhlIEBcIiArIGRpcmVjdGl2ZU5hbWUgKyBcIiBkaXJlY3RpdmUgbXVzdCBiZSBhIHZhcmlhYmxlIG9yIGEgYm9vbGVhbiB2YWx1ZS5cIik7XG4gICAgICAgIHJldHVybiB7IGRpcmVjdGl2ZTogZGlyZWN0aXZlLCBpZkFyZ3VtZW50OiBpZkFyZ3VtZW50IH07XG4gICAgfSkgOiBbXTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRRdWVyeURvY3VtZW50KGRvY3VtZW50LCBmcmFnbWVudE5hbWUpIHtcbiAgICB2YXIgYWN0dWFsRnJhZ21lbnROYW1lID0gZnJhZ21lbnROYW1lO1xuICAgIHZhciBmcmFnbWVudHMgPSBbXTtcbiAgICBkb2N1bWVudC5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDExKSA6IG5ldyBJbnZhcmlhbnRFcnJvcihcIkZvdW5kIGEgXCIgKyBkZWZpbml0aW9uLm9wZXJhdGlvbiArIFwiIG9wZXJhdGlvblwiICsgKGRlZmluaXRpb24ubmFtZSA/IFwiIG5hbWVkICdcIiArIGRlZmluaXRpb24ubmFtZS52YWx1ZSArIFwiJ1wiIDogJycpICsgXCIuIFwiICtcbiAgICAgICAgICAgICAgICAnTm8gb3BlcmF0aW9ucyBhcmUgYWxsb3dlZCB3aGVuIHVzaW5nIGEgZnJhZ21lbnQgYXMgYSBxdWVyeS4gT25seSBmcmFnbWVudHMgYXJlIGFsbG93ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluaXRpb24ua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBhY3R1YWxGcmFnbWVudE5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmcmFnbWVudHMubGVuZ3RoID09PSAxLCAxMikgOiBpbnZhcmlhbnQoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSwgXCJGb3VuZCBcIiArIGZyYWdtZW50cy5sZW5ndGggKyBcIiBmcmFnbWVudHMuIGBmcmFnbWVudE5hbWVgIG11c3QgYmUgcHJvdmlkZWQgd2hlbiB0aGVyZSBpcyBub3QgZXhhY3RseSAxIGZyYWdtZW50LlwiKTtcbiAgICAgICAgYWN0dWFsRnJhZ21lbnROYW1lID0gZnJhZ21lbnRzWzBdLm5hbWUudmFsdWU7XG4gICAgfVxuICAgIHZhciBxdWVyeSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb2N1bWVudCksIHsgZGVmaW5pdGlvbnM6IF9fc3ByZWFkQXJyYXlzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBraW5kOiAnT3BlcmF0aW9uRGVmaW5pdGlvbicsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAncXVlcnknLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDoge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiAnU2VsZWN0aW9uU2V0JyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdGcmFnbWVudFNwcmVhZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnTmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhY3R1YWxGcmFnbWVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSwgZG9jdW1lbnQuZGVmaW5pdGlvbnMpIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnIHx8IHNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBnZXRNdXRhdGlvbkRlZmluaXRpb24oZG9jKSB7XG4gICAgY2hlY2tEb2N1bWVudChkb2MpO1xuICAgIHZhciBtdXRhdGlvbkRlZiA9IGRvYy5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nICYmXG4gICAgICAgICAgICBkZWZpbml0aW9uLm9wZXJhdGlvbiA9PT0gJ211dGF0aW9uJztcbiAgICB9KVswXTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQobXV0YXRpb25EZWYsIDEpIDogaW52YXJpYW50KG11dGF0aW9uRGVmLCAnTXVzdCBjb250YWluIGEgbXV0YXRpb24gZGVmaW5pdGlvbi4nKTtcbiAgICByZXR1cm4gbXV0YXRpb25EZWY7XG59XG5mdW5jdGlvbiBjaGVja0RvY3VtZW50KGRvYykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChkb2MgJiYgZG9jLmtpbmQgPT09ICdEb2N1bWVudCcsIDIpIDogaW52YXJpYW50KGRvYyAmJiBkb2Mua2luZCA9PT0gJ0RvY3VtZW50JywgXCJFeHBlY3RpbmcgYSBwYXJzZWQgR3JhcGhRTCBkb2N1bWVudC4gUGVyaGFwcyB5b3UgbmVlZCB0byB3cmFwIHRoZSBxdWVyeSBzdHJpbmcgaW4gYSBcXFwiZ3FsXFxcIiB0YWc/IGh0dHA6Ly9kb2NzLmFwb2xsb3N0YWNrLmNvbS9hcG9sbG8tY2xpZW50L2NvcmUuaHRtbCNncWxcIik7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSBkb2MuZGVmaW5pdGlvbnNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5raW5kICE9PSAnRnJhZ21lbnREZWZpbml0aW9uJzsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kICE9PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcigzKSA6IG5ldyBJbnZhcmlhbnRFcnJvcihcIlNjaGVtYSB0eXBlIGRlZmluaXRpb25zIG5vdCBhbGxvd2VkIGluIHF1ZXJpZXMuIEZvdW5kOiBcXFwiXCIgKyBkZWZpbml0aW9uLmtpbmQgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfSk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KG9wZXJhdGlvbnMubGVuZ3RoIDw9IDEsIDQpIDogaW52YXJpYW50KG9wZXJhdGlvbnMubGVuZ3RoIDw9IDEsIFwiQW1iaWd1b3VzIEdyYXBoUUwgZG9jdW1lbnQ6IGNvbnRhaW5zIFwiICsgb3BlcmF0aW9ucy5sZW5ndGggKyBcIiBvcGVyYXRpb25zXCIpO1xuICAgIHJldHVybiBkb2M7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25EZWZpbml0aW9uKGRvYykge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jKTtcbiAgICByZXR1cm4gZG9jLmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoZGVmaW5pdGlvbikgeyByZXR1cm4gZGVmaW5pdGlvbi5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbic7IH0pWzBdO1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbk9yRGllKGRvY3VtZW50KSB7XG4gICAgdmFyIGRlZiA9IGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jdW1lbnQpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChkZWYsIDUpIDogaW52YXJpYW50KGRlZiwgXCJHcmFwaFFMIGRvY3VtZW50IGlzIG1pc3NpbmcgYW4gb3BlcmF0aW9uXCIpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25OYW1lKGRvYykge1xuICAgIHJldHVybiAoZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nICYmIGRlZmluaXRpb24ubmFtZTtcbiAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWUudmFsdWU7IH0pWzBdIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2MpIHtcbiAgICByZXR1cm4gZG9jLmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoZGVmaW5pdGlvbikgeyByZXR1cm4gZGVmaW5pdGlvbi5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJzsgfSk7XG59XG5mdW5jdGlvbiBnZXRRdWVyeURlZmluaXRpb24oZG9jKSB7XG4gICAgdmFyIHF1ZXJ5RGVmID0gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2MpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChxdWVyeURlZiAmJiBxdWVyeURlZi5vcGVyYXRpb24gPT09ICdxdWVyeScsIDYpIDogaW52YXJpYW50KHF1ZXJ5RGVmICYmIHF1ZXJ5RGVmLm9wZXJhdGlvbiA9PT0gJ3F1ZXJ5JywgJ011c3QgY29udGFpbiBhIHF1ZXJ5IGRlZmluaXRpb24uJyk7XG4gICAgcmV0dXJuIHF1ZXJ5RGVmO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnREZWZpbml0aW9uKGRvYykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChkb2Mua2luZCA9PT0gJ0RvY3VtZW50JywgNykgOiBpbnZhcmlhbnQoZG9jLmtpbmQgPT09ICdEb2N1bWVudCcsIFwiRXhwZWN0aW5nIGEgcGFyc2VkIEdyYXBoUUwgZG9jdW1lbnQuIFBlcmhhcHMgeW91IG5lZWQgdG8gd3JhcCB0aGUgcXVlcnkgc3RyaW5nIGluIGEgXFxcImdxbFxcXCIgdGFnPyBodHRwOi8vZG9jcy5hcG9sbG9zdGFjay5jb20vYXBvbGxvLWNsaWVudC9jb3JlLmh0bWwjZ3FsXCIpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChkb2MuZGVmaW5pdGlvbnMubGVuZ3RoIDw9IDEsIDgpIDogaW52YXJpYW50KGRvYy5kZWZpbml0aW9ucy5sZW5ndGggPD0gMSwgJ0ZyYWdtZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBkZWZpbml0aW9uLicpO1xuICAgIHZhciBmcmFnbWVudERlZiA9IGRvYy5kZWZpbml0aW9uc1swXTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZnJhZ21lbnREZWYua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbicsIDkpIDogaW52YXJpYW50KGZyYWdtZW50RGVmLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nLCAnTXVzdCBiZSBhIGZyYWdtZW50IGRlZmluaXRpb24uJyk7XG4gICAgcmV0dXJuIGZyYWdtZW50RGVmO1xufVxuZnVuY3Rpb24gZ2V0TWFpbkRlZmluaXRpb24ocXVlcnlEb2MpIHtcbiAgICBjaGVja0RvY3VtZW50KHF1ZXJ5RG9jKTtcbiAgICB2YXIgZnJhZ21lbnREZWZpbml0aW9uO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBxdWVyeURvYy5kZWZpbml0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSBfYVtfaV07XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJykge1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGRlZmluaXRpb24ub3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ3F1ZXJ5JyB8fFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9PT0gJ211dGF0aW9uJyB8fFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJyAmJiAhZnJhZ21lbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICBmcmFnbWVudERlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFnbWVudERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50RGVmaW5pdGlvbjtcbiAgICB9XG4gICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDEwKSA6IG5ldyBJbnZhcmlhbnRFcnJvcignRXhwZWN0ZWQgYSBwYXJzZWQgR3JhcGhRTCBxdWVyeSB3aXRoIGEgcXVlcnksIG11dGF0aW9uLCBzdWJzY3JpcHRpb24sIG9yIGEgZnJhZ21lbnQuJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudE1hcChmcmFnbWVudHMpIHtcbiAgICBpZiAoZnJhZ21lbnRzID09PSB2b2lkIDApIHsgZnJhZ21lbnRzID0gW107IH1cbiAgICB2YXIgc3ltVGFibGUgPSB7fTtcbiAgICBmcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgc3ltVGFibGVbZnJhZ21lbnQubmFtZS52YWx1ZV0gPSBmcmFnbWVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gc3ltVGFibGU7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWVzKGRlZmluaXRpb24pIHtcbiAgICBpZiAoZGVmaW5pdGlvbiAmJlxuICAgICAgICBkZWZpbml0aW9uLnZhcmlhYmxlRGVmaW5pdGlvbnMgJiZcbiAgICAgICAgZGVmaW5pdGlvbi52YXJpYWJsZURlZmluaXRpb25zLmxlbmd0aCkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlcyA9IGRlZmluaXRpb24udmFyaWFibGVEZWZpbml0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBfYS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IF9hLnZhcmlhYmxlLCBkZWZhdWx0VmFsdWUgPSBfYS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlT2JqID0ge307XG4gICAgICAgICAgICB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oZGVmYXVsdFZhbHVlT2JqLCB2YXJpYWJsZS5uYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZU9iajtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhc3NpZ24uYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5cyhbe31dLCBkZWZhdWx0VmFsdWVzKSk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uIHZhcmlhYmxlc0luT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgIHZhciBuYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBpZiAob3BlcmF0aW9uLnZhcmlhYmxlRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG9wZXJhdGlvbi52YXJpYWJsZURlZmluaXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBfYVtfaV07XG4gICAgICAgICAgICBuYW1lcy5hZGQoZGVmaW5pdGlvbi52YXJpYWJsZS5uYW1lLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmFtZXM7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckluUGxhY2UoYXJyYXksIHRlc3QsIGNvbnRleHQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gMDtcbiAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtLCBpKSB7XG4gICAgICAgIGlmICh0ZXN0LmNhbGwodGhpcywgZWxlbSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgICBhcnJheVt0YXJnZXQrK10gPSBlbGVtO1xuICAgICAgICB9XG4gICAgfSwgY29udGV4dCk7XG4gICAgYXJyYXkubGVuZ3RoID0gdGFyZ2V0O1xuICAgIHJldHVybiBhcnJheTtcbn1cblxudmFyIFRZUEVOQU1FX0ZJRUxEID0ge1xuICAgIGtpbmQ6ICdGaWVsZCcsXG4gICAgbmFtZToge1xuICAgICAgICBraW5kOiAnTmFtZScsXG4gICAgICAgIHZhbHVlOiAnX190eXBlbmFtZScsXG4gICAgfSxcbn07XG5mdW5jdGlvbiBpc0VtcHR5KG9wLCBmcmFnbWVudHMpIHtcbiAgICByZXR1cm4gb3Auc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmtpbmQgPT09ICdGcmFnbWVudFNwcmVhZCcgJiZcbiAgICAgICAgICAgIGlzRW1wdHkoZnJhZ21lbnRzW3NlbGVjdGlvbi5uYW1lLnZhbHVlXSwgZnJhZ21lbnRzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG51bGxJZkRvY0lzRW1wdHkoZG9jKSB7XG4gICAgcmV0dXJuIGlzRW1wdHkoZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2MpIHx8IGdldEZyYWdtZW50RGVmaW5pdGlvbihkb2MpLCBjcmVhdGVGcmFnbWVudE1hcChnZXRGcmFnbWVudERlZmluaXRpb25zKGRvYykpKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBkb2M7XG59XG5mdW5jdGlvbiBnZXREaXJlY3RpdmVNYXRjaGVyKGRpcmVjdGl2ZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGRpci5uYW1lICYmIGRpci5uYW1lID09PSBkaXJlY3RpdmUubmFtZS52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZGlyLnRlc3QgJiYgZGlyLnRlc3QoZGlyZWN0aXZlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50KGRpcmVjdGl2ZXMsIGRvYykge1xuICAgIHZhciB2YXJpYWJsZXNJblVzZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHZhcmlhYmxlc1RvUmVtb3ZlID0gW107XG4gICAgdmFyIGZyYWdtZW50U3ByZWFkc0luVXNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgZnJhZ21lbnRTcHJlYWRzVG9SZW1vdmUgPSBbXTtcbiAgICB2YXIgbW9kaWZpZWREb2MgPSBudWxsSWZEb2NJc0VtcHR5KHZpc2l0KGRvYywge1xuICAgICAgICBWYXJpYWJsZToge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBfa2V5LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmtpbmQgIT09ICdWYXJpYWJsZURlZmluaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc0luVXNlW25vZGUubmFtZS52YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIEZpZWxkOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlcyAmJiBub2RlLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZFJlbW92ZUZpZWxkID0gZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5yZW1vdmU7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlRmllbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGlyZWN0aXZlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXJlY3RpdmVzLnNvbWUoZ2V0RGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmVzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc1RvUmVtb3ZlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGFyZy52YWx1ZS5uYW1lLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbEZyYWdtZW50U3ByZWFkc0Zyb21TZWxlY3Rpb25TZXQobm9kZS5zZWxlY3Rpb25TZXQpLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRTcHJlYWRzVG9SZW1vdmUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmcmFnLm5hbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBGcmFnbWVudFNwcmVhZDoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTcHJlYWRzSW5Vc2Vbbm9kZS5uYW1lLnZhbHVlXSA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBEaXJlY3RpdmU6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChnZXREaXJlY3RpdmVNYXRjaGVyKGRpcmVjdGl2ZXMpKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSkpO1xuICAgIGlmIChtb2RpZmllZERvYyAmJlxuICAgICAgICBmaWx0ZXJJblBsYWNlKHZhcmlhYmxlc1RvUmVtb3ZlLCBmdW5jdGlvbiAodikgeyByZXR1cm4gIXZhcmlhYmxlc0luVXNlW3YubmFtZV07IH0pLmxlbmd0aCkge1xuICAgICAgICBtb2RpZmllZERvYyA9IHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudCh2YXJpYWJsZXNUb1JlbW92ZSwgbW9kaWZpZWREb2MpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWREb2MgJiZcbiAgICAgICAgZmlsdGVySW5QbGFjZShmcmFnbWVudFNwcmVhZHNUb1JlbW92ZSwgZnVuY3Rpb24gKGZzKSB7IHJldHVybiAhZnJhZ21lbnRTcHJlYWRzSW5Vc2VbZnMubmFtZV07IH0pXG4gICAgICAgICAgICAubGVuZ3RoKSB7XG4gICAgICAgIG1vZGlmaWVkRG9jID0gcmVtb3ZlRnJhZ21lbnRTcHJlYWRGcm9tRG9jdW1lbnQoZnJhZ21lbnRTcHJlYWRzVG9SZW1vdmUsIG1vZGlmaWVkRG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGlmaWVkRG9jO1xufVxuZnVuY3Rpb24gYWRkVHlwZW5hbWVUb0RvY3VtZW50KGRvYykge1xuICAgIHJldHVybiB2aXNpdChjaGVja0RvY3VtZW50KGRvYyksIHtcbiAgICAgICAgU2VsZWN0aW9uU2V0OiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIF9rZXksIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gbm9kZS5zZWxlY3Rpb25zO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBza2lwID0gc2VsZWN0aW9ucy5zb21lKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpc0ZpZWxkKHNlbGVjdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb24ubmFtZS52YWx1ZSA9PT0gJ19fdHlwZW5hbWUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLm5hbWUudmFsdWUubGFzdEluZGV4T2YoJ19fJywgMCkgPT09IDApKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaWVsZChmaWVsZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZGlyZWN0aXZlcyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZS52YWx1ZSA9PT0gJ2V4cG9ydCc7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBub2RlKSwgeyBzZWxlY3Rpb25zOiBfX3NwcmVhZEFycmF5cyhzZWxlY3Rpb25zLCBbVFlQRU5BTUVfRklFTERdKSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG52YXIgY29ubmVjdGlvblJlbW92ZUNvbmZpZyA9IHtcbiAgICB0ZXN0OiBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciB3aWxsUmVtb3ZlID0gZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09ICdjb25uZWN0aW9uJztcbiAgICAgICAgaWYgKHdpbGxSZW1vdmUpIHtcbiAgICAgICAgICAgIGlmICghZGlyZWN0aXZlLmFyZ3VtZW50cyB8fFxuICAgICAgICAgICAgICAgICFkaXJlY3RpdmUuYXJndW1lbnRzLnNvbWUoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnLm5hbWUudmFsdWUgPT09ICdrZXknOyB9KSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybignUmVtb3ZpbmcgYW4gQGNvbm5lY3Rpb24gZGlyZWN0aXZlIGV2ZW4gdGhvdWdoIGl0IGRvZXMgbm90IGhhdmUgYSBrZXkuICcgK1xuICAgICAgICAgICAgICAgICAgICAnWW91IG1heSB3YW50IHRvIHVzZSB0aGUga2V5IHBhcmFtZXRlciB0byBzcGVjaWZ5IGEgc3RvcmUga2V5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWxsUmVtb3ZlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gcmVtb3ZlQ29ubmVjdGlvbkRpcmVjdGl2ZUZyb21Eb2N1bWVudChkb2MpIHtcbiAgICByZXR1cm4gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudChbY29ubmVjdGlvblJlbW92ZUNvbmZpZ10sIGNoZWNrRG9jdW1lbnQoZG9jKSk7XG59XG5mdW5jdGlvbiBoYXNEaXJlY3RpdmVzSW5TZWxlY3Rpb25TZXQoZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0LCBuZXN0ZWRDaGVjaykge1xuICAgIGlmIChuZXN0ZWRDaGVjayA9PT0gdm9pZCAwKSB7IG5lc3RlZENoZWNrID0gdHJ1ZTsgfVxuICAgIHJldHVybiAoc2VsZWN0aW9uU2V0ICYmXG4gICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zICYmXG4gICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGhhc0RpcmVjdGl2ZXNJblNlbGVjdGlvbihkaXJlY3RpdmVzLCBzZWxlY3Rpb24sIG5lc3RlZENoZWNrKTtcbiAgICAgICAgfSkpO1xufVxuZnVuY3Rpb24gaGFzRGlyZWN0aXZlc0luU2VsZWN0aW9uKGRpcmVjdGl2ZXMsIHNlbGVjdGlvbiwgbmVzdGVkQ2hlY2spIHtcbiAgICBpZiAobmVzdGVkQ2hlY2sgPT09IHZvaWQgMCkgeyBuZXN0ZWRDaGVjayA9IHRydWU7IH1cbiAgICBpZiAoIWlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzZWxlY3Rpb24uZGlyZWN0aXZlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoc2VsZWN0aW9uLmRpcmVjdGl2ZXMuc29tZShnZXREaXJlY3RpdmVNYXRjaGVyKGRpcmVjdGl2ZXMpKSB8fFxuICAgICAgICAobmVzdGVkQ2hlY2sgJiZcbiAgICAgICAgICAgIGhhc0RpcmVjdGl2ZXNJblNlbGVjdGlvblNldChkaXJlY3RpdmVzLCBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0LCBuZXN0ZWRDaGVjaykpKTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZXNGcm9tRG9jdW1lbnQoZGlyZWN0aXZlcywgZG9jKSB7XG4gICAgY2hlY2tEb2N1bWVudChkb2MpO1xuICAgIHZhciBwYXJlbnRQYXRoO1xuICAgIHJldHVybiBudWxsSWZEb2NJc0VtcHR5KHZpc2l0KGRvYywge1xuICAgICAgICBTZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgX2tleSwgX3BhcmVudCwgcGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHBhdGguam9pbignLScpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50UGF0aCB8fFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9PT0gcGFyZW50UGF0aCB8fFxuICAgICAgICAgICAgICAgICAgICAhY3VycmVudFBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uc1dpdGhEaXJlY3RpdmVzID0gbm9kZS5zZWxlY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7IHJldHVybiBoYXNEaXJlY3RpdmVzSW5TZWxlY3Rpb24oZGlyZWN0aXZlcywgc2VsZWN0aW9uKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRGlyZWN0aXZlc0luU2VsZWN0aW9uU2V0KGRpcmVjdGl2ZXMsIG5vZGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFBhdGggPSBjdXJyZW50UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgc2VsZWN0aW9uczogc2VsZWN0aW9uc1dpdGhEaXJlY3RpdmVzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGdldEFyZ3VtZW50TWF0Y2hlcihjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXJndW1lbnRNYXRjaGVyKGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBjb25maWcuc29tZShmdW5jdGlvbiAoYUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgYXJndW1lbnQudmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJyAmJlxuICAgICAgICAgICAgICAgIGFyZ3VtZW50LnZhbHVlLm5hbWUgJiZcbiAgICAgICAgICAgICAgICAoYUNvbmZpZy5uYW1lID09PSBhcmd1bWVudC52YWx1ZS5uYW1lLnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgIChhQ29uZmlnLnRlc3QgJiYgYUNvbmZpZy50ZXN0KGFyZ3VtZW50KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlQXJndW1lbnRzRnJvbURvY3VtZW50KGNvbmZpZywgZG9jKSB7XG4gICAgdmFyIGFyZ01hdGNoZXIgPSBnZXRBcmd1bWVudE1hdGNoZXIoY29uZmlnKTtcbiAgICByZXR1cm4gbnVsbElmRG9jSXNFbXB0eSh2aXNpdChkb2MsIHtcbiAgICAgICAgT3BlcmF0aW9uRGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBub2RlKSwgeyB2YXJpYWJsZURlZmluaXRpb25zOiBub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uICh2YXJEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY29uZmlnLnNvbWUoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnLm5hbWUgPT09IHZhckRlZi52YXJpYWJsZS5uYW1lLnZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBGaWVsZDoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFJlbW92ZUZpZWxkID0gY29uZmlnLnNvbWUoZnVuY3Rpb24gKGFyZ0NvbmZpZykgeyByZXR1cm4gYXJnQ29uZmlnLnJlbW92ZTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdNYXRjaENvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdNYXRjaGVyKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdNYXRjaENvdW50XzEgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdNYXRjaENvdW50XzEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgQXJndW1lbnQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdNYXRjaGVyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJhZ21lbnRTcHJlYWRGcm9tRG9jdW1lbnQoY29uZmlnLCBkb2MpIHtcbiAgICBmdW5jdGlvbiBlbnRlcihub2RlKSB7XG4gICAgICAgIGlmIChjb25maWcuc29tZShmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBkZWYubmFtZSA9PT0gbm9kZS5uYW1lLnZhbHVlOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxJZkRvY0lzRW1wdHkodmlzaXQoZG9jLCB7XG4gICAgICAgIEZyYWdtZW50U3ByZWFkOiB7IGVudGVyOiBlbnRlciB9LFxuICAgICAgICBGcmFnbWVudERlZmluaXRpb246IHsgZW50ZXI6IGVudGVyIH0sXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0QWxsRnJhZ21lbnRTcHJlYWRzRnJvbVNlbGVjdGlvblNldChzZWxlY3Rpb25TZXQpIHtcbiAgICB2YXIgYWxsRnJhZ21lbnRzID0gW107XG4gICAgc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICgoaXNGaWVsZChzZWxlY3Rpb24pIHx8IGlzSW5saW5lRnJhZ21lbnQoc2VsZWN0aW9uKSkgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgIGdldEFsbEZyYWdtZW50U3ByZWFkc0Zyb21TZWxlY3Rpb25TZXQoc2VsZWN0aW9uLnNlbGVjdGlvblNldCkuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykgeyByZXR1cm4gYWxsRnJhZ21lbnRzLnB1c2goZnJhZyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbi5raW5kID09PSAnRnJhZ21lbnRTcHJlYWQnKSB7XG4gICAgICAgICAgICBhbGxGcmFnbWVudHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFsbEZyYWdtZW50cztcbn1cbmZ1bmN0aW9uIGJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0KGRvY3VtZW50KSB7XG4gICAgdmFyIGRlZmluaXRpb24gPSBnZXRNYWluRGVmaW5pdGlvbihkb2N1bWVudCk7XG4gICAgdmFyIGRlZmluaXRpb25PcGVyYXRpb24gPSBkZWZpbml0aW9uLm9wZXJhdGlvbjtcbiAgICBpZiAoZGVmaW5pdGlvbk9wZXJhdGlvbiA9PT0gJ3F1ZXJ5Jykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBtb2RpZmllZERvYyA9IHZpc2l0KGRvY3VtZW50LCB7XG4gICAgICAgIE9wZXJhdGlvbkRlZmluaXRpb246IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgb3BlcmF0aW9uOiAncXVlcnknIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kaWZpZWREb2M7XG59XG5mdW5jdGlvbiByZW1vdmVDbGllbnRTZXRzRnJvbURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgY2hlY2tEb2N1bWVudChkb2N1bWVudCk7XG4gICAgdmFyIG1vZGlmaWVkRG9jID0gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudChbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5uYW1lLnZhbHVlID09PSAnY2xpZW50JzsgfSxcbiAgICAgICAgICAgIHJlbW92ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICBdLCBkb2N1bWVudCk7XG4gICAgaWYgKG1vZGlmaWVkRG9jKSB7XG4gICAgICAgIG1vZGlmaWVkRG9jID0gdmlzaXQobW9kaWZpZWREb2MsIHtcbiAgICAgICAgICAgIEZyYWdtZW50RGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1R5cGVuYW1lT25seSA9IG5vZGUuc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0ZpZWxkKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLm5hbWUudmFsdWUgPT09ICdfX3R5cGVuYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHlwZW5hbWVPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZERvYztcbn1cblxudmFyIGNhblVzZVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmXG4gICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNsb25lRGVlcEhlbHBlcih2YWx1ZSwgbmV3IE1hcCgpKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGVlcEhlbHBlcih2YWwsIHNlZW4pIHtcbiAgICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjoge1xuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHZhbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4uZ2V0KHZhbCk7XG4gICAgICAgICAgICB2YXIgY29weV8xID0gdmFsLnNsaWNlKDApO1xuICAgICAgICAgICAgc2Vlbi5zZXQodmFsLCBjb3B5XzEpO1xuICAgICAgICAgICAgY29weV8xLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgICAgICAgICAgY29weV8xW2ldID0gY2xvbmVEZWVwSGVscGVyKGNoaWxkLCBzZWVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlfMTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2YWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLmdldCh2YWwpO1xuICAgICAgICAgICAgdmFyIGNvcHlfMiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCkpO1xuICAgICAgICAgICAgc2Vlbi5zZXQodmFsLCBjb3B5XzIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb3B5XzJba2V5XSA9IGNsb25lRGVlcEhlbHBlcih2YWxba2V5XSwgc2Vlbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5XzI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbnYoKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG4gICAgfVxuICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xufVxuZnVuY3Rpb24gaXNFbnYoZW52KSB7XG4gICAgcmV0dXJuIGdldEVudigpID09PSBlbnY7XG59XG5mdW5jdGlvbiBpc1Byb2R1Y3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzRW52KCdwcm9kdWN0aW9uJykgPT09IHRydWU7XG59XG5mdW5jdGlvbiBpc0RldmVsb3BtZW50KCkge1xuICAgIHJldHVybiBpc0VudignZGV2ZWxvcG1lbnQnKSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzVGVzdCgpIHtcbiAgICByZXR1cm4gaXNFbnYoJ3Rlc3QnKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdHJ5RnVuY3Rpb25PckxvZ0Vycm9yKGYpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0LmVycm9ycyAmJiByZXN1bHQuZXJyb3JzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gZGVlcEZyZWV6ZShvKSB7XG4gICAgT2JqZWN0LmZyZWV6ZShvKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChvW3Byb3BdICE9PSBudWxsICYmXG4gICAgICAgICAgICAodHlwZW9mIG9bcHJvcF0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvW3Byb3BdID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgICAgICAgIU9iamVjdC5pc0Zyb3plbihvW3Byb3BdKSkge1xuICAgICAgICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvO1xufVxuZnVuY3Rpb24gbWF5YmVEZWVwRnJlZXplKG9iaikge1xuICAgIGlmIChpc0RldmVsb3BtZW50KCkgfHwgaXNUZXN0KCkpIHtcbiAgICAgICAgdmFyIHN5bWJvbElzUG9seWZpbGxlZCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnJykgPT09ICdzdHJpbmcnO1xuICAgICAgICBpZiAoIXN5bWJvbElzUG9seWZpbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBGcmVlemUob2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gbWVyZ2VEZWVwKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEZWVwQXJyYXkoc291cmNlcyk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXBBcnJheShzb3VyY2VzKSB7XG4gICAgdmFyIHRhcmdldCA9IHNvdXJjZXNbMF0gfHwge307XG4gICAgdmFyIGNvdW50ID0gc291cmNlcy5sZW5ndGg7XG4gICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICB2YXIgcGFzdENvcGllcyA9IFtdO1xuICAgICAgICB0YXJnZXQgPSBzaGFsbG93Q29weUZvck1lcmdlKHRhcmdldCwgcGFzdENvcGllcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gbWVyZ2VIZWxwZXIodGFyZ2V0LCBzb3VyY2VzW2ldLCBwYXN0Q29waWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cbmZ1bmN0aW9uIG1lcmdlSGVscGVyKHRhcmdldCwgc291cmNlLCBwYXN0Q29waWVzKSB7XG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSAmJiAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBzaGFsbG93Q29weUZvck1lcmdlKHRhcmdldCwgcGFzdENvcGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VLZXkpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtzb3VyY2VLZXldO1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBzb3VyY2VLZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFZhbHVlID0gdGFyZ2V0W3NvdXJjZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZhbHVlICE9PSB0YXJnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlS2V5XSA9IG1lcmdlSGVscGVyKHNoYWxsb3dDb3B5Rm9yTWVyZ2UodGFyZ2V0VmFsdWUsIHBhc3RDb3BpZXMpLCBzb3VyY2VWYWx1ZSwgcGFzdENvcGllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZUtleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBzaGFsbG93Q29weUZvck1lcmdlKHZhbHVlLCBwYXN0Q29waWVzKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgcGFzdENvcGllcy5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBfX2Fzc2lnbih7IF9fcHJvdG9fXzogT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSB9LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFzdENvcGllcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgaGF2ZVdhcm5lZCA9IE9iamVjdC5jcmVhdGUoe30pO1xuZnVuY3Rpb24gd2Fybk9uY2VJbkRldmVsb3BtZW50KG1zZywgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9ICd3YXJuJzsgfVxuICAgIGlmICghaXNQcm9kdWN0aW9uKCkgJiYgIWhhdmVXYXJuZWRbbXNnXSkge1xuICAgICAgICBpZiAoIWlzVGVzdCgpKSB7XG4gICAgICAgICAgICBoYXZlV2FybmVkW21zZ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBTeW1ib2xzKGRhdGEpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59XG5cbmV4cG9ydCB7IGFkZFR5cGVuYW1lVG9Eb2N1bWVudCwgYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkLCBhc3NpZ24sIGJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0LCBjYW5Vc2VXZWFrTWFwLCBjaGVja0RvY3VtZW50LCBjbG9uZURlZXAsIGNyZWF0ZUZyYWdtZW50TWFwLCBnZXREZWZhdWx0VmFsdWVzLCBnZXREaXJlY3RpdmVJbmZvRnJvbUZpZWxkLCBnZXREaXJlY3RpdmVOYW1lcywgZ2V0RGlyZWN0aXZlc0Zyb21Eb2N1bWVudCwgZ2V0RW52LCBnZXRGcmFnbWVudERlZmluaXRpb24sIGdldEZyYWdtZW50RGVmaW5pdGlvbnMsIGdldEZyYWdtZW50UXVlcnlEb2N1bWVudCwgZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcywgZ2V0TWFpbkRlZmluaXRpb24sIGdldE11dGF0aW9uRGVmaW5pdGlvbiwgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiwgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbk9yRGllLCBnZXRPcGVyYXRpb25OYW1lLCBnZXRRdWVyeURlZmluaXRpb24sIGdldFN0b3JlS2V5TmFtZSwgZ3JhcGhRTFJlc3VsdEhhc0Vycm9yLCBoYXNDbGllbnRFeHBvcnRzLCBoYXNEaXJlY3RpdmVzLCBpc0RldmVsb3BtZW50LCBpc0VudiwgaXNGaWVsZCwgaXNJZFZhbHVlLCBpc0lubGluZUZyYWdtZW50LCBpc0pzb25WYWx1ZSwgaXNOdW1iZXJWYWx1ZSwgaXNQcm9kdWN0aW9uLCBpc1NjYWxhclZhbHVlLCBpc1Rlc3QsIG1heWJlRGVlcEZyZWV6ZSwgbWVyZ2VEZWVwLCBtZXJnZURlZXBBcnJheSwgcmVtb3ZlQXJndW1lbnRzRnJvbURvY3VtZW50LCByZW1vdmVDbGllbnRTZXRzRnJvbURvY3VtZW50LCByZW1vdmVDb25uZWN0aW9uRGlyZWN0aXZlRnJvbURvY3VtZW50LCByZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50LCByZW1vdmVGcmFnbWVudFNwcmVhZEZyb21Eb2N1bWVudCwgcmVzdWx0S2V5TmFtZUZyb21GaWVsZCwgc2hvdWxkSW5jbHVkZSwgc3RvcmVLZXlOYW1lRnJvbUZpZWxkLCBzdHJpcFN5bWJvbHMsIHRvSWRWYWx1ZSwgdHJ5RnVuY3Rpb25PckxvZ0Vycm9yLCB2YWx1ZUZyb21Ob2RlLCB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24sIHZhcmlhYmxlc0luT3BlcmF0aW9uLCB3YXJuT25jZUluRGV2ZWxvcG1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgb3B0cyA9IHsgY21wOiBvcHRzIH07XG4gICAgdmFyIGN5Y2xlcyA9ICh0eXBlb2Ygb3B0cy5jeWNsZXMgPT09ICdib29sZWFuJykgPyBvcHRzLmN5Y2xlcyA6IGZhbHNlO1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT0gJ251bWJlcicpIHJldHVybiBpc0Zpbml0ZShub2RlKSA/ICcnICsgbm9kZSA6ICdudWxsJztcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vZGUpO1xuXG4gICAgICAgIHZhciBpLCBvdXQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICBvdXQgPSAnWyc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXQgKz0gJywnO1xuICAgICAgICAgICAgICAgIG91dCArPSBzdHJpbmdpZnkobm9kZVtpXSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dCArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuXG4gICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVzKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ19fY3ljbGVfXycpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ucHVzaChub2RlKSAtIDE7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcbiAgICAgICAgb3V0ID0gJyc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0cmluZ2lmeShub2RlW2tleV0pO1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChvdXQpIG91dCArPSAnLCc7XG4gICAgICAgICAgICBvdXQgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc3BsaWNlKHNlZW5JbmRleCwgMSk7XG4gICAgICAgIHJldHVybiAneycgKyBvdXQgKyAnfSc7XG4gICAgfSkoZGF0YSk7XG59O1xuIiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJ2dyYXBocWwvbGFuZ3VhZ2UvcGFyc2VyJyk7XG5cbnZhciBwYXJzZSA9IHBhcnNlci5wYXJzZTtcblxuLy8gU3RyaXAgaW5zaWduaWZpY2FudCB3aGl0ZXNwYWNlXG4vLyBOb3RlIHRoYXQgdGhpcyBjb3VsZCBkbyBhIGxvdCBtb3JlLCBzdWNoIGFzIHJlb3JkZXIgZmllbGRzIGV0Yy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxzLF0rL2csICcgJykudHJpbSgpO1xufVxuXG4vLyBBIG1hcCBkb2NTdHJpbmcgLT4gZ3JhcGhxbCBkb2N1bWVudFxudmFyIGRvY0NhY2hlID0ge307XG5cbi8vIEEgbWFwIGZyYWdtZW50TmFtZSAtPiBbbm9ybWFsaXplZCBzb3VyY2VdXG52YXIgZnJhZ21lbnRTb3VyY2VNYXAgPSB7fTtcblxuZnVuY3Rpb24gY2FjaGVLZXlGcm9tTG9jKGxvYykge1xuICByZXR1cm4gbm9ybWFsaXplKGxvYy5zb3VyY2UuYm9keS5zdWJzdHJpbmcobG9jLnN0YXJ0LCBsb2MuZW5kKSk7XG59XG5cbi8vIEZvciB0ZXN0aW5nLlxuZnVuY3Rpb24gcmVzZXRDYWNoZXMoKSB7XG4gIGRvY0NhY2hlID0ge307XG4gIGZyYWdtZW50U291cmNlTWFwID0ge307XG59XG5cbi8vIFRha2UgYSB1bnN0cmlwcGVkIHBhcnNlZCBkb2N1bWVudCAocXVlcnkvbXV0YXRpb24gb3IgZXZlbiBmcmFnbWVudCksIGFuZFxuLy8gY2hlY2sgYWxsIGZyYWdtZW50IGRlZmluaXRpb25zLCBjaGVja2luZyBmb3IgbmFtZS0+c291cmNlIHVuaXF1ZW5lc3MuXG4vLyBXZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIG9ubHkgdW5pcXVlIGZyYWdtZW50cyBleGlzdCBpbiB0aGUgZG9jdW1lbnQuXG52YXIgcHJpbnRGcmFnbWVudFdhcm5pbmdzID0gdHJ1ZTtcbmZ1bmN0aW9uIHByb2Nlc3NGcmFnbWVudHMoYXN0KSB7XG4gIHZhciBhc3RGcmFnbWVudE1hcCA9IHt9O1xuICB2YXIgZGVmaW5pdGlvbnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdC5kZWZpbml0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmcmFnbWVudERlZmluaXRpb24gPSBhc3QuZGVmaW5pdGlvbnNbaV07XG5cbiAgICBpZiAoZnJhZ21lbnREZWZpbml0aW9uLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nKSB7XG4gICAgICB2YXIgZnJhZ21lbnROYW1lID0gZnJhZ21lbnREZWZpbml0aW9uLm5hbWUudmFsdWU7XG4gICAgICB2YXIgc291cmNlS2V5ID0gY2FjaGVLZXlGcm9tTG9jKGZyYWdtZW50RGVmaW5pdGlvbi5sb2MpO1xuXG4gICAgICAvLyBXZSBrbm93IHNvbWV0aGluZyBhYm91dCB0aGlzIGZyYWdtZW50XG4gICAgICBpZiAoZnJhZ21lbnRTb3VyY2VNYXAuaGFzT3duUHJvcGVydHkoZnJhZ21lbnROYW1lKSAmJiAhZnJhZ21lbnRTb3VyY2VNYXBbZnJhZ21lbnROYW1lXVtzb3VyY2VLZXldKSB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhIHByb2JsZW0gYmVjYXVzZSB0aGUgYXBwIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcmVnaXN0ZXIgYW5vdGhlciBmcmFnbWVudCB3aXRoXG4gICAgICAgIC8vIHRoZSBzYW1lIG5hbWUgYXMgb25lIHByZXZpb3VzbHkgcmVnaXN0ZXJlZC4gU28sIHdlIHRlbGwgdGhlbSBhYm91dCBpdC5cbiAgICAgICAgaWYgKHByaW50RnJhZ21lbnRXYXJuaW5ncykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IGZyYWdtZW50IHdpdGggbmFtZSBcIiArIGZyYWdtZW50TmFtZSArIFwiIGFscmVhZHkgZXhpc3RzLlxcblwiXG4gICAgICAgICAgICArIFwiZ3JhcGhxbC10YWcgZW5mb3JjZXMgYWxsIGZyYWdtZW50IG5hbWVzIGFjcm9zcyB5b3VyIGFwcGxpY2F0aW9uIHRvIGJlIHVuaXF1ZTsgcmVhZCBtb3JlIGFib3V0XFxuXCJcbiAgICAgICAgICAgICsgXCJ0aGlzIGluIHRoZSBkb2NzOiBodHRwOi8vZGV2LmFwb2xsb2RhdGEuY29tL2NvcmUvZnJhZ21lbnRzLmh0bWwjdW5pcXVlLW5hbWVzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnRTb3VyY2VNYXBbZnJhZ21lbnROYW1lXVtzb3VyY2VLZXldID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmICghZnJhZ21lbnRTb3VyY2VNYXAuaGFzT3duUHJvcGVydHkoZnJhZ21lbnROYW1lKSkge1xuICAgICAgICBmcmFnbWVudFNvdXJjZU1hcFtmcmFnbWVudE5hbWVdID0ge307XG4gICAgICAgIGZyYWdtZW50U291cmNlTWFwW2ZyYWdtZW50TmFtZV1bc291cmNlS2V5XSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXN0RnJhZ21lbnRNYXBbc291cmNlS2V5XSkge1xuICAgICAgICBhc3RGcmFnbWVudE1hcFtzb3VyY2VLZXldID0gdHJ1ZTtcbiAgICAgICAgZGVmaW5pdGlvbnMucHVzaChmcmFnbWVudERlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbml0aW9ucy5wdXNoKGZyYWdtZW50RGVmaW5pdGlvbik7XG4gICAgfVxuICB9XG5cbiAgYXN0LmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gIHJldHVybiBhc3Q7XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVGcmFnbWVudFdhcm5pbmdzKCkge1xuICBwcmludEZyYWdtZW50V2FybmluZ3MgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RyaXBMb2MoZG9jLCByZW1vdmVMb2NBdFRoaXNMZXZlbCkge1xuICB2YXIgZG9jVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2MpO1xuXG4gIGlmIChkb2NUeXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIGRvYy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBzdHJpcExvYyhkLCByZW1vdmVMb2NBdFRoaXNMZXZlbCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZG9jVHlwZSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQuJyk7XG4gIH1cblxuICAvLyBXZSBkb24ndCB3YW50IHRvIHJlbW92ZSB0aGUgcm9vdCBsb2MgZmllbGQgc28gd2UgY2FuIHVzZSBpdFxuICAvLyBmb3IgZnJhZ21lbnQgc3Vic3RpdHV0aW9uIChzZWUgYmVsb3cpXG4gIGlmIChyZW1vdmVMb2NBdFRoaXNMZXZlbCAmJiBkb2MubG9jKSB7XG4gICAgZGVsZXRlIGRvYy5sb2M7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXBvbGxvZ3JhcGhxbC9ncmFwaHFsLXRhZy9pc3N1ZXMvNDBcbiAgaWYgKGRvYy5sb2MpIHtcbiAgICBkZWxldGUgZG9jLmxvYy5zdGFydFRva2VuO1xuICAgIGRlbGV0ZSBkb2MubG9jLmVuZFRva2VuO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkb2MpO1xuICB2YXIga2V5O1xuICB2YXIgdmFsdWU7XG4gIHZhciB2YWx1ZVR5cGU7XG5cbiAgZm9yIChrZXkgaW4ga2V5cykge1xuICAgIGlmIChrZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhbHVlID0gZG9jW2tleXNba2V5XV07XG4gICAgICB2YWx1ZVR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgICBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZG9jW2tleXNba2V5XV0gPSBzdHJpcExvYyh2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvYztcbn1cblxudmFyIGV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzID0gZmFsc2U7XG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KGRvYykge1xuICB2YXIgY2FjaGVLZXkgPSBub3JtYWxpemUoZG9jKTtcblxuICBpZiAoZG9jQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGRvY0NhY2hlW2NhY2hlS2V5XTtcbiAgfVxuXG4gIHZhciBwYXJzZWQgPSBwYXJzZShkb2MsIHsgZXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM6IGV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzIH0pO1xuICBpZiAoIXBhcnNlZCB8fCBwYXJzZWQua2luZCAhPT0gJ0RvY3VtZW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgR3JhcGhRTCBkb2N1bWVudC4nKTtcbiAgfVxuXG4gIC8vIGNoZWNrIHRoYXQgYWxsIFwibmV3XCIgZnJhZ21lbnRzIGluc2lkZSB0aGUgZG9jdW1lbnRzIGFyZSBjb25zaXN0ZW50IHdpdGhcbiAgLy8gZXhpc3RpbmcgZnJhZ21lbnRzIG9mIHRoZSBzYW1lIG5hbWVcbiAgcGFyc2VkID0gcHJvY2Vzc0ZyYWdtZW50cyhwYXJzZWQpO1xuICBwYXJzZWQgPSBzdHJpcExvYyhwYXJzZWQsIGZhbHNlKTtcbiAgZG9jQ2FjaGVbY2FjaGVLZXldID0gcGFyc2VkO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzKCkge1xuICBleHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcygpIHtcbiAgZXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMgPSBmYWxzZTtcbn1cblxuLy8gWFhYIFRoaXMgc2hvdWxkIGV2ZW50dWFsbHkgZGlzYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyBpbnRlcnBvbGF0aW9uLCBsaWtlIFJlbGF5IGRvZXNcbmZ1bmN0aW9uIGdxbCgvKiBhcmd1bWVudHMgKi8pIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIHZhciBsaXRlcmFscyA9IGFyZ3NbMF07XG5cbiAgLy8gV2UgYWx3YXlzIGdldCBsaXRlcmFsc1swXSBhbmQgdGhlbiBtYXRjaGluZyBwb3N0IGxpdGVyYWxzIGZvciBlYWNoIGFyZyBnaXZlblxuICB2YXIgcmVzdWx0ID0gKHR5cGVvZihsaXRlcmFscykgPT09IFwic3RyaW5nXCIpID8gbGl0ZXJhbHMgOiBsaXRlcmFsc1swXTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJnc1tpXSAmJiBhcmdzW2ldLmtpbmQgJiYgYXJnc1tpXS5raW5kID09PSAnRG9jdW1lbnQnKSB7XG4gICAgICByZXN1bHQgKz0gYXJnc1tpXS5sb2Muc291cmNlLmJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBhcmdzW2ldO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBsaXRlcmFsc1tpXTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZURvY3VtZW50KHJlc3VsdCk7XG59XG5cbi8vIFN1cHBvcnQgdHlwZXNjcmlwdCwgd2hpY2ggaXNuJ3QgYXMgbmljZSBhcyBCYWJlbCBhYm91dCBkZWZhdWx0IGV4cG9ydHNcbmdxbC5kZWZhdWx0ID0gZ3FsO1xuZ3FsLnJlc2V0Q2FjaGVzID0gcmVzZXRDYWNoZXM7XG5ncWwuZGlzYWJsZUZyYWdtZW50V2FybmluZ3MgPSBkaXNhYmxlRnJhZ21lbnRXYXJuaW5ncztcbmdxbC5lbmFibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcyA9IGVuYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzO1xuZ3FsLmRpc2FibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcyA9IGRpc2FibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcztcblxubW9kdWxlLmV4cG9ydHMgPSBncWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucHJpbnRFcnJvciA9IHByaW50RXJyb3I7XG5leHBvcnRzLkdyYXBoUUxFcnJvciA9IHZvaWQgMDtcblxudmFyIF9pc09iamVjdExpa2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9qc3V0aWxzL2lzT2JqZWN0TGlrZVwiKSk7XG5cbnZhciBfc3ltYm9scyA9IHJlcXVpcmUoXCIuLi9wb2x5ZmlsbHMvc3ltYm9sc1wiKTtcblxudmFyIF9sb2NhdGlvbiA9IHJlcXVpcmUoXCIuLi9sYW5ndWFnZS9sb2NhdGlvblwiKTtcblxudmFyIF9wcmludExvY2F0aW9uID0gcmVxdWlyZShcIi4uL2xhbmd1YWdlL3ByaW50TG9jYXRpb25cIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogQSBHcmFwaFFMRXJyb3IgZGVzY3JpYmVzIGFuIEVycm9yIGZvdW5kIGR1cmluZyB0aGUgcGFyc2UsIHZhbGlkYXRlLCBvclxuICogZXhlY3V0ZSBwaGFzZXMgb2YgcGVyZm9ybWluZyBhIEdyYXBoUUwgb3BlcmF0aW9uLiBJbiBhZGRpdGlvbiB0byBhIG1lc3NhZ2VcbiAqIGFuZCBzdGFjayB0cmFjZSwgaXQgYWxzbyBpbmNsdWRlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9jYXRpb25zIGluIGFcbiAqIEdyYXBoUUwgZG9jdW1lbnQgYW5kL29yIGV4ZWN1dGlvbiByZXN1bHQgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBFcnJvci5cbiAqL1xudmFyIEdyYXBoUUxFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhHcmFwaFFMRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihHcmFwaFFMRXJyb3IpO1xuXG4gIC8qKlxuICAgKiBBIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgRXJyb3IgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICpcbiAgICogRW51bWVyYWJsZSwgYW5kIGFwcGVhcnMgaW4gdGhlIHJlc3VsdCBvZiBKU09OLnN0cmluZ2lmeSgpLlxuICAgKlxuICAgKiBOb3RlOiBzaG91bGQgYmUgdHJlYXRlZCBhcyByZWFkb25seSwgZGVzcGl0ZSBpbnZhcmlhbnQgdXNhZ2UuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB7IGxpbmUsIGNvbHVtbiB9IGxvY2F0aW9ucyB3aXRoaW4gdGhlIHNvdXJjZSBHcmFwaFFMIGRvY3VtZW50XG4gICAqIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhpcyBlcnJvci5cbiAgICpcbiAgICogRXJyb3JzIGR1cmluZyB2YWxpZGF0aW9uIG9mdGVuIGNvbnRhaW4gbXVsdGlwbGUgbG9jYXRpb25zLCBmb3IgZXhhbXBsZSB0b1xuICAgKiBwb2ludCBvdXQgdHdvIHRoaW5ncyB3aXRoIHRoZSBzYW1lIG5hbWUuIEVycm9ycyBkdXJpbmcgZXhlY3V0aW9uIGluY2x1ZGUgYVxuICAgKiBzaW5nbGUgbG9jYXRpb24sIHRoZSBmaWVsZCB3aGljaCBwcm9kdWNlZCB0aGUgZXJyb3IuXG4gICAqXG4gICAqIEVudW1lcmFibGUsIGFuZCBhcHBlYXJzIGluIHRoZSByZXN1bHQgb2YgSlNPTi5zdHJpbmdpZnkoKS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IGRlc2NyaWJpbmcgdGhlIEpTT04tcGF0aCBpbnRvIHRoZSBleGVjdXRpb24gcmVzcG9uc2Ugd2hpY2hcbiAgICogY29ycmVzcG9uZHMgdG8gdGhpcyBlcnJvci4gT25seSBpbmNsdWRlZCBmb3IgZXJyb3JzIGR1cmluZyBleGVjdXRpb24uXG4gICAqXG4gICAqIEVudW1lcmFibGUsIGFuZCBhcHBlYXJzIGluIHRoZSByZXN1bHQgb2YgSlNPTi5zdHJpbmdpZnkoKS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIEdyYXBoUUwgQVNUIE5vZGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBlcnJvci5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgR3JhcGhRTCBkb2N1bWVudCBmb3IgdGhlIGZpcnN0IGxvY2F0aW9uIG9mIHRoaXMgZXJyb3IuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB0aGlzIEVycm9yIHJlcHJlc2VudHMgbW9yZSB0aGFuIG9uZSBub2RlLCB0aGUgc291cmNlIG1heSBub3RcbiAgICogcmVwcmVzZW50IG5vZGVzIGFmdGVyIHRoZSBmaXJzdCBub2RlLlxuICAgKi9cblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgY2hhcmFjdGVyIG9mZnNldHMgd2l0aGluIHRoZSBzb3VyY2UgR3JhcGhRTCBkb2N1bWVudFxuICAgKiB3aGljaCBjb3JyZXNwb25kIHRvIHRoaXMgZXJyb3IuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgZXJyb3IgdGhyb3duIGZyb20gYSBmaWVsZCByZXNvbHZlciBkdXJpbmcgZXhlY3V0aW9uLlxuICAgKi9cblxuICAvKipcbiAgICogRXh0ZW5zaW9uIGZpZWxkcyB0byBhZGQgdG8gdGhlIGZvcm1hdHRlZCBlcnJvci5cbiAgICovXG4gIGZ1bmN0aW9uIEdyYXBoUUxFcnJvcihtZXNzYWdlLCBub2Rlcywgc291cmNlLCBwb3NpdGlvbnMsIHBhdGgsIG9yaWdpbmFsRXJyb3IsIGV4dGVuc2lvbnMpIHtcbiAgICB2YXIgX2xvY2F0aW9uczIsIF9zb3VyY2UyLCBfcG9zaXRpb25zMiwgX2V4dGVuc2lvbnMyO1xuXG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyYXBoUUxFcnJvcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpOyAvLyBDb21wdXRlIGxpc3Qgb2YgYmxhbWUgbm9kZXMuXG5cbiAgICB2YXIgX25vZGVzID0gQXJyYXkuaXNBcnJheShub2RlcykgPyBub2Rlcy5sZW5ndGggIT09IDAgPyBub2RlcyA6IHVuZGVmaW5lZCA6IG5vZGVzID8gW25vZGVzXSA6IHVuZGVmaW5lZDsgLy8gQ29tcHV0ZSBsb2NhdGlvbnMgaW4gdGhlIHNvdXJjZSBmb3IgdGhlIGdpdmVuIG5vZGVzL3Bvc2l0aW9ucy5cblxuXG4gICAgdmFyIF9zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICBpZiAoIV9zb3VyY2UgJiYgX25vZGVzKSB7XG4gICAgICB2YXIgX25vZGVzJDAkbG9jO1xuXG4gICAgICBfc291cmNlID0gKF9ub2RlcyQwJGxvYyA9IF9ub2Rlc1swXS5sb2MpID09PSBudWxsIHx8IF9ub2RlcyQwJGxvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVzJDAkbG9jLnNvdXJjZTtcbiAgICB9XG5cbiAgICB2YXIgX3Bvc2l0aW9ucyA9IHBvc2l0aW9ucztcblxuICAgIGlmICghX3Bvc2l0aW9ucyAmJiBfbm9kZXMpIHtcbiAgICAgIF9wb3NpdGlvbnMgPSBfbm9kZXMucmVkdWNlKGZ1bmN0aW9uIChsaXN0LCBub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmxvYykge1xuICAgICAgICAgIGxpc3QucHVzaChub2RlLmxvYy5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH0sIFtdKTtcbiAgICB9XG5cbiAgICBpZiAoX3Bvc2l0aW9ucyAmJiBfcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgX3Bvc2l0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgX2xvY2F0aW9ucztcblxuICAgIGlmIChwb3NpdGlvbnMgJiYgc291cmNlKSB7XG4gICAgICBfbG9jYXRpb25zID0gcG9zaXRpb25zLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiAoMCwgX2xvY2F0aW9uLmdldExvY2F0aW9uKShzb3VyY2UsIHBvcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF9ub2Rlcykge1xuICAgICAgX2xvY2F0aW9ucyA9IF9ub2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKGxpc3QsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKCgwLCBfbG9jYXRpb24uZ2V0TG9jYXRpb24pKG5vZGUubG9jLnNvdXJjZSwgbm9kZS5sb2Muc3RhcnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIHZhciBfZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cbiAgICBpZiAoX2V4dGVuc2lvbnMgPT0gbnVsbCAmJiBvcmlnaW5hbEVycm9yICE9IG51bGwpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV4dGVuc2lvbnMgPSBvcmlnaW5hbEVycm9yLmV4dGVuc2lvbnM7XG5cbiAgICAgIGlmICgoMCwgX2lzT2JqZWN0TGlrZS5kZWZhdWx0KShvcmlnaW5hbEV4dGVuc2lvbnMpKSB7XG4gICAgICAgIF9leHRlbnNpb25zID0gb3JpZ2luYWxFeHRlbnNpb25zO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIHZhbHVlOiAnR3JhcGhRTEVycm9yJ1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgdmFsdWU6IG1lc3NhZ2UsXG4gICAgICAgIC8vIEJ5IGJlaW5nIGVudW1lcmFibGUsIEpTT04uc3RyaW5naWZ5IHdpbGwgaW5jbHVkZSBgbWVzc2FnZWAgaW4gdGhlXG4gICAgICAgIC8vIHJlc3VsdGluZyBvdXRwdXQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzaW1wbGVzdCBwb3NzaWJsZSBHcmFwaFFMXG4gICAgICAgIC8vIHNlcnZpY2UgYWRoZXJlcyB0byB0aGUgc3BlYy5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsb2NhdGlvbnM6IHtcbiAgICAgICAgLy8gQ29lcmNpbmcgZmFsc3kgdmFsdWVzIHRvIHVuZGVmaW5lZCBlbnN1cmVzIHRoZXkgd2lsbCBub3QgYmUgaW5jbHVkZWRcbiAgICAgICAgLy8gaW4gSlNPTi5zdHJpbmdpZnkoKSB3aGVuIG5vdCBwcm92aWRlZC5cbiAgICAgICAgdmFsdWU6IChfbG9jYXRpb25zMiA9IF9sb2NhdGlvbnMpICE9PSBudWxsICYmIF9sb2NhdGlvbnMyICE9PSB2b2lkIDAgPyBfbG9jYXRpb25zMiA6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gQnkgYmVpbmcgZW51bWVyYWJsZSwgSlNPTi5zdHJpbmdpZnkgd2lsbCBpbmNsdWRlIGBsb2NhdGlvbnNgIGluIHRoZVxuICAgICAgICAvLyByZXN1bHRpbmcgb3V0cHV0LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgc2ltcGxlc3QgcG9zc2libGUgR3JhcGhRTFxuICAgICAgICAvLyBzZXJ2aWNlIGFkaGVyZXMgdG8gdGhlIHNwZWMuXG4gICAgICAgIGVudW1lcmFibGU6IF9sb2NhdGlvbnMgIT0gbnVsbFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgLy8gQ29lcmNpbmcgZmFsc3kgdmFsdWVzIHRvIHVuZGVmaW5lZCBlbnN1cmVzIHRoZXkgd2lsbCBub3QgYmUgaW5jbHVkZWRcbiAgICAgICAgLy8gaW4gSlNPTi5zdHJpbmdpZnkoKSB3aGVuIG5vdCBwcm92aWRlZC5cbiAgICAgICAgdmFsdWU6IHBhdGggIT09IG51bGwgJiYgcGF0aCAhPT0gdm9pZCAwID8gcGF0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gQnkgYmVpbmcgZW51bWVyYWJsZSwgSlNPTi5zdHJpbmdpZnkgd2lsbCBpbmNsdWRlIGBwYXRoYCBpbiB0aGVcbiAgICAgICAgLy8gcmVzdWx0aW5nIG91dHB1dC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHNpbXBsZXN0IHBvc3NpYmxlIEdyYXBoUUxcbiAgICAgICAgLy8gc2VydmljZSBhZGhlcmVzIHRvIHRoZSBzcGVjLlxuICAgICAgICBlbnVtZXJhYmxlOiBwYXRoICE9IG51bGxcbiAgICAgIH0sXG4gICAgICBub2Rlczoge1xuICAgICAgICB2YWx1ZTogX25vZGVzICE9PSBudWxsICYmIF9ub2RlcyAhPT0gdm9pZCAwID8gX25vZGVzIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgc291cmNlOiB7XG4gICAgICAgIHZhbHVlOiAoX3NvdXJjZTIgPSBfc291cmNlKSAhPT0gbnVsbCAmJiBfc291cmNlMiAhPT0gdm9pZCAwID8gX3NvdXJjZTIgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgdmFsdWU6IChfcG9zaXRpb25zMiA9IF9wb3NpdGlvbnMpICE9PSBudWxsICYmIF9wb3NpdGlvbnMyICE9PSB2b2lkIDAgPyBfcG9zaXRpb25zMiA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIG9yaWdpbmFsRXJyb3I6IHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbmFsRXJyb3JcbiAgICAgIH0sXG4gICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgIC8vIENvZXJjaW5nIGZhbHN5IHZhbHVlcyB0byB1bmRlZmluZWQgZW5zdXJlcyB0aGV5IHdpbGwgbm90IGJlIGluY2x1ZGVkXG4gICAgICAgIC8vIGluIEpTT04uc3RyaW5naWZ5KCkgd2hlbiBub3QgcHJvdmlkZWQuXG4gICAgICAgIHZhbHVlOiAoX2V4dGVuc2lvbnMyID0gX2V4dGVuc2lvbnMpICE9PSBudWxsICYmIF9leHRlbnNpb25zMiAhPT0gdm9pZCAwID8gX2V4dGVuc2lvbnMyIDogdW5kZWZpbmVkLFxuICAgICAgICAvLyBCeSBiZWluZyBlbnVtZXJhYmxlLCBKU09OLnN0cmluZ2lmeSB3aWxsIGluY2x1ZGUgYHBhdGhgIGluIHRoZVxuICAgICAgICAvLyByZXN1bHRpbmcgb3V0cHV0LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgc2ltcGxlc3QgcG9zc2libGUgR3JhcGhRTFxuICAgICAgICAvLyBzZXJ2aWNlIGFkaGVyZXMgdG8gdGhlIHNwZWMuXG4gICAgICAgIGVudW1lcmFibGU6IF9leHRlbnNpb25zICE9IG51bGxcbiAgICAgIH1cbiAgICB9KTsgLy8gSW5jbHVkZSAobm9uLWVudW1lcmFibGUpIHN0YWNrIHRyYWNlLlxuXG4gICAgaWYgKG9yaWdpbmFsRXJyb3IgPT09IG51bGwgfHwgb3JpZ2luYWxFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWxFcnJvci5zdGFjaykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnc3RhY2snLCB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yLnN0YWNrLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfSAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAoU2VlOiAnaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9pc3N1ZXMvMjMxNycpXG5cblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIEdyYXBoUUxFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJ3N0YWNrJywge1xuICAgICAgICB2YWx1ZTogRXJyb3IoKS5zdGFjayxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdyYXBoUUxFcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gcHJpbnRFcnJvcih0aGlzKTtcbiAgICB9IC8vIEZJWE1FOiB3b3JrYXJvdW5kIHRvIG5vdCBicmVhayBjaGFpIGNvbXBhcmlzb25zLCBzaG91bGQgYmUgcmVtb3ZlIGluIHYxNlxuICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgY29tcHV0ZWQgcHJvcGVydGllcyB5ZXRcblxuICB9LCB7XG4gICAga2V5OiBfc3ltYm9scy5TWU1CT0xfVE9fU1RSSU5HX1RBRyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR3JhcGhRTEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbi8qKlxuICogUHJpbnRzIGEgR3JhcGhRTEVycm9yIHRvIGEgc3RyaW5nLCByZXByZXNlbnRpbmcgdXNlZnVsIGxvY2F0aW9uIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGUgZXJyb3IncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlLlxuICovXG5cblxuZXhwb3J0cy5HcmFwaFFMRXJyb3IgPSBHcmFwaFFMRXJyb3I7XG5cbmZ1bmN0aW9uIHByaW50RXJyb3IoZXJyb3IpIHtcbiAgdmFyIG91dHB1dCA9IGVycm9yLm1lc3NhZ2U7XG5cbiAgaWYgKGVycm9yLm5vZGVzKSB7XG4gICAgZm9yICh2YXIgX2kyID0gMCwgX2Vycm9yJG5vZGVzMiA9IGVycm9yLm5vZGVzOyBfaTIgPCBfZXJyb3Ikbm9kZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBub2RlID0gX2Vycm9yJG5vZGVzMltfaTJdO1xuXG4gICAgICBpZiAobm9kZS5sb2MpIHtcbiAgICAgICAgb3V0cHV0ICs9ICdcXG5cXG4nICsgKDAsIF9wcmludExvY2F0aW9uLnByaW50TG9jYXRpb24pKG5vZGUubG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZXJyb3Iuc291cmNlICYmIGVycm9yLmxvY2F0aW9ucykge1xuICAgIGZvciAodmFyIF9pNCA9IDAsIF9lcnJvciRsb2NhdGlvbnMyID0gZXJyb3IubG9jYXRpb25zOyBfaTQgPCBfZXJyb3IkbG9jYXRpb25zMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfZXJyb3IkbG9jYXRpb25zMltfaTRdO1xuICAgICAgb3V0cHV0ICs9ICdcXG5cXG4nICsgKDAsIF9wcmludExvY2F0aW9uLnByaW50U291cmNlTG9jYXRpb24pKGVycm9yLnNvdXJjZSwgbG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3ludGF4RXJyb3IgPSBzeW50YXhFcnJvcjtcblxudmFyIF9HcmFwaFFMRXJyb3IgPSByZXF1aXJlKFwiLi9HcmFwaFFMRXJyb3JcIik7XG5cbi8qKlxuICogUHJvZHVjZXMgYSBHcmFwaFFMRXJyb3IgcmVwcmVzZW50aW5nIGEgc3ludGF4IGVycm9yLCBjb250YWluaW5nIHVzZWZ1bFxuICogZGVzY3JpcHRpdmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN5bnRheCBlcnJvcidzIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIHN5bnRheEVycm9yKHNvdXJjZSwgcG9zaXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiBuZXcgX0dyYXBoUUxFcnJvci5HcmFwaFFMRXJyb3IoXCJTeW50YXggRXJyb3I6IFwiLmNvbmNhdChkZXNjcmlwdGlvbiksIHVuZGVmaW5lZCwgc291cmNlLCBbcG9zaXRpb25dKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmaW5lSW5zcGVjdDtcblxudmFyIF9pbnZhcmlhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKSk7XG5cbnZhciBfbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIGBkZWZpbmVJbnNwZWN0KClgIGZ1bmN0aW9uIGRlZmluZXMgYGluc3BlY3QoKWAgcHJvdG90eXBlIG1ldGhvZCBhcyBhbGlhcyBvZiBgdG9KU09OYFxuICovXG5mdW5jdGlvbiBkZWZpbmVJbnNwZWN0KGNsYXNzT2JqZWN0KSB7XG4gIHZhciBmbiA9IGNsYXNzT2JqZWN0LnByb3RvdHlwZS50b0pTT047XG4gIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyB8fCAoMCwgX2ludmFyaWFudC5kZWZhdWx0KSgwKTtcbiAgY2xhc3NPYmplY3QucHJvdG90eXBlLmluc3BlY3QgPSBmbjsgLy8gaXN0YW5idWwgaWdub3JlIGVsc2UgKFNlZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvaXNzdWVzLzIzMTcnKVxuXG4gIGlmIChfbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbC5kZWZhdWx0KSB7XG4gICAgY2xhc3NPYmplY3QucHJvdG90eXBlW19ub2RlanNDdXN0b21JbnNwZWN0U3ltYm9sLmRlZmF1bHRdID0gZm47XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGV2QXNzZXJ0O1xuXG5mdW5jdGlvbiBkZXZBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIHZhciBib29sZWFuQ29uZGl0aW9uID0gQm9vbGVhbihjb25kaXRpb24pOyAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAoU2VlIHRyYW5zZm9ybWF0aW9uIGRvbmUgaW4gJy4vcmVzb3VyY2VzL2lubGluZUludmFyaWFudC5qcycpXG5cbiAgaWYgKCFib29sZWFuQ29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluc3BlY3Q7XG5cbnZhciBfbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIE1BWF9BUlJBWV9MRU5HVEggPSAxMDtcbnZhciBNQVhfUkVDVVJTSVZFX0RFUFRIID0gMjtcbi8qKlxuICogVXNlZCB0byBwcmludCB2YWx1ZXMgaW4gZXJyb3IgbWVzc2FnZXMuXG4gKi9cblxuZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSkge1xuICByZXR1cm4gZm9ybWF0VmFsdWUodmFsdWUsIFtdKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHNlZW5WYWx1ZXMpIHtcbiAgc3dpdGNoIChfdHlwZW9mKHZhbHVlKSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHZhbHVlLm5hbWUgPyBcIltmdW5jdGlvbiBcIi5jb25jYXQodmFsdWUubmFtZSwgXCJdXCIpIDogJ1tmdW5jdGlvbl0nO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0T2JqZWN0VmFsdWUodmFsdWUsIHNlZW5WYWx1ZXMpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBwcmV2aW91c2x5U2VlblZhbHVlcykge1xuICBpZiAocHJldmlvdXNseVNlZW5WYWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgfVxuXG4gIHZhciBzZWVuVmFsdWVzID0gW10uY29uY2F0KHByZXZpb3VzbHlTZWVuVmFsdWVzLCBbdmFsdWVdKTtcbiAgdmFyIGN1c3RvbUluc3BlY3RGbiA9IGdldEN1c3RvbUZuKHZhbHVlKTtcblxuICBpZiAoY3VzdG9tSW5zcGVjdEZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyAkRmxvd0ZpeE1lKD49MC45MC4wKVxuICAgIHZhciBjdXN0b21WYWx1ZSA9IGN1c3RvbUluc3BlY3RGbi5jYWxsKHZhbHVlKTsgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuXG4gICAgaWYgKGN1c3RvbVZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjdXN0b21WYWx1ZSA9PT0gJ3N0cmluZycgPyBjdXN0b21WYWx1ZSA6IGZvcm1hdFZhbHVlKGN1c3RvbVZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0QXJyYXkodmFsdWUsIHNlZW5WYWx1ZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdE9iamVjdCh2YWx1ZSwgc2VlblZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChvYmplY3QsIHNlZW5WYWx1ZXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAne30nO1xuICB9XG5cbiAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gTUFYX1JFQ1VSU0lWRV9ERVBUSCkge1xuICAgIHJldHVybiAnWycgKyBnZXRPYmplY3RUYWcob2JqZWN0KSArICddJztcbiAgfVxuXG4gIHZhciBwcm9wZXJ0aWVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWx1ZSA9IGZvcm1hdFZhbHVlKG9iamVjdFtrZXldLCBzZWVuVmFsdWVzKTtcbiAgICByZXR1cm4ga2V5ICsgJzogJyArIHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuICd7ICcgKyBwcm9wZXJ0aWVzLmpvaW4oJywgJykgKyAnIH0nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgc2VlblZhbHVlcykge1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdbXSc7XG4gIH1cblxuICBpZiAoc2VlblZhbHVlcy5sZW5ndGggPiBNQVhfUkVDVVJTSVZFX0RFUFRIKSB7XG4gICAgcmV0dXJuICdbQXJyYXldJztcbiAgfVxuXG4gIHZhciBsZW4gPSBNYXRoLm1pbihNQVhfQVJSQVlfTEVOR1RILCBhcnJheS5sZW5ndGgpO1xuICB2YXIgcmVtYWluaW5nID0gYXJyYXkubGVuZ3RoIC0gbGVuO1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaXRlbXMucHVzaChmb3JtYXRWYWx1ZShhcnJheVtpXSwgc2VlblZhbHVlcykpO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZyA9PT0gMSkge1xuICAgIGl0ZW1zLnB1c2goJy4uLiAxIG1vcmUgaXRlbScpO1xuICB9IGVsc2UgaWYgKHJlbWFpbmluZyA+IDEpIHtcbiAgICBpdGVtcy5wdXNoKFwiLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgaXRlbXNcIikpO1xuICB9XG5cbiAgcmV0dXJuICdbJyArIGl0ZW1zLmpvaW4oJywgJykgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIGdldEN1c3RvbUZuKG9iamVjdCkge1xuICB2YXIgY3VzdG9tSW5zcGVjdEZuID0gb2JqZWN0W1N0cmluZyhfbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbC5kZWZhdWx0KV07XG5cbiAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY3VzdG9tSW5zcGVjdEZuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmplY3QuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvYmplY3QuaW5zcGVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPYmplY3RUYWcob2JqZWN0KSB7XG4gIHZhciB0YWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5yZXBsYWNlKC9eXFxbb2JqZWN0IC8sICcnKS5yZXBsYWNlKC9dJC8sICcnKTtcblxuICBpZiAodGFnID09PSAnT2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG5hbWUgPSBvYmplY3QuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZSAhPT0gJycpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGludmFyaWFudDtcblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICB2YXIgYm9vbGVhbkNvbmRpdGlvbiA9IEJvb2xlYW4oY29uZGl0aW9uKTsgLy8gaXN0YW5idWwgaWdub3JlIGVsc2UgKFNlZSB0cmFuc2Zvcm1hdGlvbiBkb25lIGluICcuL3Jlc291cmNlcy9pbmxpbmVJbnZhcmlhbnQuanMnKVxuXG4gIGlmICghYm9vbGVhbkNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogJ1VuZXhwZWN0ZWQgaW52YXJpYW50IHRyaWdnZXJlZC4nKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc09iamVjdExpa2U7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90XG4gKiBgbnVsbGAgYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAoU2VlOiAnaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9pc3N1ZXMvMjMxNycpXG52YXIgbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIDogdW5kZWZpbmVkO1xudmFyIF9kZWZhdWx0ID0gbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbmV4cG9ydHMuVG9rZW4gPSBleHBvcnRzLkxvY2F0aW9uID0gdm9pZCAwO1xuXG52YXIgX2RlZmluZUluc3BlY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9qc3V0aWxzL2RlZmluZUluc3BlY3RcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENvbnRhaW5zIGEgcmFuZ2Ugb2YgVVRGLTggY2hhcmFjdGVyIG9mZnNldHMgYW5kIHRva2VuIHJlZmVyZW5jZXMgdGhhdFxuICogaWRlbnRpZnkgdGhlIHJlZ2lvbiBvZiB0aGUgc291cmNlIGZyb20gd2hpY2ggdGhlIEFTVCBkZXJpdmVkLlxuICovXG52YXIgTG9jYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIFRva2VuIGF0IHdoaWNoIHRoaXMgTm9kZSBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgVG9rZW4gYXQgd2hpY2ggdGhpcyBOb2RlIGVuZHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgU291cmNlIGRvY3VtZW50IHRoZSBBU1QgcmVwcmVzZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIExvY2F0aW9uKHN0YXJ0VG9rZW4sIGVuZFRva2VuLCBzb3VyY2UpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRUb2tlbi5zdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZFRva2VuLmVuZDtcbiAgICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgIHRoaXMuZW5kVG9rZW4gPSBlbmRUb2tlbjtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2NhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuZW5kXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gTG9jYXRpb247XG59KCk7IC8vIFByaW50IGEgc2ltcGxpZmllZCBmb3JtIHdoZW4gYXBwZWFyaW5nIGluIGBpbnNwZWN0YCBhbmQgYHV0aWwuaW5zcGVjdGAuXG5cblxuZXhwb3J0cy5Mb2NhdGlvbiA9IExvY2F0aW9uO1xuKDAsIF9kZWZpbmVJbnNwZWN0LmRlZmF1bHQpKExvY2F0aW9uKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHJhbmdlIG9mIGNoYXJhY3RlcnMgcmVwcmVzZW50ZWQgYnkgYSBsZXhpY2FsIHRva2VuXG4gKiB3aXRoaW4gYSBTb3VyY2UuXG4gKi9cblxudmFyIFRva2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIFRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIDEtaW5kZXhlZCBsaW5lIG51bWJlciBvbiB3aGljaCB0aGlzIFRva2VuIGFwcGVhcnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgMS1pbmRleGVkIGNvbHVtbiBudW1iZXIgYXQgd2hpY2ggdGhpcyBUb2tlbiBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGb3Igbm9uLXB1bmN0dWF0aW9uIHRva2VucywgcmVwcmVzZW50cyB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUgb2YgdGhlIHRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVG9rZW5zIGV4aXN0IGFzIG5vZGVzIGluIGEgZG91YmxlLWxpbmtlZC1saXN0IGFtb25nc3QgYWxsIHRva2Vuc1xuICAgKiBpbmNsdWRpbmcgaWdub3JlZCB0b2tlbnMuIDxTT0Y+IGlzIGFsd2F5cyB0aGUgZmlyc3Qgbm9kZSBhbmQgPEVPRj5cbiAgICogdGhlIGxhc3QuXG4gICAqL1xuICBmdW5jdGlvbiBUb2tlbihraW5kLCBzdGFydCwgZW5kLCBsaW5lLCBjb2x1bW4sIHByZXYsIHZhbHVlKSB7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBUb2tlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgY29sdW1uOiB0aGlzLmNvbHVtblxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIFRva2VuO1xufSgpOyAvLyBQcmludCBhIHNpbXBsaWZpZWQgZm9ybSB3aGVuIGFwcGVhcmluZyBpbiBgaW5zcGVjdGAgYW5kIGB1dGlsLmluc3BlY3RgLlxuXG5cbmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbigwLCBfZGVmaW5lSW5zcGVjdC5kZWZhdWx0KShUb2tlbik7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmZ1bmN0aW9uIGlzTm9kZShtYXliZU5vZGUpIHtcbiAgcmV0dXJuIG1heWJlTm9kZSAhPSBudWxsICYmIHR5cGVvZiBtYXliZU5vZGUua2luZCA9PT0gJ3N0cmluZyc7XG59XG4vKipcbiAqIFRoZSBsaXN0IG9mIGFsbCBwb3NzaWJsZSBBU1Qgbm9kZSB0eXBlcy5cbiAqL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZGVudEJsb2NrU3RyaW5nVmFsdWUgPSBkZWRlbnRCbG9ja1N0cmluZ1ZhbHVlO1xuZXhwb3J0cy5nZXRCbG9ja1N0cmluZ0luZGVudGF0aW9uID0gZ2V0QmxvY2tTdHJpbmdJbmRlbnRhdGlvbjtcbmV4cG9ydHMucHJpbnRCbG9ja1N0cmluZyA9IHByaW50QmxvY2tTdHJpbmc7XG5cbi8qKlxuICogUHJvZHVjZXMgdGhlIHZhbHVlIG9mIGEgYmxvY2sgc3RyaW5nIGZyb20gaXRzIHBhcnNlZCByYXcgdmFsdWUsIHNpbWlsYXIgdG9cbiAqIENvZmZlZVNjcmlwdCdzIGJsb2NrIHN0cmluZywgUHl0aG9uJ3MgZG9jc3RyaW5nIHRyaW0gb3IgUnVieSdzIHN0cmlwX2hlcmVkb2MuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIHRoZSBHcmFwaFFMIHNwZWMncyBCbG9ja1N0cmluZ1ZhbHVlKCkgc3RhdGljIGFsZ29yaXRobS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVkZW50QmxvY2tTdHJpbmdWYWx1ZShyYXdTdHJpbmcpIHtcbiAgLy8gRXhwYW5kIGEgYmxvY2sgc3RyaW5nJ3MgcmF3IHZhbHVlIGludG8gaW5kZXBlbmRlbnQgbGluZXMuXG4gIHZhciBsaW5lcyA9IHJhd1N0cmluZy5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpOyAvLyBSZW1vdmUgY29tbW9uIGluZGVudGF0aW9uIGZyb20gYWxsIGxpbmVzIGJ1dCBmaXJzdC5cblxuICB2YXIgY29tbW9uSW5kZW50ID0gZ2V0QmxvY2tTdHJpbmdJbmRlbnRhdGlvbihsaW5lcyk7XG5cbiAgaWYgKGNvbW1vbkluZGVudCAhPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0uc2xpY2UoY29tbW9uSW5kZW50KTtcbiAgICB9XG4gIH0gLy8gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIGJsYW5rIGxpbmVzLlxuXG5cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCA+IDAgJiYgaXNCbGFuayhsaW5lc1swXSkpIHtcbiAgICBsaW5lcy5zaGlmdCgpO1xuICB9XG5cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCA+IDAgJiYgaXNCbGFuayhsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkpIHtcbiAgICBsaW5lcy5wb3AoKTtcbiAgfSAvLyBSZXR1cm4gYSBzdHJpbmcgb2YgdGhlIGxpbmVzIGpvaW5lZCB3aXRoIFUrMDAwQS5cblxuXG4gIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCbG9ja1N0cmluZ0luZGVudGF0aW9uKGxpbmVzKSB7XG4gIHZhciBjb21tb25JbmRlbnQgPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgIHZhciBpbmRlbnQgPSBsZWFkaW5nV2hpdGVzcGFjZShsaW5lKTtcblxuICAgIGlmIChpbmRlbnQgPT09IGxpbmUubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTsgLy8gc2tpcCBlbXB0eSBsaW5lc1xuICAgIH1cblxuICAgIGlmIChjb21tb25JbmRlbnQgPT09IG51bGwgfHwgaW5kZW50IDwgY29tbW9uSW5kZW50KSB7XG4gICAgICBjb21tb25JbmRlbnQgPSBpbmRlbnQ7XG5cbiAgICAgIGlmIChjb21tb25JbmRlbnQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbW1vbkluZGVudCA9PT0gbnVsbCA/IDAgOiBjb21tb25JbmRlbnQ7XG59XG5cbmZ1bmN0aW9uIGxlYWRpbmdXaGl0ZXNwYWNlKHN0cikge1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoICYmIChzdHJbaV0gPT09ICcgJyB8fCBzdHJbaV0gPT09ICdcXHQnKSkge1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBpc0JsYW5rKHN0cikge1xuICByZXR1cm4gbGVhZGluZ1doaXRlc3BhY2Uoc3RyKSA9PT0gc3RyLmxlbmd0aDtcbn1cbi8qKlxuICogUHJpbnQgYSBibG9jayBzdHJpbmcgaW4gdGhlIGluZGVudGVkIGJsb2NrIGZvcm0gYnkgYWRkaW5nIGEgbGVhZGluZyBhbmRcbiAqIHRyYWlsaW5nIGJsYW5rIGxpbmUuIEhvd2V2ZXIsIGlmIGEgYmxvY2sgc3RyaW5nIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UgYW5kIGlzXG4gKiBhIHNpbmdsZS1saW5lLCBhZGRpbmcgYSBsZWFkaW5nIGJsYW5rIGxpbmUgd291bGQgc3RyaXAgdGhhdCB3aGl0ZXNwYWNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gcHJpbnRCbG9ja1N0cmluZyh2YWx1ZSkge1xuICB2YXIgaW5kZW50YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICB2YXIgcHJlZmVyTXVsdGlwbGVMaW5lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBpc1NpbmdsZUxpbmUgPSB2YWx1ZS5pbmRleE9mKCdcXG4nKSA9PT0gLTE7XG4gIHZhciBoYXNMZWFkaW5nU3BhY2UgPSB2YWx1ZVswXSA9PT0gJyAnIHx8IHZhbHVlWzBdID09PSAnXFx0JztcbiAgdmFyIGhhc1RyYWlsaW5nUXVvdGUgPSB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJztcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnO1xuICB2YXIgcHJpbnRBc011bHRpcGxlTGluZXMgPSAhaXNTaW5nbGVMaW5lIHx8IGhhc1RyYWlsaW5nUXVvdGUgfHwgaGFzVHJhaWxpbmdTbGFzaCB8fCBwcmVmZXJNdWx0aXBsZUxpbmVzO1xuICB2YXIgcmVzdWx0ID0gJyc7IC8vIEZvcm1hdCBhIG11bHRpLWxpbmUgYmxvY2sgcXVvdGUgdG8gYWNjb3VudCBmb3IgbGVhZGluZyBzcGFjZS5cblxuICBpZiAocHJpbnRBc011bHRpcGxlTGluZXMgJiYgIShpc1NpbmdsZUxpbmUgJiYgaGFzTGVhZGluZ1NwYWNlKSkge1xuICAgIHJlc3VsdCArPSAnXFxuJyArIGluZGVudGF0aW9uO1xuICB9XG5cbiAgcmVzdWx0ICs9IGluZGVudGF0aW9uID8gdmFsdWUucmVwbGFjZSgvXFxuL2csICdcXG4nICsgaW5kZW50YXRpb24pIDogdmFsdWU7XG5cbiAgaWYgKHByaW50QXNNdWx0aXBsZUxpbmVzKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgcmV0dXJuICdcIlwiXCInICsgcmVzdWx0LnJlcGxhY2UoL1wiXCJcIi9nLCAnXFxcXFwiXCJcIicpICsgJ1wiXCJcIic7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGlyZWN0aXZlTG9jYXRpb24gPSB2b2lkIDA7XG5cbi8qKlxuICogVGhlIHNldCBvZiBhbGxvd2VkIGRpcmVjdGl2ZSBsb2NhdGlvbiB2YWx1ZXMuXG4gKi9cbnZhciBEaXJlY3RpdmVMb2NhdGlvbiA9IE9iamVjdC5mcmVlemUoe1xuICAvLyBSZXF1ZXN0IERlZmluaXRpb25zXG4gIFFVRVJZOiAnUVVFUlknLFxuICBNVVRBVElPTjogJ01VVEFUSU9OJyxcbiAgU1VCU0NSSVBUSU9OOiAnU1VCU0NSSVBUSU9OJyxcbiAgRklFTEQ6ICdGSUVMRCcsXG4gIEZSQUdNRU5UX0RFRklOSVRJT046ICdGUkFHTUVOVF9ERUZJTklUSU9OJyxcbiAgRlJBR01FTlRfU1BSRUFEOiAnRlJBR01FTlRfU1BSRUFEJyxcbiAgSU5MSU5FX0ZSQUdNRU5UOiAnSU5MSU5FX0ZSQUdNRU5UJyxcbiAgVkFSSUFCTEVfREVGSU5JVElPTjogJ1ZBUklBQkxFX0RFRklOSVRJT04nLFxuICAvLyBUeXBlIFN5c3RlbSBEZWZpbml0aW9uc1xuICBTQ0hFTUE6ICdTQ0hFTUEnLFxuICBTQ0FMQVI6ICdTQ0FMQVInLFxuICBPQkpFQ1Q6ICdPQkpFQ1QnLFxuICBGSUVMRF9ERUZJTklUSU9OOiAnRklFTERfREVGSU5JVElPTicsXG4gIEFSR1VNRU5UX0RFRklOSVRJT046ICdBUkdVTUVOVF9ERUZJTklUSU9OJyxcbiAgSU5URVJGQUNFOiAnSU5URVJGQUNFJyxcbiAgVU5JT046ICdVTklPTicsXG4gIEVOVU06ICdFTlVNJyxcbiAgRU5VTV9WQUxVRTogJ0VOVU1fVkFMVUUnLFxuICBJTlBVVF9PQkpFQ1Q6ICdJTlBVVF9PQkpFQ1QnLFxuICBJTlBVVF9GSUVMRF9ERUZJTklUSU9OOiAnSU5QVVRfRklFTERfREVGSU5JVElPTidcbn0pO1xuLyoqXG4gKiBUaGUgZW51bSB0eXBlIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aXZlIGxvY2F0aW9uIHZhbHVlcy5cbiAqL1xuXG5leHBvcnRzLkRpcmVjdGl2ZUxvY2F0aW9uID0gRGlyZWN0aXZlTG9jYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuS2luZCA9IHZvaWQgMDtcblxuLyoqXG4gKiBUaGUgc2V0IG9mIGFsbG93ZWQga2luZCB2YWx1ZXMgZm9yIEFTVCBub2Rlcy5cbiAqL1xudmFyIEtpbmQgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gTmFtZVxuICBOQU1FOiAnTmFtZScsXG4gIC8vIERvY3VtZW50XG4gIERPQ1VNRU5UOiAnRG9jdW1lbnQnLFxuICBPUEVSQVRJT05fREVGSU5JVElPTjogJ09wZXJhdGlvbkRlZmluaXRpb24nLFxuICBWQVJJQUJMRV9ERUZJTklUSU9OOiAnVmFyaWFibGVEZWZpbml0aW9uJyxcbiAgU0VMRUNUSU9OX1NFVDogJ1NlbGVjdGlvblNldCcsXG4gIEZJRUxEOiAnRmllbGQnLFxuICBBUkdVTUVOVDogJ0FyZ3VtZW50JyxcbiAgLy8gRnJhZ21lbnRzXG4gIEZSQUdNRU5UX1NQUkVBRDogJ0ZyYWdtZW50U3ByZWFkJyxcbiAgSU5MSU5FX0ZSQUdNRU5UOiAnSW5saW5lRnJhZ21lbnQnLFxuICBGUkFHTUVOVF9ERUZJTklUSU9OOiAnRnJhZ21lbnREZWZpbml0aW9uJyxcbiAgLy8gVmFsdWVzXG4gIFZBUklBQkxFOiAnVmFyaWFibGUnLFxuICBJTlQ6ICdJbnRWYWx1ZScsXG4gIEZMT0FUOiAnRmxvYXRWYWx1ZScsXG4gIFNUUklORzogJ1N0cmluZ1ZhbHVlJyxcbiAgQk9PTEVBTjogJ0Jvb2xlYW5WYWx1ZScsXG4gIE5VTEw6ICdOdWxsVmFsdWUnLFxuICBFTlVNOiAnRW51bVZhbHVlJyxcbiAgTElTVDogJ0xpc3RWYWx1ZScsXG4gIE9CSkVDVDogJ09iamVjdFZhbHVlJyxcbiAgT0JKRUNUX0ZJRUxEOiAnT2JqZWN0RmllbGQnLFxuICAvLyBEaXJlY3RpdmVzXG4gIERJUkVDVElWRTogJ0RpcmVjdGl2ZScsXG4gIC8vIFR5cGVzXG4gIE5BTUVEX1RZUEU6ICdOYW1lZFR5cGUnLFxuICBMSVNUX1RZUEU6ICdMaXN0VHlwZScsXG4gIE5PTl9OVUxMX1RZUEU6ICdOb25OdWxsVHlwZScsXG4gIC8vIFR5cGUgU3lzdGVtIERlZmluaXRpb25zXG4gIFNDSEVNQV9ERUZJTklUSU9OOiAnU2NoZW1hRGVmaW5pdGlvbicsXG4gIE9QRVJBVElPTl9UWVBFX0RFRklOSVRJT046ICdPcGVyYXRpb25UeXBlRGVmaW5pdGlvbicsXG4gIC8vIFR5cGUgRGVmaW5pdGlvbnNcbiAgU0NBTEFSX1RZUEVfREVGSU5JVElPTjogJ1NjYWxhclR5cGVEZWZpbml0aW9uJyxcbiAgT0JKRUNUX1RZUEVfREVGSU5JVElPTjogJ09iamVjdFR5cGVEZWZpbml0aW9uJyxcbiAgRklFTERfREVGSU5JVElPTjogJ0ZpZWxkRGVmaW5pdGlvbicsXG4gIElOUFVUX1ZBTFVFX0RFRklOSVRJT046ICdJbnB1dFZhbHVlRGVmaW5pdGlvbicsXG4gIElOVEVSRkFDRV9UWVBFX0RFRklOSVRJT046ICdJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbicsXG4gIFVOSU9OX1RZUEVfREVGSU5JVElPTjogJ1VuaW9uVHlwZURlZmluaXRpb24nLFxuICBFTlVNX1RZUEVfREVGSU5JVElPTjogJ0VudW1UeXBlRGVmaW5pdGlvbicsXG4gIEVOVU1fVkFMVUVfREVGSU5JVElPTjogJ0VudW1WYWx1ZURlZmluaXRpb24nLFxuICBJTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OOiAnSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbicsXG4gIC8vIERpcmVjdGl2ZSBEZWZpbml0aW9uc1xuICBESVJFQ1RJVkVfREVGSU5JVElPTjogJ0RpcmVjdGl2ZURlZmluaXRpb24nLFxuICAvLyBUeXBlIFN5c3RlbSBFeHRlbnNpb25zXG4gIFNDSEVNQV9FWFRFTlNJT046ICdTY2hlbWFFeHRlbnNpb24nLFxuICAvLyBUeXBlIEV4dGVuc2lvbnNcbiAgU0NBTEFSX1RZUEVfRVhURU5TSU9OOiAnU2NhbGFyVHlwZUV4dGVuc2lvbicsXG4gIE9CSkVDVF9UWVBFX0VYVEVOU0lPTjogJ09iamVjdFR5cGVFeHRlbnNpb24nLFxuICBJTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT046ICdJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uJyxcbiAgVU5JT05fVFlQRV9FWFRFTlNJT046ICdVbmlvblR5cGVFeHRlbnNpb24nLFxuICBFTlVNX1RZUEVfRVhURU5TSU9OOiAnRW51bVR5cGVFeHRlbnNpb24nLFxuICBJTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT046ICdJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24nXG59KTtcbi8qKlxuICogVGhlIGVudW0gdHlwZSByZXByZXNlbnRpbmcgdGhlIHBvc3NpYmxlIGtpbmQgdmFsdWVzIG9mIEFTVCBub2Rlcy5cbiAqL1xuXG5leHBvcnRzLktpbmQgPSBLaW5kO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzUHVuY3R1YXRvclRva2VuS2luZCA9IGlzUHVuY3R1YXRvclRva2VuS2luZDtcbmV4cG9ydHMuTGV4ZXIgPSB2b2lkIDA7XG5cbnZhciBfc3ludGF4RXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3Ivc3ludGF4RXJyb3JcIik7XG5cbnZhciBfYXN0ID0gcmVxdWlyZShcIi4vYXN0XCIpO1xuXG52YXIgX3Rva2VuS2luZCA9IHJlcXVpcmUoXCIuL3Rva2VuS2luZFwiKTtcblxudmFyIF9ibG9ja1N0cmluZyA9IHJlcXVpcmUoXCIuL2Jsb2NrU3RyaW5nXCIpO1xuXG4vKipcbiAqIEdpdmVuIGEgU291cmNlIG9iamVjdCwgY3JlYXRlcyBhIExleGVyIGZvciB0aGF0IHNvdXJjZS5cbiAqIEEgTGV4ZXIgaXMgYSBzdGF0ZWZ1bCBzdHJlYW0gZ2VuZXJhdG9yIGluIHRoYXQgZXZlcnkgdGltZVxuICogaXQgaXMgYWR2YW5jZWQsIGl0IHJldHVybnMgdGhlIG5leHQgdG9rZW4gaW4gdGhlIFNvdXJjZS4gQXNzdW1pbmcgdGhlXG4gKiBzb3VyY2UgbGV4ZXMsIHRoZSBmaW5hbCBUb2tlbiBlbWl0dGVkIGJ5IHRoZSBsZXhlciB3aWxsIGJlIG9mIGtpbmRcbiAqIEVPRiwgYWZ0ZXIgd2hpY2ggdGhlIGxleGVyIHdpbGwgcmVwZWF0ZWRseSByZXR1cm4gdGhlIHNhbWUgRU9GIHRva2VuXG4gKiB3aGVuZXZlciBjYWxsZWQuXG4gKi9cbnZhciBMZXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXNseSBmb2N1c2VkIG5vbi1pZ25vcmVkIHRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBmb2N1c2VkIG5vbi1pZ25vcmVkIHRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlICgxLWluZGV4ZWQpIGxpbmUgY29udGFpbmluZyB0aGUgY3VycmVudCB0b2tlbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoZSBjdXJyZW50IGxpbmUgYmVnaW5zLlxuICAgKi9cbiAgZnVuY3Rpb24gTGV4ZXIoc291cmNlKSB7XG4gICAgdmFyIHN0YXJ0T2ZGaWxlVG9rZW4gPSBuZXcgX2FzdC5Ub2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5TT0YsIDAsIDAsIDAsIDAsIG51bGwpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMubGFzdFRva2VuID0gc3RhcnRPZkZpbGVUb2tlbjtcbiAgICB0aGlzLnRva2VuID0gc3RhcnRPZkZpbGVUb2tlbjtcbiAgICB0aGlzLmxpbmUgPSAxO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgfVxuICAvKipcbiAgICogQWR2YW5jZXMgdGhlIHRva2VuIHN0cmVhbSB0byB0aGUgbmV4dCBub24taWdub3JlZCB0b2tlbi5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTGV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICB0aGlzLmxhc3RUb2tlbiA9IHRoaXMudG9rZW47XG4gICAgdmFyIHRva2VuID0gdGhpcy50b2tlbiA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIC8qKlxuICAgKiBMb29rcyBhaGVhZCBhbmQgcmV0dXJucyB0aGUgbmV4dCBub24taWdub3JlZCB0b2tlbiwgYnV0IGRvZXMgbm90IGNoYW5nZVxuICAgKiB0aGUgc3RhdGUgb2YgTGV4ZXIuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCgpIHtcbiAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgIT09IF90b2tlbktpbmQuVG9rZW5LaW5kLkVPRikge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgX3Rva2VuJG5leHQ7XG5cbiAgICAgICAgLy8gTm90ZTogbmV4dCBpcyBvbmx5IG11dGFibGUgZHVyaW5nIHBhcnNpbmcsIHNvIHdlIGNhc3QgdG8gYWxsb3cgdGhpcy5cbiAgICAgICAgdG9rZW4gPSAoX3Rva2VuJG5leHQgPSB0b2tlbi5uZXh0KSAhPT0gbnVsbCAmJiBfdG9rZW4kbmV4dCAhPT0gdm9pZCAwID8gX3Rva2VuJG5leHQgOiB0b2tlbi5uZXh0ID0gcmVhZFRva2VuKHRoaXMsIHRva2VuKTtcbiAgICAgIH0gd2hpbGUgKHRva2VuLmtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLkNPTU1FTlQpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbjtcbiAgfTtcblxuICByZXR1cm4gTGV4ZXI7XG59KCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZXhwb3J0cy5MZXhlciA9IExleGVyO1xuXG5mdW5jdGlvbiBpc1B1bmN0dWF0b3JUb2tlbktpbmQoa2luZCkge1xuICByZXR1cm4ga2luZCA9PT0gX3Rva2VuS2luZC5Ub2tlbktpbmQuQkFORyB8fCBraW5kID09PSBfdG9rZW5LaW5kLlRva2VuS2luZC5ET0xMQVIgfHwga2luZCA9PT0gX3Rva2VuS2luZC5Ub2tlbktpbmQuQU1QIHx8IGtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLlBBUkVOX0wgfHwga2luZCA9PT0gX3Rva2VuS2luZC5Ub2tlbktpbmQuUEFSRU5fUiB8fCBraW5kID09PSBfdG9rZW5LaW5kLlRva2VuS2luZC5TUFJFQUQgfHwga2luZCA9PT0gX3Rva2VuS2luZC5Ub2tlbktpbmQuQ09MT04gfHwga2luZCA9PT0gX3Rva2VuS2luZC5Ub2tlbktpbmQuRVFVQUxTIHx8IGtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLkFUIHx8IGtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNLRVRfTCB8fCBraW5kID09PSBfdG9rZW5LaW5kLlRva2VuS2luZC5CUkFDS0VUX1IgfHwga2luZCA9PT0gX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfTCB8fCBraW5kID09PSBfdG9rZW5LaW5kLlRva2VuS2luZC5QSVBFIHx8IGtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX1I7XG59XG5cbmZ1bmN0aW9uIHByaW50Q2hhckNvZGUoY29kZSkge1xuICByZXR1cm4gKC8vIE5hTi91bmRlZmluZWQgcmVwcmVzZW50cyBhY2Nlc3MgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgaXNOYU4oY29kZSkgPyBfdG9rZW5LaW5kLlRva2VuS2luZC5FT0YgOiAvLyBUcnVzdCBKU09OIGZvciBBU0NJSS5cbiAgICBjb2RlIDwgMHgwMDdmID8gSlNPTi5zdHJpbmdpZnkoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgOiAvLyBPdGhlcndpc2UgcHJpbnQgdGhlIGVzY2FwZWQgZm9ybS5cbiAgICBcIlxcXCJcXFxcdVwiLmNvbmNhdCgoJzAwJyArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KSwgXCJcXFwiXCIpXG4gICk7XG59XG4vKipcbiAqIEdldHMgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgc291cmNlIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAqXG4gKiBUaGlzIHNraXBzIG92ZXIgd2hpdGVzcGFjZSB1bnRpbCBpdCBmaW5kcyB0aGUgbmV4dCBsZXhhYmxlIHRva2VuLCB0aGVuIGxleGVzXG4gKiBwdW5jdHVhdG9ycyBpbW1lZGlhdGVseSBvciBjYWxscyB0aGUgYXBwcm9wcmlhdGUgaGVscGVyIGZ1bmN0aW9uIGZvciBtb3JlXG4gKiBjb21wbGljYXRlZCB0b2tlbnMuXG4gKi9cblxuXG5mdW5jdGlvbiByZWFkVG9rZW4obGV4ZXIsIHByZXYpIHtcbiAgdmFyIHNvdXJjZSA9IGxleGVyLnNvdXJjZTtcbiAgdmFyIGJvZHkgPSBzb3VyY2UuYm9keTtcbiAgdmFyIGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgdmFyIHBvcyA9IHBvc2l0aW9uQWZ0ZXJXaGl0ZXNwYWNlKGJvZHksIHByZXYuZW5kLCBsZXhlcik7XG4gIHZhciBsaW5lID0gbGV4ZXIubGluZTtcbiAgdmFyIGNvbCA9IDEgKyBwb3MgLSBsZXhlci5saW5lU3RhcnQ7XG5cbiAgaWYgKHBvcyA+PSBib2R5TGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkVPRiwgYm9keUxlbmd0aCwgYm9keUxlbmd0aCwgbGluZSwgY29sLCBwcmV2KTtcbiAgfVxuXG4gIHZhciBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvcyk7IC8vIFNvdXJjZUNoYXJhY3RlclxuXG4gIHN3aXRjaCAoY29kZSkge1xuICAgIC8vICFcbiAgICBjYXNlIDMzOlxuICAgICAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkJBTkcsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyAjXG5cbiAgICBjYXNlIDM1OlxuICAgICAgcmV0dXJuIHJlYWRDb21tZW50KHNvdXJjZSwgcG9zLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vICRcblxuICAgIGNhc2UgMzY6XG4gICAgICByZXR1cm4gbmV3IF9hc3QuVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuRE9MTEFSLCBwb3MsIHBvcyArIDEsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8gJlxuXG4gICAgY2FzZSAzODpcbiAgICAgIHJldHVybiBuZXcgX2FzdC5Ub2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5BTVAsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyAoXG5cbiAgICBjYXNlIDQwOlxuICAgICAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLlBBUkVOX0wsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyApXG5cbiAgICBjYXNlIDQxOlxuICAgICAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLlBBUkVOX1IsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyAuXG5cbiAgICBjYXNlIDQ2OlxuICAgICAgaWYgKGJvZHkuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDYgJiYgYm9keS5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA0Nikge1xuICAgICAgICByZXR1cm4gbmV3IF9hc3QuVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuU1BSRUFELCBwb3MsIHBvcyArIDMsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIC8vIDpcblxuICAgIGNhc2UgNTg6XG4gICAgICByZXR1cm4gbmV3IF9hc3QuVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQ09MT04sIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyA9XG5cbiAgICBjYXNlIDYxOlxuICAgICAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkVRVUFMUywgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIEBcblxuICAgIGNhc2UgNjQ6XG4gICAgICByZXR1cm4gbmV3IF9hc3QuVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQVQsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyBbXG5cbiAgICBjYXNlIDkxOlxuICAgICAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNLRVRfTCwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIF1cblxuICAgIGNhc2UgOTM6XG4gICAgICByZXR1cm4gbmV3IF9hc3QuVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0tFVF9SLCBwb3MsIHBvcyArIDEsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8ge1xuXG4gICAgY2FzZSAxMjM6XG4gICAgICByZXR1cm4gbmV3IF9hc3QuVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfTCwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIHxcblxuICAgIGNhc2UgMTI0OlxuICAgICAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLlBJUEUsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyB9XG5cbiAgICBjYXNlIDEyNTpcbiAgICAgIHJldHVybiBuZXcgX2FzdC5Ub2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5CUkFDRV9SLCBwb3MsIHBvcyArIDEsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8gQS1aIF8gYS16XG5cbiAgICBjYXNlIDY1OlxuICAgIGNhc2UgNjY6XG4gICAgY2FzZSA2NzpcbiAgICBjYXNlIDY4OlxuICAgIGNhc2UgNjk6XG4gICAgY2FzZSA3MDpcbiAgICBjYXNlIDcxOlxuICAgIGNhc2UgNzI6XG4gICAgY2FzZSA3MzpcbiAgICBjYXNlIDc0OlxuICAgIGNhc2UgNzU6XG4gICAgY2FzZSA3NjpcbiAgICBjYXNlIDc3OlxuICAgIGNhc2UgNzg6XG4gICAgY2FzZSA3OTpcbiAgICBjYXNlIDgwOlxuICAgIGNhc2UgODE6XG4gICAgY2FzZSA4MjpcbiAgICBjYXNlIDgzOlxuICAgIGNhc2UgODQ6XG4gICAgY2FzZSA4NTpcbiAgICBjYXNlIDg2OlxuICAgIGNhc2UgODc6XG4gICAgY2FzZSA4ODpcbiAgICBjYXNlIDg5OlxuICAgIGNhc2UgOTA6XG4gICAgY2FzZSA5NTpcbiAgICBjYXNlIDk3OlxuICAgIGNhc2UgOTg6XG4gICAgY2FzZSA5OTpcbiAgICBjYXNlIDEwMDpcbiAgICBjYXNlIDEwMTpcbiAgICBjYXNlIDEwMjpcbiAgICBjYXNlIDEwMzpcbiAgICBjYXNlIDEwNDpcbiAgICBjYXNlIDEwNTpcbiAgICBjYXNlIDEwNjpcbiAgICBjYXNlIDEwNzpcbiAgICBjYXNlIDEwODpcbiAgICBjYXNlIDEwOTpcbiAgICBjYXNlIDExMDpcbiAgICBjYXNlIDExMTpcbiAgICBjYXNlIDExMjpcbiAgICBjYXNlIDExMzpcbiAgICBjYXNlIDExNDpcbiAgICBjYXNlIDExNTpcbiAgICBjYXNlIDExNjpcbiAgICBjYXNlIDExNzpcbiAgICBjYXNlIDExODpcbiAgICBjYXNlIDExOTpcbiAgICBjYXNlIDEyMDpcbiAgICBjYXNlIDEyMTpcbiAgICBjYXNlIDEyMjpcbiAgICAgIHJldHVybiByZWFkTmFtZShzb3VyY2UsIHBvcywgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyAtIDAtOVxuXG4gICAgY2FzZSA0NTpcbiAgICBjYXNlIDQ4OlxuICAgIGNhc2UgNDk6XG4gICAgY2FzZSA1MDpcbiAgICBjYXNlIDUxOlxuICAgIGNhc2UgNTI6XG4gICAgY2FzZSA1MzpcbiAgICBjYXNlIDU0OlxuICAgIGNhc2UgNTU6XG4gICAgY2FzZSA1NjpcbiAgICBjYXNlIDU3OlxuICAgICAgcmV0dXJuIHJlYWROdW1iZXIoc291cmNlLCBwb3MsIGNvZGUsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8gXCJcblxuICAgIGNhc2UgMzQ6XG4gICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAzNCAmJiBib2R5LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDM0KSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvY2tTdHJpbmcoc291cmNlLCBwb3MsIGxpbmUsIGNvbCwgcHJldiwgbGV4ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZFN0cmluZyhzb3VyY2UsIHBvcywgbGluZSwgY29sLCBwcmV2KTtcbiAgfVxuXG4gIHRocm93ICgwLCBfc3ludGF4RXJyb3Iuc3ludGF4RXJyb3IpKHNvdXJjZSwgcG9zLCB1bmV4cGVjdGVkQ2hhcmFjdGVyTWVzc2FnZShjb2RlKSk7XG59XG4vKipcbiAqIFJlcG9ydCBhIG1lc3NhZ2UgdGhhdCBhbiB1bmV4cGVjdGVkIGNoYXJhY3RlciB3YXMgZW5jb3VudGVyZWQuXG4gKi9cblxuXG5mdW5jdGlvbiB1bmV4cGVjdGVkQ2hhcmFjdGVyTWVzc2FnZShjb2RlKSB7XG4gIGlmIChjb2RlIDwgMHgwMDIwICYmIGNvZGUgIT09IDB4MDAwOSAmJiBjb2RlICE9PSAweDAwMGEgJiYgY29kZSAhPT0gMHgwMDBkKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGNvbnRhaW4gdGhlIGludmFsaWQgY2hhcmFjdGVyIFwiLmNvbmNhdChwcmludENoYXJDb2RlKGNvZGUpLCBcIi5cIik7XG4gIH1cblxuICBpZiAoY29kZSA9PT0gMzkpIHtcbiAgICAvLyAnXG4gICAgcmV0dXJuICdVbmV4cGVjdGVkIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXIgKFxcJyksIGRpZCB5b3UgbWVhbiB0byB1c2UgYSBkb3VibGUgcXVvdGUgKFwiKT8nO1xuICB9XG5cbiAgcmV0dXJuIFwiQ2Fubm90IHBhcnNlIHRoZSB1bmV4cGVjdGVkIGNoYXJhY3RlciBcIi5jb25jYXQocHJpbnRDaGFyQ29kZShjb2RlKSwgXCIuXCIpO1xufVxuLyoqXG4gKiBSZWFkcyBmcm9tIGJvZHkgc3RhcnRpbmcgYXQgc3RhcnRQb3NpdGlvbiB1bnRpbCBpdCBmaW5kcyBhIG5vbi13aGl0ZXNwYWNlXG4gKiBjaGFyYWN0ZXIsIHRoZW4gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhhdCBjaGFyYWN0ZXIgZm9yIGxleGluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBvc2l0aW9uQWZ0ZXJXaGl0ZXNwYWNlKGJvZHksIHN0YXJ0UG9zaXRpb24sIGxleGVyKSB7XG4gIHZhciBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIHZhciBwb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIHZhciBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTsgLy8gdGFiIHwgc3BhY2UgfCBjb21tYSB8IEJPTVxuXG4gICAgaWYgKGNvZGUgPT09IDkgfHwgY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gNDQgfHwgY29kZSA9PT0gMHhmZWZmKSB7XG4gICAgICArK3Bvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMTApIHtcbiAgICAgIC8vIG5ldyBsaW5lXG4gICAgICArK3Bvc2l0aW9uO1xuICAgICAgKytsZXhlci5saW5lO1xuICAgICAgbGV4ZXIubGluZVN0YXJ0ID0gcG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAxMykge1xuICAgICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDEwKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3Bvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICArK2xleGVyLmxpbmU7XG4gICAgICBsZXhlci5saW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuLyoqXG4gKiBSZWFkcyBhIGNvbW1lbnQgdG9rZW4gZnJvbSB0aGUgc291cmNlIGZpbGUuXG4gKlxuICogI1tcXHUwMDA5XFx1MDAyMC1cXHVGRkZGXSpcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlYWRDb21tZW50KHNvdXJjZSwgc3RhcnQsIGxpbmUsIGNvbCwgcHJldikge1xuICB2YXIgYm9keSA9IHNvdXJjZS5ib2R5O1xuICB2YXIgY29kZTtcbiAgdmFyIHBvc2l0aW9uID0gc3RhcnQ7XG5cbiAgZG8ge1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG4gIH0gd2hpbGUgKCFpc05hTihjb2RlKSAmJiAoIC8vIFNvdXJjZUNoYXJhY3RlciBidXQgbm90IExpbmVUZXJtaW5hdG9yXG4gIGNvZGUgPiAweDAwMWYgfHwgY29kZSA9PT0gMHgwMDA5KSk7XG5cbiAgcmV0dXJuIG5ldyBfYXN0LlRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkNPTU1FTlQsIHN0YXJ0LCBwb3NpdGlvbiwgbGluZSwgY29sLCBwcmV2LCBib2R5LnNsaWNlKHN0YXJ0ICsgMSwgcG9zaXRpb24pKTtcbn1cbi8qKlxuICogUmVhZHMgYSBudW1iZXIgdG9rZW4gZnJvbSB0aGUgc291cmNlIGZpbGUsIGVpdGhlciBhIGZsb2F0XG4gKiBvciBhbiBpbnQgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYSBkZWNpbWFsIHBvaW50IGFwcGVhcnMuXG4gKlxuICogSW50OiAgIC0/KDB8WzEtOV1bMC05XSopXG4gKiBGbG9hdDogLT8oMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8oKEV8ZSkoK3wtKT9bMC05XSspP1xuICovXG5cblxuZnVuY3Rpb24gcmVhZE51bWJlcihzb3VyY2UsIHN0YXJ0LCBmaXJzdENvZGUsIGxpbmUsIGNvbCwgcHJldikge1xuICB2YXIgYm9keSA9IHNvdXJjZS5ib2R5O1xuICB2YXIgY29kZSA9IGZpcnN0Q29kZTtcbiAgdmFyIHBvc2l0aW9uID0gc3RhcnQ7XG4gIHZhciBpc0Zsb2F0ID0gZmFsc2U7XG5cbiAgaWYgKGNvZGUgPT09IDQ1KSB7XG4gICAgLy8gLVxuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG4gIH1cblxuICBpZiAoY29kZSA9PT0gNDgpIHtcbiAgICAvLyAwXG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcblxuICAgIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcbiAgICAgIHRocm93ICgwLCBfc3ludGF4RXJyb3Iuc3ludGF4RXJyb3IpKHNvdXJjZSwgcG9zaXRpb24sIFwiSW52YWxpZCBudW1iZXIsIHVuZXhwZWN0ZWQgZGlnaXQgYWZ0ZXIgMDogXCIuY29uY2F0KHByaW50Q2hhckNvZGUoY29kZSksIFwiLlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvc2l0aW9uID0gcmVhZERpZ2l0cyhzb3VyY2UsIHBvc2l0aW9uLCBjb2RlKTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChjb2RlID09PSA0Nikge1xuICAgIC8vIC5cbiAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgIHBvc2l0aW9uID0gcmVhZERpZ2l0cyhzb3VyY2UsIHBvc2l0aW9uLCBjb2RlKTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChjb2RlID09PSA2OSB8fCBjb2RlID09PSAxMDEpIHtcbiAgICAvLyBFIGVcbiAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuXG4gICAgaWYgKGNvZGUgPT09IDQzIHx8IGNvZGUgPT09IDQ1KSB7XG4gICAgICAvLyArIC1cbiAgICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcG9zaXRpb24gPSByZWFkRGlnaXRzKHNvdXJjZSwgcG9zaXRpb24sIGNvZGUpO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICB9IC8vIE51bWJlcnMgY2Fubm90IGJlIGZvbGxvd2VkIGJ5IC4gb3IgTmFtZVN0YXJ0XG5cblxuICBpZiAoY29kZSA9PT0gNDYgfHwgaXNOYW1lU3RhcnQoY29kZSkpIHtcbiAgICB0aHJvdyAoMCwgX3N5bnRheEVycm9yLnN5bnRheEVycm9yKShzb3VyY2UsIHBvc2l0aW9uLCBcIkludmFsaWQgbnVtYmVyLCBleHBlY3RlZCBkaWdpdCBidXQgZ290OiBcIi5jb25jYXQocHJpbnRDaGFyQ29kZShjb2RlKSwgXCIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX2FzdC5Ub2tlbihpc0Zsb2F0ID8gX3Rva2VuS2luZC5Ub2tlbktpbmQuRkxPQVQgOiBfdG9rZW5LaW5kLlRva2VuS2luZC5JTlQsIHN0YXJ0LCBwb3NpdGlvbiwgbGluZSwgY29sLCBwcmV2LCBib2R5LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBhZnRlciByZWFkaW5nIGRpZ2l0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlYWREaWdpdHMoc291cmNlLCBzdGFydCwgZmlyc3RDb2RlKSB7XG4gIHZhciBib2R5ID0gc291cmNlLmJvZHk7XG4gIHZhciBwb3NpdGlvbiA9IHN0YXJ0O1xuICB2YXIgY29kZSA9IGZpcnN0Q29kZTtcblxuICBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7XG4gICAgLy8gMCAtIDlcbiAgICBkbyB7XG4gICAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgIH0gd2hpbGUgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1Nyk7IC8vIDAgLSA5XG5cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuXG4gIHRocm93ICgwLCBfc3ludGF4RXJyb3Iuc3ludGF4RXJyb3IpKHNvdXJjZSwgcG9zaXRpb24sIFwiSW52YWxpZCBudW1iZXIsIGV4cGVjdGVkIGRpZ2l0IGJ1dCBnb3Q6IFwiLmNvbmNhdChwcmludENoYXJDb2RlKGNvZGUpLCBcIi5cIikpO1xufVxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyB0b2tlbiBmcm9tIHRoZSBzb3VyY2UgZmlsZS5cbiAqXG4gKiBcIihbXlwiXFxcXFxcdTAwMEFcXHUwMDBEXXwoXFxcXCh1WzAtOWEtZkEtRl17NH18W1wiXFxcXC9iZm5ydF0pKSkqXCJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlYWRTdHJpbmcoc291cmNlLCBzdGFydCwgbGluZSwgY29sLCBwcmV2KSB7XG4gIHZhciBib2R5ID0gc291cmNlLmJvZHk7XG4gIHZhciBwb3NpdGlvbiA9IHN0YXJ0ICsgMTtcbiAgdmFyIGNodW5rU3RhcnQgPSBwb3NpdGlvbjtcbiAgdmFyIGNvZGUgPSAwO1xuICB2YXIgdmFsdWUgPSAnJztcblxuICB3aGlsZSAocG9zaXRpb24gPCBib2R5Lmxlbmd0aCAmJiAhaXNOYU4oY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbikpICYmIC8vIG5vdCBMaW5lVGVybWluYXRvclxuICBjb2RlICE9PSAweDAwMGEgJiYgY29kZSAhPT0gMHgwMDBkKSB7XG4gICAgLy8gQ2xvc2luZyBRdW90ZSAoXCIpXG4gICAgaWYgKGNvZGUgPT09IDM0KSB7XG4gICAgICB2YWx1ZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBuZXcgX2FzdC5Ub2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5TVFJJTkcsIHN0YXJ0LCBwb3NpdGlvbiArIDEsIGxpbmUsIGNvbCwgcHJldiwgdmFsdWUpO1xuICAgIH0gLy8gU291cmNlQ2hhcmFjdGVyXG5cblxuICAgIGlmIChjb2RlIDwgMHgwMDIwICYmIGNvZGUgIT09IDB4MDAwOSkge1xuICAgICAgdGhyb3cgKDAsIF9zeW50YXhFcnJvci5zeW50YXhFcnJvcikoc291cmNlLCBwb3NpdGlvbiwgXCJJbnZhbGlkIGNoYXJhY3RlciB3aXRoaW4gU3RyaW5nOiBcIi5jb25jYXQocHJpbnRDaGFyQ29kZShjb2RlKSwgXCIuXCIpKTtcbiAgICB9XG5cbiAgICArK3Bvc2l0aW9uO1xuXG4gICAgaWYgKGNvZGUgPT09IDkyKSB7XG4gICAgICAvLyBcXFxuICAgICAgdmFsdWUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbiAtIDEpO1xuICAgICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG5cbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIHZhbHVlICs9ICdcIic7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICB2YWx1ZSArPSAnLyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICB2YWx1ZSArPSAnXFxcXCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICB2YWx1ZSArPSAnXFxiJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICB2YWx1ZSArPSAnXFxmJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDExMDpcbiAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICB2YWx1ZSArPSAnXFxyJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDExNjpcbiAgICAgICAgICB2YWx1ZSArPSAnXFx0JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyB1WFhYWFxuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdW5pQ2hhckNvZGUoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSksIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpLCBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAzKSwgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgNCkpO1xuXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAwKSB7XG4gICAgICAgICAgICAgIHZhciBpbnZhbGlkU2VxdWVuY2UgPSBib2R5LnNsaWNlKHBvc2l0aW9uICsgMSwgcG9zaXRpb24gKyA1KTtcbiAgICAgICAgICAgICAgdGhyb3cgKDAsIF9zeW50YXhFcnJvci5zeW50YXhFcnJvcikoc291cmNlLCBwb3NpdGlvbiwgXCJJbnZhbGlkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2U6IFxcXFx1XCIuY29uY2F0KGludmFsaWRTZXF1ZW5jZSwgXCIuXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgKDAsIF9zeW50YXhFcnJvci5zeW50YXhFcnJvcikoc291cmNlLCBwb3NpdGlvbiwgXCJJbnZhbGlkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2U6IFxcXFxcIi5jb25jYXQoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSwgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgKytwb3NpdGlvbjtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvdyAoMCwgX3N5bnRheEVycm9yLnN5bnRheEVycm9yKShzb3VyY2UsIHBvc2l0aW9uLCAnVW50ZXJtaW5hdGVkIHN0cmluZy4nKTtcbn1cbi8qKlxuICogUmVhZHMgYSBibG9jayBzdHJpbmcgdG9rZW4gZnJvbSB0aGUgc291cmNlIGZpbGUuXG4gKlxuICogXCJcIlwiKFwiP1wiPyhcXFxcXCJcIlwifFxcXFwoPyE9XCJcIlwiKXxbXlwiXFxcXF0pKSpcIlwiXCJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1N0cmluZyhzb3VyY2UsIHN0YXJ0LCBsaW5lLCBjb2wsIHByZXYsIGxleGVyKSB7XG4gIHZhciBib2R5ID0gc291cmNlLmJvZHk7XG4gIHZhciBwb3NpdGlvbiA9IHN0YXJ0ICsgMztcbiAgdmFyIGNodW5rU3RhcnQgPSBwb3NpdGlvbjtcbiAgdmFyIGNvZGUgPSAwO1xuICB2YXIgcmF3VmFsdWUgPSAnJztcblxuICB3aGlsZSAocG9zaXRpb24gPCBib2R5Lmxlbmd0aCAmJiAhaXNOYU4oY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbikpKSB7XG4gICAgLy8gQ2xvc2luZyBUcmlwbGUtUXVvdGUgKFwiXCJcIilcbiAgICBpZiAoY29kZSA9PT0gMzQgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDM0ICYmIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpID09PSAzNCkge1xuICAgICAgcmF3VmFsdWUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbik7XG4gICAgICByZXR1cm4gbmV3IF9hc3QuVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQkxPQ0tfU1RSSU5HLCBzdGFydCwgcG9zaXRpb24gKyAzLCBsaW5lLCBjb2wsIHByZXYsICgwLCBfYmxvY2tTdHJpbmcuZGVkZW50QmxvY2tTdHJpbmdWYWx1ZSkocmF3VmFsdWUpKTtcbiAgICB9IC8vIFNvdXJjZUNoYXJhY3RlclxuXG5cbiAgICBpZiAoY29kZSA8IDB4MDAyMCAmJiBjb2RlICE9PSAweDAwMDkgJiYgY29kZSAhPT0gMHgwMDBhICYmIGNvZGUgIT09IDB4MDAwZCkge1xuICAgICAgdGhyb3cgKDAsIF9zeW50YXhFcnJvci5zeW50YXhFcnJvcikoc291cmNlLCBwb3NpdGlvbiwgXCJJbnZhbGlkIGNoYXJhY3RlciB3aXRoaW4gU3RyaW5nOiBcIi5jb25jYXQocHJpbnRDaGFyQ29kZShjb2RlKSwgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMTApIHtcbiAgICAgIC8vIG5ldyBsaW5lXG4gICAgICArK3Bvc2l0aW9uO1xuICAgICAgKytsZXhlci5saW5lO1xuICAgICAgbGV4ZXIubGluZVN0YXJ0ID0gcG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAxMykge1xuICAgICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDEwKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3Bvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICArK2xleGVyLmxpbmU7XG4gICAgICBsZXhlci5saW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKCAvLyBFc2NhcGUgVHJpcGxlLVF1b3RlIChcXFwiXCJcIilcbiAgICBjb2RlID09PSA5MiAmJiBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMzQgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IDM0ICYmIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDMpID09PSAzNCkge1xuICAgICAgcmF3VmFsdWUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbikgKyAnXCJcIlwiJztcbiAgICAgIHBvc2l0aW9uICs9IDQ7XG4gICAgICBjaHVua1N0YXJ0ID0gcG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICsrcG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgKDAsIF9zeW50YXhFcnJvci5zeW50YXhFcnJvcikoc291cmNlLCBwb3NpdGlvbiwgJ1VudGVybWluYXRlZCBzdHJpbmcuJyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGZvdXIgaGV4YWRlY2ltYWwgY2hhcnMgdG8gdGhlIGludGVnZXIgdGhhdCB0aGVcbiAqIHN0cmluZyByZXByZXNlbnRzLiBGb3IgZXhhbXBsZSwgdW5pQ2hhckNvZGUoJzAnLCcwJywnMCcsJ2YnKVxuICogd2lsbCByZXR1cm4gMTUsIGFuZCB1bmlDaGFyQ29kZSgnMCcsJzAnLCdmJywnZicpIHJldHVybnMgMjU1LlxuICpcbiAqIFJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIgb24gZXJyb3IsIGlmIGEgY2hhciB3YXMgaW52YWxpZC5cbiAqXG4gKiBUaGlzIGlzIGltcGxlbWVudGVkIGJ5IG5vdGluZyB0aGF0IGNoYXIyaGV4KCkgcmV0dXJucyAtMSBvbiBlcnJvcixcbiAqIHdoaWNoIG1lYW5zIHRoZSByZXN1bHQgb2YgT1JpbmcgdGhlIGNoYXIyaGV4KCkgd2lsbCBhbHNvIGJlIG5lZ2F0aXZlLlxuICovXG5cblxuZnVuY3Rpb24gdW5pQ2hhckNvZGUoYSwgYiwgYywgZCkge1xuICByZXR1cm4gY2hhcjJoZXgoYSkgPDwgMTIgfCBjaGFyMmhleChiKSA8PCA4IHwgY2hhcjJoZXgoYykgPDwgNCB8IGNoYXIyaGV4KGQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBjaGFyYWN0ZXIgdG8gaXRzIGludGVnZXIgdmFsdWUuXG4gKiAnMCcgYmVjb21lcyAwLCAnOScgYmVjb21lcyA5XG4gKiAnQScgYmVjb21lcyAxMCwgJ0YnIGJlY29tZXMgMTVcbiAqICdhJyBiZWNvbWVzIDEwLCAnZicgYmVjb21lcyAxNVxuICpcbiAqIFJldHVybnMgLTEgb24gZXJyb3IuXG4gKi9cblxuXG5mdW5jdGlvbiBjaGFyMmhleChhKSB7XG4gIHJldHVybiBhID49IDQ4ICYmIGEgPD0gNTcgPyBhIC0gNDggLy8gMC05XG4gIDogYSA+PSA2NSAmJiBhIDw9IDcwID8gYSAtIDU1IC8vIEEtRlxuICA6IGEgPj0gOTcgJiYgYSA8PSAxMDIgPyBhIC0gODcgLy8gYS1mXG4gIDogLTE7XG59XG4vKipcbiAqIFJlYWRzIGFuIGFscGhhbnVtZXJpYyArIHVuZGVyc2NvcmUgbmFtZSBmcm9tIHRoZSBzb3VyY2UuXG4gKlxuICogW19BLVphLXpdW18wLTlBLVphLXpdKlxuICovXG5cblxuZnVuY3Rpb24gcmVhZE5hbWUoc291cmNlLCBzdGFydCwgbGluZSwgY29sLCBwcmV2KSB7XG4gIHZhciBib2R5ID0gc291cmNlLmJvZHk7XG4gIHZhciBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIHZhciBwb3NpdGlvbiA9IHN0YXJ0ICsgMTtcbiAgdmFyIGNvZGUgPSAwO1xuXG4gIHdoaWxlIChwb3NpdGlvbiAhPT0gYm9keUxlbmd0aCAmJiAhaXNOYU4oY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbikpICYmIChjb2RlID09PSA5NSB8fCAvLyBfXG4gIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NyB8fCAvLyAwLTlcbiAgY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwIHx8IC8vIEEtWlxuICBjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSAvLyBhLXpcbiAgKSB7XG4gICAgKytwb3NpdGlvbjtcbiAgfVxuXG4gIHJldHVybiBuZXcgX2FzdC5Ub2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5OQU1FLCBzdGFydCwgcG9zaXRpb24sIGxpbmUsIGNvbCwgcHJldiwgYm9keS5zbGljZShzdGFydCwgcG9zaXRpb24pKTtcbn0gLy8gXyBBLVogYS16XG5cblxuZnVuY3Rpb24gaXNOYW1lU3RhcnQoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gOTUgfHwgY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwIHx8IGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0TG9jYXRpb24gPSBnZXRMb2NhdGlvbjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbG9jYXRpb24gaW4gYSBTb3VyY2UuXG4gKi9cblxuLyoqXG4gKiBUYWtlcyBhIFNvdXJjZSBhbmQgYSBVVEYtOCBjaGFyYWN0ZXIgb2Zmc2V0LCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xuICogbGluZSBhbmQgY29sdW1uIGFzIGEgU291cmNlTG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldExvY2F0aW9uKHNvdXJjZSwgcG9zaXRpb24pIHtcbiAgdmFyIGxpbmVSZWdleHAgPSAvXFxyXFxufFtcXG5cXHJdL2c7XG4gIHZhciBsaW5lID0gMTtcbiAgdmFyIGNvbHVtbiA9IHBvc2l0aW9uICsgMTtcbiAgdmFyIG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSBsaW5lUmVnZXhwLmV4ZWMoc291cmNlLmJvZHkpKSAmJiBtYXRjaC5pbmRleCA8IHBvc2l0aW9uKSB7XG4gICAgbGluZSArPSAxO1xuICAgIGNvbHVtbiA9IHBvc2l0aW9uICsgMSAtIChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmU6IGxpbmUsXG4gICAgY29sdW1uOiBjb2x1bW5cbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZVZhbHVlID0gcGFyc2VWYWx1ZTtcbmV4cG9ydHMucGFyc2VUeXBlID0gcGFyc2VUeXBlO1xuXG52YXIgX2luc3BlY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9qc3V0aWxzL2luc3BlY3RcIikpO1xuXG52YXIgX2RldkFzc2VydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2pzdXRpbHMvZGV2QXNzZXJ0XCIpKTtcblxudmFyIF9zeW50YXhFcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvci9zeW50YXhFcnJvclwiKTtcblxudmFyIF9raW5kcyA9IHJlcXVpcmUoXCIuL2tpbmRzXCIpO1xuXG52YXIgX2FzdCA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcblxudmFyIF9zb3VyY2UgPSByZXF1aXJlKFwiLi9zb3VyY2VcIik7XG5cbnZhciBfdG9rZW5LaW5kID0gcmVxdWlyZShcIi4vdG9rZW5LaW5kXCIpO1xuXG52YXIgX2RpcmVjdGl2ZUxvY2F0aW9uID0gcmVxdWlyZShcIi4vZGlyZWN0aXZlTG9jYXRpb25cIik7XG5cbnZhciBfbGV4ZXIgPSByZXF1aXJlKFwiLi9sZXhlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBHaXZlbiBhIEdyYXBoUUwgc291cmNlLCBwYXJzZXMgaXQgaW50byBhIERvY3VtZW50LlxuICogVGhyb3dzIEdyYXBoUUxFcnJvciBpZiBhIHN5bnRheCBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHJldHVybiBwYXJzZXIucGFyc2VEb2N1bWVudCgpO1xufVxuLyoqXG4gKiBHaXZlbiBhIHN0cmluZyBjb250YWluaW5nIGEgR3JhcGhRTCB2YWx1ZSAoZXguIGBbNDJdYCksIHBhcnNlIHRoZSBBU1QgZm9yXG4gKiB0aGF0IHZhbHVlLlxuICogVGhyb3dzIEdyYXBoUUxFcnJvciBpZiBhIHN5bnRheCBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aXRoaW4gdG9vbHMgdGhhdCBvcGVyYXRlIHVwb24gR3JhcGhRTCBWYWx1ZXMgZGlyZWN0bHkgYW5kXG4gKiBpbiBpc29sYXRpb24gb2YgY29tcGxldGUgR3JhcGhRTCBkb2N1bWVudHMuXG4gKlxuICogQ29uc2lkZXIgcHJvdmlkaW5nIHRoZSByZXN1bHRzIHRvIHRoZSB1dGlsaXR5IGZ1bmN0aW9uOiB2YWx1ZUZyb21BU1QoKS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5TT0YpO1xuICB2YXIgdmFsdWUgPSBwYXJzZXIucGFyc2VWYWx1ZUxpdGVyYWwoZmFsc2UpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuRU9GKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBHaXZlbiBhIHN0cmluZyBjb250YWluaW5nIGEgR3JhcGhRTCBUeXBlIChleC4gYFtJbnQhXWApLCBwYXJzZSB0aGUgQVNUIGZvclxuICogdGhhdCB0eXBlLlxuICogVGhyb3dzIEdyYXBoUUxFcnJvciBpZiBhIHN5bnRheCBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aXRoaW4gdG9vbHMgdGhhdCBvcGVyYXRlIHVwb24gR3JhcGhRTCBUeXBlcyBkaXJlY3RseSBhbmRcbiAqIGluIGlzb2xhdGlvbiBvZiBjb21wbGV0ZSBHcmFwaFFMIGRvY3VtZW50cy5cbiAqXG4gKiBDb25zaWRlciBwcm92aWRpbmcgdGhlIHJlc3VsdHMgdG8gdGhlIHV0aWxpdHkgZnVuY3Rpb246IHR5cGVGcm9tQVNUKCkuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVR5cGUoc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5TT0YpO1xuICB2YXIgdHlwZSA9IHBhcnNlci5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkVPRik7XG4gIHJldHVybiB0eXBlO1xufVxuXG52YXIgUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFyc2VyKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBzb3VyY2VPYmogPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IG5ldyBfc291cmNlLlNvdXJjZShzb3VyY2UpIDogc291cmNlO1xuICAgIHNvdXJjZU9iaiBpbnN0YW5jZW9mIF9zb3VyY2UuU291cmNlIHx8ICgwLCBfZGV2QXNzZXJ0LmRlZmF1bHQpKDAsIFwiTXVzdCBwcm92aWRlIFNvdXJjZS4gUmVjZWl2ZWQ6IFwiLmNvbmNhdCgoMCwgX2luc3BlY3QuZGVmYXVsdCkoc291cmNlT2JqKSwgXCIuXCIpKTtcbiAgICB0aGlzLl9sZXhlciA9IG5ldyBfbGV4ZXIuTGV4ZXIoc291cmNlT2JqKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBuYW1lIGxleCB0b2tlbiBpbnRvIGEgbmFtZSBwYXJzZSBub2RlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5wYXJzZU5hbWUgPSBmdW5jdGlvbiBwYXJzZU5hbWUoKSB7XG4gICAgdmFyIHRva2VuID0gdGhpcy5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5OQU1FKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuTkFNRSxcbiAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgIGxvYzogdGhpcy5sb2ModG9rZW4pXG4gICAgfTtcbiAgfSAvLyBJbXBsZW1lbnRzIHRoZSBwYXJzaW5nIHJ1bGVzIGluIHRoZSBEb2N1bWVudCBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBEb2N1bWVudCA6IERlZmluaXRpb24rXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRG9jdW1lbnQgPSBmdW5jdGlvbiBwYXJzZURvY3VtZW50KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5ET0NVTUVOVCxcbiAgICAgIGRlZmluaXRpb25zOiB0aGlzLm1hbnkoX3Rva2VuS2luZC5Ub2tlbktpbmQuU09GLCB0aGlzLnBhcnNlRGVmaW5pdGlvbiwgX3Rva2VuS2luZC5Ub2tlbktpbmQuRU9GKSxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVmaW5pdGlvbiA6XG4gICAqICAgLSBFeGVjdXRhYmxlRGVmaW5pdGlvblxuICAgKiAgIC0gVHlwZVN5c3RlbURlZmluaXRpb25cbiAgICogICAtIFR5cGVTeXN0ZW1FeHRlbnNpb25cbiAgICpcbiAgICogRXhlY3V0YWJsZURlZmluaXRpb24gOlxuICAgKiAgIC0gT3BlcmF0aW9uRGVmaW5pdGlvblxuICAgKiAgIC0gRnJhZ21lbnREZWZpbml0aW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRGVmaW5pdGlvbigpIHtcbiAgICBpZiAodGhpcy5wZWVrKF90b2tlbktpbmQuVG9rZW5LaW5kLk5BTUUpKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX2xleGVyLnRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgY2FzZSAnbXV0YXRpb24nOlxuICAgICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2ZyYWdtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZyYWdtZW50RGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ3NjaGVtYSc6XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2V4dGVuZCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnBlZWsoX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfTCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wZWVrRGVzY3JpcHRpb24oKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRGVmaW5pdGlvbigpO1xuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIE9wZXJhdGlvbnMgc2VjdGlvbi5cblxuICAvKipcbiAgICogT3BlcmF0aW9uRGVmaW5pdGlvbiA6XG4gICAqICAtIFNlbGVjdGlvblNldFxuICAgKiAgLSBPcGVyYXRpb25UeXBlIE5hbWU/IFZhcmlhYmxlRGVmaW5pdGlvbnM/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9wZXJhdGlvbkRlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodGhpcy5wZWVrKF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX0wpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBfa2luZHMuS2luZC5PUEVSQVRJT05fREVGSU5JVElPTixcbiAgICAgICAgb3BlcmF0aW9uOiAncXVlcnknLFxuICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnM6IFtdLFxuICAgICAgICBkaXJlY3RpdmVzOiBbXSxcbiAgICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZSgpO1xuICAgIHZhciBuYW1lO1xuXG4gICAgaWYgKHRoaXMucGVlayhfdG9rZW5LaW5kLlRva2VuS2luZC5OQU1FKSkge1xuICAgICAgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OLFxuICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFyaWFibGVEZWZpbml0aW9uczogdGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPcGVyYXRpb25UeXBlIDogb25lIG9mIHF1ZXJ5IG11dGF0aW9uIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9wZXJhdGlvblR5cGUgPSBmdW5jdGlvbiBwYXJzZU9wZXJhdGlvblR5cGUoKSB7XG4gICAgdmFyIG9wZXJhdGlvblRva2VuID0gdGhpcy5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5OQU1FKTtcblxuICAgIHN3aXRjaCAob3BlcmF0aW9uVG9rZW4udmFsdWUpIHtcbiAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgcmV0dXJuICdxdWVyeSc7XG5cbiAgICAgIGNhc2UgJ211dGF0aW9uJzpcbiAgICAgICAgcmV0dXJuICdtdXRhdGlvbic7XG5cbiAgICAgIGNhc2UgJ3N1YnNjcmlwdGlvbic6XG4gICAgICAgIHJldHVybiAnc3Vic2NyaXB0aW9uJztcbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQob3BlcmF0aW9uVG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBWYXJpYWJsZURlZmluaXRpb25zIDogKCBWYXJpYWJsZURlZmluaXRpb24rIClcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VWYXJpYWJsZURlZmluaXRpb25zID0gZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlZmluaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShfdG9rZW5LaW5kLlRva2VuS2luZC5QQVJFTl9MLCB0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9uLCBfdG9rZW5LaW5kLlRva2VuS2luZC5QQVJFTl9SKTtcbiAgfVxuICAvKipcbiAgICogVmFyaWFibGVEZWZpbml0aW9uIDogVmFyaWFibGUgOiBUeXBlIERlZmF1bHRWYWx1ZT8gRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVmFyaWFibGVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLlZBUklBQkxFX0RFRklOSVRJT04sXG4gICAgICB2YXJpYWJsZTogdGhpcy5wYXJzZVZhcmlhYmxlKCksXG4gICAgICB0eXBlOiAodGhpcy5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5DT0xPTiksIHRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCkpLFxuICAgICAgZGVmYXVsdFZhbHVlOiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuRVFVQUxTKSA/IHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwodHJ1ZSkgOiB1bmRlZmluZWQsXG4gICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKSxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVmFyaWFibGUgOiAkIE5hbWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VWYXJpYWJsZSA9IGZ1bmN0aW9uIHBhcnNlVmFyaWFibGUoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5ET0xMQVIpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5WQVJJQUJMRSxcbiAgICAgIG5hbWU6IHRoaXMucGFyc2VOYW1lKCksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdGlvblNldCA6IHsgU2VsZWN0aW9uKyB9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU2VsZWN0aW9uU2V0ID0gZnVuY3Rpb24gcGFyc2VTZWxlY3Rpb25TZXQoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLlNFTEVDVElPTl9TRVQsXG4gICAgICBzZWxlY3Rpb25zOiB0aGlzLm1hbnkoX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfTCwgdGhpcy5wYXJzZVNlbGVjdGlvbiwgX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfUiksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdGlvbiA6XG4gICAqICAgLSBGaWVsZFxuICAgKiAgIC0gRnJhZ21lbnRTcHJlYWRcbiAgICogICAtIElubGluZUZyYWdtZW50XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU2VsZWN0aW9uID0gZnVuY3Rpb24gcGFyc2VTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGVlayhfdG9rZW5LaW5kLlRva2VuS2luZC5TUFJFQUQpID8gdGhpcy5wYXJzZUZyYWdtZW50KCkgOiB0aGlzLnBhcnNlRmllbGQoKTtcbiAgfVxuICAvKipcbiAgICogRmllbGQgOiBBbGlhcz8gTmFtZSBBcmd1bWVudHM/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldD9cbiAgICpcbiAgICogQWxpYXMgOiBOYW1lIDpcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VGaWVsZCA9IGZ1bmN0aW9uIHBhcnNlRmllbGQoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIG5hbWVPckFsaWFzID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgYWxpYXM7XG4gICAgdmFyIG5hbWU7XG5cbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkNPTE9OKSkge1xuICAgICAgYWxpYXMgPSBuYW1lT3JBbGlhcztcbiAgICAgIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZU9yQWxpYXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkZJRUxELFxuICAgICAgYWxpYXM6IGFsaWFzLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGFyZ3VtZW50czogdGhpcy5wYXJzZUFyZ3VtZW50cyhmYWxzZSksXG4gICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMucGVlayhfdG9rZW5LaW5kLlRva2VuS2luZC5CUkFDRV9MKSA/IHRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKSA6IHVuZGVmaW5lZCxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXJndW1lbnRzW0NvbnN0XSA6ICggQXJndW1lbnRbP0NvbnN0XSsgKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKGlzQ29uc3QpIHtcbiAgICB2YXIgaXRlbSA9IGlzQ29uc3QgPyB0aGlzLnBhcnNlQ29uc3RBcmd1bWVudCA6IHRoaXMucGFyc2VBcmd1bWVudDtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoX3Rva2VuS2luZC5Ub2tlbktpbmQuUEFSRU5fTCwgaXRlbSwgX3Rva2VuS2luZC5Ub2tlbktpbmQuUEFSRU5fUik7XG4gIH1cbiAgLyoqXG4gICAqIEFyZ3VtZW50W0NvbnN0XSA6IE5hbWUgOiBWYWx1ZVs/Q29uc3RdXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlQXJndW1lbnQgPSBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkNPTE9OKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuQVJHVU1FTlQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoZmFsc2UpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUNvbnN0QXJndW1lbnQgPSBmdW5jdGlvbiBwYXJzZUNvbnN0QXJndW1lbnQoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkFSR1VNRU5ULFxuICAgICAgbmFtZTogdGhpcy5wYXJzZU5hbWUoKSxcbiAgICAgIHZhbHVlOiAodGhpcy5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5DT0xPTiksIHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwodHJ1ZSkpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIEZyYWdtZW50cyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBDb3JyZXNwb25kcyB0byBib3RoIEZyYWdtZW50U3ByZWFkIGFuZCBJbmxpbmVGcmFnbWVudCBpbiB0aGUgc3BlYy5cbiAgICpcbiAgICogRnJhZ21lbnRTcHJlYWQgOiAuLi4gRnJhZ21lbnROYW1lIERpcmVjdGl2ZXM/XG4gICAqXG4gICAqIElubGluZUZyYWdtZW50IDogLi4uIFR5cGVDb25kaXRpb24/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24gcGFyc2VGcmFnbWVudCgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLlNQUkVBRCk7XG4gICAgdmFyIGhhc1R5cGVDb25kaXRpb24gPSB0aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgnb24nKTtcblxuICAgIGlmICghaGFzVHlwZUNvbmRpdGlvbiAmJiB0aGlzLnBlZWsoX3Rva2VuS2luZC5Ub2tlbktpbmQuTkFNRSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkZSQUdNRU5UX1NQUkVBRCxcbiAgICAgICAgbmFtZTogdGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLFxuICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5JTkxJTkVfRlJBR01FTlQsXG4gICAgICB0eXBlQ29uZGl0aW9uOiBoYXNUeXBlQ29uZGl0aW9uID8gdGhpcy5wYXJzZU5hbWVkVHlwZSgpIDogdW5kZWZpbmVkLFxuICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXMoZmFsc2UpLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEZyYWdtZW50RGVmaW5pdGlvbiA6XG4gICAqICAgLSBmcmFnbWVudCBGcmFnbWVudE5hbWUgb24gVHlwZUNvbmRpdGlvbiBEaXJlY3RpdmVzPyBTZWxlY3Rpb25TZXRcbiAgICpcbiAgICogVHlwZUNvbmRpdGlvbiA6IE5hbWVkVHlwZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZyYWdtZW50RGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRnJhZ21lbnREZWZpbml0aW9uKCkge1xuICAgIHZhciBfdGhpcyRfb3B0aW9ucztcblxuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnJhZ21lbnQnKTsgLy8gRXhwZXJpbWVudGFsIHN1cHBvcnQgZm9yIGRlZmluaW5nIHZhcmlhYmxlcyB3aXRoaW4gZnJhZ21lbnRzIGNoYW5nZXNcbiAgICAvLyB0aGUgZ3JhbW1hciBvZiBGcmFnbWVudERlZmluaXRpb246XG4gICAgLy8gICAtIGZyYWdtZW50IEZyYWdtZW50TmFtZSBWYXJpYWJsZURlZmluaXRpb25zPyBvbiBUeXBlQ29uZGl0aW9uIERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuXG4gICAgaWYgKCgoX3RoaXMkX29wdGlvbnMgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfdGhpcyRfb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX29wdGlvbnMuZXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMpID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBfa2luZHMuS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OLFxuICAgICAgICBuYW1lOiB0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksXG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnM6IHRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb25zKCksXG4gICAgICAgIHR5cGVDb25kaXRpb246ICh0aGlzLmV4cGVjdEtleXdvcmQoJ29uJyksIHRoaXMucGFyc2VOYW1lZFR5cGUoKSksXG4gICAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OLFxuICAgICAgbmFtZTogdGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLFxuICAgICAgdHlwZUNvbmRpdGlvbjogKHRoaXMuZXhwZWN0S2V5d29yZCgnb24nKSwgdGhpcy5wYXJzZU5hbWVkVHlwZSgpKSxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBGcmFnbWVudE5hbWUgOiBOYW1lIGJ1dCBub3QgYG9uYFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZyYWdtZW50TmFtZSA9IGZ1bmN0aW9uIHBhcnNlRnJhZ21lbnROYW1lKCkge1xuICAgIGlmICh0aGlzLl9sZXhlci50b2tlbi52YWx1ZSA9PT0gJ29uJykge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VOYW1lKCk7XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgVmFsdWVzIHNlY3Rpb24uXG5cbiAgLyoqXG4gICAqIFZhbHVlW0NvbnN0XSA6XG4gICAqICAgLSBbfkNvbnN0XSBWYXJpYWJsZVxuICAgKiAgIC0gSW50VmFsdWVcbiAgICogICAtIEZsb2F0VmFsdWVcbiAgICogICAtIFN0cmluZ1ZhbHVlXG4gICAqICAgLSBCb29sZWFuVmFsdWVcbiAgICogICAtIE51bGxWYWx1ZVxuICAgKiAgIC0gRW51bVZhbHVlXG4gICAqICAgLSBMaXN0VmFsdWVbP0NvbnN0XVxuICAgKiAgIC0gT2JqZWN0VmFsdWVbP0NvbnN0XVxuICAgKlxuICAgKiBCb29sZWFuVmFsdWUgOiBvbmUgb2YgYHRydWVgIGBmYWxzZWBcbiAgICpcbiAgICogTnVsbFZhbHVlIDogYG51bGxgXG4gICAqXG4gICAqIEVudW1WYWx1ZSA6IE5hbWUgYnV0IG5vdCBgdHJ1ZWAsIGBmYWxzZWAgb3IgYG51bGxgXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVmFsdWVMaXRlcmFsID0gZnVuY3Rpb24gcGFyc2VWYWx1ZUxpdGVyYWwoaXNDb25zdCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgc3dpdGNoICh0b2tlbi5raW5kKSB7XG4gICAgICBjYXNlIF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNLRVRfTDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KGlzQ29uc3QpO1xuXG4gICAgICBjYXNlIF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX0w6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0KGlzQ29uc3QpO1xuXG4gICAgICBjYXNlIF90b2tlbktpbmQuVG9rZW5LaW5kLklOVDpcbiAgICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2luZDogX2tpbmRzLktpbmQuSU5ULFxuICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICBsb2M6IHRoaXMubG9jKHRva2VuKVxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIF90b2tlbktpbmQuVG9rZW5LaW5kLkZMT0FUOlxuICAgICAgICB0aGlzLl9sZXhlci5hZHZhbmNlKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiBfa2luZHMuS2luZC5GTE9BVCxcbiAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgICAgbG9jOiB0aGlzLmxvYyh0b2tlbilcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBfdG9rZW5LaW5kLlRva2VuS2luZC5TVFJJTkc6XG4gICAgICBjYXNlIF90b2tlbktpbmQuVG9rZW5LaW5kLkJMT0NLX1NUUklORzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKCk7XG5cbiAgICAgIGNhc2UgX3Rva2VuS2luZC5Ub2tlbktpbmQuTkFNRTpcbiAgICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkJPT0xFQU4sXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICBsb2M6IHRoaXMubG9jKHRva2VuKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkJPT0xFQU4sXG4gICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgbG9jOiB0aGlzLmxvYyh0b2tlbilcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLk5VTEwsXG4gICAgICAgICAgICAgIGxvYzogdGhpcy5sb2ModG9rZW4pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkVOVU0sXG4gICAgICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgbG9jOiB0aGlzLmxvYyh0b2tlbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBfdG9rZW5LaW5kLlRva2VuS2luZC5ET0xMQVI6XG4gICAgICAgIGlmICghaXNDb25zdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyaWFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiBwYXJzZVN0cmluZ0xpdGVyYWwoKSB7XG4gICAgdmFyIHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICB0aGlzLl9sZXhlci5hZHZhbmNlKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuU1RSSU5HLFxuICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgYmxvY2s6IHRva2VuLmtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLkJMT0NLX1NUUklORyxcbiAgICAgIGxvYzogdGhpcy5sb2ModG9rZW4pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTGlzdFZhbHVlW0NvbnN0XSA6XG4gICAqICAgLSBbIF1cbiAgICogICAtIFsgVmFsdWVbP0NvbnN0XSsgXVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUxpc3QgPSBmdW5jdGlvbiBwYXJzZUxpc3QoaXNDb25zdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIHZhciBpdGVtID0gZnVuY3Rpb24gaXRlbSgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkxJU1QsXG4gICAgICB2YWx1ZXM6IHRoaXMuYW55KF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNLRVRfTCwgaXRlbSwgX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0tFVF9SKSxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT2JqZWN0VmFsdWVbQ29uc3RdIDpcbiAgICogICAtIHsgfVxuICAgKiAgIC0geyBPYmplY3RGaWVsZFs/Q29uc3RdKyB9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gcGFyc2VPYmplY3QoaXNDb25zdCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICB2YXIgaXRlbSA9IGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnBhcnNlT2JqZWN0RmllbGQoaXNDb25zdCk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5PQkpFQ1QsXG4gICAgICBmaWVsZHM6IHRoaXMuYW55KF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX0wsIGl0ZW0sIF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX1IpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPYmplY3RGaWVsZFtDb25zdF0gOiBOYW1lIDogVmFsdWVbP0NvbnN0XVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9iamVjdEZpZWxkID0gZnVuY3Rpb24gcGFyc2VPYmplY3RGaWVsZChpc0NvbnN0KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQ09MT04pO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5PQkpFQ1RfRklFTEQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoaXNDb25zdCksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgRGlyZWN0aXZlcyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBEaXJlY3RpdmVzW0NvbnN0XSA6IERpcmVjdGl2ZVs/Q29uc3RdK1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiBwYXJzZURpcmVjdGl2ZXMoaXNDb25zdCkge1xuICAgIHZhciBkaXJlY3RpdmVzID0gW107XG5cbiAgICB3aGlsZSAodGhpcy5wZWVrKF90b2tlbktpbmQuVG9rZW5LaW5kLkFUKSkge1xuICAgICAgZGlyZWN0aXZlcy5wdXNoKHRoaXMucGFyc2VEaXJlY3RpdmUoaXNDb25zdCkpO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3RpdmVzO1xuICB9XG4gIC8qKlxuICAgKiBEaXJlY3RpdmVbQ29uc3RdIDogQCBOYW1lIEFyZ3VtZW50c1s/Q29uc3RdP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZURpcmVjdGl2ZSA9IGZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlKGlzQ29uc3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkFUKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuRElSRUNUSVZFLFxuICAgICAgbmFtZTogdGhpcy5wYXJzZU5hbWUoKSxcbiAgICAgIGFyZ3VtZW50czogdGhpcy5wYXJzZUFyZ3VtZW50cyhpc0NvbnN0KSxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfSAvLyBJbXBsZW1lbnRzIHRoZSBwYXJzaW5nIHJ1bGVzIGluIHRoZSBUeXBlcyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBUeXBlIDpcbiAgICogICAtIE5hbWVkVHlwZVxuICAgKiAgIC0gTGlzdFR5cGVcbiAgICogICAtIE5vbk51bGxUeXBlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVHlwZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIHBhcnNlVHlwZVJlZmVyZW5jZSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgdHlwZTtcblxuICAgIGlmICh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0tFVF9MKSkge1xuICAgICAgdHlwZSA9IHRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gICAgICB0aGlzLmV4cGVjdFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNLRVRfUik7XG4gICAgICB0eXBlID0ge1xuICAgICAgICBraW5kOiBfa2luZHMuS2luZC5MSVNUX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5wYXJzZU5hbWVkVHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQkFORykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLk5PTl9OVUxMX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIC8qKlxuICAgKiBOYW1lZFR5cGUgOiBOYW1lXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlTmFtZWRUeXBlID0gZnVuY3Rpb24gcGFyc2VOYW1lZFR5cGUoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLk5BTUVEX1RZUEUsXG4gICAgICBuYW1lOiB0aGlzLnBhcnNlTmFtZSgpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIFR5cGUgRGVmaW5pdGlvbiBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBUeXBlU3lzdGVtRGVmaW5pdGlvbiA6XG4gICAqICAgLSBTY2hlbWFEZWZpbml0aW9uXG4gICAqICAgLSBUeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gRGlyZWN0aXZlRGVmaW5pdGlvblxuICAgKlxuICAgKiBUeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBTY2FsYXJUeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gT2JqZWN0VHlwZURlZmluaXRpb25cbiAgICogICAtIEludGVyZmFjZVR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBVbmlvblR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBFbnVtVHlwZURlZmluaXRpb25cbiAgICogICAtIElucHV0T2JqZWN0VHlwZURlZmluaXRpb25cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VUeXBlU3lzdGVtRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlVHlwZVN5c3RlbURlZmluaXRpb24oKSB7XG4gICAgLy8gTWFueSBkZWZpbml0aW9ucyBiZWdpbiB3aXRoIGEgZGVzY3JpcHRpb24gYW5kIHJlcXVpcmUgYSBsb29rYWhlYWQuXG4gICAgdmFyIGtleXdvcmRUb2tlbiA9IHRoaXMucGVla0Rlc2NyaXB0aW9uKCkgPyB0aGlzLl9sZXhlci5sb29rYWhlYWQoKSA6IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKGtleXdvcmRUb2tlbi5raW5kID09PSBfdG9rZW5LaW5kLlRva2VuS2luZC5OQU1FKSB7XG4gICAgICBzd2l0Y2ggKGtleXdvcmRUb2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdzY2hlbWEnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2FsYXJUeXBlRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmlvblR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnZGlyZWN0aXZlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURpcmVjdGl2ZURlZmluaXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoa2V5d29yZFRva2VuKTtcbiAgfTtcblxuICBfcHJvdG8ucGVla0Rlc2NyaXB0aW9uID0gZnVuY3Rpb24gcGVla0Rlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBlZWsoX3Rva2VuS2luZC5Ub2tlbktpbmQuU1RSSU5HKSB8fCB0aGlzLnBlZWsoX3Rva2VuS2luZC5Ub2tlbktpbmQuQkxPQ0tfU1RSSU5HKTtcbiAgfVxuICAvKipcbiAgICogRGVzY3JpcHRpb24gOiBTdHJpbmdWYWx1ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gcGFyc2VEZXNjcmlwdGlvbigpIHtcbiAgICBpZiAodGhpcy5wZWVrRGVzY3JpcHRpb24oKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTY2hlbWFEZWZpbml0aW9uIDogRGVzY3JpcHRpb24/IHNjaGVtYSBEaXJlY3RpdmVzW0NvbnN0XT8geyBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbisgfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVNjaGVtYURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZVNjaGVtYURlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzY2hlbWEnKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciBvcGVyYXRpb25UeXBlcyA9IHRoaXMubWFueShfdG9rZW5LaW5kLlRva2VuS2luZC5CUkFDRV9MLCB0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24sIF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX1IpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5TQ0hFTUFfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBvcGVyYXRpb25UeXBlczogb3BlcmF0aW9uVHlwZXMsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uIDogT3BlcmF0aW9uVHlwZSA6IE5hbWVkVHlwZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5wYXJzZU9wZXJhdGlvblR5cGUoKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkNPTE9OKTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucGFyc2VOYW1lZFR5cGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTixcbiAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2NhbGFyVHlwZURlZmluaXRpb24gOiBEZXNjcmlwdGlvbj8gc2NhbGFyIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU2NhbGFyVHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc2NhbGFyJyk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLlNDQUxBUl9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT2JqZWN0VHlwZURlZmluaXRpb24gOlxuICAgKiAgIERlc2NyaXB0aW9uP1xuICAgKiAgIHR5cGUgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlcz8gRGlyZWN0aXZlc1tDb25zdF0/IEZpZWxkc0RlZmluaXRpb24/XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZU9iamVjdFR5cGVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndHlwZScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLk9CSkVDVF9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW50ZXJmYWNlczogaW50ZXJmYWNlcyxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW1wbGVtZW50c0ludGVyZmFjZXMgOlxuICAgKiAgIC0gaW1wbGVtZW50cyBgJmA/IE5hbWVkVHlwZVxuICAgKiAgIC0gSW1wbGVtZW50c0ludGVyZmFjZXMgJiBOYW1lZFR5cGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcyA9IGZ1bmN0aW9uIHBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKSB7XG4gICAgdmFyIHR5cGVzID0gW107XG5cbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoJ2ltcGxlbWVudHMnKSkge1xuICAgICAgLy8gT3B0aW9uYWwgbGVhZGluZyBhbXBlcnNhbmRcbiAgICAgIHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5BTVApO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBfdGhpcyRfb3B0aW9uczI7XG5cbiAgICAgICAgdHlwZXMucHVzaCh0aGlzLnBhcnNlTmFtZWRUeXBlKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLkFNUCkgfHwgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHRoZSBTREw/XG4gICAgICAoKF90aGlzJF9vcHRpb25zMiA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF90aGlzJF9vcHRpb25zMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX29wdGlvbnMyLmFsbG93TGVnYWN5U0RMSW1wbGVtZW50c0ludGVyZmFjZXMpID09PSB0cnVlICYmIHRoaXMucGVlayhfdG9rZW5LaW5kLlRva2VuS2luZC5OQU1FKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVzO1xuICB9XG4gIC8qKlxuICAgKiBGaWVsZHNEZWZpbml0aW9uIDogeyBGaWVsZERlZmluaXRpb24rIH1cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VGaWVsZHNEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VGaWVsZHNEZWZpbml0aW9uKCkge1xuICAgIHZhciBfdGhpcyRfb3B0aW9uczM7XG5cbiAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdGhlIFNETD9cbiAgICBpZiAoKChfdGhpcyRfb3B0aW9uczMgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfdGhpcyRfb3B0aW9uczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9vcHRpb25zMy5hbGxvd0xlZ2FjeVNETEVtcHR5RmllbGRzKSA9PT0gdHJ1ZSAmJiB0aGlzLnBlZWsoX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfTCkgJiYgdGhpcy5fbGV4ZXIubG9va2FoZWFkKCkua2luZCA9PT0gX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfUikge1xuICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgICB0aGlzLl9sZXhlci5hZHZhbmNlKCk7XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfTCwgdGhpcy5wYXJzZUZpZWxkRGVmaW5pdGlvbiwgX3Rva2VuS2luZC5Ub2tlbktpbmQuQlJBQ0VfUik7XG4gIH1cbiAgLyoqXG4gICAqIEZpZWxkRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gTmFtZSBBcmd1bWVudHNEZWZpbml0aW9uPyA6IFR5cGUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRmllbGREZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VGaWVsZERlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50RGVmcygpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQ09MT04pO1xuICAgIHZhciB0eXBlID0gdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5GSUVMRF9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBcmd1bWVudHNEZWZpbml0aW9uIDogKCBJbnB1dFZhbHVlRGVmaW5pdGlvbisgKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUFyZ3VtZW50RGVmcyA9IGZ1bmN0aW9uIHBhcnNlQXJndW1lbnREZWZzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShfdG9rZW5LaW5kLlRva2VuS2luZC5QQVJFTl9MLCB0aGlzLnBhcnNlSW5wdXRWYWx1ZURlZiwgX3Rva2VuS2luZC5Ub2tlbktpbmQuUEFSRU5fUik7XG4gIH1cbiAgLyoqXG4gICAqIElucHV0VmFsdWVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBOYW1lIDogVHlwZSBEZWZhdWx0VmFsdWU/IERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUlucHV0VmFsdWVEZWYgPSBmdW5jdGlvbiBwYXJzZUlucHV0VmFsdWVEZWYoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuQ09MT04pO1xuICAgIHZhciB0eXBlID0gdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5FUVVBTFMpKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKHRydWUpO1xuICAgIH1cblxuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLklOUFVUX1ZBTFVFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJmYWNlVHlwZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IGludGVyZmFjZSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBGaWVsZHNEZWZpbml0aW9uP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUludGVyZmFjZVR5cGVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ludGVyZmFjZScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW50ZXJmYWNlczogaW50ZXJmYWNlcyxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVW5pb25UeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gdW5pb24gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gVW5pb25NZW1iZXJUeXBlcz9cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VVbmlvblR5cGVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VVbmlvblR5cGVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndW5pb24nKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKTtcbiAgICB2YXIgdHlwZXMgPSB0aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5VTklPTl9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIHR5cGVzOiB0eXBlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVW5pb25NZW1iZXJUeXBlcyA6XG4gICAqICAgLSA9IGB8YD8gTmFtZWRUeXBlXG4gICAqICAgLSBVbmlvbk1lbWJlclR5cGVzIHwgTmFtZWRUeXBlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVW5pb25NZW1iZXJUeXBlcyA9IGZ1bmN0aW9uIHBhcnNlVW5pb25NZW1iZXJUeXBlcygpIHtcbiAgICB2YXIgdHlwZXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuRVFVQUxTKSkge1xuICAgICAgLy8gT3B0aW9uYWwgbGVhZGluZyBwaXBlXG4gICAgICB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuUElQRSk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdHlwZXMucHVzaCh0aGlzLnBhcnNlTmFtZWRUeXBlKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKF90b2tlbktpbmQuVG9rZW5LaW5kLlBJUEUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZXM7XG4gIH1cbiAgLyoqXG4gICAqIEVudW1UeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gZW51bSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBFbnVtVmFsdWVzRGVmaW5pdGlvbj9cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VFbnVtVHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZUVudW1UeXBlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2VudW0nKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKTtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLkVOVU1fVFlQRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRW51bVZhbHVlc0RlZmluaXRpb24gOiB7IEVudW1WYWx1ZURlZmluaXRpb24rIH1cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VFbnVtVmFsdWVzRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX0wsIHRoaXMucGFyc2VFbnVtVmFsdWVEZWZpbml0aW9uLCBfdG9rZW5LaW5kLlRva2VuS2luZC5CUkFDRV9SKTtcbiAgfVxuICAvKipcbiAgICogRW51bVZhbHVlRGVmaW5pdGlvbiA6IERlc2NyaXB0aW9uPyBFbnVtVmFsdWUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqXG4gICAqIEVudW1WYWx1ZSA6IE5hbWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VFbnVtVmFsdWVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5FTlVNX1ZBTFVFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gaW5wdXQgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gSW5wdXRGaWVsZHNEZWZpbml0aW9uP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbnB1dCcpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLklOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbnB1dEZpZWxkc0RlZmluaXRpb24gOiB7IElucHV0VmFsdWVEZWZpbml0aW9uKyB9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX0wsIHRoaXMucGFyc2VJbnB1dFZhbHVlRGVmLCBfdG9rZW5LaW5kLlRva2VuS2luZC5CUkFDRV9SKTtcbiAgfVxuICAvKipcbiAgICogVHlwZVN5c3RlbUV4dGVuc2lvbiA6XG4gICAqICAgLSBTY2hlbWFFeHRlbnNpb25cbiAgICogICAtIFR5cGVFeHRlbnNpb25cbiAgICpcbiAgICogVHlwZUV4dGVuc2lvbiA6XG4gICAqICAgLSBTY2FsYXJUeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBPYmplY3RUeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBVbmlvblR5cGVFeHRlbnNpb25cbiAgICogICAtIEVudW1UeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbigpIHtcbiAgICB2YXIga2V5d29yZFRva2VuID0gdGhpcy5fbGV4ZXIubG9va2FoZWFkKCk7XG5cbiAgICBpZiAoa2V5d29yZFRva2VuLmtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLk5BTUUpIHtcbiAgICAgIHN3aXRjaCAoa2V5d29yZFRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3NjaGVtYSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWFFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NhbGFyVHlwZUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uKCk7XG5cbiAgICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVW5pb25UeXBlRXh0ZW5zaW9uKCk7XG5cbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlucHV0T2JqZWN0VHlwZUV4dGVuc2lvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZChrZXl3b3JkVG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBTY2hlbWFFeHRlbnNpb24gOlxuICAgKiAgLSBleHRlbmQgc2NoZW1hIERpcmVjdGl2ZXNbQ29uc3RdPyB7IE9wZXJhdGlvblR5cGVEZWZpbml0aW9uKyB9XG4gICAqICAtIGV4dGVuZCBzY2hlbWEgRGlyZWN0aXZlc1tDb25zdF1cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VTY2hlbWFFeHRlbnNpb24gPSBmdW5jdGlvbiBwYXJzZVNjaGVtYUV4dGVuc2lvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc2NoZW1hJyk7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKTtcbiAgICB2YXIgb3BlcmF0aW9uVHlwZXMgPSB0aGlzLm9wdGlvbmFsTWFueShfdG9rZW5LaW5kLlRva2VuS2luZC5CUkFDRV9MLCB0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24sIF90b2tlbktpbmQuVG9rZW5LaW5kLkJSQUNFX1IpO1xuXG4gICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmIG9wZXJhdGlvblR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLlNDSEVNQV9FWFRFTlNJT04sXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgb3BlcmF0aW9uVHlwZXM6IG9wZXJhdGlvblR5cGVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTY2FsYXJUeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCBzY2FsYXIgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVNjYWxhclR5cGVFeHRlbnNpb24gPSBmdW5jdGlvbiBwYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3NjYWxhcicpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuXG4gICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuU0NBTEFSX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdFR5cGVFeHRlbnNpb24gOlxuICAgKiAgLSBleHRlbmQgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvblxuICAgKiAgLSBleHRlbmQgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKiAgLSBleHRlbmQgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndHlwZScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoaW50ZXJmYWNlcy5sZW5ndGggPT09IDAgJiYgZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLk9CSkVDVF9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbnRlcmZhY2VzOiBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uIDpcbiAgICogIC0gZXh0ZW5kIGludGVyZmFjZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvblxuICAgKiAgLSBleHRlbmQgaW50ZXJmYWNlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXM/IERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqICAtIGV4dGVuZCBpbnRlcmZhY2UgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlc1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUludGVyZmFjZVR5cGVFeHRlbnNpb24gPSBmdW5jdGlvbiBwYXJzZUludGVyZmFjZVR5cGVFeHRlbnNpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ludGVyZmFjZScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoaW50ZXJmYWNlcy5sZW5ndGggPT09IDAgJiYgZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLklOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbnRlcmZhY2VzOiBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVbmlvblR5cGVFeHRlbnNpb24gOlxuICAgKiAgIC0gZXh0ZW5kIHVuaW9uIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IFVuaW9uTWVtYmVyVHlwZXNcbiAgICogICAtIGV4dGVuZCB1bmlvbiBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVW5pb25UeXBlRXh0ZW5zaW9uID0gZnVuY3Rpb24gcGFyc2VVbmlvblR5cGVFeHRlbnNpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3VuaW9uJyk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIHR5cGVzID0gdGhpcy5wYXJzZVVuaW9uTWVtYmVyVHlwZXMoKTtcblxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBfa2luZHMuS2luZC5VTklPTl9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgdHlwZXM6IHR5cGVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbnVtVHlwZUV4dGVuc2lvbiA6XG4gICAqICAgLSBleHRlbmQgZW51bSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBFbnVtVmFsdWVzRGVmaW5pdGlvblxuICAgKiAgIC0gZXh0ZW5kIGVudW0gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUVudW1UeXBlRXh0ZW5zaW9uID0gZnVuY3Rpb24gcGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZW51bScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtcblxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuRU5VTV9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbiA6XG4gICAqICAgLSBleHRlbmQgaW5wdXQgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gSW5wdXRGaWVsZHNEZWZpbml0aW9uXG4gICAqICAgLSBleHRlbmQgaW5wdXQgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUlucHV0T2JqZWN0VHlwZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXh0ZW5kJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbnB1dCcpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IF9raW5kcy5LaW5kLklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgZmllbGRzOiBmaWVsZHMsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERpcmVjdGl2ZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IGRpcmVjdGl2ZSBAIE5hbWUgQXJndW1lbnRzRGVmaW5pdGlvbj8gYHJlcGVhdGFibGVgPyBvbiBEaXJlY3RpdmVMb2NhdGlvbnNcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZGlyZWN0aXZlJyk7XG4gICAgdGhpcy5leHBlY3RUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5BVCk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50RGVmcygpO1xuICAgIHZhciByZXBlYXRhYmxlID0gdGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoJ3JlcGVhdGFibGUnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ29uJyk7XG4gICAgdmFyIGxvY2F0aW9ucyA9IHRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogX2tpbmRzLktpbmQuRElSRUNUSVZFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgcmVwZWF0YWJsZTogcmVwZWF0YWJsZSxcbiAgICAgIGxvY2F0aW9uczogbG9jYXRpb25zLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEaXJlY3RpdmVMb2NhdGlvbnMgOlxuICAgKiAgIC0gYHxgPyBEaXJlY3RpdmVMb2NhdGlvblxuICAgKiAgIC0gRGlyZWN0aXZlTG9jYXRpb25zIHwgRGlyZWN0aXZlTG9jYXRpb25cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMgPSBmdW5jdGlvbiBwYXJzZURpcmVjdGl2ZUxvY2F0aW9ucygpIHtcbiAgICAvLyBPcHRpb25hbCBsZWFkaW5nIHBpcGVcbiAgICB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oX3Rva2VuS2luZC5Ub2tlbktpbmQuUElQRSk7XG4gICAgdmFyIGxvY2F0aW9ucyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgbG9jYXRpb25zLnB1c2godGhpcy5wYXJzZURpcmVjdGl2ZUxvY2F0aW9uKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihfdG9rZW5LaW5kLlRva2VuS2luZC5QSVBFKSk7XG5cbiAgICByZXR1cm4gbG9jYXRpb25zO1xuICB9XG4gIC8qXG4gICAqIERpcmVjdGl2ZUxvY2F0aW9uIDpcbiAgICogICAtIEV4ZWN1dGFibGVEaXJlY3RpdmVMb2NhdGlvblxuICAgKiAgIC0gVHlwZVN5c3RlbURpcmVjdGl2ZUxvY2F0aW9uXG4gICAqXG4gICAqIEV4ZWN1dGFibGVEaXJlY3RpdmVMb2NhdGlvbiA6IG9uZSBvZlxuICAgKiAgIGBRVUVSWWBcbiAgICogICBgTVVUQVRJT05gXG4gICAqICAgYFNVQlNDUklQVElPTmBcbiAgICogICBgRklFTERgXG4gICAqICAgYEZSQUdNRU5UX0RFRklOSVRJT05gXG4gICAqICAgYEZSQUdNRU5UX1NQUkVBRGBcbiAgICogICBgSU5MSU5FX0ZSQUdNRU5UYFxuICAgKlxuICAgKiBUeXBlU3lzdGVtRGlyZWN0aXZlTG9jYXRpb24gOiBvbmUgb2ZcbiAgICogICBgU0NIRU1BYFxuICAgKiAgIGBTQ0FMQVJgXG4gICAqICAgYE9CSkVDVGBcbiAgICogICBgRklFTERfREVGSU5JVElPTmBcbiAgICogICBgQVJHVU1FTlRfREVGSU5JVElPTmBcbiAgICogICBgSU5URVJGQUNFYFxuICAgKiAgIGBVTklPTmBcbiAgICogICBgRU5VTWBcbiAgICogICBgRU5VTV9WQUxVRWBcbiAgICogICBgSU5QVVRfT0JKRUNUYFxuICAgKiAgIGBJTlBVVF9GSUVMRF9ERUZJTklUSU9OYFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZURpcmVjdGl2ZUxvY2F0aW9uID0gZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmVMb2NhdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG5cbiAgICBpZiAoX2RpcmVjdGl2ZUxvY2F0aW9uLkRpcmVjdGl2ZUxvY2F0aW9uW25hbWUudmFsdWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZChzdGFydCk7XG4gIH0gLy8gQ29yZSBwYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhdGlvbiBvYmplY3QsIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHBsYWNlIGluXG4gICAqIHRoZSBzb3VyY2UgdGhhdCBjcmVhdGVkIGEgZ2l2ZW4gcGFyc2VkIG9iamVjdC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ubG9jID0gZnVuY3Rpb24gbG9jKHN0YXJ0VG9rZW4pIHtcbiAgICB2YXIgX3RoaXMkX29wdGlvbnM0O1xuXG4gICAgaWYgKCgoX3RoaXMkX29wdGlvbnM0ID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX3RoaXMkX29wdGlvbnM0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfb3B0aW9uczQubm9Mb2NhdGlvbikgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBuZXcgX2FzdC5Mb2NhdGlvbihzdGFydFRva2VuLCB0aGlzLl9sZXhlci5sYXN0VG9rZW4sIHRoaXMuX2xleGVyLnNvdXJjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHRva2VuIGlzIG9mIGEgZ2l2ZW4ga2luZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wZWVrID0gZnVuY3Rpb24gcGVlayhraW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xleGVyLnRva2VuLmtpbmQgPT09IGtpbmQ7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlbiBraW5kLCByZXR1cm4gdGhhdCB0b2tlbiBhZnRlciBhZHZhbmNpbmdcbiAgICogdGhlIGxleGVyLiBPdGhlcndpc2UsIGRvIG5vdCBjaGFuZ2UgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4cGVjdFRva2VuID0gZnVuY3Rpb24gZXhwZWN0VG9rZW4oa2luZCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgPT09IGtpbmQpIHtcbiAgICAgIHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcblxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHRocm93ICgwLCBfc3ludGF4RXJyb3Iuc3ludGF4RXJyb3IpKHRoaXMuX2xleGVyLnNvdXJjZSwgdG9rZW4uc3RhcnQsIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGdldFRva2VuS2luZERlc2Moa2luZCksIFwiLCBmb3VuZCBcIikuY29uY2F0KGdldFRva2VuRGVzYyh0b2tlbiksIFwiLlwiKSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlbiBraW5kLCByZXR1cm4gdGhhdCB0b2tlbiBhZnRlciBhZHZhbmNpbmdcbiAgICogdGhlIGxleGVyLiBPdGhlcndpc2UsIGRvIG5vdCBjaGFuZ2UgdGhlIHBhcnNlciBzdGF0ZSBhbmQgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXhwZWN0T3B0aW9uYWxUb2tlbiA9IGZ1bmN0aW9uIGV4cGVjdE9wdGlvbmFsVG9rZW4oa2luZCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgPT09IGtpbmQpIHtcbiAgICAgIHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcblxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIGEgZ2l2ZW4ga2V5d29yZCwgYWR2YW5jZSB0aGUgbGV4ZXIuXG4gICAqIE90aGVyd2lzZSwgZG8gbm90IGNoYW5nZSB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvdyBhbiBlcnJvci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXhwZWN0S2V5d29yZCA9IGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQodmFsdWUpIHtcbiAgICB2YXIgdG9rZW4gPSB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIGlmICh0b2tlbi5raW5kID09PSBfdG9rZW5LaW5kLlRva2VuS2luZC5OQU1FICYmIHRva2VuLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAoMCwgX3N5bnRheEVycm9yLnN5bnRheEVycm9yKSh0aGlzLl9sZXhlci5zb3VyY2UsIHRva2VuLnN0YXJ0LCBcIkV4cGVjdGVkIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIiwgZm91bmQgXCIpLmNvbmNhdChnZXRUb2tlbkRlc2ModG9rZW4pLCBcIi5cIikpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSWYgdGhlIG5leHQgdG9rZW4gaXMgYSBnaXZlbiBrZXl3b3JkLCByZXR1cm4gXCJ0cnVlXCIgYWZ0ZXIgYWR2YW5jaW5nXG4gICAqIHRoZSBsZXhlci4gT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHJldHVybiBcImZhbHNlXCIuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4cGVjdE9wdGlvbmFsS2V5d29yZCA9IGZ1bmN0aW9uIGV4cGVjdE9wdGlvbmFsS2V5d29yZCh2YWx1ZSkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgPT09IF90b2tlbktpbmQuVG9rZW5LaW5kLk5BTUUgJiYgdG9rZW4udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9sZXhlci5hZHZhbmNlKCk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBlcnJvciB3aGVuIGFuIHVuZXhwZWN0ZWQgbGV4ZWQgdG9rZW5cbiAgICogaXMgZW5jb3VudGVyZWQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbiB1bmV4cGVjdGVkKGF0VG9rZW4pIHtcbiAgICB2YXIgdG9rZW4gPSBhdFRva2VuICE9PSBudWxsICYmIGF0VG9rZW4gIT09IHZvaWQgMCA/IGF0VG9rZW4gOiB0aGlzLl9sZXhlci50b2tlbjtcbiAgICByZXR1cm4gKDAsIF9zeW50YXhFcnJvci5zeW50YXhFcnJvcikodGhpcy5fbGV4ZXIuc291cmNlLCB0b2tlbi5zdGFydCwgXCJVbmV4cGVjdGVkIFwiLmNvbmNhdChnZXRUb2tlbkRlc2ModG9rZW4pLCBcIi5cIikpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcG9zc2libHkgZW1wdHkgbGlzdCBvZiBwYXJzZSBub2RlcywgZGV0ZXJtaW5lZCBieVxuICAgKiB0aGUgcGFyc2VGbi4gVGhpcyBsaXN0IGJlZ2lucyB3aXRoIGEgbGV4IHRva2VuIG9mIG9wZW5LaW5kXG4gICAqIGFuZCBlbmRzIHdpdGggYSBsZXggdG9rZW4gb2YgY2xvc2VLaW5kLiBBZHZhbmNlcyB0aGUgcGFyc2VyXG4gICAqIHRvIHRoZSBuZXh0IGxleCB0b2tlbiBhZnRlciB0aGUgY2xvc2luZyB0b2tlbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYW55ID0gZnVuY3Rpb24gYW55KG9wZW5LaW5kLCBwYXJzZUZuLCBjbG9zZUtpbmQpIHtcbiAgICB0aGlzLmV4cGVjdFRva2VuKG9wZW5LaW5kKTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcblxuICAgIHdoaWxlICghdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGNsb3NlS2luZCkpIHtcbiAgICAgIG5vZGVzLnB1c2gocGFyc2VGbi5jYWxsKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJzZUZuLlxuICAgKiBJdCBjYW4gYmUgZW1wdHkgb25seSBpZiBvcGVuIHRva2VuIGlzIG1pc3Npbmcgb3RoZXJ3aXNlIGl0IHdpbGwgYWx3YXlzXG4gICAqIHJldHVybiBub24tZW1wdHkgbGlzdCB0aGF0IGJlZ2lucyB3aXRoIGEgbGV4IHRva2VuIG9mIG9wZW5LaW5kIGFuZCBlbmRzXG4gICAqIHdpdGggYSBsZXggdG9rZW4gb2YgY2xvc2VLaW5kLiBBZHZhbmNlcyB0aGUgcGFyc2VyIHRvIHRoZSBuZXh0IGxleCB0b2tlblxuICAgKiBhZnRlciB0aGUgY2xvc2luZyB0b2tlbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub3B0aW9uYWxNYW55ID0gZnVuY3Rpb24gb3B0aW9uYWxNYW55KG9wZW5LaW5kLCBwYXJzZUZuLCBjbG9zZUtpbmQpIHtcbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKG9wZW5LaW5kKSkge1xuICAgICAgdmFyIG5vZGVzID0gW107XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZXMucHVzaChwYXJzZUZuLmNhbGwodGhpcykpO1xuICAgICAgfSB3aGlsZSAoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihjbG9zZUtpbmQpKTtcblxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5vbi1lbXB0eSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5XG4gICAqIHRoZSBwYXJzZUZuLiBUaGlzIGxpc3QgYmVnaW5zIHdpdGggYSBsZXggdG9rZW4gb2Ygb3BlbktpbmRcbiAgICogYW5kIGVuZHMgd2l0aCBhIGxleCB0b2tlbiBvZiBjbG9zZUtpbmQuIEFkdmFuY2VzIHRoZSBwYXJzZXJcbiAgICogdG8gdGhlIG5leHQgbGV4IHRva2VuIGFmdGVyIHRoZSBjbG9zaW5nIHRva2VuLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5tYW55ID0gZnVuY3Rpb24gbWFueShvcGVuS2luZCwgcGFyc2VGbiwgY2xvc2VLaW5kKSB7XG4gICAgdGhpcy5leHBlY3RUb2tlbihvcGVuS2luZCk7XG4gICAgdmFyIG5vZGVzID0gW107XG5cbiAgICBkbyB7XG4gICAgICBub2Rlcy5wdXNoKHBhcnNlRm4uY2FsbCh0aGlzKSk7XG4gICAgfSB3aGlsZSAoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihjbG9zZUtpbmQpKTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfTtcblxuICByZXR1cm4gUGFyc2VyO1xufSgpO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBkZXNjcmliZSBhIHRva2VuIGFzIGEgc3RyaW5nIGZvciBkZWJ1Z2dpbmdcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRva2VuRGVzYyh0b2tlbikge1xuICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgcmV0dXJuIGdldFRva2VuS2luZERlc2ModG9rZW4ua2luZCkgKyAodmFsdWUgIT0gbnVsbCA/IFwiIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSA6ICcnKTtcbn1cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZGVzY3JpYmUgYSB0b2tlbiBraW5kIGFzIGEgc3RyaW5nIGZvciBkZWJ1Z2dpbmdcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRva2VuS2luZERlc2Moa2luZCkge1xuICByZXR1cm4gKDAsIF9sZXhlci5pc1B1bmN0dWF0b3JUb2tlbktpbmQpKGtpbmQpID8gXCJcXFwiXCIuY29uY2F0KGtpbmQsIFwiXFxcIlwiKSA6IGtpbmQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucHJpbnRMb2NhdGlvbiA9IHByaW50TG9jYXRpb247XG5leHBvcnRzLnByaW50U291cmNlTG9jYXRpb24gPSBwcmludFNvdXJjZUxvY2F0aW9uO1xuXG52YXIgX2xvY2F0aW9uID0gcmVxdWlyZShcIi4vbG9jYXRpb25cIik7XG5cbi8qKlxuICogUmVuZGVyIGEgaGVscGZ1bCBkZXNjcmlwdGlvbiBvZiB0aGUgbG9jYXRpb24gaW4gdGhlIEdyYXBoUUwgU291cmNlIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiBwcmludExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBwcmludFNvdXJjZUxvY2F0aW9uKGxvY2F0aW9uLnNvdXJjZSwgKDAsIF9sb2NhdGlvbi5nZXRMb2NhdGlvbikobG9jYXRpb24uc291cmNlLCBsb2NhdGlvbi5zdGFydCkpO1xufVxuLyoqXG4gKiBSZW5kZXIgYSBoZWxwZnVsIGRlc2NyaXB0aW9uIG9mIHRoZSBsb2NhdGlvbiBpbiB0aGUgR3JhcGhRTCBTb3VyY2UgZG9jdW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBwcmludFNvdXJjZUxvY2F0aW9uKHNvdXJjZSwgc291cmNlTG9jYXRpb24pIHtcbiAgdmFyIGZpcnN0TGluZUNvbHVtbk9mZnNldCA9IHNvdXJjZS5sb2NhdGlvbk9mZnNldC5jb2x1bW4gLSAxO1xuICB2YXIgYm9keSA9IHdoaXRlc3BhY2UoZmlyc3RMaW5lQ29sdW1uT2Zmc2V0KSArIHNvdXJjZS5ib2R5O1xuICB2YXIgbGluZUluZGV4ID0gc291cmNlTG9jYXRpb24ubGluZSAtIDE7XG4gIHZhciBsaW5lT2Zmc2V0ID0gc291cmNlLmxvY2F0aW9uT2Zmc2V0LmxpbmUgLSAxO1xuICB2YXIgbGluZU51bSA9IHNvdXJjZUxvY2F0aW9uLmxpbmUgKyBsaW5lT2Zmc2V0O1xuICB2YXIgY29sdW1uT2Zmc2V0ID0gc291cmNlTG9jYXRpb24ubGluZSA9PT0gMSA/IGZpcnN0TGluZUNvbHVtbk9mZnNldCA6IDA7XG4gIHZhciBjb2x1bW5OdW0gPSBzb3VyY2VMb2NhdGlvbi5jb2x1bW4gKyBjb2x1bW5PZmZzZXQ7XG4gIHZhciBsb2NhdGlvblN0ciA9IFwiXCIuY29uY2F0KHNvdXJjZS5uYW1lLCBcIjpcIikuY29uY2F0KGxpbmVOdW0sIFwiOlwiKS5jb25jYXQoY29sdW1uTnVtLCBcIlxcblwiKTtcbiAgdmFyIGxpbmVzID0gYm9keS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICB2YXIgbG9jYXRpb25MaW5lID0gbGluZXNbbGluZUluZGV4XTsgLy8gU3BlY2lhbCBjYXNlIGZvciBtaW5pZmllZCBkb2N1bWVudHNcblxuICBpZiAobG9jYXRpb25MaW5lLmxlbmd0aCA+IDEyMCkge1xuICAgIHZhciBzdWJMaW5lSW5kZXggPSBNYXRoLmZsb29yKGNvbHVtbk51bSAvIDgwKTtcbiAgICB2YXIgc3ViTGluZUNvbHVtbk51bSA9IGNvbHVtbk51bSAlIDgwO1xuICAgIHZhciBzdWJMaW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhdGlvbkxpbmUubGVuZ3RoOyBpICs9IDgwKSB7XG4gICAgICBzdWJMaW5lcy5wdXNoKGxvY2F0aW9uTGluZS5zbGljZShpLCBpICsgODApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYXRpb25TdHIgKyBwcmludFByZWZpeGVkTGluZXMoW1tcIlwiLmNvbmNhdChsaW5lTnVtKSwgc3ViTGluZXNbMF1dXS5jb25jYXQoc3ViTGluZXMuc2xpY2UoMSwgc3ViTGluZUluZGV4ICsgMSkubWFwKGZ1bmN0aW9uIChzdWJMaW5lKSB7XG4gICAgICByZXR1cm4gWycnLCBzdWJMaW5lXTtcbiAgICB9KSwgW1snICcsIHdoaXRlc3BhY2Uoc3ViTGluZUNvbHVtbk51bSAtIDEpICsgJ14nXSwgWycnLCBzdWJMaW5lc1tzdWJMaW5lSW5kZXggKyAxXV1dKSk7XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb25TdHIgKyBwcmludFByZWZpeGVkTGluZXMoWy8vIExpbmVzIHNwZWNpZmllZCBsaWtlIHRoaXM6IFtcInByZWZpeFwiLCBcInN0cmluZ1wiXSxcbiAgW1wiXCIuY29uY2F0KGxpbmVOdW0gLSAxKSwgbGluZXNbbGluZUluZGV4IC0gMV1dLCBbXCJcIi5jb25jYXQobGluZU51bSksIGxvY2F0aW9uTGluZV0sIFsnJywgd2hpdGVzcGFjZShjb2x1bW5OdW0gLSAxKSArICdeJ10sIFtcIlwiLmNvbmNhdChsaW5lTnVtICsgMSksIGxpbmVzW2xpbmVJbmRleCArIDFdXV0pO1xufVxuXG5mdW5jdGlvbiBwcmludFByZWZpeGVkTGluZXMobGluZXMpIHtcbiAgdmFyIGV4aXN0aW5nTGluZXMgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgXyA9IF9yZWZbMF0sXG4gICAgICAgIGxpbmUgPSBfcmVmWzFdO1xuICAgIHJldHVybiBsaW5lICE9PSB1bmRlZmluZWQ7XG4gIH0pO1xuICB2YXIgcGFkTGVuID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZXhpc3RpbmdMaW5lcy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHByZWZpeCA9IF9yZWYyWzBdO1xuICAgIHJldHVybiBwcmVmaXgubGVuZ3RoO1xuICB9KSk7XG4gIHJldHVybiBleGlzdGluZ0xpbmVzLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgcHJlZml4ID0gX3JlZjNbMF0sXG4gICAgICAgIGxpbmUgPSBfcmVmM1sxXTtcbiAgICByZXR1cm4gbGVmdFBhZChwYWRMZW4sIHByZWZpeCkgKyAobGluZSA/ICcgfCAnICsgbGluZSA6ICcgfCcpO1xuICB9KS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gd2hpdGVzcGFjZShsZW4pIHtcbiAgcmV0dXJuIEFycmF5KGxlbiArIDEpLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZChsZW4sIHN0cikge1xuICByZXR1cm4gd2hpdGVzcGFjZShsZW4gLSBzdHIubGVuZ3RoKSArIHN0cjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wcmludCA9IHByaW50O1xuXG52YXIgX3Zpc2l0b3IgPSByZXF1aXJlKFwiLi92aXNpdG9yXCIpO1xuXG52YXIgX2Jsb2NrU3RyaW5nID0gcmVxdWlyZShcIi4vYmxvY2tTdHJpbmdcIik7XG5cbi8qKlxuICogQ29udmVydHMgYW4gQVNUIGludG8gYSBzdHJpbmcsIHVzaW5nIG9uZSBzZXQgb2YgcmVhc29uYWJsZVxuICogZm9ybWF0dGluZyBydWxlcy5cbiAqL1xuZnVuY3Rpb24gcHJpbnQoYXN0KSB7XG4gIHJldHVybiAoMCwgX3Zpc2l0b3IudmlzaXQpKGFzdCwge1xuICAgIGxlYXZlOiBwcmludERvY0FTVFJlZHVjZXJcbiAgfSk7XG59IC8vIFRPRE86IHByb3ZpZGUgYmV0dGVyIHR5cGUgY292ZXJhZ2UgaW4gZnV0dXJlXG5cblxudmFyIHByaW50RG9jQVNUUmVkdWNlciA9IHtcbiAgTmFtZTogZnVuY3Rpb24gTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0sXG4gIFZhcmlhYmxlOiBmdW5jdGlvbiBWYXJpYWJsZShub2RlKSB7XG4gICAgcmV0dXJuICckJyArIG5vZGUubmFtZTtcbiAgfSxcbiAgLy8gRG9jdW1lbnRcbiAgRG9jdW1lbnQ6IGZ1bmN0aW9uIERvY3VtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gam9pbihub2RlLmRlZmluaXRpb25zLCAnXFxuXFxuJykgKyAnXFxuJztcbiAgfSxcbiAgT3BlcmF0aW9uRGVmaW5pdGlvbjogZnVuY3Rpb24gT3BlcmF0aW9uRGVmaW5pdGlvbihub2RlKSB7XG4gICAgdmFyIG9wID0gbm9kZS5vcGVyYXRpb247XG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgdmFyIHZhckRlZnMgPSB3cmFwKCcoJywgam9pbihub2RlLnZhcmlhYmxlRGVmaW5pdGlvbnMsICcsICcpLCAnKScpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gam9pbihub2RlLmRpcmVjdGl2ZXMsICcgJyk7XG4gICAgdmFyIHNlbGVjdGlvblNldCA9IG5vZGUuc2VsZWN0aW9uU2V0OyAvLyBBbm9ueW1vdXMgcXVlcmllcyB3aXRoIG5vIGRpcmVjdGl2ZXMgb3IgdmFyaWFibGUgZGVmaW5pdGlvbnMgY2FuIHVzZVxuICAgIC8vIHRoZSBxdWVyeSBzaG9ydCBmb3JtLlxuXG4gICAgcmV0dXJuICFuYW1lICYmICFkaXJlY3RpdmVzICYmICF2YXJEZWZzICYmIG9wID09PSAncXVlcnknID8gc2VsZWN0aW9uU2V0IDogam9pbihbb3AsIGpvaW4oW25hbWUsIHZhckRlZnNdKSwgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0XSwgJyAnKTtcbiAgfSxcbiAgVmFyaWFibGVEZWZpbml0aW9uOiBmdW5jdGlvbiBWYXJpYWJsZURlZmluaXRpb24oX3JlZikge1xuICAgIHZhciB2YXJpYWJsZSA9IF9yZWYudmFyaWFibGUsXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9yZWYuZGVmYXVsdFZhbHVlLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZi5kaXJlY3RpdmVzO1xuICAgIHJldHVybiB2YXJpYWJsZSArICc6ICcgKyB0eXBlICsgd3JhcCgnID0gJywgZGVmYXVsdFZhbHVlKSArIHdyYXAoJyAnLCBqb2luKGRpcmVjdGl2ZXMsICcgJykpO1xuICB9LFxuICBTZWxlY3Rpb25TZXQ6IGZ1bmN0aW9uIFNlbGVjdGlvblNldChfcmVmMikge1xuICAgIHZhciBzZWxlY3Rpb25zID0gX3JlZjIuc2VsZWN0aW9ucztcbiAgICByZXR1cm4gYmxvY2soc2VsZWN0aW9ucyk7XG4gIH0sXG4gIEZpZWxkOiBmdW5jdGlvbiBGaWVsZChfcmVmMykge1xuICAgIHZhciBhbGlhcyA9IF9yZWYzLmFsaWFzLFxuICAgICAgICBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgYXJncyA9IF9yZWYzLmFyZ3VtZW50cyxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzLmRpcmVjdGl2ZXMsXG4gICAgICAgIHNlbGVjdGlvblNldCA9IF9yZWYzLnNlbGVjdGlvblNldDtcbiAgICByZXR1cm4gam9pbihbd3JhcCgnJywgYWxpYXMsICc6ICcpICsgbmFtZSArIHdyYXAoJygnLCBqb2luKGFyZ3MsICcsICcpLCAnKScpLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIHNlbGVjdGlvblNldF0sICcgJyk7XG4gIH0sXG4gIEFyZ3VtZW50OiBmdW5jdGlvbiBBcmd1bWVudChfcmVmNCkge1xuICAgIHZhciBuYW1lID0gX3JlZjQubmFtZSxcbiAgICAgICAgdmFsdWUgPSBfcmVmNC52YWx1ZTtcbiAgICByZXR1cm4gbmFtZSArICc6ICcgKyB2YWx1ZTtcbiAgfSxcbiAgLy8gRnJhZ21lbnRzXG4gIEZyYWdtZW50U3ByZWFkOiBmdW5jdGlvbiBGcmFnbWVudFNwcmVhZChfcmVmNSkge1xuICAgIHZhciBuYW1lID0gX3JlZjUubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWY1LmRpcmVjdGl2ZXM7XG4gICAgcmV0dXJuICcuLi4nICsgbmFtZSArIHdyYXAoJyAnLCBqb2luKGRpcmVjdGl2ZXMsICcgJykpO1xuICB9LFxuICBJbmxpbmVGcmFnbWVudDogZnVuY3Rpb24gSW5saW5lRnJhZ21lbnQoX3JlZjYpIHtcbiAgICB2YXIgdHlwZUNvbmRpdGlvbiA9IF9yZWY2LnR5cGVDb25kaXRpb24sXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmNi5kaXJlY3RpdmVzLFxuICAgICAgICBzZWxlY3Rpb25TZXQgPSBfcmVmNi5zZWxlY3Rpb25TZXQ7XG4gICAgcmV0dXJuIGpvaW4oWycuLi4nLCB3cmFwKCdvbiAnLCB0eXBlQ29uZGl0aW9uKSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBzZWxlY3Rpb25TZXRdLCAnICcpO1xuICB9LFxuICBGcmFnbWVudERlZmluaXRpb246IGZ1bmN0aW9uIEZyYWdtZW50RGVmaW5pdGlvbihfcmVmNykge1xuICAgIHZhciBuYW1lID0gX3JlZjcubmFtZSxcbiAgICAgICAgdHlwZUNvbmRpdGlvbiA9IF9yZWY3LnR5cGVDb25kaXRpb24sXG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnMgPSBfcmVmNy52YXJpYWJsZURlZmluaXRpb25zLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjcuZGlyZWN0aXZlcyxcbiAgICAgICAgc2VsZWN0aW9uU2V0ID0gX3JlZjcuc2VsZWN0aW9uU2V0O1xuICAgIHJldHVybiAoLy8gTm90ZTogZnJhZ21lbnQgdmFyaWFibGUgZGVmaW5pdGlvbnMgYXJlIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGJlIGNoYW5nZWRcbiAgICAgIC8vIG9yIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgIFwiZnJhZ21lbnQgXCIuY29uY2F0KG5hbWUpLmNvbmNhdCh3cmFwKCcoJywgam9pbih2YXJpYWJsZURlZmluaXRpb25zLCAnLCAnKSwgJyknKSwgXCIgXCIpICsgXCJvbiBcIi5jb25jYXQodHlwZUNvbmRpdGlvbiwgXCIgXCIpLmNvbmNhdCh3cmFwKCcnLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksICcgJykpICsgc2VsZWN0aW9uU2V0XG4gICAgKTtcbiAgfSxcbiAgLy8gVmFsdWVcbiAgSW50VmFsdWU6IGZ1bmN0aW9uIEludFZhbHVlKF9yZWY4KSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjgudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBGbG9hdFZhbHVlOiBmdW5jdGlvbiBGbG9hdFZhbHVlKF9yZWY5KSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjkudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBTdHJpbmdWYWx1ZTogZnVuY3Rpb24gU3RyaW5nVmFsdWUoX3JlZjEwLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmMTAudmFsdWUsXG4gICAgICAgIGlzQmxvY2tTdHJpbmcgPSBfcmVmMTAuYmxvY2s7XG4gICAgcmV0dXJuIGlzQmxvY2tTdHJpbmcgPyAoMCwgX2Jsb2NrU3RyaW5nLnByaW50QmxvY2tTdHJpbmcpKHZhbHVlLCBrZXkgPT09ICdkZXNjcmlwdGlvbicgPyAnJyA6ICcgICcpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9LFxuICBCb29sZWFuVmFsdWU6IGZ1bmN0aW9uIEJvb2xlYW5WYWx1ZShfcmVmMTEpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmMTEudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSxcbiAgTnVsbFZhbHVlOiBmdW5jdGlvbiBOdWxsVmFsdWUoKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSxcbiAgRW51bVZhbHVlOiBmdW5jdGlvbiBFbnVtVmFsdWUoX3JlZjEyKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjEyLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgTGlzdFZhbHVlOiBmdW5jdGlvbiBMaXN0VmFsdWUoX3JlZjEzKSB7XG4gICAgdmFyIHZhbHVlcyA9IF9yZWYxMy52YWx1ZXM7XG4gICAgcmV0dXJuICdbJyArIGpvaW4odmFsdWVzLCAnLCAnKSArICddJztcbiAgfSxcbiAgT2JqZWN0VmFsdWU6IGZ1bmN0aW9uIE9iamVjdFZhbHVlKF9yZWYxNCkge1xuICAgIHZhciBmaWVsZHMgPSBfcmVmMTQuZmllbGRzO1xuICAgIHJldHVybiAneycgKyBqb2luKGZpZWxkcywgJywgJykgKyAnfSc7XG4gIH0sXG4gIE9iamVjdEZpZWxkOiBmdW5jdGlvbiBPYmplY3RGaWVsZChfcmVmMTUpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYxNS5uYW1lLFxuICAgICAgICB2YWx1ZSA9IF9yZWYxNS52YWx1ZTtcbiAgICByZXR1cm4gbmFtZSArICc6ICcgKyB2YWx1ZTtcbiAgfSxcbiAgLy8gRGlyZWN0aXZlXG4gIERpcmVjdGl2ZTogZnVuY3Rpb24gRGlyZWN0aXZlKF9yZWYxNikge1xuICAgIHZhciBuYW1lID0gX3JlZjE2Lm5hbWUsXG4gICAgICAgIGFyZ3MgPSBfcmVmMTYuYXJndW1lbnRzO1xuICAgIHJldHVybiAnQCcgKyBuYW1lICsgd3JhcCgnKCcsIGpvaW4oYXJncywgJywgJyksICcpJyk7XG4gIH0sXG4gIC8vIFR5cGVcbiAgTmFtZWRUeXBlOiBmdW5jdGlvbiBOYW1lZFR5cGUoX3JlZjE3KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMTcubmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfSxcbiAgTGlzdFR5cGU6IGZ1bmN0aW9uIExpc3RUeXBlKF9yZWYxOCkge1xuICAgIHZhciB0eXBlID0gX3JlZjE4LnR5cGU7XG4gICAgcmV0dXJuICdbJyArIHR5cGUgKyAnXSc7XG4gIH0sXG4gIE5vbk51bGxUeXBlOiBmdW5jdGlvbiBOb25OdWxsVHlwZShfcmVmMTkpIHtcbiAgICB2YXIgdHlwZSA9IF9yZWYxOS50eXBlO1xuICAgIHJldHVybiB0eXBlICsgJyEnO1xuICB9LFxuICAvLyBUeXBlIFN5c3RlbSBEZWZpbml0aW9uc1xuICBTY2hlbWFEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjIwKSB7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSBfcmVmMjAuZGlyZWN0aXZlcyxcbiAgICAgICAgb3BlcmF0aW9uVHlwZXMgPSBfcmVmMjAub3BlcmF0aW9uVHlwZXM7XG4gICAgcmV0dXJuIGpvaW4oWydzY2hlbWEnLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKG9wZXJhdGlvblR5cGVzKV0sICcgJyk7XG4gIH0pLFxuICBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjogZnVuY3Rpb24gT3BlcmF0aW9uVHlwZURlZmluaXRpb24oX3JlZjIxKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IF9yZWYyMS5vcGVyYXRpb24sXG4gICAgICAgIHR5cGUgPSBfcmVmMjEudHlwZTtcbiAgICByZXR1cm4gb3BlcmF0aW9uICsgJzogJyArIHR5cGU7XG4gIH0sXG4gIFNjYWxhclR5cGVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjIyKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjIubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYyMi5kaXJlY3RpdmVzO1xuICAgIHJldHVybiBqb2luKFsnc2NhbGFyJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSwgJyAnKTtcbiAgfSksXG4gIE9iamVjdFR5cGVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjIzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjMubmFtZSxcbiAgICAgICAgaW50ZXJmYWNlcyA9IF9yZWYyMy5pbnRlcmZhY2VzLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjIzLmRpcmVjdGl2ZXMsXG4gICAgICAgIGZpZWxkcyA9IF9yZWYyMy5maWVsZHM7XG4gICAgcmV0dXJuIGpvaW4oWyd0eXBlJywgbmFtZSwgd3JhcCgnaW1wbGVtZW50cyAnLCBqb2luKGludGVyZmFjZXMsICcgJiAnKSksIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyk7XG4gIH0pLFxuICBGaWVsZERlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjQpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyNC5uYW1lLFxuICAgICAgICBhcmdzID0gX3JlZjI0LmFyZ3VtZW50cyxcbiAgICAgICAgdHlwZSA9IF9yZWYyNC50eXBlLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjI0LmRpcmVjdGl2ZXM7XG4gICAgcmV0dXJuIG5hbWUgKyAoaGFzTXVsdGlsaW5lSXRlbXMoYXJncykgPyB3cmFwKCcoXFxuJywgaW5kZW50KGpvaW4oYXJncywgJ1xcbicpKSwgJ1xcbiknKSA6IHdyYXAoJygnLCBqb2luKGFyZ3MsICcsICcpLCAnKScpKSArICc6ICcgKyB0eXBlICsgd3JhcCgnICcsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSk7XG4gIH0pLFxuICBJbnB1dFZhbHVlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyNSkge1xuICAgIHZhciBuYW1lID0gX3JlZjI1Lm5hbWUsXG4gICAgICAgIHR5cGUgPSBfcmVmMjUudHlwZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gX3JlZjI1LmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYyNS5kaXJlY3RpdmVzO1xuICAgIHJldHVybiBqb2luKFtuYW1lICsgJzogJyArIHR5cGUsIHdyYXAoJz0gJywgZGVmYXVsdFZhbHVlKSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSwgJyAnKTtcbiAgfSksXG4gIEludGVyZmFjZVR5cGVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjI2KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjYubmFtZSxcbiAgICAgICAgaW50ZXJmYWNlcyA9IF9yZWYyNi5pbnRlcmZhY2VzLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjI2LmRpcmVjdGl2ZXMsXG4gICAgICAgIGZpZWxkcyA9IF9yZWYyNi5maWVsZHM7XG4gICAgcmV0dXJuIGpvaW4oWydpbnRlcmZhY2UnLCBuYW1lLCB3cmFwKCdpbXBsZW1lbnRzICcsIGpvaW4oaW50ZXJmYWNlcywgJyAmICcpKSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhmaWVsZHMpXSwgJyAnKTtcbiAgfSksXG4gIFVuaW9uVHlwZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjcpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyNy5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjI3LmRpcmVjdGl2ZXMsXG4gICAgICAgIHR5cGVzID0gX3JlZjI3LnR5cGVzO1xuICAgIHJldHVybiBqb2luKFsndW5pb24nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIHR5cGVzICYmIHR5cGVzLmxlbmd0aCAhPT0gMCA/ICc9ICcgKyBqb2luKHR5cGVzLCAnIHwgJykgOiAnJ10sICcgJyk7XG4gIH0pLFxuICBFbnVtVHlwZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjgpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyOC5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjI4LmRpcmVjdGl2ZXMsXG4gICAgICAgIHZhbHVlcyA9IF9yZWYyOC52YWx1ZXM7XG4gICAgcmV0dXJuIGpvaW4oWydlbnVtJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayh2YWx1ZXMpXSwgJyAnKTtcbiAgfSksXG4gIEVudW1WYWx1ZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjkpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyOS5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjI5LmRpcmVjdGl2ZXM7XG4gICAgcmV0dXJuIGpvaW4oW25hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyk7XG4gIH0pLFxuICBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjMwKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzAubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzMC5kaXJlY3RpdmVzLFxuICAgICAgICBmaWVsZHMgPSBfcmVmMzAuZmllbGRzO1xuICAgIHJldHVybiBqb2luKFsnaW5wdXQnLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpO1xuICB9KSxcbiAgRGlyZWN0aXZlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYzMSkge1xuICAgIHZhciBuYW1lID0gX3JlZjMxLm5hbWUsXG4gICAgICAgIGFyZ3MgPSBfcmVmMzEuYXJndW1lbnRzLFxuICAgICAgICByZXBlYXRhYmxlID0gX3JlZjMxLnJlcGVhdGFibGUsXG4gICAgICAgIGxvY2F0aW9ucyA9IF9yZWYzMS5sb2NhdGlvbnM7XG4gICAgcmV0dXJuICdkaXJlY3RpdmUgQCcgKyBuYW1lICsgKGhhc011bHRpbGluZUl0ZW1zKGFyZ3MpID8gd3JhcCgnKFxcbicsIGluZGVudChqb2luKGFyZ3MsICdcXG4nKSksICdcXG4pJykgOiB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKSkgKyAocmVwZWF0YWJsZSA/ICcgcmVwZWF0YWJsZScgOiAnJykgKyAnIG9uICcgKyBqb2luKGxvY2F0aW9ucywgJyB8ICcpO1xuICB9KSxcbiAgU2NoZW1hRXh0ZW5zaW9uOiBmdW5jdGlvbiBTY2hlbWFFeHRlbnNpb24oX3JlZjMyKSB7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSBfcmVmMzIuZGlyZWN0aXZlcyxcbiAgICAgICAgb3BlcmF0aW9uVHlwZXMgPSBfcmVmMzIub3BlcmF0aW9uVHlwZXM7XG4gICAgcmV0dXJuIGpvaW4oWydleHRlbmQgc2NoZW1hJywgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhvcGVyYXRpb25UeXBlcyldLCAnICcpO1xuICB9LFxuICBTY2FsYXJUeXBlRXh0ZW5zaW9uOiBmdW5jdGlvbiBTY2FsYXJUeXBlRXh0ZW5zaW9uKF9yZWYzMykge1xuICAgIHZhciBuYW1lID0gX3JlZjMzLm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMzMuZGlyZWN0aXZlcztcbiAgICByZXR1cm4gam9pbihbJ2V4dGVuZCBzY2FsYXInLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyldLCAnICcpO1xuICB9LFxuICBPYmplY3RUeXBlRXh0ZW5zaW9uOiBmdW5jdGlvbiBPYmplY3RUeXBlRXh0ZW5zaW9uKF9yZWYzNCkge1xuICAgIHZhciBuYW1lID0gX3JlZjM0Lm5hbWUsXG4gICAgICAgIGludGVyZmFjZXMgPSBfcmVmMzQuaW50ZXJmYWNlcyxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzNC5kaXJlY3RpdmVzLFxuICAgICAgICBmaWVsZHMgPSBfcmVmMzQuZmllbGRzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIHR5cGUnLCBuYW1lLCB3cmFwKCdpbXBsZW1lbnRzICcsIGpvaW4oaW50ZXJmYWNlcywgJyAmICcpKSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhmaWVsZHMpXSwgJyAnKTtcbiAgfSxcbiAgSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjogZnVuY3Rpb24gSW50ZXJmYWNlVHlwZUV4dGVuc2lvbihfcmVmMzUpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzNS5uYW1lLFxuICAgICAgICBpbnRlcmZhY2VzID0gX3JlZjM1LmludGVyZmFjZXMsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMzUuZGlyZWN0aXZlcyxcbiAgICAgICAgZmllbGRzID0gX3JlZjM1LmZpZWxkcztcbiAgICByZXR1cm4gam9pbihbJ2V4dGVuZCBpbnRlcmZhY2UnLCBuYW1lLCB3cmFwKCdpbXBsZW1lbnRzICcsIGpvaW4oaW50ZXJmYWNlcywgJyAmICcpKSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhmaWVsZHMpXSwgJyAnKTtcbiAgfSxcbiAgVW5pb25UeXBlRXh0ZW5zaW9uOiBmdW5jdGlvbiBVbmlvblR5cGVFeHRlbnNpb24oX3JlZjM2KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzYubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzNi5kaXJlY3RpdmVzLFxuICAgICAgICB0eXBlcyA9IF9yZWYzNi50eXBlcztcbiAgICByZXR1cm4gam9pbihbJ2V4dGVuZCB1bmlvbicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgdHlwZXMgJiYgdHlwZXMubGVuZ3RoICE9PSAwID8gJz0gJyArIGpvaW4odHlwZXMsICcgfCAnKSA6ICcnXSwgJyAnKTtcbiAgfSxcbiAgRW51bVR5cGVFeHRlbnNpb246IGZ1bmN0aW9uIEVudW1UeXBlRXh0ZW5zaW9uKF9yZWYzNykge1xuICAgIHZhciBuYW1lID0gX3JlZjM3Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMzcuZGlyZWN0aXZlcyxcbiAgICAgICAgdmFsdWVzID0gX3JlZjM3LnZhbHVlcztcbiAgICByZXR1cm4gam9pbihbJ2V4dGVuZCBlbnVtJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayh2YWx1ZXMpXSwgJyAnKTtcbiAgfSxcbiAgSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOiBmdW5jdGlvbiBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24oX3JlZjM4KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzgubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzOC5kaXJlY3RpdmVzLFxuICAgICAgICBmaWVsZHMgPSBfcmVmMzguZmllbGRzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIGlucHV0JywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhmaWVsZHMpXSwgJyAnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYWRkRGVzY3JpcHRpb24oY2IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGpvaW4oW25vZGUuZGVzY3JpcHRpb24sIGNiKG5vZGUpXSwgJ1xcbicpO1xuICB9O1xufVxuLyoqXG4gKiBHaXZlbiBtYXliZUFycmF5LCBwcmludCBhbiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgbnVsbCBvciBlbXB0eSwgb3RoZXJ3aXNlXG4gKiBwcmludCBhbGwgaXRlbXMgdG9nZXRoZXIgc2VwYXJhdGVkIGJ5IHNlcGFyYXRvciBpZiBwcm92aWRlZFxuICovXG5cblxuZnVuY3Rpb24gam9pbihtYXliZUFycmF5KSB7XG4gIHZhciBfbWF5YmVBcnJheSRmaWx0ZXIkam87XG5cbiAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHJldHVybiAoX21heWJlQXJyYXkkZmlsdGVyJGpvID0gbWF5YmVBcnJheSA9PT0gbnVsbCB8fCBtYXliZUFycmF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZUFycmF5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4O1xuICB9KS5qb2luKHNlcGFyYXRvcikpICE9PSBudWxsICYmIF9tYXliZUFycmF5JGZpbHRlciRqbyAhPT0gdm9pZCAwID8gX21heWJlQXJyYXkkZmlsdGVyJGpvIDogJyc7XG59XG4vKipcbiAqIEdpdmVuIGFycmF5LCBwcmludCBlYWNoIGl0ZW0gb24gaXRzIG93biBsaW5lLCB3cmFwcGVkIGluIGFuXG4gKiBpbmRlbnRlZCBcInsgfVwiIGJsb2NrLlxuICovXG5cblxuZnVuY3Rpb24gYmxvY2soYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCAhPT0gMCA/ICd7XFxuJyArIGluZGVudChqb2luKGFycmF5LCAnXFxuJykpICsgJ1xcbn0nIDogJyc7XG59XG4vKipcbiAqIElmIG1heWJlU3RyaW5nIGlzIG5vdCBudWxsIG9yIGVtcHR5LCB0aGVuIHdyYXAgd2l0aCBzdGFydCBhbmQgZW5kLCBvdGhlcndpc2VcbiAqIHByaW50IGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdyYXAoc3RhcnQsIG1heWJlU3RyaW5nKSB7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICByZXR1cm4gbWF5YmVTdHJpbmcgPyBzdGFydCArIG1heWJlU3RyaW5nICsgZW5kIDogJyc7XG59XG5cbmZ1bmN0aW9uIGluZGVudChtYXliZVN0cmluZykge1xuICByZXR1cm4gbWF5YmVTdHJpbmcgJiYgJyAgJyArIG1heWJlU3RyaW5nLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKTtcbn1cblxuZnVuY3Rpb24gaXNNdWx0aWxpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuaW5kZXhPZignXFxuJykgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBoYXNNdWx0aWxpbmVJdGVtcyhtYXliZUFycmF5KSB7XG4gIHJldHVybiBtYXliZUFycmF5ICYmIG1heWJlQXJyYXkuc29tZShpc011bHRpbGluZSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU291cmNlID0gdm9pZCAwO1xuXG52YXIgX3N5bWJvbHMgPSByZXF1aXJlKFwiLi4vcG9seWZpbGxzL3N5bWJvbHNcIik7XG5cbnZhciBfZGV2QXNzZXJ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vanN1dGlscy9kZXZBc3NlcnRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBzb3VyY2UgaW5wdXQgdG8gR3JhcGhRTC4gVGhlIGBuYW1lYCBhbmQgYGxvY2F0aW9uT2Zmc2V0YCBwYXJhbWV0ZXJzIGFyZVxuICogb3B0aW9uYWwsIGJ1dCB0aGV5IGFyZSB1c2VmdWwgZm9yIGNsaWVudHMgd2hvIHN0b3JlIEdyYXBoUUwgZG9jdW1lbnRzIGluIHNvdXJjZSBmaWxlcy5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgR3JhcGhRTCBpbnB1dCBzdGFydHMgYXQgbGluZSA0MCBpbiBhIGZpbGUgbmFtZWQgYEZvby5ncmFwaHFsYCwgaXQgbWlnaHRcbiAqIGJlIHVzZWZ1bCBmb3IgYG5hbWVgIHRvIGJlIGBcIkZvby5ncmFwaHFsXCJgIGFuZCBsb2NhdGlvbiB0byBiZSBgeyBsaW5lOiA0MCwgY29sdW1uOiAxIH1gLlxuICogVGhlIGBsaW5lYCBhbmQgYGNvbHVtbmAgcHJvcGVydGllcyBpbiBgbG9jYXRpb25PZmZzZXRgIGFyZSAxLWluZGV4ZWQuXG4gKi9cbnZhciBTb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTb3VyY2UoYm9keSkge1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnR3JhcGhRTCByZXF1ZXN0JztcbiAgICB2YXIgbG9jYXRpb25PZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDFcbiAgICB9O1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmxvY2F0aW9uT2Zmc2V0ID0gbG9jYXRpb25PZmZzZXQ7XG4gICAgdGhpcy5sb2NhdGlvbk9mZnNldC5saW5lID4gMCB8fCAoMCwgX2RldkFzc2VydC5kZWZhdWx0KSgwLCAnbGluZSBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUuJyk7XG4gICAgdGhpcy5sb2NhdGlvbk9mZnNldC5jb2x1bW4gPiAwIHx8ICgwLCBfZGV2QXNzZXJ0LmRlZmF1bHQpKDAsICdjb2x1bW4gaW4gbG9jYXRpb25PZmZzZXQgaXMgMS1pbmRleGVkIGFuZCBtdXN0IGJlIHBvc2l0aXZlLicpO1xuICB9IC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgY29tcHV0ZWQgcHJvcGVydGllcyB5ZXRcblxuXG4gIF9jcmVhdGVDbGFzcyhTb3VyY2UsIFt7XG4gICAga2V5OiBfc3ltYm9scy5TWU1CT0xfVE9fU1RSSU5HX1RBRyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnU291cmNlJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU291cmNlO1xufSgpO1xuXG5leHBvcnRzLlNvdXJjZSA9IFNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Ub2tlbktpbmQgPSB2b2lkIDA7XG5cbi8qKlxuICogQW4gZXhwb3J0ZWQgZW51bSBkZXNjcmliaW5nIHRoZSBkaWZmZXJlbnQga2luZHMgb2YgdG9rZW5zIHRoYXQgdGhlXG4gKiBsZXhlciBlbWl0cy5cbiAqL1xudmFyIFRva2VuS2luZCA9IE9iamVjdC5mcmVlemUoe1xuICBTT0Y6ICc8U09GPicsXG4gIEVPRjogJzxFT0Y+JyxcbiAgQkFORzogJyEnLFxuICBET0xMQVI6ICckJyxcbiAgQU1QOiAnJicsXG4gIFBBUkVOX0w6ICcoJyxcbiAgUEFSRU5fUjogJyknLFxuICBTUFJFQUQ6ICcuLi4nLFxuICBDT0xPTjogJzonLFxuICBFUVVBTFM6ICc9JyxcbiAgQVQ6ICdAJyxcbiAgQlJBQ0tFVF9MOiAnWycsXG4gIEJSQUNLRVRfUjogJ10nLFxuICBCUkFDRV9MOiAneycsXG4gIFBJUEU6ICd8JyxcbiAgQlJBQ0VfUjogJ30nLFxuICBOQU1FOiAnTmFtZScsXG4gIElOVDogJ0ludCcsXG4gIEZMT0FUOiAnRmxvYXQnLFxuICBTVFJJTkc6ICdTdHJpbmcnLFxuICBCTE9DS19TVFJJTkc6ICdCbG9ja1N0cmluZycsXG4gIENPTU1FTlQ6ICdDb21tZW50J1xufSk7XG4vKipcbiAqIFRoZSBlbnVtIHR5cGUgcmVwcmVzZW50aW5nIHRoZSB0b2tlbiBraW5kcyB2YWx1ZXMuXG4gKi9cblxuZXhwb3J0cy5Ub2tlbktpbmQgPSBUb2tlbktpbmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudmlzaXQgPSB2aXNpdDtcbmV4cG9ydHMudmlzaXRJblBhcmFsbGVsID0gdmlzaXRJblBhcmFsbGVsO1xuZXhwb3J0cy5nZXRWaXNpdEZuID0gZ2V0VmlzaXRGbjtcbmV4cG9ydHMuQlJFQUsgPSBleHBvcnRzLlF1ZXJ5RG9jdW1lbnRLZXlzID0gdm9pZCAwO1xuXG52YXIgX2luc3BlY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9qc3V0aWxzL2luc3BlY3RcIikpO1xuXG52YXIgX2FzdCA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFF1ZXJ5RG9jdW1lbnRLZXlzID0ge1xuICBOYW1lOiBbXSxcbiAgRG9jdW1lbnQ6IFsnZGVmaW5pdGlvbnMnXSxcbiAgT3BlcmF0aW9uRGVmaW5pdGlvbjogWyduYW1lJywgJ3ZhcmlhYmxlRGVmaW5pdGlvbnMnLCAnZGlyZWN0aXZlcycsICdzZWxlY3Rpb25TZXQnXSxcbiAgVmFyaWFibGVEZWZpbml0aW9uOiBbJ3ZhcmlhYmxlJywgJ3R5cGUnLCAnZGVmYXVsdFZhbHVlJywgJ2RpcmVjdGl2ZXMnXSxcbiAgVmFyaWFibGU6IFsnbmFtZSddLFxuICBTZWxlY3Rpb25TZXQ6IFsnc2VsZWN0aW9ucyddLFxuICBGaWVsZDogWydhbGlhcycsICduYW1lJywgJ2FyZ3VtZW50cycsICdkaXJlY3RpdmVzJywgJ3NlbGVjdGlvblNldCddLFxuICBBcmd1bWVudDogWyduYW1lJywgJ3ZhbHVlJ10sXG4gIEZyYWdtZW50U3ByZWFkOiBbJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBJbmxpbmVGcmFnbWVudDogWyd0eXBlQ29uZGl0aW9uJywgJ2RpcmVjdGl2ZXMnLCAnc2VsZWN0aW9uU2V0J10sXG4gIEZyYWdtZW50RGVmaW5pdGlvbjogWyduYW1lJywgLy8gTm90ZTogZnJhZ21lbnQgdmFyaWFibGUgZGVmaW5pdGlvbnMgYXJlIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGJlIGNoYW5nZWRcbiAgLy8gb3IgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAndmFyaWFibGVEZWZpbml0aW9ucycsICd0eXBlQ29uZGl0aW9uJywgJ2RpcmVjdGl2ZXMnLCAnc2VsZWN0aW9uU2V0J10sXG4gIEludFZhbHVlOiBbXSxcbiAgRmxvYXRWYWx1ZTogW10sXG4gIFN0cmluZ1ZhbHVlOiBbXSxcbiAgQm9vbGVhblZhbHVlOiBbXSxcbiAgTnVsbFZhbHVlOiBbXSxcbiAgRW51bVZhbHVlOiBbXSxcbiAgTGlzdFZhbHVlOiBbJ3ZhbHVlcyddLFxuICBPYmplY3RWYWx1ZTogWydmaWVsZHMnXSxcbiAgT2JqZWN0RmllbGQ6IFsnbmFtZScsICd2YWx1ZSddLFxuICBEaXJlY3RpdmU6IFsnbmFtZScsICdhcmd1bWVudHMnXSxcbiAgTmFtZWRUeXBlOiBbJ25hbWUnXSxcbiAgTGlzdFR5cGU6IFsndHlwZSddLFxuICBOb25OdWxsVHlwZTogWyd0eXBlJ10sXG4gIFNjaGVtYURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnZGlyZWN0aXZlcycsICdvcGVyYXRpb25UeXBlcyddLFxuICBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjogWyd0eXBlJ10sXG4gIFNjYWxhclR5cGVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBPYmplY3RUeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2ludGVyZmFjZXMnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXSxcbiAgRmllbGREZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ3R5cGUnLCAnZGlyZWN0aXZlcyddLFxuICBJbnB1dFZhbHVlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ3R5cGUnLCAnZGVmYXVsdFZhbHVlJywgJ2RpcmVjdGl2ZXMnXSxcbiAgSW50ZXJmYWNlVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdpbnRlcmZhY2VzJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIFVuaW9uVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJywgJ3R5cGVzJ10sXG4gIEVudW1UeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndmFsdWVzJ10sXG4gIEVudW1WYWx1ZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIElucHV0T2JqZWN0VHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBEaXJlY3RpdmVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ2xvY2F0aW9ucyddLFxuICBTY2hlbWFFeHRlbnNpb246IFsnZGlyZWN0aXZlcycsICdvcGVyYXRpb25UeXBlcyddLFxuICBTY2FsYXJUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBPYmplY3RUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnaW50ZXJmYWNlcycsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnaW50ZXJmYWNlcycsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBVbmlvblR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJywgJ3R5cGVzJ10sXG4gIEVudW1UeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcycsICd2YWx1ZXMnXSxcbiAgSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXVxufTtcbmV4cG9ydHMuUXVlcnlEb2N1bWVudEtleXMgPSBRdWVyeURvY3VtZW50S2V5cztcbnZhciBCUkVBSyA9IE9iamVjdC5mcmVlemUoe30pO1xuLyoqXG4gKiB2aXNpdCgpIHdpbGwgd2FsayB0aHJvdWdoIGFuIEFTVCB1c2luZyBhIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCwgY2FsbGluZ1xuICogdGhlIHZpc2l0b3IncyBlbnRlciBmdW5jdGlvbiBhdCBlYWNoIG5vZGUgaW4gdGhlIHRyYXZlcnNhbCwgYW5kIGNhbGxpbmcgdGhlXG4gKiBsZWF2ZSBmdW5jdGlvbiBhZnRlciB2aXNpdGluZyB0aGF0IG5vZGUgYW5kIGFsbCBvZiBpdHMgY2hpbGQgbm9kZXMuXG4gKlxuICogQnkgcmV0dXJuaW5nIGRpZmZlcmVudCB2YWx1ZXMgZnJvbSB0aGUgZW50ZXIgYW5kIGxlYXZlIGZ1bmN0aW9ucywgdGhlXG4gKiBiZWhhdmlvciBvZiB0aGUgdmlzaXRvciBjYW4gYmUgYWx0ZXJlZCwgaW5jbHVkaW5nIHNraXBwaW5nIG92ZXIgYSBzdWItdHJlZSBvZlxuICogdGhlIEFTVCAoYnkgcmV0dXJuaW5nIGZhbHNlKSwgZWRpdGluZyB0aGUgQVNUIGJ5IHJldHVybmluZyBhIHZhbHVlIG9yIG51bGxcbiAqIHRvIHJlbW92ZSB0aGUgdmFsdWUsIG9yIHRvIHN0b3AgdGhlIHdob2xlIHRyYXZlcnNhbCBieSByZXR1cm5pbmcgQlJFQUsuXG4gKlxuICogV2hlbiB1c2luZyB2aXNpdCgpIHRvIGVkaXQgYW4gQVNULCB0aGUgb3JpZ2luYWwgQVNUIHdpbGwgbm90IGJlIG1vZGlmaWVkLCBhbmRcbiAqIGEgbmV3IHZlcnNpb24gb2YgdGhlIEFTVCB3aXRoIHRoZSBjaGFuZ2VzIGFwcGxpZWQgd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoZVxuICogdmlzaXQgZnVuY3Rpb24uXG4gKlxuICogICAgIGNvbnN0IGVkaXRlZEFTVCA9IHZpc2l0KGFzdCwge1xuICogICAgICAgZW50ZXIobm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycykge1xuICogICAgICAgICAvLyBAcmV0dXJuXG4gKiAgICAgICAgIC8vICAgdW5kZWZpbmVkOiBubyBhY3Rpb25cbiAqICAgICAgICAgLy8gICBmYWxzZTogc2tpcCB2aXNpdGluZyB0aGlzIG5vZGVcbiAqICAgICAgICAgLy8gICB2aXNpdG9yLkJSRUFLOiBzdG9wIHZpc2l0aW5nIGFsdG9nZXRoZXJcbiAqICAgICAgICAgLy8gICBudWxsOiBkZWxldGUgdGhpcyBub2RlXG4gKiAgICAgICAgIC8vICAgYW55IHZhbHVlOiByZXBsYWNlIHRoaXMgbm9kZSB3aXRoIHRoZSByZXR1cm5lZCB2YWx1ZVxuICogICAgICAgfSxcbiAqICAgICAgIGxlYXZlKG5vZGUsIGtleSwgcGFyZW50LCBwYXRoLCBhbmNlc3RvcnMpIHtcbiAqICAgICAgICAgLy8gQHJldHVyblxuICogICAgICAgICAvLyAgIHVuZGVmaW5lZDogbm8gYWN0aW9uXG4gKiAgICAgICAgIC8vICAgZmFsc2U6IG5vIGFjdGlvblxuICogICAgICAgICAvLyAgIHZpc2l0b3IuQlJFQUs6IHN0b3AgdmlzaXRpbmcgYWx0b2dldGhlclxuICogICAgICAgICAvLyAgIG51bGw6IGRlbGV0ZSB0aGlzIG5vZGVcbiAqICAgICAgICAgLy8gICBhbnkgdmFsdWU6IHJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIHJldHVybmVkIHZhbHVlXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQWx0ZXJuYXRpdmVseSB0byBwcm92aWRpbmcgZW50ZXIoKSBhbmQgbGVhdmUoKSBmdW5jdGlvbnMsIGEgdmlzaXRvciBjYW5cbiAqIGluc3RlYWQgcHJvdmlkZSBmdW5jdGlvbnMgbmFtZWQgdGhlIHNhbWUgYXMgdGhlIGtpbmRzIG9mIEFTVCBub2Rlcywgb3JcbiAqIGVudGVyL2xlYXZlIHZpc2l0b3JzIGF0IGEgbmFtZWQga2V5LCBsZWFkaW5nIHRvIGZvdXIgcGVybXV0YXRpb25zIG9mIHRoZVxuICogdmlzaXRvciBBUEk6XG4gKlxuICogMSkgTmFtZWQgdmlzaXRvcnMgdHJpZ2dlcmVkIHdoZW4gZW50ZXJpbmcgYSBub2RlIG9mIGEgc3BlY2lmaWMga2luZC5cbiAqXG4gKiAgICAgdmlzaXQoYXN0LCB7XG4gKiAgICAgICBLaW5kKG5vZGUpIHtcbiAqICAgICAgICAgLy8gZW50ZXIgdGhlIFwiS2luZFwiIG5vZGVcbiAqICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqIDIpIE5hbWVkIHZpc2l0b3JzIHRoYXQgdHJpZ2dlciB1cG9uIGVudGVyaW5nIGFuZCBsZWF2aW5nIGEgbm9kZSBvZlxuICogICAgYSBzcGVjaWZpYyBraW5kLlxuICpcbiAqICAgICB2aXNpdChhc3QsIHtcbiAqICAgICAgIEtpbmQ6IHtcbiAqICAgICAgICAgZW50ZXIobm9kZSkge1xuICogICAgICAgICAgIC8vIGVudGVyIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgbGVhdmUobm9kZSkge1xuICogICAgICAgICAgIC8vIGxlYXZlIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqIDMpIEdlbmVyaWMgdmlzaXRvcnMgdGhhdCB0cmlnZ2VyIHVwb24gZW50ZXJpbmcgYW5kIGxlYXZpbmcgYW55IG5vZGUuXG4gKlxuICogICAgIHZpc2l0KGFzdCwge1xuICogICAgICAgZW50ZXIobm9kZSkge1xuICogICAgICAgICAvLyBlbnRlciBhbnkgbm9kZVxuICogICAgICAgfSxcbiAqICAgICAgIGxlYXZlKG5vZGUpIHtcbiAqICAgICAgICAgLy8gbGVhdmUgYW55IG5vZGVcbiAqICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqIDQpIFBhcmFsbGVsIHZpc2l0b3JzIGZvciBlbnRlcmluZyBhbmQgbGVhdmluZyBub2RlcyBvZiBhIHNwZWNpZmljIGtpbmQuXG4gKlxuICogICAgIHZpc2l0KGFzdCwge1xuICogICAgICAgZW50ZXI6IHtcbiAqICAgICAgICAgS2luZChub2RlKSB7XG4gKiAgICAgICAgICAgLy8gZW50ZXIgdGhlIFwiS2luZFwiIG5vZGVcbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIGxlYXZlOiB7XG4gKiAgICAgICAgIEtpbmQobm9kZSkge1xuICogICAgICAgICAgIC8vIGxlYXZlIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KVxuICovXG5cbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcblxuZnVuY3Rpb24gdmlzaXQocm9vdCwgdmlzaXRvcikge1xuICB2YXIgdmlzaXRvcktleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFF1ZXJ5RG9jdW1lbnRLZXlzO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLWluaXQgKi9cbiAgdmFyIHN0YWNrID0gdW5kZWZpbmVkO1xuICB2YXIgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkocm9vdCk7XG4gIHZhciBrZXlzID0gW3Jvb3RdO1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGVkaXRzID0gW107XG4gIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuICB2YXIgcGFyZW50ID0gdW5kZWZpbmVkO1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgYW5jZXN0b3JzID0gW107XG4gIHZhciBuZXdSb290ID0gcm9vdDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZi1pbml0ICovXG5cbiAgZG8ge1xuICAgIGluZGV4Kys7XG4gICAgdmFyIGlzTGVhdmluZyA9IGluZGV4ID09PSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaXNFZGl0ZWQgPSBpc0xlYXZpbmcgJiYgZWRpdHMubGVuZ3RoICE9PSAwO1xuXG4gICAgaWYgKGlzTGVhdmluZykge1xuICAgICAga2V5ID0gYW5jZXN0b3JzLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBhbmNlc3RvcnMucG9wKCk7XG5cbiAgICAgIGlmIChpc0VkaXRlZCkge1xuICAgICAgICBpZiAoaW5BcnJheSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNsaWNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXMobm9kZSk7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBfT2JqZWN0JGtleXMyW19pMl07XG4gICAgICAgICAgICBjbG9uZVtrXSA9IG5vZGVba107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZSA9IGNsb25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRPZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBlZGl0cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICB2YXIgZWRpdEtleSA9IGVkaXRzW2lpXVswXTtcbiAgICAgICAgICB2YXIgZWRpdFZhbHVlID0gZWRpdHNbaWldWzFdO1xuXG4gICAgICAgICAgaWYgKGluQXJyYXkpIHtcbiAgICAgICAgICAgIGVkaXRLZXkgLT0gZWRpdE9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5BcnJheSAmJiBlZGl0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuc3BsaWNlKGVkaXRLZXksIDEpO1xuICAgICAgICAgICAgZWRpdE9mZnNldCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlW2VkaXRLZXldID0gZWRpdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbmRleCA9IHN0YWNrLmluZGV4O1xuICAgICAga2V5cyA9IHN0YWNrLmtleXM7XG4gICAgICBlZGl0cyA9IHN0YWNrLmVkaXRzO1xuICAgICAgaW5BcnJheSA9IHN0YWNrLmluQXJyYXk7XG4gICAgICBzdGFjayA9IHN0YWNrLnByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHBhcmVudCA/IGluQXJyYXkgPyBpbmRleCA6IGtleXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgbm9kZSA9IHBhcmVudCA/IHBhcmVudFtrZXldIDogbmV3Um9vdDtcblxuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGlmICghKDAsIF9hc3QuaXNOb2RlKShub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFTVCBOb2RlOiBcIi5jb25jYXQoKDAsIF9pbnNwZWN0LmRlZmF1bHQpKG5vZGUpLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlzaXRGbiA9IGdldFZpc2l0Rm4odmlzaXRvciwgbm9kZS5raW5kLCBpc0xlYXZpbmcpO1xuXG4gICAgICBpZiAodmlzaXRGbikge1xuICAgICAgICByZXN1bHQgPSB2aXNpdEZuLmNhbGwodmlzaXRvciwgbm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKFtrZXksIHJlc3VsdF0pO1xuXG4gICAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2FzdC5pc05vZGUpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBpc0VkaXRlZCkge1xuICAgICAgZWRpdHMucHVzaChba2V5LCBub2RlXSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTGVhdmluZykge1xuICAgICAgcGF0aC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF92aXNpdG9yS2V5cyRub2RlJGtpbjtcblxuICAgICAgc3RhY2sgPSB7XG4gICAgICAgIGluQXJyYXk6IGluQXJyYXksXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgZWRpdHM6IGVkaXRzLFxuICAgICAgICBwcmV2OiBzdGFja1xuICAgICAgfTtcbiAgICAgIGluQXJyYXkgPSBBcnJheS5pc0FycmF5KG5vZGUpO1xuICAgICAga2V5cyA9IGluQXJyYXkgPyBub2RlIDogKF92aXNpdG9yS2V5cyRub2RlJGtpbiA9IHZpc2l0b3JLZXlzW25vZGUua2luZF0pICE9PSBudWxsICYmIF92aXNpdG9yS2V5cyRub2RlJGtpbiAhPT0gdm9pZCAwID8gX3Zpc2l0b3JLZXlzJG5vZGUka2luIDogW107XG4gICAgICBpbmRleCA9IC0xO1xuICAgICAgZWRpdHMgPSBbXTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBub2RlO1xuICAgIH1cbiAgfSB3aGlsZSAoc3RhY2sgIT09IHVuZGVmaW5lZCk7XG5cbiAgaWYgKGVkaXRzLmxlbmd0aCAhPT0gMCkge1xuICAgIG5ld1Jvb3QgPSBlZGl0c1tlZGl0cy5sZW5ndGggLSAxXVsxXTtcbiAgfVxuXG4gIHJldHVybiBuZXdSb290O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZpc2l0b3IgaW5zdGFuY2Ugd2hpY2ggZGVsZWdhdGVzIHRvIG1hbnkgdmlzaXRvcnMgdG8gcnVuIGluXG4gKiBwYXJhbGxlbC4gRWFjaCB2aXNpdG9yIHdpbGwgYmUgdmlzaXRlZCBmb3IgZWFjaCBub2RlIGJlZm9yZSBtb3Zpbmcgb24uXG4gKlxuICogSWYgYSBwcmlvciB2aXNpdG9yIGVkaXRzIGEgbm9kZSwgbm8gZm9sbG93aW5nIHZpc2l0b3JzIHdpbGwgc2VlIHRoYXQgbm9kZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZpc2l0SW5QYXJhbGxlbCh2aXNpdG9ycykge1xuICB2YXIgc2tpcHBpbmcgPSBuZXcgQXJyYXkodmlzaXRvcnMubGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2tpcHBpbmdbaV0gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmbiA9IGdldFZpc2l0Rm4odmlzaXRvcnNbaV0sIG5vZGUua2luZCxcbiAgICAgICAgICAvKiBpc0xlYXZpbmcgKi9cbiAgICAgICAgICBmYWxzZSk7XG5cbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh2aXNpdG9yc1tpXSwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgIHNraXBwaW5nW2ldID0gQlJFQUs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2tpcHBpbmdbaV0gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmbiA9IGdldFZpc2l0Rm4odmlzaXRvcnNbaV0sIG5vZGUua2luZCxcbiAgICAgICAgICAvKiBpc0xlYXZpbmcgKi9cbiAgICAgICAgICB0cnVlKTtcblxuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHZpc2l0b3JzW2ldLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IEJSRUFLO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNraXBwaW5nW2ldID09PSBub2RlKSB7XG4gICAgICAgICAgc2tpcHBpbmdbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBHaXZlbiBhIHZpc2l0b3IgaW5zdGFuY2UsIGlmIGl0IGlzIGxlYXZpbmcgb3Igbm90LCBhbmQgYSBub2RlIGtpbmQsIHJldHVyblxuICogdGhlIGZ1bmN0aW9uIHRoZSB2aXNpdG9yIHJ1bnRpbWUgc2hvdWxkIGNhbGwuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRWaXNpdEZuKHZpc2l0b3IsIGtpbmQsIGlzTGVhdmluZykge1xuICB2YXIga2luZFZpc2l0b3IgPSB2aXNpdG9yW2tpbmRdO1xuXG4gIGlmIChraW5kVmlzaXRvcikge1xuICAgIGlmICghaXNMZWF2aW5nICYmIHR5cGVvZiBraW5kVmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8geyBLaW5kKCkge30gfVxuICAgICAgcmV0dXJuIGtpbmRWaXNpdG9yO1xuICAgIH1cblxuICAgIHZhciBraW5kU3BlY2lmaWNWaXNpdG9yID0gaXNMZWF2aW5nID8ga2luZFZpc2l0b3IubGVhdmUgOiBraW5kVmlzaXRvci5lbnRlcjtcblxuICAgIGlmICh0eXBlb2Yga2luZFNwZWNpZmljVmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8geyBLaW5kOiB7IGVudGVyKCkge30sIGxlYXZlKCkge30gfSB9XG4gICAgICByZXR1cm4ga2luZFNwZWNpZmljVmlzaXRvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNwZWNpZmljVmlzaXRvciA9IGlzTGVhdmluZyA/IHZpc2l0b3IubGVhdmUgOiB2aXNpdG9yLmVudGVyO1xuXG4gICAgaWYgKHNwZWNpZmljVmlzaXRvcikge1xuICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpY1Zpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8geyBlbnRlcigpIHt9LCBsZWF2ZSgpIHt9IH1cbiAgICAgICAgcmV0dXJuIHNwZWNpZmljVmlzaXRvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNwZWNpZmljS2luZFZpc2l0b3IgPSBzcGVjaWZpY1Zpc2l0b3Jba2luZF07XG5cbiAgICAgIGlmICh0eXBlb2Ygc3BlY2lmaWNLaW5kVmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyB7IGVudGVyOiB7IEtpbmQoKSB7fSB9LCBsZWF2ZTogeyBLaW5kKCkge30gfSB9XG4gICAgICAgIHJldHVybiBzcGVjaWZpY0tpbmRWaXNpdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNZTUJPTF9UT19TVFJJTkdfVEFHID0gZXhwb3J0cy5TWU1CT0xfQVNZTkNfSVRFUkFUT1IgPSBleHBvcnRzLlNZTUJPTF9JVEVSQVRPUiA9IHZvaWQgMDtcbi8vIEluIEVTMjAxNSAob3IgYSBwb2x5ZmlsbGVkKSBlbnZpcm9ubWVudCwgdGhpcyB3aWxsIGJlIFN5bWJvbC5pdGVyYXRvclxuLy8gaXN0YW5idWwgaWdub3JlIG5leHQgKFNlZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvaXNzdWVzLzIzMTcnKVxudmFyIFNZTUJPTF9JVEVSQVRPUiA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgPyBTeW1ib2wuaXRlcmF0b3IgOiAnQEBpdGVyYXRvcic7IC8vIEluIEVTMjAxNyAob3IgYSBwb2x5ZmlsbGVkKSBlbnZpcm9ubWVudCwgdGhpcyB3aWxsIGJlIFN5bWJvbC5hc3luY0l0ZXJhdG9yXG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAoU2VlOiAnaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9pc3N1ZXMvMjMxNycpXG5cbmV4cG9ydHMuU1lNQk9MX0lURVJBVE9SID0gU1lNQk9MX0lURVJBVE9SO1xudmFyIFNZTUJPTF9BU1lOQ19JVEVSQVRPUiA9IC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGRlZmluZSBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIHlldFxudHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyA/IFN5bWJvbC5hc3luY0l0ZXJhdG9yIDogJ0BAYXN5bmNJdGVyYXRvcic7IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IChTZWU6ICdodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMzE3JylcblxuZXhwb3J0cy5TWU1CT0xfQVNZTkNfSVRFUkFUT1IgPSBTWU1CT0xfQVNZTkNfSVRFUkFUT1I7XG52YXIgU1lNQk9MX1RPX1NUUklOR19UQUcgPSAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBkZWZpbmUgYFN5bWJvbC50b1N0cmluZ1RhZ2AgeWV0XG50eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogJ0BAdG9TdHJpbmdUYWcnO1xuZXhwb3J0cy5TWU1CT0xfVE9fU1RSSU5HX1RBRyA9IFNZTUJPTF9UT19TVFJJTkdfVEFHO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldE9wZXJhdGlvbkFTVCA9IGdldE9wZXJhdGlvbkFTVDtcblxudmFyIF9raW5kcyA9IHJlcXVpcmUoXCIuLi9sYW5ndWFnZS9raW5kc1wiKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9wZXJhdGlvbiBBU1QgZ2l2ZW4gYSBkb2N1bWVudCBBU1QgYW5kIG9wdGlvbmFsbHkgYW4gb3BlcmF0aW9uXG4gKiBuYW1lLiBJZiBhIG5hbWUgaXMgbm90IHByb3ZpZGVkLCBhbiBvcGVyYXRpb24gaXMgb25seSByZXR1cm5lZCBpZiBvbmx5IG9uZSBpc1xuICogcHJvdmlkZWQgaW4gdGhlIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiBnZXRPcGVyYXRpb25BU1QoZG9jdW1lbnRBU1QsIG9wZXJhdGlvbk5hbWUpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IG51bGw7XG5cbiAgZm9yICh2YXIgX2kyID0gMCwgX2RvY3VtZW50QVNUJGRlZmluaXRpMiA9IGRvY3VtZW50QVNULmRlZmluaXRpb25zOyBfaTIgPCBfZG9jdW1lbnRBU1QkZGVmaW5pdGkyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IF9kb2N1bWVudEFTVCRkZWZpbml0aTJbX2kyXTtcblxuICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09IF9raW5kcy5LaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OKSB7XG4gICAgICB2YXIgX2RlZmluaXRpb24kbmFtZTtcblxuICAgICAgaWYgKG9wZXJhdGlvbk5hbWUgPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiBubyBvcGVyYXRpb24gbmFtZSB3YXMgcHJvdmlkZWQsIG9ubHkgcmV0dXJuIGFuIE9wZXJhdGlvbiBpZiB0aGVyZVxuICAgICAgICAvLyBpcyBvbmUgZGVmaW5lZCBpbiB0aGUgZG9jdW1lbnQuIFVwb24gZW5jb3VudGVyaW5nIHRoZSBzZWNvbmQsIHJldHVyblxuICAgICAgICAvLyBudWxsLlxuICAgICAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBvcGVyYXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgfSBlbHNlIGlmICgoKF9kZWZpbml0aW9uJG5hbWUgPSBkZWZpbml0aW9uLm5hbWUpID09PSBudWxsIHx8IF9kZWZpbml0aW9uJG5hbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZpbml0aW9uJG5hbWUudmFsdWUpID09PSBvcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcGVyYXRpb247XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gdXNlIGFzIGEgYmluYXJ5IGNhcnJpZXIuXG4gKlxuICogQW55IHZhbGlkIE9iamVjdCB3aXRoIGEgZmllbGQgbmFtZWQgYGJ1ZmZlcmAgbWF5IGJlIHVzZWQgYXMgYSBiaW5hcnkgY2FycmllcjtcbiAqIHRoaXMgY2xhc3MgaXMgb25seSBvbmUgc3VjaCB0eXBlIG9mIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkLlxuICovXG52YXIgQmluYXJ5Q2FycmllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlDYXJyaWVyKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeUNhcnJpZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmluYXJ5Q2Fycmllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeV9jYXJyaWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUaGUgRk9STUFUX0JJTkFSWSBmb3JtYXQgcmVwcmVzZW50cyBTcGFuQ29udGV4dHMgaW4gYW4gb3BhcXVlIGJpbmFyeVxuICogY2Fycmllci5cbiAqXG4gKiBUcmFjZXIuaW5qZWN0KCkgd2lsbCBzZXQgdGhlIGJ1ZmZlciBmaWVsZCB0byBhbiBBcnJheS1saWtlIChBcnJheSxcbiAqIEFycmF5QnVmZmVyLCBvciBUeXBlZEJ1ZmZlcikgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGluamVjdGVkIGJpbmFyeSBkYXRhLlxuICogQW55IHZhbGlkIE9iamVjdCBjYW4gYmUgdXNlZCBhcyBsb25nIGFzIHRoZSBidWZmZXIgZmllbGQgb2YgdGhlIG9iamVjdFxuICogY2FuIGJlIHNldC5cbiAqXG4gKiBUcmFjZXIuZXh0cmFjdCgpIHdpbGwgbG9vayBmb3IgYGNhcnJpZXIuYnVmZmVyYCwgYW5kIHRoYXQgZmllbGQgaXNcbiAqIGV4cGVjdGVkIHRvIGJlIGFuIEFycmF5LWxpa2Ugb2JqZWN0IChBcnJheSwgQXJyYXlCdWZmZXIsIG9yXG4gKiBUeXBlZEJ1ZmZlcikuXG4gKi9cbmV4cG9ydHMuRk9STUFUX0JJTkFSWSA9ICdiaW5hcnknO1xuLyoqXG4gKiBUaGUgRk9STUFUX1RFWFRfTUFQIGZvcm1hdCByZXByZXNlbnRzIFNwYW5Db250ZXh0cyB1c2luZyBhXG4gKiBzdHJpbmctPnN0cmluZyBtYXAgKGJhY2tlZCBieSBhIEphdmFzY3JpcHQgT2JqZWN0KSBhcyBhIGNhcnJpZXIuXG4gKlxuICogTk9URTogVW5saWtlIEZPUk1BVF9IVFRQX0hFQURFUlMsIEZPUk1BVF9URVhUX01BUCBwbGFjZXMgbm8gcmVzdHJpY3Rpb25zXG4gKiBvbiB0aGUgY2hhcmFjdGVycyB1c2VkIGluIGVpdGhlciB0aGUga2V5cyBvciB0aGUgdmFsdWVzIG9mIHRoZSBtYXBcbiAqIGVudHJpZXMuXG4gKlxuICogVGhlIEZPUk1BVF9URVhUX01BUCBjYXJyaWVyIG1hcCBtYXkgY29udGFpbiB1bnJlbGF0ZWQgZGF0YSAoZS5nLixcbiAqIGFyYml0cmFyeSBnUlBDIG1ldGFkYXRhKTsgYXMgc3VjaCwgdGhlIFRyYWNlciBpbXBsZW1lbnRhdGlvbiBzaG91bGQgdXNlXG4gKiBhIHByZWZpeCBvciBvdGhlciBjb252ZW50aW9uIHRvIGRpc3Rpbmd1aXNoIFRyYWNlci1zcGVjaWZpYyBrZXk6dmFsdWVcbiAqIHBhaXJzLlxuICovXG5leHBvcnRzLkZPUk1BVF9URVhUX01BUCA9ICd0ZXh0X21hcCc7XG4vKipcbiAqIFRoZSBGT1JNQVRfSFRUUF9IRUFERVJTIGZvcm1hdCByZXByZXNlbnRzIFNwYW5Db250ZXh0cyB1c2luZyBhXG4gKiBjaGFyYWN0ZXItcmVzdHJpY3RlZCBzdHJpbmctPnN0cmluZyBtYXAgKGJhY2tlZCBieSBhIEphdmFzY3JpcHQgT2JqZWN0KVxuICogYXMgYSBjYXJyaWVyLlxuICpcbiAqIEtleXMgYW5kIHZhbHVlcyBpbiB0aGUgRk9STUFUX0hUVFBfSEVBREVSUyBjYXJyaWVyIG11c3QgYmUgc3VpdGFibGUgZm9yXG4gKiB1c2UgYXMgSFRUUCBoZWFkZXJzICh3aXRob3V0IG1vZGlmaWNhdGlvbiBvciBmdXJ0aGVyIGVzY2FwaW5nKS4gVGhhdCBpcyxcbiAqIHRoZSBrZXlzIGhhdmUgYSBncmVhdGx5IHJlc3RyaWN0ZWQgY2hhcmFjdGVyIHNldCwgY2FzaW5nIGZvciB0aGUga2V5c1xuICogbWF5IG5vdCBiZSBwcmVzZXJ2ZWQgYnkgdmFyaW91cyBpbnRlcm1lZGlhcmllcywgYW5kIHRoZSB2YWx1ZXMgc2hvdWxkIGJlXG4gKiBVUkwtZXNjYXBlZC5cbiAqXG4gKiBUaGUgRk9STUFUX0hUVFBfSEVBREVSUyBjYXJyaWVyIG1hcCBtYXkgY29udGFpbiB1bnJlbGF0ZWQgZGF0YSAoZS5nLixcbiAqIGFyYml0cmFyeSBIVFRQIGhlYWRlcnMpOyBhcyBzdWNoLCB0aGUgVHJhY2VyIGltcGxlbWVudGF0aW9uIHNob3VsZCB1c2UgYVxuICogcHJlZml4IG9yIG90aGVyIGNvbnZlbnRpb24gdG8gZGlzdGluZ3Vpc2ggVHJhY2VyLXNwZWNpZmljIGtleTp2YWx1ZVxuICogcGFpcnMuXG4gKi9cbmV4cG9ydHMuRk9STUFUX0hUVFBfSEVBREVSUyA9ICdodHRwX2hlYWRlcnMnO1xuLyoqXG4gKiBBIFNwYW4gbWF5IGJlIHRoZSBcImNoaWxkIG9mXCIgYSBwYXJlbnQgU3Bhbi4gSW4gYSDigJxjaGlsZCBvZuKAnSByZWZlcmVuY2UsXG4gKiB0aGUgcGFyZW50IFNwYW4gZGVwZW5kcyBvbiB0aGUgY2hpbGQgU3BhbiBpbiBzb21lIGNhcGFjaXR5LlxuICpcbiAqIFNlZSBtb3JlIGFib3V0IHJlZmVyZW5jZSB0eXBlcyBhdCBodHRwczovL2dpdGh1Yi5jb20vb3BlbnRyYWNpbmcvc3BlY2lmaWNhdGlvblxuICovXG5leHBvcnRzLlJFRkVSRU5DRV9DSElMRF9PRiA9ICdjaGlsZF9vZic7XG4vKipcbiAqIFNvbWUgcGFyZW50IFNwYW5zIGRvIG5vdCBkZXBlbmQgaW4gYW55IHdheSBvbiB0aGUgcmVzdWx0IG9mIHRoZWlyIGNoaWxkXG4gKiBTcGFucy4gSW4gdGhlc2UgY2FzZXMsIHdlIHNheSBtZXJlbHkgdGhhdCB0aGUgY2hpbGQgU3BhbiDigJxmb2xsb3dzIGZyb23igJ1cbiAqIHRoZSBwYXJlbnQgU3BhbiBpbiBhIGNhdXNhbCBzZW5zZS5cbiAqXG4gKiBTZWUgbW9yZSBhYm91dCByZWZlcmVuY2UgdHlwZXMgYXQgaHR0cHM6Ly9naXRodWIuY29tL29wZW50cmFjaW5nL3NwZWNpZmljYXRpb25cbiAqL1xuZXhwb3J0cy5SRUZFUkVOQ0VfRk9MTE9XU19GUk9NID0gJ2ZvbGxvd3NfZnJvbSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogU1BBTl9LSU5EIGhpbnRzIGF0IHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHNwYW5zLCBlLmcuIGNsaWVudC9zZXJ2ZXIgKi9cbmV4cG9ydHMuU1BBTl9LSU5EID0gJ3NwYW4ua2luZCc7XG4vKiogTWFya3MgYSBzcGFuIHJlcHJlc2VudGluZyB0aGUgY2xpZW50LXNpZGUgb2YgYW4gUlBDIG9yIG90aGVyIHJlbW90ZSBjYWxsICovXG5leHBvcnRzLlNQQU5fS0lORF9SUENfQ0xJRU5UID0gJ2NsaWVudCc7XG4vKiogTWFya3MgYSBzcGFuIHJlcHJlc2VudGluZyB0aGUgc2VydmVyLXNpZGUgb2YgYW4gUlBDIG9yIG90aGVyIHJlbW90ZSBjYWxsICovXG5leHBvcnRzLlNQQU5fS0lORF9SUENfU0VSVkVSID0gJ3NlcnZlcic7XG4vKiogTWFya3MgYSBzcGFuIHJlcHJlc2VudGluZyB0aGUgcHJvZHVjaW5nLXNpZGUgd2l0aGluIGEgbWVzc2FnaW5nIHN5c3RlbSBvciBvdGhlciByZW1vdGUgY2FsbCAqL1xuZXhwb3J0cy5TUEFOX0tJTkRfTUVTU0FHSU5HX1BST0RVQ0VSID0gJ3Byb2R1Y2VyJztcbi8qKiBNYXJrcyBhIHNwYW4gcmVwcmVzZW50aW5nIHRoZSBjb25zdW1pbmctc2lkZSB3aXRoaW4gYSBtZXNzYWdpbmcgc3lzdGVtIG9yIG90aGVyIHJlbW90ZSBjYWxsICovXG5leHBvcnRzLlNQQU5fS0lORF9NRVNTQUdJTkdfQ09OU1VNRVIgPSAnY29uc3VtZXInO1xuLyoqXG4gKiBFUlJPUiAoYm9vbGVhbikgdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGUgYXBwbGljYXRpb24gY29uc2lkZXJzIHRoZSBvcGVyYXRpb25cbiAqIHJlcHJlc2VudGVkIGJ5IHRoZSBTcGFuIHRvIGhhdmUgZmFpbGVkXG4gKi9cbmV4cG9ydHMuRVJST1IgPSAnZXJyb3InO1xuLyoqXG4gKiBDT01QT05FTlQgKHN0cmluZykgaWEgcyBsb3ctY2FyZGluYWxpdHkgaWRlbnRpZmllciBvZiB0aGUgbW9kdWxlLCBsaWJyYXJ5LFxuICogb3IgcGFja2FnZSB0aGF0IGlzIGdlbmVyYXRpbmcgYSBzcGFuLlxuICovXG5leHBvcnRzLkNPTVBPTkVOVCA9ICdjb21wb25lbnQnO1xuLyoqXG4gKiBTQU1QTElOR19QUklPUklUWSAobnVtYmVyKSBkZXRlcm1pbmVzIHRoZSBwcmlvcml0eSBvZiBzYW1wbGluZyB0aGlzIFNwYW4uXG4gKiBJZiBncmVhdGVyIHRoYW4gMCwgYSBoaW50IHRvIHRoZSBUcmFjZXIgdG8gZG8gaXRzIGJlc3QgdG8gY2FwdHVyZSB0aGUgdHJhY2UuXG4gKiBJZiAwLCBhIGhpbnQgdG8gdGhlIHRyYWNlIHRvIG5vdC1jYXB0dXJlIHRoZSB0cmFjZS4gSWYgYWJzZW50LCB0aGUgVHJhY2VyXG4gKiBzaG91bGQgdXNlIGl0cyBkZWZhdWx0IHNhbXBsaW5nIG1lY2hhbmlzbS5cbiAqL1xuZXhwb3J0cy5TQU1QTElOR19QUklPUklUWSA9ICdzYW1wbGluZy5wcmlvcml0eSc7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBFRVJfKiB0YWdzIGNhbiBiZSBlbWl0dGVkIGJ5IGVpdGhlciBjbGllbnQtc2lkZSBvZiBzZXJ2ZXItc2lkZSB0byBkZXNjcmliZVxuLy8gdGhlIG90aGVyIHNpZGUvc2VydmljZSBpbiBhIHBlZXItdG8tcGVlciBjb21tdW5pY2F0aW9ucywgbGlrZSBhbiBSUEMgY2FsbC5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBQRUVSX1NFUlZJQ0UgKHN0cmluZykgUmVtb3RlIHNlcnZpY2UgbmFtZSAoZm9yIHNvbWUgdW5zcGVjaWZpZWRcbiAqIGRlZmluaXRpb24gb2YgXCJzZXJ2aWNlXCIpLiBFLmcuLCBcImVsYXN0aWNzZWFyY2hcIiwgXCJhX2N1c3RvbV9taWNyb3NlcnZpY2VcIiwgXCJtZW1jYWNoZVwiXG4gKi9cbmV4cG9ydHMuUEVFUl9TRVJWSUNFID0gJ3BlZXIuc2VydmljZSc7XG4vKiogUEVFUl9IT1NUTkFNRSAoc3RyaW5nKSBSZW1vdGUgaG9zdG5hbWUuIEUuZy4sIFwib3BlbnRyYWNpbmcuaW9cIiwgXCJpbnRlcm5hbC5kbnMubmFtZVwiICovXG5leHBvcnRzLlBFRVJfSE9TVE5BTUUgPSAncGVlci5ob3N0bmFtZSc7XG4vKipcbiAqIFBFRVJfQUREUkVTUyAoc3RyaW5nKSBSZW1vdGUgXCJhZGRyZXNzXCIsIHN1aXRhYmxlIGZvciB1c2UgaW4gYVxuICogbmV0d29ya2luZyBjbGllbnQgbGlicmFyeS4gVGhpcyBtYXkgYmUgYSBcImlwOnBvcnRcIiwgYSBiYXJlXG4gKiBcImhvc3RuYW1lXCIsIGEgRlFETiwgb3IgZXZlbiBhIEpEQkMgc3Vic3RyaW5nIGxpa2UgXCJteXNxbDovL3Byb2QtZGI6MzMwNlwiXG4gKi9cbmV4cG9ydHMuUEVFUl9BRERSRVNTID0gJ3BlZXIuYWRkcmVzcyc7XG4vKipcbiAqIFBFRVJfSE9TVF9JUFY0IChudW1iZXIpIFJlbW90ZSBJUHY0IGFkZHJlc3MgYXMgYSAuLXNlcGFyYXRlZCB0dXBsZS5cbiAqIEUuZy4sIFwiMTI3LjAuMC4xXCJcbiAqL1xuZXhwb3J0cy5QRUVSX0hPU1RfSVBWNCA9ICdwZWVyLmlwdjQnO1xuLy8gUEVFUl9IT1NUX0lQVjYgKHN0cmluZykgUmVtb3RlIElQdjYgYWRkcmVzcyBhcyBhIHN0cmluZyBvZlxuLy8gY29sb24tc2VwYXJhdGVkIDQtY2hhciBoZXggdHVwbGVzLiBFLmcuLCBcIjIwMDE6MGRiODo4NWEzOjAwMDA6MDAwMDo4YTJlOjAzNzA6NzMzNFwiXG5leHBvcnRzLlBFRVJfSE9TVF9JUFY2ID0gJ3BlZXIuaXB2Nic7XG4vLyBQRUVSX1BPUlQgKG51bWJlcikgUmVtb3RlIHBvcnQuIEUuZy4sIDgwXG5leHBvcnRzLlBFRVJfUE9SVCA9ICdwZWVyLnBvcnQnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIVFRQIHRhZ3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBIVFRQX1VSTCAoc3RyaW5nKSBVUkwgb2YgdGhlIHJlcXVlc3QgYmVpbmcgaGFuZGxlZCBpbiB0aGlzIHNlZ21lbnQgb2YgdGhlXG4gKiB0cmFjZSwgaW4gc3RhbmRhcmQgVVJJIGZvcm1hdC4gRS5nLiwgXCJodHRwczovL2RvbWFpbi5uZXQvcGF0aC90bz9yZXNvdXJjZT1oZXJlXCJcbiAqL1xuZXhwb3J0cy5IVFRQX1VSTCA9ICdodHRwLnVybCc7XG4vKipcbiAqIEhUVFBfTUVUSE9EIChzdHJpbmcpIEhUVFAgbWV0aG9kIG9mIHRoZSByZXF1ZXN0IGZvciB0aGUgYXNzb2NpYXRlZCBTcGFuLiBFLmcuLFxuICogXCJHRVRcIiwgXCJQT1NUXCJcbiAqL1xuZXhwb3J0cy5IVFRQX01FVEhPRCA9ICdodHRwLm1ldGhvZCc7XG4vKipcbiAqIEhUVFBfU1RBVFVTX0NPREUgKG51bWJlcikgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBmb3IgdGhlIGFzc29jaWF0ZWQgU3Bhbi5cbiAqIEUuZy4sIDIwMCwgNTAzLCA0MDRcbiAqL1xuZXhwb3J0cy5IVFRQX1NUQVRVU19DT0RFID0gJ2h0dHAuc3RhdHVzX2NvZGUnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTWVzc2FnaW5nIHRhZ3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogTUVTU0FHRV9CVVNfREVTVElOQVRJT04gKHN0cmluZykgQW4gYWRkcmVzcyBhdCB3aGljaCBtZXNzYWdlcyBjYW4gYmUgZXhjaGFuZ2VkLlxuICogRS5nLiBBIEthZmthIHJlY29yZCBoYXMgYW4gYXNzb2NpYXRlZCBcInRvcGljIG5hbWVcIiB0aGF0IGNhbiBiZSBleHRyYWN0ZWRcbiAqIGJ5IHRoZSBpbnN0cnVtZW50ZWQgcHJvZHVjZXIgb3IgY29uc3VtZXIgYW5kIHN0b3JlZCB1c2luZyB0aGlzIHRhZy5cbiAqL1xuZXhwb3J0cy5NRVNTQUdFX0JVU19ERVNUSU5BVElPTiA9ICdtZXNzYWdlX2J1cy5kZXN0aW5hdGlvbic7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGF0YWJhc2UgdGFnc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogREJfSU5TVEFOQ0UgKHN0cmluZykgRGF0YWJhc2UgaW5zdGFuY2UgbmFtZS4gRS5nLiwgSW4gamF2YSwgaWYgdGhlXG4gKiBqZGJjLnVybD1cImpkYmM6bXlzcWw6Ly8xMjcuMC4wLjE6MzMwNi9jdXN0b21lcnNcIiwgdGhlIGluc3RhbmNlIG5hbWUgaXMgXCJjdXN0b21lcnNcIi5cbiAqL1xuZXhwb3J0cy5EQl9JTlNUQU5DRSA9ICdkYi5pbnN0YW5jZSc7XG4vKipcbiAqIERCX1NUQVRFTUVOVCAoc3RyaW5nKSBBIGRhdGFiYXNlIHN0YXRlbWVudCBmb3IgdGhlIGdpdmVuIGRhdGFiYXNlIHR5cGUuXG4gKiBFLmcuLCBmb3IgZGIudHlwZT1cIlNRTFwiLCBcIlNFTEVDVCAqIEZST00gd3VzZXJfdGFibGVcIjtcbiAqIGZvciBkYi50eXBlPVwicmVkaXNcIiwgXCJTRVQgbXlrZXkgJ1d1VmFsdWUnXCIuXG4gKi9cbmV4cG9ydHMuREJfU1RBVEVNRU5UID0gJ2RiLnN0YXRlbWVudCc7XG4vKipcbiAqIERCX1RZUEUgKHN0cmluZykgRGF0YWJhc2UgdHlwZS4gRm9yIGFueSBTUUwgZGF0YWJhc2UsIFwic3FsXCIuIEZvciBvdGhlcnMsXG4gKiB0aGUgbG93ZXItY2FzZSBkYXRhYmFzZSBjYXRlZ29yeSwgZS5nLiBcImNhc3NhbmRyYVwiLCBcImhiYXNlXCIsIG9yIFwicmVkaXNcIi5cbiAqL1xuZXhwb3J0cy5EQl9UWVBFID0gJ2RiLnR5cGUnO1xuLyoqXG4gKiBEQl9VU0VSIChzdHJpbmcpIFVzZXJuYW1lIGZvciBhY2Nlc3NpbmcgZGF0YWJhc2UuIEUuZy4sIFwicmVhZG9ubHlfdXNlclwiXG4gKiBvciBcInJlcG9ydGluZ191c2VyXCJcbiAqL1xuZXhwb3J0cy5EQl9VU0VSID0gJ2RiLnVzZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgcmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9yZWZlcmVuY2VcIik7XG52YXIgc3Bhbl8xID0gcmVxdWlyZShcIi4vc3BhblwiKTtcbi8qKlxuICogUmV0dXJuIGEgbmV3IFJFRkVSRU5DRV9DSElMRF9PRiByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHtTcGFuQ29udGV4dH0gc3BhbkNvbnRleHQgLSB0aGUgcGFyZW50IFNwYW5Db250ZXh0IGluc3RhbmNlIHRvXG4gKiAgICAgICAgcmVmZXJlbmNlLlxuICogQHJldHVybiBhIFJFRkVSRU5DRV9DSElMRF9PRiByZWZlcmVuY2UgcG9pbnRpbmcgdG8gYHNwYW5Db250ZXh0YFxuICovXG5mdW5jdGlvbiBjaGlsZE9mKHNwYW5Db250ZXh0KSB7XG4gICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gcGFzcyBhIFNwYW4gaW5zdGVhZCBvZiBhIFNwYW5Db250ZXh0XG4gICAgaWYgKHNwYW5Db250ZXh0IGluc3RhbmNlb2Ygc3Bhbl8xLmRlZmF1bHQpIHtcbiAgICAgICAgc3BhbkNvbnRleHQgPSBzcGFuQ29udGV4dC5jb250ZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcmVmZXJlbmNlXzEuZGVmYXVsdChDb25zdGFudHMuUkVGRVJFTkNFX0NISUxEX09GLCBzcGFuQ29udGV4dCk7XG59XG5leHBvcnRzLmNoaWxkT2YgPSBjaGlsZE9mO1xuLyoqXG4gKiBSZXR1cm4gYSBuZXcgUkVGRVJFTkNFX0ZPTExPV1NfRlJPTSByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHtTcGFuQ29udGV4dH0gc3BhbkNvbnRleHQgLSB0aGUgcGFyZW50IFNwYW5Db250ZXh0IGluc3RhbmNlIHRvXG4gKiAgICAgICAgcmVmZXJlbmNlLlxuICogQHJldHVybiBhIFJFRkVSRU5DRV9GT0xMT1dTX0ZST00gcmVmZXJlbmNlIHBvaW50aW5nIHRvIGBzcGFuQ29udGV4dGBcbiAqL1xuZnVuY3Rpb24gZm9sbG93c0Zyb20oc3BhbkNvbnRleHQpIHtcbiAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBwYXNzIGEgU3BhbiBpbnN0ZWFkIG9mIGEgU3BhbkNvbnRleHRcbiAgICBpZiAoc3BhbkNvbnRleHQgaW5zdGFuY2VvZiBzcGFuXzEuZGVmYXVsdCkge1xuICAgICAgICBzcGFuQ29udGV4dCA9IHNwYW5Db250ZXh0LmNvbnRleHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyByZWZlcmVuY2VfMS5kZWZhdWx0KENvbnN0YW50cy5SRUZFUkVOQ0VfRk9MTE9XU19GUk9NLCBzcGFuQ29udGV4dCk7XG59XG5leHBvcnRzLmZvbGxvd3NGcm9tID0gZm9sbG93c0Zyb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0cmFjZXJfMSA9IHJlcXVpcmUoXCIuL3RyYWNlclwiKTtcbnZhciBub29wVHJhY2VyID0gbmV3IHRyYWNlcl8xLmRlZmF1bHQoKTtcbnZhciBfZ2xvYmFsVHJhY2VyID0gbnVsbDtcbi8vIEFsbG93cyBkaXJlY3QgaW1wb3J0aW5nL3JlcXVpcmluZyBvZiB0aGUgZ2xvYmFsIHRyYWNlcjpcbi8vXG4vLyBsZXQgZ2xvYmFsVHJhY2VyID0gcmVxdWlyZSgnb3BlbnRyYWNpbmcvZ2xvYmFsJyk7XG4vLyAgICAgIE9SXG4vLyBpbXBvcnQgZ2xvYmFsVHJhY2VyIGZyb20gJ29wZW50cmFjaW5nL2dsb2JhbCc7XG4vL1xuLy8gQWN0cyBhIGJyaWRnZSB0byB0aGUgZ2xvYmFsIHRyYWNlciB0aGF0IGNhbiBiZSBzYWZlbHkgY2FsbGVkIGJlZm9yZSB0aGVcbi8vIGdsb2JhbCB0cmFjZXIgaXMgaW5pdGlhbGl6ZWQuIFRoZSBwdXJwb3NlIG9mIHRoZSBkZWxlZ2F0aW9uIGlzIHRvIGF2b2lkIHRoZVxuLy8gc29tZXRpbWVzIG5lYXJseSBpbnRyYWN0aWJsZSBpbml0aWFsaXphdGlvbiBvcmRlciBwcm9ibGVtcyB0aGF0IGNhbiBhcmlzZSBpblxuLy8gYXBwbGljYXRpb25zIHdpdGggYSBjb21wbGV4IHNldCBvZiBkZXBlbmRlbmNpZXMsIHdoaWxlIGFsc28gYXZvaWRpbmcgdGhlXG4vLyBjYXNlIHdoZXJlXG52YXIgR2xvYmFsVHJhY2VyRGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdsb2JhbFRyYWNlckRlbGVnYXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdsb2JhbFRyYWNlckRlbGVnYXRlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEdsb2JhbFRyYWNlckRlbGVnYXRlLnByb3RvdHlwZS5zdGFydFNwYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFjZXIgPSBfZ2xvYmFsVHJhY2VyIHx8IG5vb3BUcmFjZXI7XG4gICAgICAgIHJldHVybiB0cmFjZXIuc3RhcnRTcGFuLmFwcGx5KHRyYWNlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEdsb2JhbFRyYWNlckRlbGVnYXRlLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFjZXIgPSBfZ2xvYmFsVHJhY2VyIHx8IG5vb3BUcmFjZXI7XG4gICAgICAgIHJldHVybiB0cmFjZXIuaW5qZWN0LmFwcGx5KHRyYWNlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEdsb2JhbFRyYWNlckRlbGVnYXRlLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhY2VyID0gX2dsb2JhbFRyYWNlciB8fCBub29wVHJhY2VyO1xuICAgICAgICByZXR1cm4gdHJhY2VyLmV4dHJhY3QuYXBwbHkodHJhY2VyLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb2JhbFRyYWNlckRlbGVnYXRlO1xufSh0cmFjZXJfMS5kZWZhdWx0KSk7XG52YXIgZ2xvYmFsVHJhY2VyRGVsZWdhdGUgPSBuZXcgR2xvYmFsVHJhY2VyRGVsZWdhdGUoKTtcbi8qKlxuICogU2V0IHRoZSBnbG9iYWwgVHJhY2VyLlxuICpcbiAqIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuXG4gKlxuICogQHBhcmFtIHtUcmFjZXJ9IHRyYWNlciAtIHRoZSBUcmFjZXIgaW1wbGVtZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gaW5pdEdsb2JhbFRyYWNlcih0cmFjZXIpIHtcbiAgICBfZ2xvYmFsVHJhY2VyID0gdHJhY2VyO1xufVxuZXhwb3J0cy5pbml0R2xvYmFsVHJhY2VyID0gaW5pdEdsb2JhbFRyYWNlcjtcbi8qKlxuICogUmV0dXJucyB0aGUgZ2xvYmFsIHRyYWNlci5cbiAqL1xuZnVuY3Rpb24gZ2xvYmFsVHJhY2VyKCkge1xuICAgIC8vIFJldHVybiB0aGUgZGVsZWdhdGUuICBTaW5jZSB0aGUgZ2xvYmFsIHRyYWNlciBpcyBsYXJnZWx5IGEgY29udmVuaWVuY2VcbiAgICAvLyAodGhlIHVzZXIgY2FuIGFsd2F5cyBjcmVhdGUgdGhlaXIgb3duIHRyYWNlcnMpLCB0aGUgZGVsZWdhdGUgaXMgdXNlZCB0b1xuICAgIC8vIGdpdmUgdGhlIGFkZGVkIGNvbnZlbmllbmNlIG9mIG5vdCBuZWVkaW5nIHRvIHdvcnJ5IGFib3V0IGluaXRpYWxpemF0aW9uXG4gICAgLy8gb3JkZXIuXG4gICAgcmV0dXJuIGdsb2JhbFRyYWNlckRlbGVnYXRlO1xufVxuZXhwb3J0cy5nbG9iYWxUcmFjZXIgPSBnbG9iYWxUcmFjZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxfdHJhY2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiaW5hcnlfY2Fycmllcl8xID0gcmVxdWlyZShcIi4vYmluYXJ5X2NhcnJpZXJcIik7XG5leHBvcnRzLkJpbmFyeUNhcnJpZXIgPSBiaW5hcnlfY2Fycmllcl8xLmRlZmF1bHQ7XG52YXIgVGFncyA9IHJlcXVpcmUoXCIuL2V4dC90YWdzXCIpO1xuZXhwb3J0cy5UYWdzID0gVGFncztcbnZhciBOb29wID0gcmVxdWlyZShcIi4vbm9vcFwiKTtcbnZhciByZWZlcmVuY2VfMSA9IHJlcXVpcmUoXCIuL3JlZmVyZW5jZVwiKTtcbmV4cG9ydHMuUmVmZXJlbmNlID0gcmVmZXJlbmNlXzEuZGVmYXVsdDtcbnZhciBzcGFuXzEgPSByZXF1aXJlKFwiLi9zcGFuXCIpO1xuZXhwb3J0cy5TcGFuID0gc3Bhbl8xLmRlZmF1bHQ7XG52YXIgc3Bhbl9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi9zcGFuX2NvbnRleHRcIik7XG5leHBvcnRzLlNwYW5Db250ZXh0ID0gc3Bhbl9jb250ZXh0XzEuZGVmYXVsdDtcbnZhciB0cmFjZXJfMSA9IHJlcXVpcmUoXCIuL3RyYWNlclwiKTtcbmV4cG9ydHMuVHJhY2VyID0gdHJhY2VyXzEuVHJhY2VyO1xudmFyIG1vY2tfdHJhY2VyXzEgPSByZXF1aXJlKFwiLi9tb2NrX3RyYWNlclwiKTtcbmV4cG9ydHMuTW9ja1RyYWNlciA9IG1vY2tfdHJhY2VyXzEuTW9ja1RyYWNlcjtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2dsb2JhbF90cmFjZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Z1bmN0aW9uc1wiKSk7XG4vLyBJbml0aWFsaXplIHRoZSBub29wcyBsYXN0IHRvIGF2b2lkIGEgZGVwZW5kZWN5IGN5Y2xlIGJldHdlZW4gdGhlIGNsYXNzZXMuXG5Ob29wLmluaXRpYWxpemUoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1vY2tfY29udGV4dF8xID0gcmVxdWlyZShcIi4vbW9ja19jb250ZXh0XCIpO1xuZXhwb3J0cy5Nb2NrQ29udGV4dCA9IG1vY2tfY29udGV4dF8xLmRlZmF1bHQ7XG52YXIgbW9ja19zcGFuXzEgPSByZXF1aXJlKFwiLi9tb2NrX3NwYW5cIik7XG5leHBvcnRzLk1vY2tTcGFuID0gbW9ja19zcGFuXzEuZGVmYXVsdDtcbnZhciBtb2NrX3RyYWNlcl8xID0gcmVxdWlyZShcIi4vbW9ja190cmFjZXJcIik7XG5leHBvcnRzLk1vY2tUcmFjZXIgPSBtb2NrX3RyYWNlcl8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG9wZW50cmFjaW5nID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xuLyoqXG4gKiBPcGVuVHJhY2luZyBDb250ZXh0IGltcGxlbWVudGF0aW9uIGRlc2lnbmVkIGZvciB1c2UgaW5cbiAqIHVuaXQgdGVzdHMuXG4gKi9cbnZhciBNb2NrQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9ja0NvbnRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9ja0NvbnRleHQoc3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgc3BhbiBpdHNlbGYgc2luY2UgdGhpcyBpcyBhIG1vY2sgdHJhY2VyXG4gICAgICAgIC8vIGludGVuZGVkIHRvIG1ha2UgZGVidWdnaW5nIGFuZCB1bml0IHRlc3RpbmcgZWFzaWVyLlxuICAgICAgICBfdGhpcy5fc3BhbiA9IHNwYW47XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9ja0NvbnRleHQucHJvdG90eXBlLnNwYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcGFuO1xuICAgIH07XG4gICAgcmV0dXJuIE1vY2tDb250ZXh0O1xufShvcGVudHJhY2luZy5TcGFuQ29udGV4dCkpO1xuZXhwb3J0cy5Nb2NrQ29udGV4dCA9IE1vY2tDb250ZXh0O1xuZXhwb3J0cy5kZWZhdWx0ID0gTW9ja0NvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2NrX2NvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEluZGV4IGEgY29sbGVjdGlvbiBvZiByZXBvcnRlZCBNb2NrU3BhbnMgaW4gYSB3YXkgdGhhdCdzIGVhc3kgdG8gcnVuIHVuaXRcbiAqIHRlc3QgYXNzZXJ0aW9ucyBhZ2FpbnN0LlxuICovXG52YXIgTW9ja1JlcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2NrUmVwb3J0KHNwYW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3BhbnMgPSBzcGFucztcbiAgICAgICAgdGhpcy5zcGFuc0J5VVVJRCA9IHt9O1xuICAgICAgICB0aGlzLnNwYW5zQnlUYWcgPSB7fTtcbiAgICAgICAgdGhpcy5kZWJ1Z1NwYW5zID0gW107XG4gICAgICAgIHRoaXMudW5maW5pc2hlZFNwYW5zID0gW107XG4gICAgICAgIHNwYW5zLmZvckVhY2goZnVuY3Rpb24gKHNwYW4pIHtcbiAgICAgICAgICAgIGlmIChzcGFuLl9maW5pc2hNcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVuZmluaXNoZWRTcGFucy5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc3BhbnNCeVVVSURbc3Bhbi51dWlkKCldID0gc3BhbjtcbiAgICAgICAgICAgIF90aGlzLmRlYnVnU3BhbnMucHVzaChzcGFuLmRlYnVnKCkpO1xuICAgICAgICAgICAgdmFyIHRhZ3MgPSBzcGFuLnRhZ3MoKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRhZ3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0YWdzW2tleV07XG4gICAgICAgICAgICAgICAgX3RoaXMuc3BhbnNCeVRhZ1trZXldID0gX3RoaXMuc3BhbnNCeVRhZ1trZXldIHx8IHt9O1xuICAgICAgICAgICAgICAgIF90aGlzLnNwYW5zQnlUYWdba2V5XVt2YWxdID0gX3RoaXMuc3BhbnNCeVRhZ1trZXldW3ZhbF0gfHwgW107XG4gICAgICAgICAgICAgICAgX3RoaXMuc3BhbnNCeVRhZ1trZXldW3ZhbF0ucHVzaChzcGFuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgTW9ja1JlcG9ydC5wcm90b3R5cGUuZmlyc3RTcGFuV2l0aFRhZ1ZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5zcGFuc0J5VGFnW2tleV07XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBtW3ZhbF07XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5bMF07XG4gICAgfTtcbiAgICByZXR1cm4gTW9ja1JlcG9ydDtcbn0oKSk7XG5leHBvcnRzLk1vY2tSZXBvcnQgPSBNb2NrUmVwb3J0O1xuZXhwb3J0cy5kZWZhdWx0ID0gTW9ja1JlcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vY2tfcmVwb3J0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvcGVudHJhY2luZyA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcbnZhciBtb2NrX2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL21vY2tfY29udGV4dFwiKTtcbi8qKlxuICogT3BlblRyYWNpbmcgU3BhbiBpbXBsZW1lbnRhdGlvbiBkZXNpZ25lZCBmb3IgdXNlIGluIHVuaXQgdGVzdHMuXG4gKi9cbnZhciBNb2NrU3BhbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9ja1NwYW4sIF9zdXBlcik7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIC8vIE1vY2tTcGFuLXNwZWNpZmljXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIGZ1bmN0aW9uIE1vY2tTcGFuKHRyYWNlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fbW9ja1RyYWNlciA9IHRyYWNlcjtcbiAgICAgICAgX3RoaXMuX3V1aWQgPSBfdGhpcy5fZ2VuZXJhdGVVVUlEKCk7XG4gICAgICAgIF90aGlzLl9zdGFydE1zID0gRGF0ZS5ub3coKTtcbiAgICAgICAgX3RoaXMuX2ZpbmlzaE1zID0gMDtcbiAgICAgICAgX3RoaXMuX29wZXJhdGlvbk5hbWUgPSAnJztcbiAgICAgICAgX3RoaXMuX3RhZ3MgPSB7fTtcbiAgICAgICAgX3RoaXMuX2xvZ3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgLy8gT3BlblRyYWNpbmcgaW1wbGVtZW50YXRpb25cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgTW9ja1NwYW4ucHJvdG90eXBlLl9jb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IG1vY2tfY29udGV4dF8xLmRlZmF1bHQodGhpcyk7XG4gICAgfTtcbiAgICBNb2NrU3Bhbi5wcm90b3R5cGUuX3NldE9wZXJhdGlvbk5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLl9vcGVyYXRpb25OYW1lID0gbmFtZTtcbiAgICB9O1xuICAgIE1vY2tTcGFuLnByb3RvdHlwZS5fYWRkVGFncyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzZXQpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLl90YWdzW2tleV0gPSBzZXRba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9ja1NwYW4ucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAoZmllbGRzLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy5fbG9ncy5wdXNoKHtcbiAgICAgICAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb2NrU3Bhbi5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uIChmaW5pc2hUaW1lKSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaE1zID0gZmluaXNoVGltZSB8fCBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgTW9ja1NwYW4ucHJvdG90eXBlLnV1aWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91dWlkO1xuICAgIH07XG4gICAgTW9ja1NwYW4ucHJvdG90eXBlLm9wZXJhdGlvbk5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVyYXRpb25OYW1lO1xuICAgIH07XG4gICAgTW9ja1NwYW4ucHJvdG90eXBlLmR1cmF0aW9uTXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5pc2hNcyAtIHRoaXMuX3N0YXJ0TXM7XG4gICAgfTtcbiAgICBNb2NrU3Bhbi5wcm90b3R5cGUudGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ3M7XG4gICAgfTtcbiAgICBNb2NrU3Bhbi5wcm90b3R5cGUudHJhY2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9ja1RyYWNlcjtcbiAgICB9O1xuICAgIE1vY2tTcGFuLnByb3RvdHlwZS5fZ2VuZXJhdGVVVUlEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcDAgPSAoXCIwMDAwMDAwMFwiICsgTWF0aC5hYnMoKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRkZGKSB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KTtcbiAgICAgICAgdmFyIHAxID0gKFwiMDAwMDAwMDBcIiArIE1hdGguYWJzKChNYXRoLnJhbmRvbSgpICogMHhGRkZGRkZGRikgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtOCk7XG4gICAgICAgIHJldHVybiBcIlwiICsgcDAgKyBwMTtcbiAgICB9O1xuICAgIE1vY2tTcGFuLnByb3RvdHlwZS5hZGRSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2ltcGxpZmllZCBvYmplY3QgYmV0dGVyIGZvciBjb25zb2xlLmxvZygpJ2luZy5cbiAgICAgKi9cbiAgICBNb2NrU3Bhbi5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICB1dWlkOiB0aGlzLl91dWlkLFxuICAgICAgICAgICAgb3BlcmF0aW9uOiB0aGlzLl9vcGVyYXRpb25OYW1lLFxuICAgICAgICAgICAgbWlsbGlzOiBbdGhpcy5fZmluaXNoTXMgLSB0aGlzLl9zdGFydE1zLCB0aGlzLl9zdGFydE1zLCB0aGlzLl9maW5pc2hNc11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3RhZ3MpLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLnRhZ3MgPSB0aGlzLl90YWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICByZXR1cm4gTW9ja1NwYW47XG59KG9wZW50cmFjaW5nLlNwYW4pKTtcbmV4cG9ydHMuTW9ja1NwYW4gPSBNb2NrU3BhbjtcbmV4cG9ydHMuZGVmYXVsdCA9IE1vY2tTcGFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ja19zcGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBUT0RPOiBNb3ZlIG1vY2stdHJhY2VyIHRvIGl0cyBvd24gTlBNIHBhY2thZ2Ugb25jZSBpdCBpcyBjb21wbGV0ZSBhbmQgdGVzdGVkLlxudmFyIG9wZW50cmFjaW5nID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIG1vY2tfcmVwb3J0XzEgPSByZXF1aXJlKFwiLi9tb2NrX3JlcG9ydFwiKTtcbnZhciBtb2NrX3NwYW5fMSA9IHJlcXVpcmUoXCIuL21vY2tfc3BhblwiKTtcbi8qKlxuICogT3BlblRyYWNpbmcgVHJhY2VyIGltcGxlbWVudGF0aW9uIGRlc2lnbmVkIGZvciB1c2UgaW4gdW5pdCB0ZXN0cy5cbiAqL1xudmFyIE1vY2tUcmFjZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vY2tUcmFjZXIsIF9zdXBlcik7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIC8vIE1vY2tUcmFjZXItc3BlY2lmaWNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgZnVuY3Rpb24gTW9ja1RyYWNlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3NwYW5zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIC8vIE9wZW5UcmFjaW5nIGltcGxlbWVudGF0aW9uXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIE1vY2tUcmFjZXIucHJvdG90eXBlLl9zdGFydFNwYW4gPSBmdW5jdGlvbiAobmFtZSwgZmllbGRzKSB7XG4gICAgICAgIC8vIF9hbGxvY1NwYW4gaXMgZ2l2ZW4gaXQncyBvd24gbWV0aG9kIHNvIHRoYXQgZGVyaXZlZCBjbGFzc2VzIGNhblxuICAgICAgICAvLyBhbGxvY2F0ZSBhbnkgdHlwZSBvZiBvYmplY3QgdGhleSB3YW50LCBidXQgbm90IGhhdmUgdG8gZHVwbGljYXRlXG4gICAgICAgIC8vIHRoZSBvdGhlciBjb21tb24gbG9naWMgaW4gc3RhcnRTcGFuKCkuXG4gICAgICAgIHZhciBzcGFuID0gdGhpcy5fYWxsb2NTcGFuKCk7XG4gICAgICAgIHNwYW4uc2V0T3BlcmF0aW9uTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy5fc3BhbnMucHVzaChzcGFuKTtcbiAgICAgICAgaWYgKGZpZWxkcy5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZmllbGRzLnJlZmVyZW5jZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBzcGFuLmFkZFJlZmVyZW5jZShyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhcHR1cmUgdGhlIHN0YWNrIGF0IHRoZSB0aW1lIHRoZSBzcGFuIHN0YXJ0ZWRcbiAgICAgICAgc3Bhbi5fc3RhcnRTdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9O1xuICAgIE1vY2tUcmFjZXIucHJvdG90eXBlLl9pbmplY3QgPSBmdW5jdGlvbiAoc3BhbiwgZm9ybWF0LCBjYXJyaWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFlFVCBJTVBMRU1FTlRFRCcpO1xuICAgIH07XG4gICAgTW9ja1RyYWNlci5wcm90b3R5cGUuX2V4dHJhY3QgPSBmdW5jdGlvbiAoZm9ybWF0LCBjYXJyaWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFlFVCBJTVBMRU1FTlRFRCcpO1xuICAgIH07XG4gICAgTW9ja1RyYWNlci5wcm90b3R5cGUuX2FsbG9jU3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtb2NrX3NwYW5fMS5kZWZhdWx0KHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY2FyZCBhbnkgYnVmZmVyZWQgZGF0YS5cbiAgICAgKi9cbiAgICBNb2NrVHJhY2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3BhbnMgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYnVmZmVyZWQgZGF0YSBpbiBhIGZvcm1hdCBjb252ZW5pZW50IGZvciBtYWtpbmcgdW5pdCB0ZXN0XG4gICAgICogYXNzZXJ0aW9ucy5cbiAgICAgKi9cbiAgICBNb2NrVHJhY2VyLnByb3RvdHlwZS5yZXBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgbW9ja19yZXBvcnRfMS5kZWZhdWx0KHRoaXMuX3NwYW5zKTtcbiAgICB9O1xuICAgIHJldHVybiBNb2NrVHJhY2VyO1xufShvcGVudHJhY2luZy5UcmFjZXIpKTtcbmV4cG9ydHMuTW9ja1RyYWNlciA9IE1vY2tUcmFjZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBNb2NrVHJhY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ja190cmFjZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3Bhbl8xID0gcmVxdWlyZShcIi4vc3BhblwiKTtcbnZhciBzcGFuX2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL3NwYW5fY29udGV4dFwiKTtcbnZhciB0cmFjZXJfMSA9IHJlcXVpcmUoXCIuL3RyYWNlclwiKTtcbmV4cG9ydHMudHJhY2VyID0gbnVsbDtcbmV4cG9ydHMuc3BhbkNvbnRleHQgPSBudWxsO1xuZXhwb3J0cy5zcGFuID0gbnVsbDtcbi8vIERlZmVycmVkIGluaXRpYWxpemF0aW9uIHRvIGF2b2lkIGEgZGVwZW5kZW5jeSBjeWNsZSB3aGVyZSBUcmFjZXIgZGVwZW5kcyBvblxuLy8gU3BhbiB3aGljaCBkZXBlbmRzIG9uIHRoZSBub29wIHRyYWNlci5cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgZXhwb3J0cy50cmFjZXIgPSBuZXcgdHJhY2VyXzEuZGVmYXVsdCgpO1xuICAgIGV4cG9ydHMuc3BhbiA9IG5ldyBzcGFuXzEuZGVmYXVsdCgpO1xuICAgIGV4cG9ydHMuc3BhbkNvbnRleHQgPSBuZXcgc3Bhbl9jb250ZXh0XzEuZGVmYXVsdCgpO1xufVxuZXhwb3J0cy5pbml0aWFsaXplID0gaW5pdGlhbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vb3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3Bhbl8xID0gcmVxdWlyZShcIi4vc3BhblwiKTtcbi8qKlxuICogUmVmZXJlbmNlIHBhaXJzIGEgcmVmZXJlbmNlIHR5cGUgY29uc3RhbnQgKGUuZy4sIFJFRkVSRU5DRV9DSElMRF9PRiBvclxuICogUkVGRVJFTkNFX0ZPTExPV1NfRlJPTSkgd2l0aCB0aGUgU3BhbkNvbnRleHQgaXQgcG9pbnRzIHRvLlxuICpcbiAqIFNlZSB0aGUgZXhwb3J0ZWQgY2hpbGRPZigpIGFuZCBmb2xsb3dzRnJvbSgpIGZ1bmN0aW9ucyBhdCB0aGUgcGFja2FnZSBsZXZlbC5cbiAqL1xudmFyIFJlZmVyZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IFJlZmVyZW5jZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gdGhlIFJlZmVyZW5jZSB0eXBlIGNvbnN0YW50IChlLmcuLFxuICAgICAqICAgICAgICBSRUZFUkVOQ0VfQ0hJTERfT0Ygb3IgUkVGRVJFTkNFX0ZPTExPV1NfRlJPTSkuXG4gICAgICogQHBhcmFtIHtTcGFuQ29udGV4dH0gcmVmZXJlbmNlZENvbnRleHQgLSB0aGUgU3BhbkNvbnRleHQgYmVpbmcgcmVmZXJyZWRcbiAgICAgKiAgICAgICAgdG8uIEFzIGEgY29udmVuaWVuY2UsIGEgU3BhbiBpbnN0YW5jZSBtYXkgYmUgcGFzc2VkIGluIGluc3RlYWRcbiAgICAgKiAgICAgICAgKGluIHdoaWNoIGNhc2UgaXRzIC5jb250ZXh0KCkgaXMgdXNlZCBoZXJlKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWZlcmVuY2UodHlwZSwgcmVmZXJlbmNlZENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZWRDb250ZXh0ID0gKHJlZmVyZW5jZWRDb250ZXh0IGluc3RhbmNlb2Ygc3Bhbl8xLmRlZmF1bHQgP1xuICAgICAgICAgICAgcmVmZXJlbmNlZENvbnRleHQuY29udGV4dCgpIDpcbiAgICAgICAgICAgIHJlZmVyZW5jZWRDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgUmVmZXJlbmNlIHR5cGUgKGUuZy4sIFJFRkVSRU5DRV9DSElMRF9PRiBvclxuICAgICAqICAgICAgICAgUkVGRVJFTkNFX0ZPTExPV1NfRlJPTSkuXG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1NwYW5Db250ZXh0fSBUaGUgU3BhbkNvbnRleHQgYmVpbmcgcmVmZXJyZWQgdG8gKGUuZy4sIHRoZVxuICAgICAqICAgICAgICAgcGFyZW50IGluIGEgUkVGRVJFTkNFX0NISUxEX09GIFJlZmVyZW5jZSkuXG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZWZlcmVuY2VkQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmVyZW5jZWRDb250ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmVyZW5jZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWZlcmVuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZlcmVuY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbm9vcCA9IHJlcXVpcmUoXCIuL25vb3BcIik7XG4vKipcbiAqIFNwYW4gcmVwcmVzZW50cyBhIGxvZ2ljYWwgdW5pdCBvZiB3b3JrIGFzIHBhcnQgb2YgYSBicm9hZGVyIFRyYWNlLiBFeGFtcGxlc1xuICogb2Ygc3BhbiBtaWdodCBpbmNsdWRlIHJlbW90ZSBwcm9jZWR1cmUgY2FsbHMgb3IgYSBpbi1wcm9jZXNzIGZ1bmN0aW9uIGNhbGxzXG4gKiB0byBzdWItY29tcG9uZW50cy4gQSBUcmFjZSBoYXMgYSBzaW5nbGUsIHRvcC1sZXZlbCBcInJvb3RcIiBTcGFuIHRoYXQgaW4gdHVyblxuICogbWF5IGhhdmUgemVybyBvciBtb3JlIGNoaWxkIFNwYW5zLCB3aGljaCBpbiB0dXJuIG1heSBoYXZlIGNoaWxkcmVuLlxuICovXG52YXIgU3BhbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGFuKCkge1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgLy8gT3BlblRyYWNpbmcgQVBJIG1ldGhvZHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3BhbkNvbnRleHQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNwYW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTcGFuQ29udGV4dH1cbiAgICAgKi9cbiAgICBTcGFuLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhY2VyIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIFNwYW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtUcmFjZXJ9XG4gICAgICovXG4gICAgU3Bhbi5wcm90b3R5cGUudHJhY2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2VyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJpbmcgbmFtZSBmb3IgdGhlIGxvZ2ljYWwgb3BlcmF0aW9uIHRoaXMgc3BhbiByZXByZXNlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBTcGFuLnByb3RvdHlwZS5zZXRPcGVyYXRpb25OYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fc2V0T3BlcmF0aW9uTmFtZShuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEga2V5OnZhbHVlIHBhaXIgb24gdGhpcyBTcGFuIHRoYXQgYWxzbyBwcm9wYWdhdGVzIHRvIGZ1dHVyZVxuICAgICAqIGNoaWxkcmVuIG9mIHRoZSBhc3NvY2lhdGVkIFNwYW4uXG4gICAgICpcbiAgICAgKiBzZXRCYWdnYWdlSXRlbSgpIGVuYWJsZXMgcG93ZXJmdWwgZnVuY3Rpb25hbGl0eSBnaXZlbiBhIGZ1bGwtc3RhY2tcbiAgICAgKiBvcGVudHJhY2luZyBpbnRlZ3JhdGlvbiAoZS5nLiwgYXJiaXRyYXJ5IGFwcGxpY2F0aW9uIGRhdGEgZnJvbSBhIHdlYlxuICAgICAqIGNsaWVudCBjYW4gbWFrZSBpdCwgdHJhbnNwYXJlbnRseSwgYWxsIHRoZSB3YXkgaW50byB0aGUgZGVwdGhzIG9mIGFcbiAgICAgKiBzdG9yYWdlIHN5c3RlbSksIGFuZCB3aXRoIGl0IHNvbWUgcG93ZXJmdWwgY29zdHM6IHVzZSB0aGlzIGZlYXR1cmUgd2l0aFxuICAgICAqIGNhcmUuXG4gICAgICpcbiAgICAgKiBJTVBPUlRBTlQgTk9URSAjMTogc2V0QmFnZ2FnZUl0ZW0oKSB3aWxsIG9ubHkgcHJvcGFnYXRlIGJhZ2dhZ2UgaXRlbXMgdG9cbiAgICAgKiAqZnV0dXJlKiBjYXVzYWwgZGVzY2VuZGFudHMgb2YgdGhlIGFzc29jaWF0ZWQgU3Bhbi5cbiAgICAgKlxuICAgICAqIElNUE9SVEFOVCBOT1RFICMyOiBVc2UgdGhpcyB0aG91Z2h0ZnVsbHkgYW5kIHdpdGggY2FyZS4gRXZlcnkga2V5IGFuZFxuICAgICAqIHZhbHVlIGlzIGNvcGllZCBpbnRvIGV2ZXJ5IGxvY2FsICphbmQgcmVtb3RlKiBjaGlsZCBvZiB0aGUgYXNzb2NpYXRlZFxuICAgICAqIFNwYW4sIGFuZCB0aGF0IGNhbiBhZGQgdXAgdG8gYSBsb3Qgb2YgbmV0d29yayBhbmQgY3B1IG92ZXJoZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIFNwYW4ucHJvdG90eXBlLnNldEJhZ2dhZ2VJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2V0QmFnZ2FnZUl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgYmFnZ2FnZSBpdGVtIGdpdmVuIGl0cyBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqICAgICAgICAgVGhlIGtleSBmb3IgdGhlIGdpdmVuIHRyYWNlIGF0dHJpYnV0ZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogICAgICAgICBTdHJpbmcgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXksIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5IGRvZXMgbm90XG4gICAgICogICAgICAgICBjb3JyZXNwb25kIHRvIGEgc2V0IHRyYWNlIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBTcGFuLnByb3RvdHlwZS5nZXRCYWdnYWdlSXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJhZ2dhZ2VJdGVtKGtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc2luZ2xlIHRhZyB0byB0aGUgc3Bhbi4gIFNlZSBgYWRkVGFncygpYCBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICAgKi9cbiAgICBTcGFuLnByb3RvdHlwZS5zZXRUYWcgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIE5PVEU6IHRoZSBjYWxsIGlzIG5vcm1hbGl6ZWQgdG8gYSBjYWxsIHRvIF9hZGRUYWdzKClcbiAgICAgICAgdGhpcy5fYWRkVGFncygoX2EgPSB7fSwgX2Fba2V5XSA9IHZhbHVlLCBfYSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIGtleSB2YWx1ZSBwYWlycyB0byB0aGUgc2V0IG9mIHNwYW4gdGFncy5cbiAgICAgKlxuICAgICAqIE11bHRpcGxlIGNhbGxzIHRvIGFkZFRhZ3MoKSByZXN1bHRzIGluIHRoZSB0YWdzIGJlaW5nIHRoZSBzdXBlcnNldCBvZlxuICAgICAqIGFsbCBjYWxscy5cbiAgICAgKlxuICAgICAqIFRoZSBiZWhhdmlvciBvZiBzZXR0aW5nIHRoZSBzYW1lIGtleSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBzcGFuXG4gICAgICogaXMgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogVGhlIHN1cHBvcnRlZCB0eXBlIG9mIHRoZSB2YWx1ZXMgaXMgaW1wbGVtZW50YXRpb24tZGVwZW5kZW50LlxuICAgICAqIEltcGxlbWVudGF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gc2FmZWx5IGhhbmRsZSBhbGwgdHlwZXMgb2YgdmFsdWVzIGJ1dFxuICAgICAqIG1heSBjaG9vc2UgdG8gaWdub3JlIHVucmVjb2duaXplZCAvIHVuaGFuZGxlLWFibGUgdmFsdWVzIChlLmcuIG9iamVjdHNcbiAgICAgKiB3aXRoIGN5Y2xpYyByZWZlcmVuY2VzLCBmdW5jdGlvbiBvYmplY3RzKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIFNwYW4ucHJvdG90eXBlLmFkZFRhZ3MgPSBmdW5jdGlvbiAoa2V5VmFsdWVNYXApIHtcbiAgICAgICAgdGhpcy5fYWRkVGFncyhrZXlWYWx1ZU1hcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgbG9nIHJlY29yZCB0byB0aGlzIFNwYW4sIG9wdGlvbmFsbHkgYXQgYSB1c2VyLXByb3ZpZGVkIHRpbWVzdGFtcC5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIHNwYW4ubG9nKHtcbiAgICAgKiAgICAgICAgIHNpemU6IHJwYy5zaXplKCksICAvLyBudW1lcmljIHZhbHVlXG4gICAgICogICAgICAgICBVUkk6IHJwYy5VUkkoKSwgIC8vIHN0cmluZyB2YWx1ZVxuICAgICAqICAgICAgICAgcGF5bG9hZDogcnBjLnBheWxvYWQoKSwgIC8vIE9iamVjdCB2YWx1ZVxuICAgICAqICAgICAgICAgXCJrZXlzIGNhbiBiZSBhcmJpdHJhcnkgc3RyaW5nc1wiOiBycGMuZm9vKCksXG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogICAgIHNwYW4ubG9nKHtcbiAgICAgKiAgICAgICAgIFwiZXJyb3IuZGVzY3JpcHRpb25cIjogc29tZUVycm9yLmRlc2NyaXB0aW9uKCksXG4gICAgICogICAgIH0sIHNvbWVFcnJvci50aW1lc3RhbXBNaWxsaXMoKSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ga2V5VmFsdWVQYWlyc1xuICAgICAqICAgICAgICBBbiBvYmplY3QgbWFwcGluZyBzdHJpbmcga2V5cyB0byBhcmJpdHJhcnkgdmFsdWUgdHlwZXMuIEFsbFxuICAgICAqICAgICAgICBUcmFjZXIgaW1wbGVtZW50YXRpb25zIHNob3VsZCBzdXBwb3J0IGJvb2wsIHN0cmluZywgYW5kIG51bWVyaWNcbiAgICAgKiAgICAgICAgdmFsdWUgdHlwZXMsIGFuZCBzb21lIG1heSBhbHNvIHN1cHBvcnQgT2JqZWN0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICogICAgICAgIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBzcGVjaWZ5aW5nIHRoZSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogICAgICAgIHNpbmNlIHRoZSBVbml4IGVwb2NoLiBGcmFjdGlvbmFsIHZhbHVlcyBhcmUgYWxsb3dlZCBzbyB0aGF0XG4gICAgICogICAgICAgIHRpbWVzdGFtcHMgd2l0aCBzdWItbWlsbGlzZWNvbmQgYWNjdXJhY3kgY2FuIGJlIHJlcHJlc2VudGVkLiBJZlxuICAgICAqICAgICAgICBub3Qgc3BlY2lmaWVkLCB0aGUgaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQgdG8gdXNlIGl0cyBub3Rpb25cbiAgICAgKiAgICAgICAgb2YgdGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgY2FsbC5cbiAgICAgKi9cbiAgICBTcGFuLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoa2V5VmFsdWVQYWlycywgdGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMuX2xvZyhrZXlWYWx1ZVBhaXJzLCB0aW1lc3RhbXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURURcbiAgICAgKi9cbiAgICBTcGFuLnByb3RvdHlwZS5sb2dFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZyh7IGV2ZW50OiBldmVudE5hbWUsIHBheWxvYWQ6IHBheWxvYWQgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbmQgdGltZXN0YW1wIGFuZCBmaW5hbGl6ZXMgU3BhbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjYWxscyB0byBTcGFuLmNvbnRleHQoKSAod2hpY2ggYXJlIGFsd2F5cyBhbGxvd2VkKSxcbiAgICAgKiBmaW5pc2goKSBtdXN0IGJlIHRoZSBsYXN0IGNhbGwgbWFkZSB0byBhbnkgc3BhbiBpbnN0YW5jZSwgYW5kIHRvIGRvXG4gICAgICogb3RoZXJ3aXNlIGxlYWRzIHRvIHVuZGVmaW5lZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZmluaXNoVGltZVxuICAgICAqICAgICAgICAgT3B0aW9uYWwgZmluaXNoIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIGEgVW5peCB0aW1lc3RhbXAuIERlY2ltYWxcbiAgICAgKiAgICAgICAgIHZhbHVlcyBhcmUgc3VwcG9ydGVkIGZvciB0aW1lc3RhbXBzIHdpdGggc3ViLW1pbGxpc2Vjb25kIGFjY3VyYWN5LlxuICAgICAqICAgICAgICAgSWYgbm90IHNwZWNpZmllZCwgdGhlIGN1cnJlbnQgdGltZSAoYXMgZGVmaW5lZCBieSB0aGVcbiAgICAgKiAgICAgICAgIGltcGxlbWVudGF0aW9uKSB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgU3Bhbi5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKGZpbmlzaFRpbWUpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoKGZpbmlzaFRpbWUpO1xuICAgICAgICAvLyBEbyBub3QgcmV0dXJuIGB0aGlzYC4gVGhlIFNwYW4gZ2VuZXJhbGx5IHNob3VsZCBub3QgYmUgdXNlZCBhZnRlciBpdFxuICAgICAgICAvLyBpcyBmaW5pc2hlZCBzbyBjaGFpbmluZyBpcyBub3QgZGVzaXJlZCBpbiB0aGlzIGNvbnRleHQuXG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgLy8gRGVyaXZlZCBjbGFzc2VzIGNhbiBjaG9vc2UgdG8gaW1wbGVtZW50IHRoZSBiZWxvd1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICAvLyBCeSBkZWZhdWx0IHJldHVybnMgYSBuby1vcCBTcGFuQ29udGV4dC5cbiAgICBTcGFuLnByb3RvdHlwZS5fY29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5vb3Auc3BhbkNvbnRleHQ7XG4gICAgfTtcbiAgICAvLyBCeSBkZWZhdWx0IHJldHVybnMgYSBuby1vcCB0cmFjZXIuXG4gICAgLy9cbiAgICAvLyBUaGUgYmFzZSBjbGFzcyBjb3VsZCBzdG9yZSB0aGUgdHJhY2VyIHRoYXQgY3JlYXRlZCBpdCwgYnV0IGl0IGRvZXMgbm90XG4gICAgLy8gaW4gb3JkZXIgdG8gZW5zdXJlIHRoZSBuby1vcCBzcGFuIGltcGxlbWVudGF0aW9uIGhhcyB6ZXJvIG1lbWJlcnMsXG4gICAgLy8gd2hpY2ggYWxsb3dzIFY4IHRvIGFnZ3Jlc3NpdmVseSBvcHRpbWl6ZSBjYWxscyB0byBzdWNoIG9iamVjdHMuXG4gICAgU3Bhbi5wcm90b3R5cGUuX3RyYWNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5vb3AudHJhY2VyO1xuICAgIH07XG4gICAgLy8gQnkgZGVmYXVsdCBkb2VzIG5vdGhpbmdcbiAgICBTcGFuLnByb3RvdHlwZS5fc2V0T3BlcmF0aW9uTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgfTtcbiAgICAvLyBCeSBkZWZhdWx0IGRvZXMgbm90aGluZ1xuICAgIFNwYW4ucHJvdG90eXBlLl9zZXRCYWdnYWdlSXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgfTtcbiAgICAvLyBCeSBkZWZhdWx0IGRvZXMgbm90aGluZ1xuICAgIFNwYW4ucHJvdG90eXBlLl9nZXRCYWdnYWdlSXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8vIEJ5IGRlZmF1bHQgZG9lcyBub3RoaW5nXG4gICAgLy9cbiAgICAvLyBOT1RFOiBib3RoIHNldFRhZygpIGFuZCBhZGRUYWdzKCkgbWFwIHRvIHRoaXMgZnVuY3Rpb24uIGtleVZhbHVlUGFpcnNcbiAgICAvLyB3aWxsIGFsd2F5cyBiZSBhbiBhc3NvY2lhdGl2ZSBhcnJheS5cbiAgICBTcGFuLnByb3RvdHlwZS5fYWRkVGFncyA9IGZ1bmN0aW9uIChrZXlWYWx1ZVBhaXJzKSB7XG4gICAgfTtcbiAgICAvLyBCeSBkZWZhdWx0IGRvZXMgbm90aGluZ1xuICAgIFNwYW4ucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAoa2V5VmFsdWVQYWlycywgdGltZXN0YW1wKSB7XG4gICAgfTtcbiAgICAvLyBCeSBkZWZhdWx0IGRvZXMgbm90aGluZ1xuICAgIC8vXG4gICAgLy8gZmluaXNoVGltZSBpcyBleHBlY3RlZCB0byBiZSBlaXRoZXIgYSBudW1iZXIgb3IgdW5kZWZpbmVkLlxuICAgIFNwYW4ucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbiAoZmluaXNoVGltZSkge1xuICAgIH07XG4gICAgcmV0dXJuIFNwYW47XG59KCkpO1xuZXhwb3J0cy5TcGFuID0gU3BhbjtcbmV4cG9ydHMuZGVmYXVsdCA9IFNwYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBTcGFuQ29udGV4dCByZXByZXNlbnRzIFNwYW4gc3RhdGUgdGhhdCBtdXN0IHByb3BhZ2F0ZSB0byBkZXNjZW5kYW50IFNwYW5zXG4gKiBhbmQgYWNyb3NzIHByb2Nlc3MgYm91bmRhcmllcy5cbiAqXG4gKiBTcGFuQ29udGV4dCBpcyBsb2dpY2FsbHkgZGl2aWRlZCBpbnRvIHR3byBwaWVjZXM6IHRoZSB1c2VyLWxldmVsIFwiQmFnZ2FnZVwiXG4gKiAoc2VlIHNldEJhZ2dhZ2VJdGVtIGFuZCBnZXRCYWdnYWdlSXRlbSkgdGhhdCBwcm9wYWdhdGVzIGFjcm9zcyBTcGFuXG4gKiBib3VuZGFyaWVzIGFuZCBhbnkgVHJhY2VyLWltcGxlbWVudGF0aW9uLXNwZWNpZmljIGZpZWxkcyB0aGF0IGFyZSBuZWVkZWQgdG9cbiAqIGlkZW50aWZ5IG9yIG90aGVyd2lzZSBjb250ZXh0dWFsaXplIHRoZSBhc3NvY2lhdGVkIFNwYW4gaW5zdGFuY2UgKGUuZy4sIGFcbiAqIDx0cmFjZV9pZCwgc3Bhbl9pZCwgc2FtcGxlZD4gdHVwbGUpLlxuICovXG52YXIgU3BhbkNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BhbkNvbnRleHQoKSB7XG4gICAgfVxuICAgIC8vIFRoZSBTcGFuQ29udGV4dCBpcyBlbnRpcmVseSBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnRcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBpbnRlcm5hbCB0cmFjZSBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgU3BhbkNvbnRleHQucHJvdG90eXBlLnRvVHJhY2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW1wbGVtZW50YXRpb24gaW50ZXJuYWwgc3BhbiBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgU3BhbkNvbnRleHQucHJvdG90eXBlLnRvU3BhbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICByZXR1cm4gU3BhbkNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5TcGFuQ29udGV4dCA9IFNwYW5Db250ZXh0O1xuZXhwb3J0cy5kZWZhdWx0ID0gU3BhbkNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGFuX2NvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRnVuY3Rpb25zID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zXCIpO1xudmFyIE5vb3AgPSByZXF1aXJlKFwiLi9ub29wXCIpO1xudmFyIHNwYW5fMSA9IHJlcXVpcmUoXCIuL3NwYW5cIik7XG4vKipcbiAqIFRyYWNlciBpcyB0aGUgZW50cnktcG9pbnQgYmV0d2VlbiB0aGUgaW5zdHJ1bWVudGF0aW9uIEFQSSBhbmQgdGhlIHRyYWNpbmdcbiAqIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoZSBkZWZhdWx0IG9iamVjdCBhY3RzIGFzIGEgbm8tb3AgaW1wbGVtZW50YXRpb24uXG4gKlxuICogTm90ZSB0byBpbXBsZW1lbnRhdG9yczogZGVyaXZlZCBjbGFzc2VzIGNhbiBjaG9vc2UgdG8gZGlyZWN0bHkgaW1wbGVtZW50IHRoZVxuICogbWV0aG9kcyBpbiB0aGUgXCJPcGVuVHJhY2luZyBBUEkgbWV0aG9kc1wiIHNlY3Rpb24sIG9yIG9wdGlvbmFsbHkgdGhlIHN1YnNldCBvZlxuICogdW5kZXJzY29yZS1wcmVmaXhlZCBtZXRob2RzIHRvIHBpY2sgdXAgdGhlIGFyZ3VtZW50IGNoZWNraW5nIGFuZCBoYW5kbGluZ1xuICogYXV0b21hdGljYWxseSBmcm9tIHRoZSBiYXNlIGNsYXNzLlxuICovXG52YXIgVHJhY2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYWNlcigpIHtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgIC8vIE9wZW5UcmFjaW5nIEFQSSBtZXRob2RzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhbmQgcmV0dXJucyBhIG5ldyBTcGFuIHJlcHJlc2VudGluZyBhIGxvZ2ljYWwgdW5pdCBvZiB3b3JrLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgLy8gU3RhcnQgYSBuZXcgKHBhcmVudGxlc3MpIHJvb3QgU3BhbjpcbiAgICAgKiAgICAgdmFyIHBhcmVudCA9IFRyYWNlci5zdGFydFNwYW4oJ0RvV29yaycpO1xuICAgICAqXG4gICAgICogICAgIC8vIFN0YXJ0IGEgbmV3IChjaGlsZCkgU3BhbjpcbiAgICAgKiAgICAgdmFyIGNoaWxkID0gVHJhY2VyLnN0YXJ0U3BhbignbG9hZC1mcm9tLWRiJywge1xuICAgICAqICAgICAgICAgY2hpbGRPZjogcGFyZW50LmNvbnRleHQoKSxcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gU3RhcnQgYSBuZXcgYXN5bmMgKEZvbGxvd3NGcm9tKSBTcGFuOlxuICAgICAqICAgICB2YXIgY2hpbGQgPSBUcmFjZXIuc3RhcnRTcGFuKCdhc3luYy1jYWNoZS13cml0ZScsIHtcbiAgICAgKiAgICAgICAgIHJlZmVyZW5jZXM6IFtcbiAgICAgKiAgICAgICAgICAgICBvcGVudHJhY2luZy5mb2xsb3dzRnJvbShwYXJlbnQuY29udGV4dCgpKVxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gKFJFUVVJUkVEKS5cbiAgICAgKiBAcGFyYW0ge1NwYW5PcHRpb25zfSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBzcGFuLlxuICAgICAqIEByZXR1cm4ge1NwYW59IC0gYSBuZXcgU3BhbiBvYmplY3QuXG4gICAgICovXG4gICAgVHJhY2VyLnByb3RvdHlwZS5zdGFydFNwYW4gPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBDb252ZXJ0IG9wdGlvbnMuY2hpbGRPZiB0byBmaWVsZHMucmVmZXJlbmNlcyBhcyBuZWVkZWQuXG4gICAgICAgIGlmIChvcHRpb25zLmNoaWxkT2YpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSBhIFNwYW4gb3IgYSBTcGFuQ29udGV4dCBpbnRvIGEgUmVmZXJlbmNlLlxuICAgICAgICAgICAgdmFyIGNoaWxkT2YgPSBGdW5jdGlvbnMuY2hpbGRPZihvcHRpb25zLmNoaWxkT2YpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVmZXJlbmNlcy5wdXNoKGNoaWxkT2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWZlcmVuY2VzID0gW2NoaWxkT2ZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIChvcHRpb25zLmNoaWxkT2YpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydFNwYW4obmFtZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmplY3RzIHRoZSBnaXZlbiBTcGFuQ29udGV4dCBpbnN0YW5jZSBmb3IgY3Jvc3MtcHJvY2VzcyBwcm9wYWdhdGlvblxuICAgICAqIHdpdGhpbiBgY2FycmllcmAuIFRoZSBleHBlY3RlZCB0eXBlIG9mIGBjYXJyaWVyYCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZlxuICAgICAqIGBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBPcGVuVHJhY2luZyBkZWZpbmVzIGEgY29tbW9uIHNldCBvZiBgZm9ybWF0YCB2YWx1ZXMgKHNlZVxuICAgICAqIEZPUk1BVF9URVhUX01BUCwgRk9STUFUX0hUVFBfSEVBREVSUywgYW5kIEZPUk1BVF9CSU5BUlkpLCBhbmQgZWFjaCBoYXNcbiAgICAgKiBhbiBleHBlY3RlZCBjYXJyaWVyIHR5cGUuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciB0aGlzIHBzZXVkb2NvZGUgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2xpZW50U3BhbiA9IC4uLjtcbiAgICAgKiAgICAgLi4uXG4gICAgICogICAgIC8vIEluamVjdCBjbGllbnRTcGFuIGludG8gYSB0ZXh0IGNhcnJpZXIuXG4gICAgICogICAgIHZhciBoZWFkZXJzQ2FycmllciA9IHt9O1xuICAgICAqICAgICBUcmFjZXIuaW5qZWN0KGNsaWVudFNwYW4uY29udGV4dCgpLCBUcmFjZXIuRk9STUFUX0hUVFBfSEVBREVSUywgaGVhZGVyc0NhcnJpZXIpO1xuICAgICAqICAgICAvLyBJbmNvcnBvcmF0ZSB0aGUgdGV4dENhcnJpZXIgaW50byB0aGUgb3V0Ym91bmQgSFRUUCByZXF1ZXN0IGhlYWRlclxuICAgICAqICAgICAvLyBtYXAuXG4gICAgICogICAgIE9iamVjdC5hc3NpZ24ob3V0Ym91bmRIVFRQUmVxLmhlYWRlcnMsIGhlYWRlcnNDYXJyaWVyKTtcbiAgICAgKiAgICAgLy8gLi4uIHNlbmQgdGhlIGh0dHBSZXFcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1NwYW5Db250ZXh0fSBzcGFuQ29udGV4dCAtIHRoZSBTcGFuQ29udGV4dCB0byBpbmplY3QgaW50byB0aGVcbiAgICAgKiAgICAgICAgIGNhcnJpZXIgb2JqZWN0LiBBcyBhIGNvbnZlbmllbmNlLCBhIFNwYW4gaW5zdGFuY2UgbWF5IGJlIHBhc3NlZFxuICAgICAqICAgICAgICAgaW4gaW5zdGVhZCAoaW4gd2hpY2ggY2FzZSBpdHMgLmNvbnRleHQoKSBpcyB1c2VkIGZvciB0aGVcbiAgICAgKiAgICAgICAgIGluamVjdCgpKS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBmb3JtYXQgb2YgdGhlIGNhcnJpZXIuXG4gICAgICogQHBhcmFtICB7YW55fSBjYXJyaWVyIC0gc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgY2hvc2VuIGBmb3JtYXRgXG4gICAgICogICAgICAgICBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgY2FycmllciBvYmplY3QuXG4gICAgICovXG4gICAgVHJhY2VyLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbiAoc3BhbkNvbnRleHQsIGZvcm1hdCwgY2Fycmllcikge1xuICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBwYXNzIGEgU3BhbiBpbnN0ZWFkIG9mIGEgU3BhbkNvbnRleHRcbiAgICAgICAgaWYgKHNwYW5Db250ZXh0IGluc3RhbmNlb2Ygc3Bhbl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHNwYW5Db250ZXh0ID0gc3BhbkNvbnRleHQuY29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmplY3Qoc3BhbkNvbnRleHQsIGZvcm1hdCwgY2Fycmllcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU3BhbkNvbnRleHQgaW5zdGFuY2UgZXh0cmFjdGVkIGZyb20gYGNhcnJpZXJgIGluIHRoZSBnaXZlblxuICAgICAqIGBmb3JtYXRgLlxuICAgICAqXG4gICAgICogT3BlblRyYWNpbmcgZGVmaW5lcyBhIGNvbW1vbiBzZXQgb2YgYGZvcm1hdGAgdmFsdWVzIChzZWVcbiAgICAgKiBGT1JNQVRfVEVYVF9NQVAsIEZPUk1BVF9IVFRQX0hFQURFUlMsIGFuZCBGT1JNQVRfQklOQVJZKSwgYW5kIGVhY2ggaGFzXG4gICAgICogYW4gZXhwZWN0ZWQgY2FycmllciB0eXBlLlxuICAgICAqXG4gICAgICogQ29uc2lkZXIgdGhpcyBwc2V1ZG9jb2RlIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgLy8gVXNlIHRoZSBpbmJvdW5kIEhUVFAgcmVxdWVzdCdzIGhlYWRlcnMgYXMgYSB0ZXh0IG1hcCBjYXJyaWVyLlxuICAgICAqICAgICB2YXIgaGVhZGVyc0NhcnJpZXIgPSBpbmJvdW5kSFRUUFJlcS5oZWFkZXJzO1xuICAgICAqICAgICB2YXIgd2lyZUN0eCA9IFRyYWNlci5leHRyYWN0KFRyYWNlci5GT1JNQVRfSFRUUF9IRUFERVJTLCBoZWFkZXJzQ2Fycmllcik7XG4gICAgICogICAgIHZhciBzZXJ2ZXJTcGFuID0gVHJhY2VyLnN0YXJ0U3BhbignLi4uJywgeyBjaGlsZE9mIDogd2lyZUN0eCB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZm9ybWF0IC0gdGhlIGZvcm1hdCBvZiB0aGUgY2Fycmllci5cbiAgICAgKiBAcGFyYW0gIHthbnl9IGNhcnJpZXIgLSB0aGUgdHlwZSBvZiB0aGUgY2FycmllciBvYmplY3QgaXMgZGV0ZXJtaW5lZCBieVxuICAgICAqICAgICAgICAgdGhlIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJuIHtTcGFuQ29udGV4dH1cbiAgICAgKiAgICAgICAgIFRoZSBleHRyYWN0ZWQgU3BhbkNvbnRleHQsIG9yIG51bGwgaWYgbm8gc3VjaCBTcGFuQ29udGV4dCBjb3VsZFxuICAgICAqICAgICAgICAgYmUgZm91bmQgaW4gYGNhcnJpZXJgXG4gICAgICovXG4gICAgVHJhY2VyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKGZvcm1hdCwgY2Fycmllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0cmFjdChmb3JtYXQsIGNhcnJpZXIpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgIC8vIERlcml2ZWQgY2xhc3NlcyBjYW4gY2hvb3NlIHRvIGltcGxlbWVudCB0aGUgYmVsb3dcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgLy8gTk9URTogdGhlIGlucHV0IHRvIHRoaXMgbWV0aG9kIGlzICphbHdheXMqIGFuIGFzc29jaWF0aXZlIGFycmF5LiBUaGVcbiAgICAvLyBwdWJsaWMtZmFjaW5nIHN0YXJ0U3BhbigpIG1ldGhvZCBub3JtYWxpemVzIHRoZSBhcmd1bWVudHMgc28gdGhhdFxuICAgIC8vIGFsbCBOIGltcGxlbWVudGF0aW9ucyBkbyBub3QgbmVlZCB0byB3b3JyeSBhYm91dCB2YXJpYXRpb25zIGluIHRoZSBjYWxsXG4gICAgLy8gc2lnbmF0dXJlLlxuICAgIC8vXG4gICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgcmV0dXJucyBhIG5vLW9wIHNwYW4uXG4gICAgVHJhY2VyLnByb3RvdHlwZS5fc3RhcnRTcGFuID0gZnVuY3Rpb24gKG5hbWUsIGZpZWxkcykge1xuICAgICAgICByZXR1cm4gTm9vcC5zcGFuO1xuICAgIH07XG4gICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYSBuby1vcC5cbiAgICBUcmFjZXIucHJvdG90eXBlLl9pbmplY3QgPSBmdW5jdGlvbiAoc3BhbkNvbnRleHQsIGZvcm1hdCwgY2Fycmllcikge1xuICAgIH07XG4gICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmV0dXJuIGEgbm8tb3AgU3BhbkNvbnRleHQuXG4gICAgVHJhY2VyLnByb3RvdHlwZS5fZXh0cmFjdCA9IGZ1bmN0aW9uIChmb3JtYXQsIGNhcnJpZXIpIHtcbiAgICAgICAgcmV0dXJuIE5vb3Auc3BhbkNvbnRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2VyO1xufSgpKTtcbmV4cG9ydHMuVHJhY2VyID0gVHJhY2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHJhY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2VyLmpzLm1hcCIsImltcG9ydCB7IFNsb3QgfSBmcm9tICdAd3J5L2NvbnRleHQnO1xuZXhwb3J0IHsgYXN5bmNGcm9tR2VuLCBiaW5kIGFzIGJpbmRDb250ZXh0LCBub0NvbnRleHQsIHNldFRpbWVvdXQgfSBmcm9tICdAd3J5L2NvbnRleHQnO1xuXG5mdW5jdGlvbiBkZWZhdWx0RGlzcG9zZSgpIHsgfVxyXG52YXIgQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYWNoZShtYXgsIGRpc3Bvc2UpIHtcclxuICAgICAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gSW5maW5pdHk7IH1cclxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7IGRpc3Bvc2UgPSBkZWZhdWx0RGlzcG9zZTsgfVxyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGRpc3Bvc2U7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5uZXdlc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub2xkZXN0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIENhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhrZXkpO1xyXG4gICAgfTtcclxuICAgIENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5nZXRFbnRyeShrZXkpO1xyXG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcclxuICAgIH07XHJcbiAgICBDYWNoZS5wcm90b3R5cGUuZ2V0RW50cnkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5tYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5ICE9PSB0aGlzLm5ld2VzdCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkZXIgPSBlbnRyeS5vbGRlciwgbmV3ZXIgPSBlbnRyeS5uZXdlcjtcclxuICAgICAgICAgICAgaWYgKG5ld2VyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdlci5vbGRlciA9IG9sZGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgb2xkZXIubmV3ZXIgPSBuZXdlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRyeS5vbGRlciA9IHRoaXMubmV3ZXN0O1xyXG4gICAgICAgICAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5O1xyXG4gICAgICAgICAgICBlbnRyeS5uZXdlciA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubmV3ZXN0ID0gZW50cnk7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gdGhpcy5vbGRlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xkZXN0ID0gbmV3ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgfTtcclxuICAgIENhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0RW50cnkoa2V5KTtcclxuICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVudHJ5ID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBuZXdlcjogbnVsbCxcclxuICAgICAgICAgICAgb2xkZXI6IHRoaXMubmV3ZXN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5uZXdlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdlc3QubmV3ZXIgPSBlbnRyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uZXdlc3QgPSBlbnRyeTtcclxuICAgICAgICB0aGlzLm9sZGVzdCA9IHRoaXMub2xkZXN0IHx8IGVudHJ5O1xyXG4gICAgICAgIHRoaXMubWFwLnNldChrZXksIGVudHJ5KTtcclxuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQ2FjaGUucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLm9sZGVzdCAmJiB0aGlzLm1hcC5zaXplID4gdGhpcy5tYXgpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxldGUodGhpcy5vbGRlc3Qua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FjaGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgaWYgKGVudHJ5ID09PSB0aGlzLm5ld2VzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdlc3QgPSBlbnRyeS5vbGRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sZGVzdCA9IGVudHJ5Lm5ld2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5uZXdlcikge1xyXG4gICAgICAgICAgICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50cnkub2xkZXIpIHtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZShlbnRyeS52YWx1ZSwga2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2FjaGU7XHJcbn0oKSk7XG5cbnZhciBwYXJlbnRFbnRyeVNsb3QgPSBuZXcgU2xvdCgpO1xuXG52YXIgcmV1c2FibGVFbXB0eUFycmF5ID0gW107XHJcbnZhciBlbXB0eVNldFBvb2wgPSBbXTtcclxudmFyIFBPT0xfVEFSR0VUX1NJWkUgPSAxMDA7XHJcbi8vIFNpbmNlIHRoaXMgcGFja2FnZSBtaWdodCBiZSB1c2VkIGJyb3dzZXJzLCB3ZSBzaG91bGQgYXZvaWQgdXNpbmcgdGhlXHJcbi8vIE5vZGUgYnVpbHQtaW4gYXNzZXJ0IG1vZHVsZS5cclxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgb3B0aW9uYWxNZXNzYWdlKSB7XHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25hbE1lc3NhZ2UgfHwgXCJhc3NlcnRpb24gZmFpbHVyZVwiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWx1ZUlzKGEsIGIpIHtcclxuICAgIHZhciBsZW4gPSBhLmxlbmd0aDtcclxuICAgIHJldHVybiAoXHJcbiAgICAvLyBVbmtub3duIHZhbHVlcyBhcmUgbm90IGVxdWFsIHRvIGVhY2ggb3RoZXIuXHJcbiAgICBsZW4gPiAwICYmXHJcbiAgICAgICAgLy8gQm90aCB2YWx1ZXMgbXVzdCBiZSBvcmRpbmFyeSAob3IgYm90aCBleGNlcHRpb25hbCkgdG8gYmUgZXF1YWwuXHJcbiAgICAgICAgbGVuID09PSBiLmxlbmd0aCAmJlxyXG4gICAgICAgIC8vIFRoZSB1bmRlcmx5aW5nIHZhbHVlIG9yIGV4Y2VwdGlvbiBtdXN0IGJlIHRoZSBzYW1lLlxyXG4gICAgICAgIGFbbGVuIC0gMV0gPT09IGJbbGVuIC0gMV0pO1xyXG59XHJcbmZ1bmN0aW9uIHZhbHVlR2V0KHZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKHZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMDogdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZVwiKTtcclxuICAgICAgICBjYXNlIDE6IHJldHVybiB2YWx1ZVswXTtcclxuICAgICAgICBjYXNlIDI6IHRocm93IHZhbHVlWzFdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbHVlQ29weSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKDApO1xyXG59XHJcbnZhciBFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudHJ5KGZuLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xyXG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRWYWx1ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gV2hlbiB0aGlzIEVudHJ5IGhhcyBjaGlsZHJlbiB0aGF0IGFyZSBkaXJ0eSwgdGhpcyBwcm9wZXJ0eSBiZWNvbWVzXHJcbiAgICAgICAgLy8gYSBTZXQgY29udGFpbmluZyBvdGhlciBFbnRyeSBvYmplY3RzLCBib3Jyb3dlZCBmcm9tIGVtcHR5U2V0UG9vbC5cclxuICAgICAgICAvLyBXaGVuIHRoZSBzZXQgYmVjb21lcyBlbXB0eSwgaXQgZ2V0cyByZWN5Y2xlZCBiYWNrIHRvIGVtcHR5U2V0UG9vbC5cclxuICAgICAgICB0aGlzLmRpcnR5Q2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVjb21wdXRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gW107XHJcbiAgICAgICAgKytFbnRyeS5jb3VudDtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IG1ldGhvZCBvZiB0aGUgRW50cnkgQVBJLCBiZWNhdXNlIGl0XHJcbiAgICAvLyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNhY2hlZCB0aGlzLnZhbHVlIGNhbiBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSxcclxuICAgIC8vIG9yIG11c3QgYmUgcmVjb21wdXRlZC4gVGhlIG92ZXJhbGwgcGVyZm9ybWFuY2Ugb2YgdGhlIGNhY2hpbmcgc3lzdGVtXHJcbiAgICAvLyBkZXBlbmRzIG9uIHRoZSB0cnV0aCBvZiB0aGUgZm9sbG93aW5nIG9ic2VydmF0aW9uczogKDEpIHRoaXMuZGlydHkgaXNcclxuICAgIC8vIHVzdWFsbHkgZmFsc2UsICgyKSB0aGlzLmRpcnR5Q2hpbGRyZW4gaXMgdXN1YWxseSBudWxsL2VtcHR5LCBhbmQgdGh1c1xyXG4gICAgLy8gKDMpIHZhbHVlR2V0KHRoaXMudmFsdWUpIGlzIHVzdWFsbHkgcmV0dXJuZWQgd2l0aG91dCByZWNvbXB1dGF0aW9uLlxyXG4gICAgRW50cnkucHJvdG90eXBlLnJlY29tcHV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhc3NlcnQoIXRoaXMucmVjb21wdXRpbmcsIFwiYWxyZWFkeSByZWNvbXB1dGluZ1wiKTtcclxuICAgICAgICBpZiAoIXJlbWVtYmVyUGFyZW50KHRoaXMpICYmIG1heWJlUmVwb3J0T3JwaGFuKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSByZWNpcGllbnQgb2YgdGhlIGVudHJ5LnJlcG9ydE9ycGhhbiBjYWxsYmFjayBkZWNpZGVkIHRvIGRpc3Bvc2VcclxuICAgICAgICAgICAgLy8gb2YgdGhpcyBvcnBoYW4gZW50cnkgYnkgY2FsbGluZyBlbnRyeS5kaXNwb3NlKCksIHNvIHdlIGRvbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gKGFuZCBzaG91bGQgbm90KSBwcm9jZWVkIHdpdGggdGhlIHJlY29tcHV0YXRpb24uXHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaWdodEJlRGlydHkodGhpcylcclxuICAgICAgICAgICAgPyByZWFsbHlSZWNvbXB1dGUodGhpcylcclxuICAgICAgICAgICAgOiB2YWx1ZUdldCh0aGlzLnZhbHVlKTtcclxuICAgIH07XHJcbiAgICBFbnRyeS5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZhbHVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmVwb3J0RGlydHkodGhpcyk7XHJcbiAgICAgICAgLy8gV2UgY2FuIGdvIGFoZWFkIGFuZCB1bnN1YnNjcmliZSBoZXJlLCBzaW5jZSBhbnkgZnVydGhlciBkaXJ0eVxyXG4gICAgICAgIC8vIG5vdGlmaWNhdGlvbnMgd2UgcmVjZWl2ZSB3aWxsIGJlIHJlZHVuZGFudCwgYW5kIHVuc3Vic2NyaWJpbmcgbWF5XHJcbiAgICAgICAgLy8gZnJlZSB1cCBzb21lIHJlc291cmNlcywgZS5nLiBmaWxlIHdhdGNoZXJzLlxyXG4gICAgICAgIG1heWJlVW5zdWJzY3JpYmUodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRW50cnkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBmb3JnZXRDaGlsZHJlbih0aGlzKS5mb3JFYWNoKG1heWJlUmVwb3J0T3JwaGFuKTtcclxuICAgICAgICBtYXliZVVuc3Vic2NyaWJlKHRoaXMpO1xyXG4gICAgICAgIC8vIEJlY2F1c2UgdGhpcyBlbnRyeSBoYXMgYmVlbiBraWNrZWQgb3V0IG9mIHRoZSBjYWNoZSAoaW4gaW5kZXguanMpLFxyXG4gICAgICAgIC8vIHdlJ3ZlIGxvc3QgdGhlIGFiaWxpdHkgdG8gZmluZCBvdXQgaWYvd2hlbiB0aGlzIGVudHJ5IGJlY29tZXMgZGlydHksXHJcbiAgICAgICAgLy8gd2hldGhlciB0aGF0IGhhcHBlbnMgdGhyb3VnaCBhIHN1YnNjcmlwdGlvbiwgYmVjYXVzZSBvZiBhIGRpcmVjdCBjYWxsXHJcbiAgICAgICAgLy8gdG8gZW50cnkuc2V0RGlydHkoKSwgb3IgYmVjYXVzZSBvbmUgb2YgaXRzIGNoaWxkcmVuIGJlY29tZXMgZGlydHkuXHJcbiAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzIGxvc3Mgb2YgZnV0dXJlIGluZm9ybWF0aW9uLCB3ZSBoYXZlIHRvIGFzc3VtZSB0aGVcclxuICAgICAgICAvLyB3b3JzdCAodGhhdCB0aGlzIGVudHJ5IG1pZ2h0IGhhdmUgYmVjb21lIGRpcnR5IHZlcnkgc29vbiksIHNvIHdlIG11c3RcclxuICAgICAgICAvLyBpbW1lZGlhdGVseSBtYXJrIHRoaXMgZW50cnkncyBwYXJlbnRzIGFzIGRpcnR5LiBOb3JtYWxseSB3ZSBjb3VsZFxyXG4gICAgICAgIC8vIGp1c3QgY2FsbCBlbnRyeS5zZXREaXJ0eSgpIHJhdGhlciB0aGFuIGNhbGxpbmcgcGFyZW50LnNldERpcnR5KCkgZm9yXHJcbiAgICAgICAgLy8gZWFjaCBwYXJlbnQsIGJ1dCB0aGF0IHdvdWxkIGxlYXZlIHRoaXMgZW50cnkgaW4gcGFyZW50LmNoaWxkVmFsdWVzXHJcbiAgICAgICAgLy8gYW5kIHBhcmVudC5kaXJ0eUNoaWxkcmVuLCB3aGljaCB3b3VsZCBwcmV2ZW50IHRoZSBjaGlsZCBmcm9tIGJlaW5nXHJcbiAgICAgICAgLy8gdHJ1bHkgZm9yZ290dGVuLlxyXG4gICAgICAgIHRoaXMucGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnNldERpcnR5KCk7XHJcbiAgICAgICAgICAgIGZvcmdldENoaWxkKHBhcmVudCwgX3RoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVudHJ5LmNvdW50ID0gMDtcclxuICAgIHJldHVybiBFbnRyeTtcclxufSgpKTtcclxuZnVuY3Rpb24gcmVtZW1iZXJQYXJlbnQoY2hpbGQpIHtcclxuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRFbnRyeVNsb3QuZ2V0VmFsdWUoKTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBjaGlsZC5wYXJlbnRzLmFkZChwYXJlbnQpO1xyXG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpIHtcclxuICAgICAgICAgICAgcGFyZW50LmNoaWxkVmFsdWVzLnNldChjaGlsZCwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWlnaHRCZURpcnR5KGNoaWxkKSkge1xyXG4gICAgICAgICAgICByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWFsbHlSZWNvbXB1dGUoZW50cnkpIHtcclxuICAgIC8vIFNpbmNlIHRoaXMgcmVjb21wdXRhdGlvbiBpcyBsaWtlbHkgdG8gcmUtcmVtZW1iZXIgc29tZSBvZiB0aGlzXHJcbiAgICAvLyBlbnRyeSdzIGNoaWxkcmVuLCB3ZSBmb3JnZXQgb3VyIGNoaWxkcmVuIGhlcmUgYnV0IGRvIG5vdCBjYWxsXHJcbiAgICAvLyBtYXliZVJlcG9ydE9ycGhhbiB1bnRpbCBhZnRlciB0aGUgcmVjb21wdXRhdGlvbiBmaW5pc2hlcy5cclxuICAgIHZhciBvcmlnaW5hbENoaWxkcmVuID0gZm9yZ2V0Q2hpbGRyZW4oZW50cnkpO1xyXG4gICAgLy8gU2V0IGVudHJ5IGFzIHRoZSBwYXJlbnQgZW50cnkgd2hpbGUgY2FsbGluZyByZWNvbXB1dGVOZXdWYWx1ZShlbnRyeSkuXHJcbiAgICBwYXJlbnRFbnRyeVNsb3Qud2l0aFZhbHVlKGVudHJ5LCByZWNvbXB1dGVOZXdWYWx1ZSwgW2VudHJ5XSk7XHJcbiAgICBpZiAobWF5YmVTdWJzY3JpYmUoZW50cnkpKSB7XHJcbiAgICAgICAgLy8gSWYgd2Ugc3VjY2Vzc2Z1bGx5IHJlY29tcHV0ZWQgZW50cnkudmFsdWUgYW5kIGRpZCBub3QgZmFpbCB0b1xyXG4gICAgICAgIC8vIChyZSlzdWJzY3JpYmUsIHRoZW4gdGhpcyBFbnRyeSBpcyBubyBsb25nZXIgZXhwbGljaXRseSBkaXJ0eS5cclxuICAgICAgICBzZXRDbGVhbihlbnRyeSk7XHJcbiAgICB9XHJcbiAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBoYWQgYSBjaGFuY2UgdG8gcmUtcmVtZW1iZXIgYW55IGNoaWxkcmVuIHRoYXQgd2VyZVxyXG4gICAgLy8gaW52b2x2ZWQgaW4gdGhlIHJlY29tcHV0YXRpb24sIHdlIGNhbiBzYWZlbHkgcmVwb3J0IGFueSBvcnBoYW5cclxuICAgIC8vIGNoaWxkcmVuIHRoYXQgcmVtYWluLlxyXG4gICAgb3JpZ2luYWxDaGlsZHJlbi5mb3JFYWNoKG1heWJlUmVwb3J0T3JwaGFuKTtcclxuICAgIHJldHVybiB2YWx1ZUdldChlbnRyeS52YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVjb21wdXRlTmV3VmFsdWUoZW50cnkpIHtcclxuICAgIGVudHJ5LnJlY29tcHV0aW5nID0gdHJ1ZTtcclxuICAgIC8vIFNldCBlbnRyeS52YWx1ZSBhcyB1bmtub3duLlxyXG4gICAgZW50cnkudmFsdWUubGVuZ3RoID0gMDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gSWYgZW50cnkuZm4gc3VjY2VlZHMsIGVudHJ5LnZhbHVlIHdpbGwgYmVjb21lIGEgbm9ybWFsIFZhbHVlLlxyXG4gICAgICAgIGVudHJ5LnZhbHVlWzBdID0gZW50cnkuZm4uYXBwbHkobnVsbCwgZW50cnkuYXJncyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElmIGVudHJ5LmZuIHRocm93cywgZW50cnkudmFsdWUgd2lsbCBiZWNvbWUgZXhjZXB0aW9uYWwuXHJcbiAgICAgICAgZW50cnkudmFsdWVbMV0gPSBlO1xyXG4gICAgfVxyXG4gICAgLy8gRWl0aGVyIHdheSwgdGhpcyBsaW5lIGlzIGFsd2F5cyByZWFjaGVkLlxyXG4gICAgZW50cnkucmVjb21wdXRpbmcgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBtaWdodEJlRGlydHkoZW50cnkpIHtcclxuICAgIHJldHVybiBlbnRyeS5kaXJ0eSB8fCAhIShlbnRyeS5kaXJ0eUNoaWxkcmVuICYmIGVudHJ5LmRpcnR5Q2hpbGRyZW4uc2l6ZSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0Q2xlYW4oZW50cnkpIHtcclxuICAgIGVudHJ5LmRpcnR5ID0gZmFsc2U7XHJcbiAgICBpZiAobWlnaHRCZURpcnR5KGVudHJ5KSkge1xyXG4gICAgICAgIC8vIFRoaXMgRW50cnkgbWF5IHN0aWxsIGhhdmUgZGlydHkgY2hpbGRyZW4sIGluIHdoaWNoIGNhc2Ugd2UgY2FuJ3RcclxuICAgICAgICAvLyBsZXQgb3VyIHBhcmVudHMga25vdyB3ZSdyZSBjbGVhbiBqdXN0IHlldC5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXBvcnRDbGVhbihlbnRyeSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb3J0RGlydHkoY2hpbGQpIHtcclxuICAgIGNoaWxkLnBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7IHJldHVybiByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpOyB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvcnRDbGVhbihjaGlsZCkge1xyXG4gICAgY2hpbGQucGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHsgcmV0dXJuIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCk7IH0pO1xyXG59XHJcbi8vIExldCBhIHBhcmVudCBFbnRyeSBrbm93IHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbiBtYXkgYmUgZGlydHkuXHJcbmZ1bmN0aW9uIHJlcG9ydERpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkge1xyXG4gICAgLy8gTXVzdCBoYXZlIGNhbGxlZCByZW1lbWJlclBhcmVudChjaGlsZCkgYmVmb3JlIGNhbGxpbmdcclxuICAgIC8vIHJlcG9ydERpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkuXHJcbiAgICBhc3NlcnQocGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpO1xyXG4gICAgYXNzZXJ0KG1pZ2h0QmVEaXJ0eShjaGlsZCkpO1xyXG4gICAgaWYgKCFwYXJlbnQuZGlydHlDaGlsZHJlbikge1xyXG4gICAgICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuID0gZW1wdHlTZXRQb29sLnBvcCgpIHx8IG5ldyBTZXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJlbnQuZGlydHlDaGlsZHJlbi5oYXMoY2hpbGQpKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBrbm93IHRoaXMgY2hpbGQgaXMgZGlydHksIHRoZW4gd2UgbXVzdCBoYXZlIGFscmVhZHlcclxuICAgICAgICAvLyBpbmZvcm1lZCBvdXIgb3duIHBhcmVudHMgdGhhdCB3ZSBhcmUgZGlydHksIHNvIHdlIGNhbiB0ZXJtaW5hdGVcclxuICAgICAgICAvLyB0aGUgcmVjdXJzaW9uIGVhcmx5LlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuLmFkZChjaGlsZCk7XHJcbiAgICByZXBvcnREaXJ0eShwYXJlbnQpO1xyXG59XHJcbi8vIExldCBhIHBhcmVudCBFbnRyeSBrbm93IHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbiBpcyBubyBsb25nZXIgZGlydHkuXHJcbmZ1bmN0aW9uIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCkge1xyXG4gICAgLy8gTXVzdCBoYXZlIGNhbGxlZCByZW1lbWJlckNoaWxkKGNoaWxkKSBiZWZvcmUgY2FsbGluZ1xyXG4gICAgLy8gcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKS5cclxuICAgIGFzc2VydChwYXJlbnQuY2hpbGRWYWx1ZXMuaGFzKGNoaWxkKSk7XHJcbiAgICBhc3NlcnQoIW1pZ2h0QmVEaXJ0eShjaGlsZCkpO1xyXG4gICAgdmFyIGNoaWxkVmFsdWUgPSBwYXJlbnQuY2hpbGRWYWx1ZXMuZ2V0KGNoaWxkKTtcclxuICAgIGlmIChjaGlsZFZhbHVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5zZXQoY2hpbGQsIHZhbHVlQ29weShjaGlsZC52YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIXZhbHVlSXMoY2hpbGRWYWx1ZSwgY2hpbGQudmFsdWUpKSB7XHJcbiAgICAgICAgcGFyZW50LnNldERpcnR5KCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVEaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xyXG4gICAgaWYgKG1pZ2h0QmVEaXJ0eShwYXJlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVwb3J0Q2xlYW4ocGFyZW50KTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVEaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpIHtcclxuICAgIHZhciBkYyA9IHBhcmVudC5kaXJ0eUNoaWxkcmVuO1xyXG4gICAgaWYgKGRjKSB7XHJcbiAgICAgICAgZGMuZGVsZXRlKGNoaWxkKTtcclxuICAgICAgICBpZiAoZGMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZW1wdHlTZXRQb29sLmxlbmd0aCA8IFBPT0xfVEFSR0VUX1NJWkUpIHtcclxuICAgICAgICAgICAgICAgIGVtcHR5U2V0UG9vbC5wdXNoKGRjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQuZGlydHlDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIElmIHRoZSBnaXZlbiBlbnRyeSBoYXMgYSByZXBvcnRPcnBoYW4gbWV0aG9kLCBhbmQgbm8gcmVtYWluaW5nIHBhcmVudHMsXHJcbi8vIGNhbGwgZW50cnkucmVwb3J0T3JwaGFuIGFuZCByZXR1cm4gdHJ1ZSBpZmYgaXQgcmV0dXJucyB0cnVlLiBUaGVcclxuLy8gcmVwb3J0T3JwaGFuIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdHJ1ZSB0byBpbmRpY2F0ZSBlbnRyeS5kaXNwb3NlKClcclxuLy8gaGFzIGJlZW4gY2FsbGVkLCBhbmQgdGhlIGVudHJ5IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBhbnkgb3RoZXIgY2FjaGVzXHJcbi8vIChzZWUgaW5kZXguanMgZm9yIHRoZSBvbmx5IGN1cnJlbnQgZXhhbXBsZSkuXHJcbmZ1bmN0aW9uIG1heWJlUmVwb3J0T3JwaGFuKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gZW50cnkucGFyZW50cy5zaXplID09PSAwICYmXHJcbiAgICAgICAgdHlwZW9mIGVudHJ5LnJlcG9ydE9ycGhhbiA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgZW50cnkucmVwb3J0T3JwaGFuKCkgPT09IHRydWU7XHJcbn1cclxuLy8gUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIGVudHJ5IGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZVxyXG4vLyByZW1vdmVkIGNoaWxkcmVuLlxyXG5mdW5jdGlvbiBmb3JnZXRDaGlsZHJlbihwYXJlbnQpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IHJldXNhYmxlRW1wdHlBcnJheTtcclxuICAgIGlmIChwYXJlbnQuY2hpbGRWYWx1ZXMuc2l6ZSA+IDApIHtcclxuICAgICAgICBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChfdmFsdWUsIGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGZvcmdldENoaWxkKHBhcmVudCwgY2hpbGQpO1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEFmdGVyIHdlIGZvcmdldCBhbGwgb3VyIGNoaWxkcmVuLCB0aGlzLmRpcnR5Q2hpbGRyZW4gbXVzdCBiZSBlbXB0eVxyXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBtdXN0IGhhdmUgYmVlbiByZXNldCB0byBudWxsLlxyXG4gICAgYXNzZXJ0KHBhcmVudC5kaXJ0eUNoaWxkcmVuID09PSBudWxsKTtcclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5mdW5jdGlvbiBmb3JnZXRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XHJcbiAgICBjaGlsZC5wYXJlbnRzLmRlbGV0ZShwYXJlbnQpO1xyXG4gICAgcGFyZW50LmNoaWxkVmFsdWVzLmRlbGV0ZShjaGlsZCk7XHJcbiAgICByZW1vdmVEaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xyXG59XHJcbmZ1bmN0aW9uIG1heWJlU3Vic2NyaWJlKGVudHJ5KSB7XHJcbiAgICBpZiAodHlwZW9mIGVudHJ5LnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbWF5YmVVbnN1YnNjcmliZShlbnRyeSk7IC8vIFByZXZlbnQgZG91YmxlIHN1YnNjcmlwdGlvbnMuXHJcbiAgICAgICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gZW50cnkuc3Vic2NyaWJlLmFwcGx5KG51bGwsIGVudHJ5LmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIEVudHJ5IGhhcyBhIHN1YnNjcmliZSBmdW5jdGlvbiBhbmQgaXQgdGhyZXcgYW4gZXhjZXB0aW9uXHJcbiAgICAgICAgICAgIC8vIChvciBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiBpdCBwcmV2aW91c2x5IHJldHVybmVkIG5vdyB0aHJvd3MpLFxyXG4gICAgICAgICAgICAvLyByZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGUgdGhhdCB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHN1YnNjcmliZSAob3JcclxuICAgICAgICAgICAgLy8gdW5zdWJzY3JpYmUpLCBhbmQgdGhpcyBFbnRyeSBzaG91bGQgcmVtYWluIGRpcnR5LlxyXG4gICAgICAgICAgICBlbnRyeS5zZXREaXJ0eSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJuaW5nIHRydWUgaW5kaWNhdGVzIGVpdGhlciB0aGF0IHRoZXJlIHdhcyBubyBlbnRyeS5zdWJzY3JpYmVcclxuICAgIC8vIGZ1bmN0aW9uIG9yIHRoYXQgaXQgc3VjY2VlZGVkLlxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gbWF5YmVVbnN1YnNjcmliZShlbnRyeSkge1xyXG4gICAgdmFyIHVuc3Vic2NyaWJlID0gZW50cnkudW5zdWJzY3JpYmU7XHJcbiAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBlbnRyeS51bnN1YnNjcmliZSA9IHZvaWQgMDtcclxuICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG59XG5cbi8vIEEgdHJpZSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhvbGRzIG9iamVjdCBrZXlzIHdlYWtseSwgeWV0IGNhbiBhbHNvIGhvbGRcclxuLy8gbm9uLW9iamVjdCBrZXlzLCB1bmxpa2UgdGhlIG5hdGl2ZSBgV2Vha01hcGAuXHJcbnZhciBLZXlUcmllID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gS2V5VHJpZSh3ZWFrbmVzcykge1xyXG4gICAgICAgIHRoaXMud2Vha25lc3MgPSB3ZWFrbmVzcztcclxuICAgIH1cclxuICAgIEtleVRyaWUucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJheVtfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBBcnJheShhcnJheSk7XHJcbiAgICB9O1xyXG4gICAgS2V5VHJpZS5wcm90b3R5cGUubG9va3VwQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XHJcbiAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBub2RlID0gbm9kZS5nZXRDaGlsZFRyaWUoa2V5KTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuZGF0YSB8fCAobm9kZS5kYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XHJcbiAgICB9O1xyXG4gICAgS2V5VHJpZS5wcm90b3R5cGUuZ2V0Q2hpbGRUcmllID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLndlYWtuZXNzICYmIGlzT2JqUmVmKGtleSlcclxuICAgICAgICAgICAgPyB0aGlzLndlYWsgfHwgKHRoaXMud2VhayA9IG5ldyBXZWFrTWFwKCkpXHJcbiAgICAgICAgICAgIDogdGhpcy5zdHJvbmcgfHwgKHRoaXMuc3Ryb25nID0gbmV3IE1hcCgpKTtcclxuICAgICAgICB2YXIgY2hpbGQgPSBtYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFjaGlsZClcclxuICAgICAgICAgICAgbWFwLnNldChrZXksIGNoaWxkID0gbmV3IEtleVRyaWUodGhpcy53ZWFrbmVzcykpO1xyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gS2V5VHJpZTtcclxufSgpKTtcclxuZnVuY3Rpb24gaXNPYmpSZWYodmFsdWUpIHtcclxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XHJcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gcmV0dXJuIHRydWUuLi5cclxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLy8gVGhlIGRlZmF1bHRNYWtlQ2FjaGVLZXkgZnVuY3Rpb24gaXMgcmVtYXJrYWJseSBwb3dlcmZ1bCwgYmVjYXVzZSBpdCBnaXZlc1xyXG4vLyBhIHVuaXF1ZSBvYmplY3QgZm9yIGFueSBzaGFsbG93LWlkZW50aWNhbCBsaXN0IG9mIGFyZ3VtZW50cy4gSWYgeW91IG5lZWRcclxuLy8gdG8gaW1wbGVtZW50IGEgY3VzdG9tIG1ha2VDYWNoZUtleSBmdW5jdGlvbiwgeW91IG1heSBmaW5kIGl0IGhlbHBmdWwgdG9cclxuLy8gZGVsZWdhdGUgdGhlIGZpbmFsIHdvcmsgdG8gZGVmYXVsdE1ha2VDYWNoZUtleSwgd2hpY2ggaXMgd2h5IHdlIGV4cG9ydCBpdFxyXG4vLyBoZXJlLiBIb3dldmVyLCB5b3UgbWF5IHdhbnQgdG8gYXZvaWQgZGVmYXVsdE1ha2VDYWNoZUtleSBpZiB5b3VyIHJ1bnRpbWVcclxuLy8gZG9lcyBub3Qgc3VwcG9ydCBXZWFrTWFwLCBvciB5b3UgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXR1cm4gYSBzdHJpbmcga2V5LlxyXG4vLyBJbiB0aG9zZSBjYXNlcywganVzdCB3cml0ZSB5b3VyIG93biBjdXN0b20gbWFrZUNhY2hlS2V5IGZ1bmN0aW9ucy5cclxudmFyIGtleVRyaWUgPSBuZXcgS2V5VHJpZSh0eXBlb2YgV2Vha01hcCA9PT0gXCJmdW5jdGlvblwiKTtcclxuZnVuY3Rpb24gZGVmYXVsdE1ha2VDYWNoZUtleSgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXlUcmllLmxvb2t1cEFycmF5KGFyZ3MpO1xyXG59XHJcbnZhciBjYWNoZXMgPSBuZXcgU2V0KCk7XHJcbmZ1bmN0aW9uIHdyYXAob3JpZ2luYWxGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxyXG4gICAgdmFyIGNhY2hlID0gbmV3IENhY2hlKG9wdGlvbnMubWF4IHx8IE1hdGgucG93KDIsIDE2KSwgZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5kaXNwb3NlKCk7IH0pO1xyXG4gICAgdmFyIGRpc3Bvc2FibGUgPSAhIW9wdGlvbnMuZGlzcG9zYWJsZTtcclxuICAgIHZhciBtYWtlQ2FjaGVLZXkgPSBvcHRpb25zLm1ha2VDYWNoZUtleSB8fCBkZWZhdWx0TWFrZUNhY2hlS2V5O1xyXG4gICAgZnVuY3Rpb24gb3B0aW1pc3RpYygpIHtcclxuICAgICAgICBpZiAoZGlzcG9zYWJsZSAmJiAhcGFyZW50RW50cnlTbG90Lmhhc1ZhbHVlKCkpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBjdXJyZW50IHBhcmVudCBjb21wdXRhdGlvbiwgYW5kIHRoaXMgd3JhcHBlZFxyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBpcyBkaXNwb3NhYmxlIChtZWFuaW5nIHdlIGRvbid0IGNhcmUgYWJvdXQgZW50cnkudmFsdWUsXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZGVwZW5kZW5jeSB0cmFja2luZyksIHRoZW4gd2UgY2FuIHNob3J0LWN1dCBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgLy8gaW4gdGhpcyBmdW5jdGlvbiwgYmVjYXVzZSBlbnRyeS5yZWNvbXB1dGUoKSBpcyBnb2luZyB0byByZWN5Y2xlXHJcbiAgICAgICAgICAgIC8vIHRoZSBlbnRyeSBvYmplY3Qgd2l0aG91dCByZWNvbXB1dGluZyBhbnl0aGluZywgYW55d2F5LlxyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5ID0gbWFrZUNhY2hlS2V5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgZW50cnkuYXJncyA9IGFyZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbnRyeSA9IG5ldyBFbnRyeShvcmlnaW5hbEZ1bmN0aW9uLCBhcmdzKTtcclxuICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgZW50cnkpO1xyXG4gICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmUgPSBvcHRpb25zLnN1YnNjcmliZTtcclxuICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGUpIHtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnJlcG9ydE9ycGhhbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlLmRlbGV0ZShrZXkpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5LnJlY29tcHV0ZSgpO1xyXG4gICAgICAgIC8vIE1vdmUgdGhpcyBlbnRyeSB0byB0aGUgZnJvbnQgb2YgdGhlIGxlYXN0LXJlY2VudGx5IHVzZWQgcXVldWUsXHJcbiAgICAgICAgLy8gc2luY2Ugd2UganVzdCBmaW5pc2hlZCBjb21wdXRpbmcgaXRzIHZhbHVlLlxyXG4gICAgICAgIGNhY2hlLnNldChrZXksIGVudHJ5KTtcclxuICAgICAgICBjYWNoZXMuYWRkKGNhY2hlKTtcclxuICAgICAgICAvLyBDbGVhbiB1cCBhbnkgZXhjZXNzIGVudHJpZXMgaW4gdGhlIGNhY2hlLCBidXQgb25seSBpZiB0aGVyZSBpcyBub1xyXG4gICAgICAgIC8vIGFjdGl2ZSBwYXJlbnQgZW50cnksIG1lYW5pbmcgd2UncmUgbm90IGluIHRoZSBtaWRkbGUgb2YgYSBsYXJnZXJcclxuICAgICAgICAvLyBjb21wdXRhdGlvbiB0aGF0IG1pZ2h0IGJlIGZsdW1tb3hlZCBieSB0aGUgY2xlYW5pbmcuXHJcbiAgICAgICAgaWYgKCFwYXJlbnRFbnRyeVNsb3QuaGFzVmFsdWUoKSkge1xyXG4gICAgICAgICAgICBjYWNoZXMuZm9yRWFjaChmdW5jdGlvbiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlLmNsZWFuKCk7IH0pO1xyXG4gICAgICAgICAgICBjYWNoZXMuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgb3B0aW9ucy5kaXNwb3NhYmxlIGlzIHRydXRoeSwgdGhlIGNhbGxlciBvZiB3cmFwIGlzIHRlbGxpbmcgdXNcclxuICAgICAgICAvLyB0aGV5IGRvbid0IGNhcmUgYWJvdXQgdGhlIHJlc3VsdCBvZiBlbnRyeS5yZWNvbXB1dGUoKSwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgLy8gYXZvaWQgcmV0dXJuaW5nIHRoZSB2YWx1ZSwgc28gaXQgd29uJ3QgYmUgYWNjaWRlbnRhbGx5IHVzZWQuXHJcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGUgPyB2b2lkIDAgOiB2YWx1ZTtcclxuICAgIH1cclxuICAgIG9wdGltaXN0aWMuZGlydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGtleSAhPT0gdm9pZCAwICYmIGNhY2hlLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZC5zZXREaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gb3B0aW1pc3RpYztcclxufVxuXG5leHBvcnQgeyBLZXlUcmllLCBkZWZhdWx0TWFrZUNhY2hlS2V5LCB3cmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbkNsaWVudCA9IHZvaWQgMDtcbnZhciBfZ2xvYmFsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fSk7XG52YXIgTmF0aXZlV2ViU29ja2V0ID0gX2dsb2JhbC5XZWJTb2NrZXQgfHwgX2dsb2JhbC5Nb3pXZWJTb2NrZXQ7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoXCJiYWNrbzJcIik7XG52YXIgZXZlbnRlbWl0dGVyM18xID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG52YXIgaXNfc3RyaW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9pcy1zdHJpbmdcIik7XG52YXIgaXNfb2JqZWN0XzEgPSByZXF1aXJlKFwiLi91dGlscy9pcy1vYmplY3RcIik7XG52YXIgcHJpbnRlcl8xID0gcmVxdWlyZShcImdyYXBocWwvbGFuZ3VhZ2UvcHJpbnRlclwiKTtcbnZhciBnZXRPcGVyYXRpb25BU1RfMSA9IHJlcXVpcmUoXCJncmFwaHFsL3V0aWxpdGllcy9nZXRPcGVyYXRpb25BU1RcIik7XG52YXIgc3ltYm9sX29ic2VydmFibGVfMSA9IHJlcXVpcmUoXCJzeW1ib2wtb2JzZXJ2YWJsZVwiKTtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4vcHJvdG9jb2xcIik7XG52YXIgZGVmYXVsdHNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xudmFyIG1lc3NhZ2VfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2UtdHlwZXNcIik7XG52YXIgU3Vic2NyaXB0aW9uQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25DbGllbnQodXJsLCBvcHRpb25zLCB3ZWJTb2NrZXRJbXBsLCB3ZWJTb2NrZXRQcm90b2NvbHMpIHtcbiAgICAgICAgdmFyIF9hID0gKG9wdGlvbnMgfHwge30pLCBfYiA9IF9hLmNvbm5lY3Rpb25DYWxsYmFjaywgY29ubmVjdGlvbkNhbGxiYWNrID0gX2IgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9iLCBfYyA9IF9hLmNvbm5lY3Rpb25QYXJhbXMsIGNvbm5lY3Rpb25QYXJhbXMgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYywgX2QgPSBfYS5taW5UaW1lb3V0LCBtaW5UaW1lb3V0ID0gX2QgPT09IHZvaWQgMCA/IGRlZmF1bHRzXzEuTUlOX1dTX1RJTUVPVVQgOiBfZCwgX2UgPSBfYS50aW1lb3V0LCB0aW1lb3V0ID0gX2UgPT09IHZvaWQgMCA/IGRlZmF1bHRzXzEuV1NfVElNRU9VVCA6IF9lLCBfZiA9IF9hLnJlY29ubmVjdCwgcmVjb25uZWN0ID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2YsIF9nID0gX2EucmVjb25uZWN0aW9uQXR0ZW1wdHMsIHJlY29ubmVjdGlvbkF0dGVtcHRzID0gX2cgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2csIF9oID0gX2EubGF6eSwgbGF6eSA9IF9oID09PSB2b2lkIDAgPyBmYWxzZSA6IF9oLCBfaiA9IF9hLmluYWN0aXZpdHlUaW1lb3V0LCBpbmFjdGl2aXR5VGltZW91dCA9IF9qID09PSB2b2lkIDAgPyAwIDogX2osIF9rID0gX2Eud3NPcHRpb25Bcmd1bWVudHMsIHdzT3B0aW9uQXJndW1lbnRzID0gX2sgPT09IHZvaWQgMCA/IFtdIDogX2s7XG4gICAgICAgIHRoaXMud3NJbXBsID0gd2ViU29ja2V0SW1wbCB8fCBOYXRpdmVXZWJTb2NrZXQ7XG4gICAgICAgIGlmICghdGhpcy53c0ltcGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBvciBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgV2ViU29ja2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3NQcm90b2NvbHMgPSB3ZWJTb2NrZXRQcm90b2NvbHMgfHwgcHJvdG9jb2xfMS5HUkFQSFFMX1dTO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25DYWxsYmFjayA9IGNvbm5lY3Rpb25DYWxsYmFjaztcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLm5leHRPcGVyYXRpb25JZCA9IDA7XG4gICAgICAgIHRoaXMubWluV3NUaW1lb3V0ID0gbWluVGltZW91dDtcbiAgICAgICAgdGhpcy53c1RpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnVuc2VudE1lc3NhZ2VzUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3Q7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSByZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgICAgICAgdGhpcy5sYXp5ID0gISFsYXp5O1xuICAgICAgICB0aGlzLmluYWN0aXZpdHlUaW1lb3V0ID0gaW5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuY2xvc2VkQnlVc2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHsgaml0dGVyOiAwLjUgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IGV2ZW50ZW1pdHRlcjNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmNsaWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubWF4Q29ubmVjdFRpbWVHZW5lcmF0b3IgPSB0aGlzLmNyZWF0ZU1heENvbm5lY3RUaW1lR2VuZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBhcmFtcyA9IHRoaXMuZ2V0Q29ubmVjdGlvblBhcmFtcyhjb25uZWN0aW9uUGFyYW1zKTtcbiAgICAgICAgdGhpcy53c09wdGlvbkFyZ3VtZW50cyA9IHdzT3B0aW9uQXJndW1lbnRzO1xuICAgICAgICBpZiAoIXRoaXMubGF6eSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53c0ltcGwuQ0xPU0VEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlYWR5U3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGlzRm9yY2VkLCBjbG9zZWRCeVVzZXIpIHtcbiAgICAgICAgaWYgKGlzRm9yY2VkID09PSB2b2lkIDApIHsgaXNGb3JjZWQgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjbG9zZWRCeVVzZXIgPT09IHZvaWQgMCkgeyBjbG9zZWRCeVVzZXIgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuY2xlYXJJbmFjdGl2aXR5VGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5jbGllbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkQnlVc2VyID0gY2xvc2VkQnlVc2VyO1xuICAgICAgICAgICAgaWYgKGlzRm9yY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckNoZWNrQ29ubmVjdGlvbkludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhck1heENvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRyeVJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQWxsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh1bmRlZmluZWQsIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9DT05ORUNUSU9OX1RFUk1JTkFURSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQub25vcGVuID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50Lm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICBpZiAoIWlzRm9yY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlSZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgZ2V0T2JzZXJ2ZXIgPSB0aGlzLmdldE9ic2VydmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZhciBleGVjdXRlT3BlcmF0aW9uID0gdGhpcy5leGVjdXRlT3BlcmF0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIG9wSWQ7XG4gICAgICAgIHRoaXMuY2xlYXJJbmFjdGl2aXR5VGltZW91dCgpO1xuICAgICAgICByZXR1cm4gX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW3N5bWJvbF9vYnNlcnZhYmxlXzEuZGVmYXVsdF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Euc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gZ2V0T2JzZXJ2ZXIob2JzZXJ2ZXJPck5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIG9wSWQgPSBleGVjdXRlT3BlcmF0aW9uKHJlcXVlc3QsIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUob3BJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRFbWl0dGVyLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGFuZGxlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLm9uQ29ubmVjdGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKCdjb25uZWN0ZWQnLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLm9uQ29ubmVjdGluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbignY29ubmVjdGluZycsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUub25EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oJ2Rpc2Nvbm5lY3RlZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUub25SZWNvbm5lY3RlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbigncmVjb25uZWN0ZWQnLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLm9uUmVjb25uZWN0aW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKCdyZWNvbm5lY3RpbmcnLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oJ2Vycm9yJywgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS51bnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5vcGVyYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJJZCkge1xuICAgICAgICAgICAgX3RoaXMudW5zdWJzY3JpYmUoc3ViSWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUuYXBwbHlNaWRkbGV3YXJlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBmdW5jdGlvbiAoZnVuY3MsIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5hcHBseU1pZGRsZXdhcmUuYXBwbHkoc2NvcGUsIFtvcHRpb25zLCBuZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHF1ZXVlKF9fc3ByZWFkQXJyYXlzKF90aGlzLm1pZGRsZXdhcmVzKSwgX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKG1pZGRsZXdhcmVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlLmFwcGx5TWlkZGxld2FyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF90aGlzLm1pZGRsZXdhcmVzLnB1c2gobWlkZGxld2FyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pZGRsZXdhcmUgbXVzdCBpbXBsZW1lbnQgdGhlIGFwcGx5TWlkZGxld2FyZSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29ubmVjdGlvblBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGNvbm5lY3Rpb25QYXJhbXMuY2FsbChudWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb25QYXJhbXMpO1xuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUuZXhlY3V0ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wSWQgPSB0aGlzLmdlbmVyYXRlT3BlcmF0aW9uSWQoKTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zW29wSWRdID0geyBvcHRpb25zOiBvcHRpb25zLCBoYW5kbGVyOiBoYW5kbGVyIH07XG4gICAgICAgIHRoaXMuYXBwbHlNaWRkbGV3YXJlcyhvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByb2Nlc3NlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIF90aGlzLmNoZWNrT3BlcmF0aW9uT3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcGVyYXRpb25zW29wSWRdKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub3BlcmF0aW9uc1tvcElkXSA9IHsgb3B0aW9uczogcHJvY2Vzc2VkT3B0aW9ucywgaGFuZGxlcjogaGFuZGxlciB9O1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRNZXNzYWdlKG9wSWQsIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9TVEFSVCwgcHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy51bnN1YnNjcmliZShvcElkKTtcbiAgICAgICAgICAgIGhhbmRsZXIoX3RoaXMuZm9ybWF0RXJyb3JzKGVycm9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3BJZDtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUuZ2V0T2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyT3JOZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2KSB7IHJldHVybiBvYnNlcnZlck9yTmV4dCh2KTsgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVycm9yICYmIGVycm9yKGUpOyB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSAmJiBjb21wbGV0ZSgpOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JzZXJ2ZXJPck5leHQ7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLmNyZWF0ZU1heENvbm5lY3RUaW1lR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWluVmFsdWUgPSB0aGlzLm1pbldzVGltZW91dDtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gdGhpcy53c1RpbWVvdXQ7XG4gICAgICAgIHJldHVybiBuZXcgQmFja29mZih7XG4gICAgICAgICAgICBtaW46IG1pblZhbHVlLFxuICAgICAgICAgICAgbWF4OiBtYXhWYWx1ZSxcbiAgICAgICAgICAgIGZhY3RvcjogMS4yLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUuY2xlYXJDaGVja0Nvbm5lY3Rpb25JbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDb25uZWN0aW9uSW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNoZWNrQ29ubmVjdGlvbkludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb25JbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5jbGVhck1heENvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tYXhDb25uZWN0VGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMubWF4Q29ubmVjdFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUuY2xlYXJUcnlSZWNvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50cnlSZWNvbm5lY3RUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyeVJlY29ubmVjdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRyeVJlY29ubmVjdFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUuY2xlYXJJbmFjdGl2aXR5VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5hY3Rpdml0eVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaW5hY3Rpdml0eVRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmluYWN0aXZpdHlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLnNldEluYWN0aXZpdHlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pbmFjdGl2aXR5VGltZW91dCA+IDAgJiYgT2JqZWN0LmtleXModGhpcy5vcGVyYXRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5hY3Rpdml0eVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhfdGhpcy5vcGVyYXRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLmluYWN0aXZpdHlUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5jaGVja09wZXJhdGlvbk9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywgaGFuZGxlcikge1xuICAgICAgICB2YXIgcXVlcnkgPSBvcHRpb25zLnF1ZXJ5LCB2YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcywgb3BlcmF0aW9uTmFtZSA9IG9wdGlvbnMub3BlcmF0aW9uTmFtZTtcbiAgICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBxdWVyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFuIGhhbmRsZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghaXNfc3RyaW5nXzEuZGVmYXVsdChxdWVyeSkgJiYgIWdldE9wZXJhdGlvbkFTVF8xLmdldE9wZXJhdGlvbkFTVChxdWVyeSwgb3BlcmF0aW9uTmFtZSkpIHx8XG4gICAgICAgICAgICAob3BlcmF0aW9uTmFtZSAmJiAhaXNfc3RyaW5nXzEuZGVmYXVsdChvcGVyYXRpb25OYW1lKSkgfHxcbiAgICAgICAgICAgICh2YXJpYWJsZXMgJiYgIWlzX29iamVjdF8xLmRlZmF1bHQodmFyaWFibGVzKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG9wdGlvbiB0eXBlcy4gcXVlcnkgbXVzdCBiZSBhIHN0cmluZyBvciBhIGRvY3VtZW50LCcgK1xuICAgICAgICAgICAgICAgICdgb3BlcmF0aW9uTmFtZWAgbXVzdCBiZSBhIHN0cmluZywgYW5kIGB2YXJpYWJsZXNgIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLmJ1aWxkTWVzc2FnZSA9IGZ1bmN0aW9uIChpZCwgdHlwZSwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgcGF5bG9hZFRvUmV0dXJuID0gcGF5bG9hZCAmJiBwYXlsb2FkLnF1ZXJ5ID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHBheWxvYWQpLCB7IHF1ZXJ5OiB0eXBlb2YgcGF5bG9hZC5xdWVyeSA9PT0gJ3N0cmluZycgPyBwYXlsb2FkLnF1ZXJ5IDogcHJpbnRlcl8xLnByaW50KHBheWxvYWQucXVlcnkpIH0pIDpcbiAgICAgICAgICAgIHBheWxvYWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFRvUmV0dXJuLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5mb3JtYXRFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9ycykpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuZXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRFcnJvcnMoZXJyb3JzLmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycyAmJiBlcnJvcnMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtlcnJvcnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdGb3JtYXRlZEVycm9yJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JzLFxuICAgICAgICAgICAgfV07XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKGlkLCB0eXBlLCBwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VSYXcodGhpcy5idWlsZE1lc3NhZ2UoaWQsIHR5cGUsIHBheWxvYWQpKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkNsaWVudC5wcm90b3R5cGUuc2VuZE1lc3NhZ2VSYXcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMud3NJbXBsLk9QRU46XG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKFwiTWVzc2FnZSBtdXN0IGJlIEpTT04tc2VyaWFsaXphYmxlLiBHb3Q6IFwiICsgbWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5zZW5kKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy53c0ltcGwuQ09OTkVDVElORzpcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VudE1lc3NhZ2VzUXVldWUucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQSBtZXNzYWdlIHdhcyBub3Qgc2VudCBiZWNhdXNlIHNvY2tldCBpcyBub3QgY29ubmVjdGVkLCBpcyBjbG9zaW5nIG9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2lzIGFscmVhZHkgY2xvc2VkLiBNZXNzYWdlIHdhczogJyArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLmdlbmVyYXRlT3BlcmF0aW9uSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoKyt0aGlzLm5leHRPcGVyYXRpb25JZCk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLnRyeVJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnJlY29ubmVjdCB8fCB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMub3BlcmF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudW5zZW50TWVzc2FnZXNRdWV1ZS5wdXNoKF90aGlzLmJ1aWxkTWVzc2FnZShrZXksIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9TVEFSVCwgX3RoaXMub3BlcmF0aW9uc1trZXldLm9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJUcnlSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgICAgICB0aGlzLnRyeVJlY29ubmVjdFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLmZsdXNoVW5zZW50TWVzc2FnZXNRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51bnNlbnRNZXNzYWdlc1F1ZXVlLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzLnNlbmRNZXNzYWdlUmF3KG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnNlbnRNZXNzYWdlc1F1ZXVlID0gW107XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25DbGllbnQucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMud2FzS2VlcEFsaXZlUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2FzS2VlcEFsaXZlUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5jaGVja01heENvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyTWF4Q29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5tYXhDb25uZWN0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzICE9PSBfdGhpcy53c0ltcGwuT1BFTikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLm1heENvbm5lY3RUaW1lR2VuZXJhdG9yLmR1cmF0aW9uKCkpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3ICgoX2EgPSB0aGlzLndzSW1wbCkuYmluZC5hcHBseShfYSwgX19zcHJlYWRBcnJheXMoW3ZvaWQgMCwgdGhpcy51cmwsIHRoaXMud3NQcm90b2NvbHNdLCB0aGlzLndzT3B0aW9uQXJndW1lbnRzKSkpKCk7XG4gICAgICAgIHRoaXMuY2hlY2tNYXhDb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmNsaWVudC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvblBhcmFtcywgZXJyb3JfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuc3RhdHVzID09PSB0aGlzLndzSW1wbC5PUEVOKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJNYXhDb25uZWN0VGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZWRCeVVzZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQodGhpcy5yZWNvbm5lY3RpbmcgPyAncmVjb25uZWN0aW5nJyA6ICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuY29ubmVjdGlvblBhcmFtcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblBhcmFtcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UodW5kZWZpbmVkLCBtZXNzYWdlX3R5cGVzXzEuZGVmYXVsdC5HUUxfQ09OTkVDVElPTl9JTklULCBjb25uZWN0aW9uUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hVbnNlbnRNZXNzYWdlc1F1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh1bmRlZmluZWQsIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9DT05ORUNUSU9OX0VSUk9SLCBlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hVbnNlbnRNZXNzYWdlc1F1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgICAgICB0aGlzLmNsaWVudC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5jbG9zZWRCeVVzZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZShmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsaWVudC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnQub25tZXNzYWdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XG4gICAgICAgICAgICBfdGhpcy5wcm9jZXNzUmVjZWl2ZWREYXRhKGRhdGEpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS5wcm9jZXNzUmVjZWl2ZWREYXRhID0gZnVuY3Rpb24gKHJlY2VpdmVkRGF0YSkge1xuICAgICAgICB2YXIgcGFyc2VkTWVzc2FnZTtcbiAgICAgICAgdmFyIG9wSWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZWRNZXNzYWdlID0gSlNPTi5wYXJzZShyZWNlaXZlZERhdGEpO1xuICAgICAgICAgICAgb3BJZCA9IHBhcnNlZE1lc3NhZ2UuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgbXVzdCBiZSBKU09OLXBhcnNlYWJsZS4gR290OiBcIiArIHJlY2VpdmVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFttZXNzYWdlX3R5cGVzXzEuZGVmYXVsdC5HUUxfREFUQSxcbiAgICAgICAgICAgIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9DT01QTEVURSxcbiAgICAgICAgICAgIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9FUlJPUixcbiAgICAgICAgXS5pbmRleE9mKHBhcnNlZE1lc3NhZ2UudHlwZSkgIT09IC0xICYmICF0aGlzLm9wZXJhdGlvbnNbb3BJZF0pIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUob3BJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwYXJzZWRNZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZV90eXBlc18xLmRlZmF1bHQuR1FMX0NPTk5FQ1RJT05fRVJST1I6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrKHBhcnNlZE1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlX3R5cGVzXzEuZGVmYXVsdC5HUUxfQ09OTkVDVElPTl9BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCh0aGlzLnJlY29ubmVjdGluZyA/ICdyZWNvbm5lY3RlZCcgOiAnY29ubmVjdGVkJywgcGFyc2VkTWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4Q29ubmVjdFRpbWVHZW5lcmF0b3IucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9DT01QTEVURTpcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMub3BlcmF0aW9uc1tvcElkXS5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wZXJhdGlvbnNbb3BJZF07XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlX3R5cGVzXzEuZGVmYXVsdC5HUUxfRVJST1I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25zW29wSWRdLmhhbmRsZXIodGhpcy5mb3JtYXRFcnJvcnMocGFyc2VkTWVzc2FnZS5wYXlsb2FkKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3BlcmF0aW9uc1tvcElkXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZV90eXBlc18xLmRlZmF1bHQuR1FMX0RBVEE6XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZFBheWxvYWQgPSAhcGFyc2VkTWVzc2FnZS5wYXlsb2FkLmVycm9ycyA/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZE1lc3NhZ2UucGF5bG9hZCA6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJzZWRNZXNzYWdlLnBheWxvYWQpLCB7IGVycm9yczogdGhpcy5mb3JtYXRFcnJvcnMocGFyc2VkTWVzc2FnZS5wYXlsb2FkLmVycm9ycykgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25zW29wSWRdLmhhbmRsZXIobnVsbCwgcGFyc2VkUGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9DT05ORUNUSU9OX0tFRVBfQUxJVkU6XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0S0EgPSB0eXBlb2YgdGhpcy53YXNLZWVwQWxpdmVSZWNlaXZlZCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICAgICAgdGhpcy53YXNLZWVwQWxpdmVSZWNlaXZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0S0EpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tDb25uZWN0aW9uSW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2hlY2tDb25uZWN0aW9uSW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tDb25uZWN0aW9uLmJpbmQodGhpcyksIHRoaXMud3NUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2UgdHlwZSEnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uQ2xpZW50LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvcElkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbnNbb3BJZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wZXJhdGlvbnNbb3BJZF07XG4gICAgICAgICAgICB0aGlzLnNldEluYWN0aXZpdHlUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG9wSWQsIG1lc3NhZ2VfdHlwZXNfMS5kZWZhdWx0LkdRTF9TVE9QLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uQ2xpZW50O1xufSgpKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uQ2xpZW50ID0gU3Vic2NyaXB0aW9uQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XU19USU1FT1VUID0gZXhwb3J0cy5NSU5fV1NfVElNRU9VVCA9IHZvaWQgMDtcbnZhciBNSU5fV1NfVElNRU9VVCA9IDEwMDA7XG5leHBvcnRzLk1JTl9XU19USU1FT1VUID0gTUlOX1dTX1RJTUVPVVQ7XG52YXIgV1NfVElNRU9VVCA9IDMwMDAwO1xuZXhwb3J0cy5XU19USU1FT1VUID0gV1NfVElNRU9VVDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1lc3NhZ2VUeXBlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVR5cGVzKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRpYyBDbGFzcycpO1xuICAgIH1cbiAgICBNZXNzYWdlVHlwZXMuR1FMX0NPTk5FQ1RJT05fSU5JVCA9ICdjb25uZWN0aW9uX2luaXQnO1xuICAgIE1lc3NhZ2VUeXBlcy5HUUxfQ09OTkVDVElPTl9BQ0sgPSAnY29ubmVjdGlvbl9hY2snO1xuICAgIE1lc3NhZ2VUeXBlcy5HUUxfQ09OTkVDVElPTl9FUlJPUiA9ICdjb25uZWN0aW9uX2Vycm9yJztcbiAgICBNZXNzYWdlVHlwZXMuR1FMX0NPTk5FQ1RJT05fS0VFUF9BTElWRSA9ICdrYSc7XG4gICAgTWVzc2FnZVR5cGVzLkdRTF9DT05ORUNUSU9OX1RFUk1JTkFURSA9ICdjb25uZWN0aW9uX3Rlcm1pbmF0ZSc7XG4gICAgTWVzc2FnZVR5cGVzLkdRTF9TVEFSVCA9ICdzdGFydCc7XG4gICAgTWVzc2FnZVR5cGVzLkdRTF9EQVRBID0gJ2RhdGEnO1xuICAgIE1lc3NhZ2VUeXBlcy5HUUxfRVJST1IgPSAnZXJyb3InO1xuICAgIE1lc3NhZ2VUeXBlcy5HUUxfQ09NUExFVEUgPSAnY29tcGxldGUnO1xuICAgIE1lc3NhZ2VUeXBlcy5HUUxfU1RPUCA9ICdzdG9wJztcbiAgICBNZXNzYWdlVHlwZXMuU1VCU0NSSVBUSU9OX1NUQVJUID0gJ3N1YnNjcmlwdGlvbl9zdGFydCc7XG4gICAgTWVzc2FnZVR5cGVzLlNVQlNDUklQVElPTl9EQVRBID0gJ3N1YnNjcmlwdGlvbl9kYXRhJztcbiAgICBNZXNzYWdlVHlwZXMuU1VCU0NSSVBUSU9OX1NVQ0NFU1MgPSAnc3Vic2NyaXB0aW9uX3N1Y2Nlc3MnO1xuICAgIE1lc3NhZ2VUeXBlcy5TVUJTQ1JJUFRJT05fRkFJTCA9ICdzdWJzY3JpcHRpb25fZmFpbCc7XG4gICAgTWVzc2FnZVR5cGVzLlNVQlNDUklQVElPTl9FTkQgPSAnc3Vic2NyaXB0aW9uX2VuZCc7XG4gICAgTWVzc2FnZVR5cGVzLklOSVQgPSAnaW5pdCc7XG4gICAgTWVzc2FnZVR5cGVzLklOSVRfU1VDQ0VTUyA9ICdpbml0X3N1Y2Nlc3MnO1xuICAgIE1lc3NhZ2VUeXBlcy5JTklUX0ZBSUwgPSAnaW5pdF9mYWlsJztcbiAgICBNZXNzYWdlVHlwZXMuS0VFUF9BTElWRSA9ICdrZWVwYWxpdmUnO1xuICAgIHJldHVybiBNZXNzYWdlVHlwZXM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZVR5cGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZS10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR1JBUEhRTF9TVUJTQ1JJUFRJT05TID0gZXhwb3J0cy5HUkFQSFFMX1dTID0gdm9pZCAwO1xudmFyIEdSQVBIUUxfV1MgPSAnZ3JhcGhxbC13cyc7XG5leHBvcnRzLkdSQVBIUUxfV1MgPSBHUkFQSFFMX1dTO1xudmFyIEdSQVBIUUxfU1VCU0NSSVBUSU9OUyA9ICdncmFwaHFsLXN1YnNjcmlwdGlvbnMnO1xuZXhwb3J0cy5HUkFQSFFMX1NVQlNDUklQVElPTlMgPSBHUkFQSFFMX1NVQlNDUklQVElPTlM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm90b2NvbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICgodmFsdWUgIT09IG51bGwpICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBpc1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXN0cmluZy5qcy5tYXAiLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbC5qcyc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVE9OQ2xpZW50ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX29wZW50cmFjaW5nID0gcmVxdWlyZShcIm9wZW50cmFjaW5nXCIpO1xuXG52YXIgX1RPTkNvbmZpZ01vZHVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kdWxlcy9UT05Db25maWdNb2R1bGVcIikpO1xuXG52YXIgX1RPTkNvbnRyYWN0c01vZHVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kdWxlcy9UT05Db250cmFjdHNNb2R1bGVcIikpO1xuXG52YXIgX1RPTkNyeXB0b01vZHVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kdWxlcy9UT05DcnlwdG9Nb2R1bGVcIikpO1xuXG52YXIgX1RPTlF1ZXJpZXNNb2R1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21vZHVsZXMvVE9OUXVlcmllc01vZHVsZVwiKSk7XG5cbnZhciBfVE9OTW9kdWxlID0gcmVxdWlyZShcIi4vVE9OTW9kdWxlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBNYWluIG9iamVjdCBwcm92aWRlZCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBUT04gQ2xpZW50IExpYnJhcnlcbiAqIEVhY2ggaW5zdGFuY2Ugb2YgVE9OQ2xpZW50IGhhcyBvd24gc2V0IG9mIFRPTiBDbGllbnQgbW9kdWxlc1xuICogYW5kIGhhcyBvd24gcHJlY29uZmlndXJlZCBjbGllbnQgY29udGV4dFxuICovXG52YXIgVE9OQ2xpZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgX2NyZWF0ZUNsYXNzKFRPTkNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwic2V0TGlicmFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMaWJyYXJ5KGNsaWVudFBsYXRmb3JtKSB7XG4gICAgICBUT05DbGllbnQuY2xpZW50UGxhdGZvcm0gPSBjbGllbnRQbGF0Zm9ybTtcbiAgICB9IC8vIFB1YmxpY1xuXG4gIH1dKTtcblxuICBmdW5jdGlvbiBUT05DbGllbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRPTkNsaWVudCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNyeXB0b1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWVyaWVzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcXVlcmllc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NvbnRleHRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb3JlQnJpZGdlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2R1bGVzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLm1vZHVsZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWcgPSB0aGlzLmdldE1vZHVsZShfVE9OQ29uZmlnTW9kdWxlW1wiZGVmYXVsdFwiXSk7XG4gICAgdGhpcy5jcnlwdG8gPSB0aGlzLmdldE1vZHVsZShfVE9OQ3J5cHRvTW9kdWxlW1wiZGVmYXVsdFwiXSk7XG4gICAgdGhpcy5jb250cmFjdHMgPSB0aGlzLmdldE1vZHVsZShfVE9OQ29udHJhY3RzTW9kdWxlW1wiZGVmYXVsdFwiXSk7XG4gICAgdGhpcy5fcXVlcmllcyA9IHRoaXMuZ2V0TW9kdWxlKF9UT05RdWVyaWVzTW9kdWxlW1wiZGVmYXVsdFwiXSk7XG4gICAgdGhpcy5xdWVyaWVzID0gdGhpcy5fcXVlcmllcztcbiAgICB0aGlzLl9jb250ZXh0ID0gMDtcbiAgICB0aGlzLl9jb3JlQnJpZGdlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVudCB3YXkgdG8gY3JlYXRlIGNvbmZpZ3VyZWQgaW5zdGFuY2Ugb2YgdGhlIFRPTiBDbGllbnRcbiAgICogQHBhcmFtIHtUT05Db25maWdEYXRhfSBjb25maWdcbiAgICogQHJldHVybiB7UHJvbWlzZTxUT05DbGllbnQ+fVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhUT05DbGllbnQsIFt7XG4gICAga2V5OiBcInNldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgdGhlIGNsaWVudCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0dXAgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgbW9kdWxlcywgX2l0ZXJhdG9yLCBfc3RlcCwgbW9kdWxlO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29yZUJyaWRnZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBtb2R1bGVzID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMubW9kdWxlcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobW9kdWxlcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDQ7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuc2V0dXAoKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE0O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg0KTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5lKF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNztcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDE3KTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbNCwgMTQsIDE3LCAyMF1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAgIHJldHVybiBfc2V0dXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldHVwO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFRlYXIgZG93biB0aGlzIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgKiBOb3RlIHRoYXQgYWZ0ZXIgeW91IGhhdmUgY2FsbGVkIHRoaXMgbWV0aG9kIGFsbCBmdXR1cmUgdXNlIG9mIHRoaXMgaW5zdGFuY2Ugd2lsbCBmYWlsXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2xvc2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIGxpYnJhcnksIGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyaWVzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGxpYnJhcnkgPSBUT05DbGllbnQuY29yZUxpYnJhcnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9jb250ZXh0ID4gMCAmJiBsaWJyYXJ5ICE9PSBudWxsICYmIGxpYnJhcnkgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvcmVCcmlkZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaWJyYXJ5LmNvcmVEZXN0cm95Q29udGV4dChjb250ZXh0LCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKSAvLyBUT05Nb2R1bGVDb250ZXh0XG5cbiAgfSwge1xuICAgIGtleTogXCJjb21wbGV0ZUVycm9yRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NvbXBsZXRlRXJyb3JEYXRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoZGF0YSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfb2JqZWN0U3ByZWFkO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MSA9IF9vYmplY3RTcHJlYWQoe30sIGRhdGEpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MiA9IHt9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZ2V0VmVyc2lvbigpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDQgPSB0aGlzLmNvbmZpZy5nZXRDb25maWdTZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDUgPSB0aGlzLl9xdWVyaWVzLmdldFF1ZXJ5VXJsKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLnQ2ID0ge1xuICAgICAgICAgICAgICAgICAgY29yZV92ZXJzaW9uOiBfY29udGV4dDMudDMsXG4gICAgICAgICAgICAgICAgICBjb25maWdfc2VydmVyOiBfY29udGV4dDMudDQsXG4gICAgICAgICAgICAgICAgICBxdWVyeV91cmw6IF9jb250ZXh0My50NVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9jb250ZXh0My50MCkoX2NvbnRleHQzLnQxLCBfY29udGV4dDMudDIsIF9jb250ZXh0My50NikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY29tcGxldGVFcnJvckRhdGEoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9jb21wbGV0ZUVycm9yRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcGxldGVFcnJvckRhdGE7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwidHJ5Q3JlYXRlTGlicmFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RyeUNyZWF0ZUxpYnJhcnkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybSA9IFRPTkNsaWVudC5jbGllbnRQbGF0Zm9ybTtcblxuICAgICAgICAgICAgICAgIGlmICghKHBsYXRmb3JtID09PSBudWxsIHx8IHBsYXRmb3JtID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiBwbGF0Zm9ybS5jcmVhdGVMaWJyYXJ5KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIFRPTkNsaWVudC5jb3JlTGlicmFyeSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIFRPTkNsaWVudC5jb3JlTGlicmFyeSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHRyeUNyZWF0ZUxpYnJhcnkoKSB7XG4gICAgICAgIHJldHVybiBfdHJ5Q3JlYXRlTGlicmFyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ5Q3JlYXRlTGlicmFyeTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJ0cnlDcmVhdGVDb3JlQnJpZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdHJ5Q3JlYXRlQ29yZUJyaWRnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBsaWJyYXJ5O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBUT05DbGllbnQuY29yZUxpYnJhcnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2NvbnRleHQ1LnQwKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ5Q3JlYXRlTGlicmFyeSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgbGlicmFyeSA9IF9jb250ZXh0NS50MDtcblxuICAgICAgICAgICAgICAgIGlmIChsaWJyYXJ5KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaWYgKCFsaWJyYXJ5LmNvcmVDcmVhdGVDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaWJyYXJ5LmNvcmVDcmVhdGVDb250ZXh0KHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvcmVCcmlkZ2UgPSB7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiByZXF1ZXN0KG1ldGhvZCwgcGFyYW1zSnNvbiwgb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRPTkNsaWVudC5jb3JlTGlicmFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgIFRPTkNsaWVudC5jb3JlTGlicmFyeS5jb3JlUmVxdWVzdChfdGhpcy5fY29udGV4dCwgbWV0aG9kLCBwYXJhbXNKc29uLCBvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3JlQnJpZGdlID0gbGlicmFyeTtcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHRyeUNyZWF0ZUNvcmVCcmlkZ2UoKSB7XG4gICAgICAgIHJldHVybiBfdHJ5Q3JlYXRlQ29yZUJyaWRnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ5Q3JlYXRlQ29yZUJyaWRnZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRDb3JlQnJpZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0Q29yZUJyaWRnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29yZUJyaWRnZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyeUNyZWF0ZUNvcmVCcmlkZ2UoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fY29yZUJyaWRnZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldENvcmVCcmlkZ2UoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0Q29yZUJyaWRnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0Q29yZUJyaWRnZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kdWxlKE1vZHVsZUNsYXNzKSB7XG4gICAgICB2YXIgbmFtZSA9IE1vZHVsZUNsYXNzLm1vZHVsZU5hbWU7XG4gICAgICB2YXIgZXhpc3RpbmdNb2R1bGUgPSB0aGlzLm1vZHVsZXMuZ2V0KG5hbWUpO1xuXG4gICAgICBpZiAoZXhpc3RpbmdNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nTW9kdWxlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kdWxlID0gbmV3IE1vZHVsZUNsYXNzKHRoaXMpO1xuICAgICAgdGhpcy5tb2R1bGVzLnNldChuYW1lLCBtb2R1bGUpO1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VydmVyVGltZURlbHRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcnZlclRpbWVEZWx0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWVyaWVzLnNlcnZlclRpbWVEZWx0YSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJ2ZXJOb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VydmVyTm93KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJpZXMuc2VydmVyTm93KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hbmFnZW1lbnRBY2Nlc3NLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRNYW5hZ2VtZW50QWNjZXNzS2V5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcmllcy5xdWVyeSgncXVlcnl7Z2V0TWFuYWdlbWVudEFjY2Vzc0tleX0nKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LmRhdGEuZ2V0TWFuYWdlbWVudEFjY2Vzc0tleSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE1hbmFnZW1lbnRBY2Nlc3NLZXkoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0TWFuYWdlbWVudEFjY2Vzc0tleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0TWFuYWdlbWVudEFjY2Vzc0tleTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcmVzb2x2ZVNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZXNvbHZlU2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleTIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNpZ25LZXlzLCBtYW5hZ2VtZW50QWNjZXNzS2V5O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcy5zaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBwYXJhbXMuc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHNpZ25LZXlzID0gcGFyYW1zLmFjY291bnRLZXlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzaWduS2V5cykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hbmFnZW1lbnRBY2Nlc3NLZXkoKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgbWFuYWdlbWVudEFjY2Vzc0tleSA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuY3J5cHRvLm5hY2xTaWduKHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG1hbmFnZW1lbnRBY2Nlc3NLZXlcbiAgICAgICAgICAgICAgICB9LCBcIlwiLmNvbmNhdChzaWduS2V5cy5zZWNyZXQpLmNvbmNhdChzaWduS2V5c1tcInB1YmxpY1wiXSksICdIZXgnKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsICcnKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX3Jlc29sdmVTaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5KF94Mikge1xuICAgICAgICByZXR1cm4gX3Jlc29sdmVTaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Jlc29sdmVTaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyQWNjZXNzS2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZ2lzdGVyQWNjZXNzS2V5cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KHBhcmFtcykge1xuICAgICAgICB2YXIgc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleSwgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVTaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5KHBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXkgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJpZXMubXV0YXRpb24oXCJtdXRhdGlvbiByZWdpc3RlckFjY2Vzc0tleXMoJGFjY291bnQ6IFN0cmluZywgJGtleXM6IFtBY2Nlc3NLZXldLCAkc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleTogU3RyaW5nKSB7XFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckFjY2Vzc0tleXMoYWNjb3VudDogJGFjY291bnQsIGtleXM6ICRrZXlzLCBzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5OiAkc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleSlcXG4gICAgICAgICAgICAgICAgfVwiLCB7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50OiBwYXJhbXMuYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgIGtleXM6IHBhcmFtcy5rZXlzLFxuICAgICAgICAgICAgICAgICAgc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleTogc2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCByZXN1bHQuZGF0YS5yZWdpc3RlckFjY2Vzc0tleXMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWdpc3RlckFjY2Vzc0tleXMoX3gzKSB7XG4gICAgICAgIHJldHVybiBfcmVnaXN0ZXJBY2Nlc3NLZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdpc3RlckFjY2Vzc0tleXM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmV2b2tlQWNjZXNzS2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Jldm9rZUFjY2Vzc0tleXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAocGFyYW1zKSB7XG4gICAgICAgIHZhciBzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5LCByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlU2lnbmVkTWFuYWdlbWVudEFjY2Vzc0tleShwYXJhbXMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5ID0gX2NvbnRleHQxMC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJpZXMubXV0YXRpb24oXCJtdXRhdGlvbiByZXZva2VBY2Nlc3NLZXlzKCRhY2NvdW50OiBTdHJpbmcsICRrZXlzOiBbU3RyaW5nXSwgJHNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXk6IFN0cmluZykge1xcbiAgICAgICAgICAgICAgICAgICAgcmV2b2tlQWNjZXNzS2V5cyhhY2NvdW50OiAkYWNjb3VudCwga2V5czogJGtleXMsIHNpZ25lZE1hbmFnZW1lbnRBY2Nlc3NLZXk6ICRzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5KVxcbiAgICAgICAgICAgICAgICB9XCIsIHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHBhcmFtcy5hY2NvdW50LFxuICAgICAgICAgICAgICAgICAga2V5czogcGFyYW1zLmtleXMsXG4gICAgICAgICAgICAgICAgICBzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5OiBzaWduZWRNYW5hZ2VtZW50QWNjZXNzS2V5XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0MTAuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LmRhdGEucmV2b2tlQWNjZXNzS2V5cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmV2b2tlQWNjZXNzS2V5cyhfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9yZXZva2VBY2Nlc3NLZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXZva2VBY2Nlc3NLZXlzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0Um9vdFNwYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRSb290U3Bhbih0cmFjZUlkLCBzcGFuSWQsIG9wZXJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciB0cmFjZXIgPSB0aGlzLmNvbmZpZy50cmFjZXI7XG4gICAgICB2YXIgc3BhbiA9IG51bGw7XG5cbiAgICAgIGlmICh0cmFjZXIuX3N0YXJ0SW50ZXJuYWxTcGFuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRyYWNlci5leHRyYWN0KF9vcGVudHJhY2luZy5GT1JNQVRfVEVYVF9NQVAsIHtcbiAgICAgICAgICAgICd1YmVyLXRyYWNlLWlkJzogXCJcIi5jb25jYXQodHJhY2VJZCwgXCI6XCIpLmNvbmNhdChzcGFuSWQsIFwiOjA6MVwiKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMuY29uZmlnLnRyYWNlci5fc3RhcnRJbnRlcm5hbFNwYW4oY3R4LCBvcGVyYXRpb25OYW1lLCBEYXRlLm5vdygpLCAvLyBzdGFydFRpbWVcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgLy8gdXNlclRhZ3NcbiAgICAgICAgICAgIHt9LCAvLyBpbnRlcm5hbFRhZ3NcbiAgICAgICAgICAgIFtdLCAvLyByZWZlcmVuY2VzXG4gICAgICAgICAgICBmYWxzZSwgLy8gaGFzVmFsaWRQYXJlbnRcbiAgICAgICAgICAgIGZhbHNlIC8vIGlzUnBjU2VydmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkgey8vIHRyYWNlciBjYW4ndCBjcmVhdGUgbWVzc2FnZSBzcGFuIHVzaW5nIHByaXZhdGUgbWV0aG9kLFxuICAgICAgICAgIC8vIHNvIHdlIGFyZSBmYWxsYmFjayB0byBjcmVhdGUgc3BhbiB1c2luZyByZWd1bGFyIG1ldGhvZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcGFuIHx8IHRyYWNlci5zdGFydFNwYW4ob3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdHJhY2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEobmFtZSwgZiwgcGFyZW50U3Bhbikge1xuICAgICAgICB2YXIgc3BhbiwgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgc3BhbiA9IHRoaXMuY29uZmlnLnRyYWNlci5zdGFydFNwYW4obmFtZSwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRPZjogcGFyZW50U3BhblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDE7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRUYWcoX29wZW50cmFjaW5nLlRhZ3MuU1BBTl9LSU5ELCAnY2xpZW50Jyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihzcGFuKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQxMS5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBzcGFuLnNldFRhZygncmVzdWx0JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzcGFuLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCByZXN1bHQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS50MCA9IF9jb250ZXh0MTFbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgICAgICBzcGFuLmxvZyh7XG4gICAgICAgICAgICAgICAgICBldmVudDogJ2ZhaWxlZCcsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBfY29udGV4dDExLnQwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5maW5pc2goKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDExLnQwO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMsIFtbMSwgMTFdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWNlKF94NSwgX3g2LCBfeDcpIHtcbiAgICAgICAgcmV0dXJuIF90cmFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhY2U7XG4gICAgfSgpIC8vIEludGVybmFsc1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jcmVhdGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoY29uZmlnKSB7XG4gICAgICAgIHZhciBjbGllbnQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEyJChfY29udGV4dDEyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBuZXcgVE9OQ2xpZW50KCk7XG4gICAgICAgICAgICAgICAgY2xpZW50LmNvbmZpZy5zZXREYXRhKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LnNldHVwKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCBjbGllbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZShfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZTtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBUT05DbGllbnQ7XG59KCk7XG5cbmV4cG9ydHMuVE9OQ2xpZW50ID0gVE9OQ2xpZW50O1xuXG5fZGVmaW5lUHJvcGVydHkoVE9OQ2xpZW50LCBcImNsaWVudFBsYXRmb3JtXCIsIG51bGwpO1xuXG5fZGVmaW5lUHJvcGVydHkoVE9OQ2xpZW50LCBcImNvcmVMaWJyYXJ5XCIsIG51bGwpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTlVVDA1RGJHbGxiblF1YW5NaVhTd2libUZ0WlhNaU9sc2lWRTlPUTJ4cFpXNTBJaXdpWTJ4cFpXNTBVR3hoZEdadmNtMGlMQ0p0YjJSMWJHVnpJaXdpVFdGd0lpd2lZMjl1Wm1sbklpd2laMlYwVFc5a2RXeGxJaXdpVkU5T1EyOXVabWxuVFc5a2RXeGxJaXdpWTNKNWNIUnZJaXdpVkU5T1EzSjVjSFJ2VFc5a2RXeGxJaXdpWTI5dWRISmhZM1J6SWl3aVZFOU9RMjl1ZEhKaFkzUnpUVzlrZFd4bElpd2lYM0YxWlhKcFpYTWlMQ0pVVDA1UmRXVnlhV1Z6VFc5a2RXeGxJaXdpY1hWbGNtbGxjeUlzSWw5amIyNTBaWGgwSWl3aVgyTnZjbVZDY21sa1oyVWlMQ0puWlhSRGIzSmxRbkpwWkdkbElpd2lkbUZzZFdWeklpd2liVzlrZFd4bElpd2ljMlYwZFhBaUxDSmpiRzl6WlNJc0lteHBZbkpoY25raUxDSmpiM0psVEdsaWNtRnllU0lzSW5WdVpHVm1hVzVsWkNJc0ltTnZiblJsZUhRaUxDSlFjbTl0YVhObElpd2ljbVZ6YjJ4MlpTSXNJbU52Y21WRVpYTjBjbTk1UTI5dWRHVjRkQ0lzSW1SaGRHRWlMQ0puWlhSV1pYSnphVzl1SWl3aVoyVjBRMjl1Wm1sblUyVnlkbVZ5SWl3aVoyVjBVWFZsY25sVmNtd2lMQ0pqYjNKbFgzWmxjbk5wYjI0aUxDSmpiMjVtYVdkZmMyVnlkbVZ5SWl3aWNYVmxjbmxmZFhKc0lpd2ljR3hoZEdadmNtMGlMQ0pqY21WaGRHVk1hV0p5WVhKNUlpd2lkSEo1UTNKbFlYUmxUR2xpY21GeWVTSXNJbU52Y21WRGNtVmhkR1ZEYjI1MFpYaDBJaXdpY21WeGRXVnpkQ0lzSW0xbGRHaHZaQ0lzSW5CaGNtRnRjMHB6YjI0aUxDSnZibEpsYzNWc2RDSXNJbU52Y21WU1pYRjFaWE4wSWl3aWRISjVRM0psWVhSbFEyOXlaVUp5YVdSblpTSXNJazF2WkhWc1pVTnNZWE56SWl3aWJtRnRaU0lzSW0xdlpIVnNaVTVoYldVaUxDSmxlR2x6ZEdsdVowMXZaSFZzWlNJc0ltZGxkQ0lzSW5ObGRDSXNJbk5sY25abGNsUnBiV1ZFWld4MFlTSXNJbk5sY25abGNrNXZkeUlzSW5GMVpYSjVJaXdpY21WemRXeDBJaXdpWjJWMFRXRnVZV2RsYldWdWRFRmpZMlZ6YzB0bGVTSXNJbkJoY21GdGN5SXNJbk5wWjI1bFpFMWhibUZuWlcxbGJuUkJZMk5sYzNOTFpYa2lMQ0p6YVdkdVMyVjVjeUlzSW1GalkyOTFiblJMWlhseklpd2liV0Z1WVdkbGJXVnVkRUZqWTJWemMwdGxlU0lzSW01aFkyeFRhV2R1SWl3aWRHVjRkQ0lzSW5ObFkzSmxkQ0lzSWw5eVpYTnZiSFpsVTJsbmJtVmtUV0Z1WVdkbGJXVnVkRUZqWTJWemMwdGxlU0lzSW0xMWRHRjBhVzl1SWl3aVlXTmpiM1Z1ZENJc0ltdGxlWE1pTENKeVpXZHBjM1JsY2tGalkyVnpjMHRsZVhNaUxDSnlaWFp2YTJWQlkyTmxjM05MWlhseklpd2lkSEpoWTJWSlpDSXNJbk53WVc1SlpDSXNJbTl3WlhKaGRHbHZiazVoYldVaUxDSjBjbUZqWlhJaUxDSnpjR0Z1SWl3aVgzTjBZWEowU1c1MFpYSnVZV3hUY0dGdUlpd2lZM1I0SWl3aVpYaDBjbUZqZENJc0lrWlBVazFCVkY5VVJWaFVYMDFCVUNJc0lrUmhkR1VpTENKdWIzY2lMQ0p6ZEdGeWRGTndZVzRpTENKbUlpd2ljR0Z5Wlc1MFUzQmhiaUlzSW1Ob2FXeGtUMllpTENKelpYUlVZV2NpTENKVVlXZHpJaXdpVTFCQlRsOUxTVTVFSWl3aVptbHVhWE5vSWl3aWJHOW5JaXdpWlhabGJuUWlMQ0p3WVhsc2IyRmtJaXdpWTJ4cFpXNTBJaXdpYzJWMFJHRjBZU0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN08wRkJTMEU3TzBGQlkwRTdPMEZCUTBFN08wRkJRMEU3TzBGQlJVRTdPMEZCVVVFN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGeFFrRTdPenM3TzBsQlMyRkJMRk03T3pzclFrRkRVME1zWXl4RlFVRnRRenRCUVVOcVJFUXNUVUZCUVVFc1UwRkJVeXhEUVVGRFF5eGpRVUZXTEVkQlFUSkNRU3hqUVVFelFqdEJRVU5JTEVzc1EwRkhSRHM3T3p0QlFWTkJMSFZDUVVGak8wRkJRVUU3TzBGQlFVRTdPMEZCUVVFN08wRkJRVUU3TzBGQlFVRTdPMEZCUVVFN08wRkJRVUU3TzBGQlFVRTdPMEZCUVVFN08wRkJRMVlzVTBGQlMwTXNUMEZCVEN4SFFVRmxMRWxCUVVsRExFZEJRVW9zUlVGQlpqdEJRVU5CTEZOQlFVdERMRTFCUVV3c1IwRkJZeXhMUVVGTFF5eFRRVUZNTEVOQlFXVkRMREpDUVVGbUxFTkJRV1E3UVVGRFFTeFRRVUZMUXl4TlFVRk1MRWRCUVdNc1MwRkJTMFlzVTBGQlRDeERRVUZsUnl3eVFrRkJaaXhEUVVGa08wRkJRMEVzVTBGQlMwTXNVMEZCVEN4SFFVRnBRaXhMUVVGTFNpeFRRVUZNTEVOQlFXVkxMRGhDUVVGbUxFTkJRV3BDTzBGQlEwRXNVMEZCUzBNc1VVRkJUQ3hIUVVGblFpeExRVUZMVGl4VFFVRk1MRU5CUVdWUExEUkNRVUZtTEVOQlFXaENPMEZCUTBFc1UwRkJTME1zVDBGQlRDeEhRVUZsTEV0QlFVdEdMRkZCUVhCQ08wRkJRMEVzVTBGQlMwY3NVVUZCVEN4SFFVRm5RaXhEUVVGb1FqdEJRVU5CTEZOQlFVdERMRmRCUVV3c1IwRkJiVUlzU1VGQmJrSTdRVUZEU0R0QlFVVkVPenM3T3pzN096czdPMEZCV1VFN096czdPenM3T3pzN096czdkVUpCUzFVc1MwRkJTME1zWVVGQlRDeEZPenM3UVVGRFFXUXNaMEpCUVVGQkxFOHNjMEpCUVRKQ0xFdEJRVXRCTEU5QlFVd3NRMEZCWVdVc1RVRkJZaXhGTzNWRVFVTmFaaXhQT3pzN096czdPenM3T3p0QlFVRldaMElzWjBKQlFVRkJMRTA3TzNWQ1FVTkVRU3hOUVVGTkxFTkJRVU5ETEV0QlFWQXNSVHM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVVsa096czdPenM3T3pzN096czdPenM3TzNWQ1FVMVZMRXRCUVV0T0xFOUJRVXdzUTBGQllVOHNTMEZCWWl4Rk96czdRVUZEUVVNc1owSkJRVUZCTEU4c1IwRkJWWEpDTEZOQlFWTXNRMEZCUTNOQ0xGYzdPM05DUVVOMFFpeExRVUZMVWl4UlFVRk1MRWRCUVdkQ0xFTkJRV2hDTEVsQlFYRkNUeXhQUVVGUExFdEJRVXNzU1VGQmFrTXNTVUZCZVVOQkxFOUJRVThzUzBGQlMwVXNVenM3T3pzN1FVRkRMME5ETEdkQ1FVRkJRU3hQTEVkQlFWVXNTMEZCUzFZc1VUdEJRVU55UWl4eFFrRkJTME1zVjBGQlRDeEhRVUZ0UWl4SlFVRnVRanRCUVVOQkxIRkNRVUZMUkN4UlFVRk1MRWRCUVdkQ0xFTkJRV2hDT3p0MVFrRkRUU3hKUVVGSlZ5eFBRVUZLTEVOQlFWa3NWVUZCUVVNc1QwRkJUenRCUVVGQkxIbENRVUZKVEN4UFFVRlBMRU5CUVVOTkxHdENRVUZTTEVOQlFUSkNTQ3hQUVVFelFpeEZRVUZ2UTBVc1QwRkJjRU1zUTBGQlNqdEJRVUZCTEdsQ1FVRnVRaXhET3pzN096czdPenM3T3pzN096czdVVUZKWkRzN096czdPRWRCUlhkQ1JTeEpPenM3T3pzN2FVUkJSV0pCTEVrN096dDFRa0ZEYVVJc1MwRkJTM2hDTEUxQlFVd3NRMEZCV1hsQ0xGVkJRVm9zUlRzN096c3JRa0ZEVEN4TFFVRkxla0lzVFVGQlRDeERRVUZaTUVJc1pVRkJXaXhGT3l0Q1FVTktMRXRCUVV0dVFpeFJRVUZNTEVOQlFXTnZRaXhYUVVGa0xFVTdPMEZCUmxoRExHdENRVUZCUVN4Wk8wRkJRMEZETEd0Q1FVRkJRU3hoTzBGQlEwRkRMR3RDUVVGQlFTeFRPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdRVUZMUlVNc1owSkJRVUZCTEZFc1IwRkJWMjVETEZOQlFWTXNRMEZCUTBNc1l6czdjMEpCUTNaQ2EwTXNVVUZCVVN4TFFVRkxMRWxCUVdJc1NVRkJjVUpCTEZGQlFWRXNTMEZCUzFvc1V6czdPenM3YTBSQlF6TkNMRWs3T3pzN2RVSkJSVzFDV1N4UlFVRlJMRU5CUVVORExHRkJRVlFzUlRzN08wRkJRVGxDY0VNc1owSkJRVUZCTEZOQlFWTXNRMEZCUTNOQ0xGYzdhMFJCUTBoMFFpeFRRVUZUTEVOQlFVTnpRaXhYT3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3SzBKQlNVUjBRaXhUUVVGVExFTkJRVU56UWl4WE96czdPenM3T3p0MVFrRkJjVUlzUzBGQlMyVXNaMEpCUVV3c1JUczdPenM3TzBGQlFYcERhRUlzWjBKQlFVRkJMRTg3TzI5Q1FVTkVRU3hQT3pzN096czdPenR4UWtGSFJFRXNUMEZCVHl4RFFVRkRhVUlzYVVJN096czdPenQxUWtGRFl5eEpRVUZKWWl4UFFVRktMRU5CUVZrc1ZVRkJRME1zVDBGQlJEdEJRVUZCTEhsQ1FVRmhUQ3hQUVVGUExFTkJRVU5wUWl4cFFrRkJVaXhEUVVFd1Fsb3NUMEZCTVVJc1EwRkJZanRCUVVGQkxHbENRVUZhTEVNN096dEJRVUYwUWl4eFFrRkJTMW9zVVR0QlFVTk1MSEZDUVVGTFF5eFhRVUZNTEVkQlFXMUNPMEZCUTJaM1FpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGRkxHbENRVU5NUXl4TlFVUkxMRVZCUlV4RExGVkJSa3NzUlVGSFRFTXNVVUZJU3l4RlFVbEZPMEZCUTFBc2QwSkJRVWt4UXl4VFFVRlRMRU5CUVVOelFpeFhRVUZrTEVWQlFUSkNPMEZCUTNaQ2RFSXNjMEpCUVVGQkxGTkJRVk1zUTBGQlEzTkNMRmRCUVZZc1EwRkJjMEp4UWl4WFFVRjBRaXhEUVVOSkxFdEJRVWtzUTBGQlF6ZENMRkZCUkZRc1JVRkZTVEJDTEUxQlJrb3NSVUZIU1VNc1ZVRklTaXhGUVVsSlF5eFJRVXBLTzBGQlRVZzdRVUZEU2p0QlFXUmpMR2xDUVVGdVFqczdPenM3UVVGcFFrRXNjVUpCUVVzelFpeFhRVUZNTEVkQlFXMUNUU3hQUVVGdVFqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzI5Q1FVdERMRXRCUVV0T0xGYzdPenM3T3p0MVFrRkRRU3hMUVVGTE5rSXNiVUpCUVV3c1JUczdPMnRFUVVWSUxFdEJRVXMzUWl4WE96czdPenM3T3pzN096czdPenM3T3pzN09FSkJSMGc0UWl4WExFVkJRV3RETzBGQlF6TkRMRlZCUVUxRExFbEJRVWtzUjBGQlIwUXNWMEZCVnl4RFFVRkRSU3hWUVVGNlFqdEJRVU5CTEZWQlFVMURMR05CUVdNc1IwRkJSeXhMUVVGTE9VTXNUMEZCVEN4RFFVRmhLME1zUjBGQllpeERRVUZwUWtnc1NVRkJha0lzUTBGQmRrSTdPMEZCUTBFc1ZVRkJTVVVzWTBGQlNpeEZRVUZ2UWp0QlFVTm9RaXhsUVVGUlFTeGpRVUZTTzBGQlEwZzdPMEZCUTBRc1ZVRkJUVGxDTEUxQlFVMHNSMEZCUnl4SlFVRkpNa0lzVjBGQlNpeERRVUZuUWl4SlFVRm9RaXhEUVVGbU8wRkJRMEVzVjBGQlN6TkRMRTlCUVV3c1EwRkJZV2RFTEVkQlFXSXNRMEZCYVVKS0xFbEJRV3BDTEVWQlFYVkNOVUlzVFVGQmRrSTdRVUZEUVN4aFFVRlJRU3hOUVVGU08wRkJRMGc3T3p0elEwRkZhME03UVVGREwwSXNZVUZCVHl4TFFVRkxVQ3hSUVVGTUxFTkJRV04zUXl4bFFVRmtMRVZCUVZBN1FVRkRTRHM3TzJkRFFVVTBRanRCUVVONlFpeGhRVUZQTEV0QlFVdDRReXhSUVVGTUxFTkJRV041UXl4VFFVRmtMRVZCUVZBN1FVRkRTRHM3T3pzN096czdPenM3ZFVKQlIzZENMRXRCUVV0NlF5eFJRVUZNTEVOQlFXTXdReXhMUVVGa0xFTkJRVzlDTEN0Q1FVRndRaXhET3pzN1FVRkJaa01zWjBKQlFVRkJMRTA3YTBSQlEwTkJMRTFCUVUwc1EwRkJRekZDTEVsQlFWQXNRMEZCV1RKQ0xITkNPenM3T3pzN096czdPenM3T3pzN096czdPemhJUVV0dVFrTXNUVHM3T3pzN08zRkNRVVZKUVN4TlFVRk5MRU5CUVVORExIbENPenM3T3p0clJFRkRRVVFzVFVGQlRTeERRVUZEUXl4NVFqczdPMEZCUlZwRExHZENRVUZCUVN4UkxFZEJRVmRHTEUxQlFVMHNRMEZCUTBjc1Z6czdjVUpCUTNCQ1JDeFJPenM3T3pzN2RVSkJRMnRETEV0QlFVdElMSE5DUVVGTUxFVTdPenRCUVVFMVFrc3NaMEpCUVVGQkxHMUNPMnRFUVVORExFdEJRVXR5UkN4TlFVRk1MRU5CUVZselJDeFJRVUZhTEVOQlEwZzdRVUZCUlVNc2EwSkJRVUZCTEVsQlFVa3NSVUZCUlVZN1FVRkJVaXhwUWtGRVJ5eFpRVVZCUml4UlFVRlJMRU5CUVVOTExFMUJSbFFzVTBGRmEwSk1MRkZCUVZFc1ZVRkdNVUlzUjBGSFNDeExRVWhITEVNN096dHJSRUZOU2l4Rk96czdPenM3T3pzN096czdPenM3T3pzN095dEhRVWxRUml4Tk96czdPenM3TzNWQ1FVVjNReXhMUVVGTFVTeHBRMEZCVEN4RFFVRjFRMUlzVFVGQmRrTXNRenM3TzBGQlFXeERReXhuUWtGQlFVRXNlVUk3TzNWQ1FVTmxMRXRCUVVzNVF5eFJRVUZNTEVOQlFXTnpSQ3hSUVVGa0xEaFFRVWRVTzBGQlEwcERMR3RDUVVGQlFTeFBRVUZQTEVWQlFVVldMRTFCUVUwc1EwRkJRMVVzVDBGRVdqdEJRVVZLUXl4clFrRkJRVUVzU1VGQlNTeEZRVUZGV0N4TlFVRk5MRU5CUVVOWExFbEJSbFE3UVVGSFNsWXNhMEpCUVVGQkxIbENRVUY1UWl4RlFVRjZRa0U3UVVGSVNTeHBRa0ZJVXl4RE96czdRVUZCWmtnc1owSkJRVUZCTEUwN2EwUkJVME5CTEUxQlFVMHNRMEZCUXpGQ0xFbEJRVkFzUTBGQldYZERMR3RDT3pzN096czdPenM3T3pzN096czdPenM3T3poSFFVbHVRbG9zVFRzN096czdPenQxUWtGRmQwTXNTMEZCUzFFc2FVTkJRVXdzUTBGQmRVTlNMRTFCUVhaRExFTTdPenRCUVVGc1EwTXNaMEpCUVVGQkxIbENPenQxUWtGRFpTeExRVUZMT1VNc1VVRkJUQ3hEUVVGamMwUXNVVUZCWkN4MVVFRkhWRHRCUVVOS1F5eHJRa0ZCUVVFc1QwRkJUeXhGUVVGRlZpeE5RVUZOTEVOQlFVTlZMRTlCUkZvN1FVRkZTa01zYTBKQlFVRkJMRWxCUVVrc1JVRkJSVmdzVFVGQlRTeERRVUZEVnl4SlFVWlVPMEZCUjBwV0xHdENRVUZCUVN4NVFrRkJlVUlzUlVGQmVrSkJPMEZCU0Vrc2FVSkJTRk1zUXpzN08wRkJRV1pJTEdkQ1FVRkJRU3hOTzIxRVFWTkRRU3hOUVVGTkxFTkJRVU14UWl4SlFVRlFMRU5CUVZsNVF5eG5RanM3T3pzN096czdPenM3T3pzN096czdPMnREUVVkVVF5eFBMRVZCUVdsQ1F5eE5MRVZCUVdkQ1F5eGhMRVZCUVRaQ08wRkJRM2hGTEZWQlFVMURMRTFCUVUwc1IwRkJSeXhMUVVGTGNrVXNUVUZCVEN4RFFVRlpjVVVzVFVGQk0wSTdRVUZEUVN4VlFVRkpReXhKUVVGWExFZEJRVWNzU1VGQmJFSTdPMEZCUTBFc1ZVRkJTVVFzVFVGQlRTeERRVUZEUlN4clFrRkJXQ3hGUVVFclFqdEJRVU16UWl4WlFVRkpPMEZCUTBFc1kwRkJUVU1zUjBGQlJ5eEhRVUZIU0N4TlFVRk5MRU5CUVVOSkxFOUJRVkFzUTBGQlpVTXNORUpCUVdZc1JVRkJaME03UVVGRGVFTXNkVU5CUVc5Q1VpeFBRVUZ3UWl4alFVRXJRa01zVFVGQkwwSTdRVUZFZDBNc1YwRkJhRU1zUTBGQldqczdRVUZIUVN4alFVRkpTeXhIUVVGS0xFVkJRVk03UVVGRFRFWXNXVUZCUVVFc1NVRkJTU3hIUVVGSExFdEJRVXQwUlN4TlFVRk1MRU5CUVZseFJTeE5RVUZhTEVOQlFXMUNSU3hyUWtGQmJrSXNRMEZEU0VNc1IwRkVSeXhGUVVWSVNpeGhRVVpITEVWQlIwaFBMRWxCUVVrc1EwRkJRME1zUjBGQlRDeEZRVWhITEVWQlIxTTdRVUZEV25wRUxGbEJRVUZCTEZOQlNrY3NSVUZKVVR0QlFVTllMR05CVEVjc1JVRkxRenRCUVVOS0xHTkJUa2NzUlVGTlF6dEJRVU5LTEdsQ1FWQkhMRVZCVDBrN1FVRkRVQ3hwUWtGU1J5eERRVkZKTzBGQlVrb3NZVUZCVUR0QlFWVklPMEZCUTBvc1UwRm9Ra1FzUTBGblFrVXNaMEpCUVUwc1EwRkRTanRCUVVOQk8wRkJRMGc3UVVGRFNqczdRVUZEUkN4aFFVRlBiVVFzU1VGQlNTeEpRVUZKUkN4TlFVRk5MRU5CUVVOUkxGTkJRVkFzUTBGQmFVSlVMR0ZCUVdwQ0xFTkJRV1k3UVVGRFNEczdPenR0UjBGSFJ6RkNMRWtzUlVGRFFXOURMRU1zUlVGRFFVTXNWVHM3T3pzN08wRkJSVTFVTEdkQ1FVRkJRU3hKTEVkQlFVOHNTMEZCUzNSRkxFMUJRVXdzUTBGQldYRkZMRTFCUVZvc1EwRkJiVUpSTEZOQlFXNUNMRU5CUVRaQ2JrTXNTVUZCTjBJc1JVRkJiVU03UVVGQlJYTkRMR3RDUVVGQlFTeFBRVUZQTEVWQlFVVkVPMEZCUVZnc2FVSkJRVzVETEVNN08wRkJSVlJVTEdkQ1FVRkJRU3hKUVVGSkxFTkJRVU5YTEUxQlFVd3NRMEZCV1VNc2EwSkJRVXRETEZOQlFXcENMRVZCUVRSQ0xGRkJRVFZDT3p0MVFrRkRjVUpNTEVOQlFVTXNRMEZCUTFJc1NVRkJSQ3hET3pzN1FVRkJhRUp3UWl4blFrRkJRVUVzVFRzN1FVRkRUaXh2UWtGQlNVRXNUVUZCVFN4TFFVRkxMMElzVTBGQlppeEZRVUV3UWp0QlFVTjBRbTFFTEd0Q1FVRkJRU3hKUVVGSkxFTkJRVU5YTEUxQlFVd3NRMEZCV1N4UlFVRmFMRVZCUVhOQ0wwSXNUVUZCZEVJN1FVRkRTRHM3UVVGRFJHOUNMR2RDUVVGQlFTeEpRVUZKTEVOQlFVTmpMRTFCUVV3N2JVUkJRMDlzUXl4Tk96czdPenRCUVVWUWIwSXNaMEpCUVVGQkxFbEJRVWtzUTBGQlEyVXNSMEZCVEN4RFFVRlRPMEZCUTB4RExHdENRVUZCUVN4TFFVRkxMRVZCUVVVc1VVRkVSanRCUVVWTVF5eHJRa0ZCUVVFc1QwRkJUenRCUVVaR0xHbENRVUZVTzBGQlNVRnFRaXhuUWtGQlFVRXNTVUZCU1N4RFFVRkRZeXhOUVVGTU96czdPenM3T3pzN096czdPenM3TzFGQlMxSTdPenM3TzI5SFFYcE9iMEp3Uml4Tk96czdPenM3UVVGRFZuZEdMR2RDUVVGQlFTeE5MRWRCUVZNc1NVRkJTVFZHTEZOQlFVb3NSVHRCUVVObU5FWXNaMEpCUVVGQkxFMUJRVTBzUTBGQlEzaEdMRTFCUVZBc1EwRkJZM2xHTEU5QlFXUXNRMEZCYzBKNlJpeE5RVUYwUWpzN2RVSkJRMDEzUml4TlFVRk5MRU5CUVVONlJTeExRVUZRTEVVN096dHRSRUZEUTNsRkxFMDdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzJkQ1FXNURSalZHTEZNc2IwSkJNRkJ0UXl4Sk96dG5Ra0V4VUc1RFFTeFRMR2xDUVRKUWJVTXNTU0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cVhHNGdLaUJEYjNCNWNtbG5hSFFnTWpBeE9DMHlNREl3SUZSUFRpQkVSVllnVTA5TVZWUkpUMDVUSUV4VVJDNWNiaUFxTDF4dUx5OGdRR1pzYjNkY2JseHVhVzF3YjNKMElIdGNiaUFnSUNCVVlXZHpMQ0JUY0dGdUxDQlRjR0Z1UTI5dWRHVjRkQ3dnUms5U1RVRlVYMVJGV0ZSZlRVRlFMRnh1ZlNCbWNtOXRJQ2R2Y0dWdWRISmhZMmx1WnljN1hHNXBiWEJ2Y25RZ2RIbHdaU0I3WEc0Z0lDQWdTVlJQVGtOc2FXVnVkQ3hjYmlBZ0lDQlVUMDVCWTJObGMzTkxaWGx6VFdGdVlXZGxiV1Z1ZEZCaGNtRnRjeXhjYmlBZ0lDQlVUMDVEYjI1bWFXZEVZWFJoTEZ4dUlDQWdJRlJQVGtOdmJuUnlZV04wY3l4Y2JpQWdJQ0JVVDA1RGNubHdkRzhzWEc0Z0lDQWdWRTlPVVhWbGNtbGxjeXhjYmlBZ0lDQlVUMDVTWldkcGMzUmxja0ZqWTJWemMwdGxlWE5RWVhKaGJYTXNYRzRnSUNBZ1ZFOU9VbVYyYjJ0bFFXTmpaWE56UzJWNWMxQmhjbUZ0Y3l4Y2JuMGdabkp2YlNBbkxpNHZkSGx3WlhNbk8xeHVYRzVwYlhCdmNuUWdWRTlPUTI5dVptbG5UVzlrZFd4bElHWnliMjBnSnk0dmJXOWtkV3hsY3k5VVQwNURiMjVtYVdkTmIyUjFiR1VuTzF4dWFXMXdiM0owSUZSUFRrTnZiblJ5WVdOMGMwMXZaSFZzWlNCbWNtOXRJQ2N1TDIxdlpIVnNaWE12VkU5T1EyOXVkSEpoWTNSelRXOWtkV3hsSnp0Y2JtbHRjRzl5ZENCVVQwNURjbmx3ZEc5TmIyUjFiR1VnWm5KdmJTQW5MaTl0YjJSMWJHVnpMMVJQVGtOeWVYQjBiMDF2WkhWc1pTYzdYRzR2S2lCbGMyeHBiblF0WkdsellXSnNaU0JqYkdGemN5MXRaWFJvYjJSekxYVnpaUzEwYUdsekxDQnVieTExYzJVdFltVm1iM0psTFdSbFptbHVaU0FxTDF4dWFXMXdiM0owSUZSUFRsRjFaWEpwWlhOTmIyUjFiR1VnWm5KdmJTQW5MaTl0YjJSMWJHVnpMMVJQVGxGMVpYSnBaWE5OYjJSMWJHVW5PMXh1YVcxd2IzSjBJSFI1Y0dVZ2V5QlVUMDVGY25KdmNrUmhkR0VnZlNCbWNtOXRJQ2N1TDFSUFRrTnNhV1Z1ZEVWeWNtOXlKenRjYmx4dWFXMXdiM0owSUhSNWNHVWdlMXh1SUNBZ0lGUlBUa05zYVdWdWRFTnZjbVZNYVdKeVlYSjVMRnh1SUNBZ0lGUlBUa05zYVdWdWRFTnZjbVZDY21sa1oyVXNYRzRnSUNBZ1ZFOU9UVzlrZFd4bFEyOXVkR1Y0ZEN4Y2JuMGdabkp2YlNBbkxpOVVUMDVOYjJSMWJHVW5PMXh1YVcxd2IzSjBJSHNnVkU5T1RXOWtkV3hsSUgwZ1puSnZiU0FuTGk5VVQwNU5iMlIxYkdVbk8xeHVYRzR2S2lwY2JpQXFJRXBoZG1GVFkzSnBjSFFnY0d4aGRHWnZjbTBnYzNCbFkybG1hV01nWTI5dVptbG5kWEpoZEdsdmJseHVJQ292WEc1MGVYQmxJRlJQVGtOc2FXVnVkRkJzWVhSbWIzSnRJRDBnZTF4dUlDQWdJQzhxS2x4dUlDQWdJQ0FxSUZCc1lYUm1iM0p0SUhOd1pXTnBabWxqSUdCbVpYUmphR0FnWm5WdVkzUnBiMjVjYmlBZ0lDQWdLaTljYmlBZ0lDQm1aWFJqYURvZ1lXNTVMRnh1SUNBZ0lDOHFLbHh1SUNBZ0lDQXFJRkJzWVhSbWIzSnRJSE53WldOcFptbGpJR0JYWldKVGIyTnJaWFJnSUdsdGNHeGxiV1Z1ZEdGMGFXOXVYRzRnSUNBZ0lDb2dWR2hwY3lCcGJYQnNaVzFsYm5SaGRHbHZiaUJ0ZFhOMElHTnZibVp2Y20xeklIUnZJRmN6UXlCWFpXSlRiMk5yWlhSY2JpQWdJQ0FnS2k5Y2JpQWdJQ0JYWldKVGIyTnJaWFE2SUdGdWVTeGNiaUFnSUNBdktpcGNiaUFnSUNBZ0tpQlNaWEYxWlhOMElHTnlaV0YwYVc5dUlHOW1JSFJvWlNCamJHbGxiblFnWTI5eVpWeHVJQ0FnSUNBcUwxeHVJQ0FnSUdOeVpXRjBaVXhwWW5KaGNuazZJQ2dwSUQwK0lGQnliMjFwYzJVOFZFOU9RMnhwWlc1MFEyOXlaVXhwWW5KaGNuaytMRnh1ZlR0Y2JseHVMeW9xWEc0Z0tpQk5ZV2x1SUc5aWFtVmpkQ0J3Y205MmFXUmxaQ0JtZFc1amRHbHZibUZzYVhSNUlHOW1JSFJvWlNCVVQwNGdRMnhwWlc1MElFeHBZbkpoY25sY2JpQXFJRVZoWTJnZ2FXNXpkR0Z1WTJVZ2IyWWdWRTlPUTJ4cFpXNTBJR2hoY3lCdmQyNGdjMlYwSUc5bUlGUlBUaUJEYkdsbGJuUWdiVzlrZFd4bGMxeHVJQ29nWVc1a0lHaGhjeUJ2ZDI0Z2NISmxZMjl1Wm1sbmRYSmxaQ0JqYkdsbGJuUWdZMjl1ZEdWNGRGeHVJQ292WEc1bGVIQnZjblFnWTJ4aGMzTWdWRTlPUTJ4cFpXNTBJR2x0Y0d4bGJXVnVkSE1nVkU5T1RXOWtkV3hsUTI5dWRHVjRkQ3dnU1ZSUFRrTnNhV1Z1ZENCN1hHNGdJQ0FnYzNSaGRHbGpJSE5sZEV4cFluSmhjbmtvWTJ4cFpXNTBVR3hoZEdadmNtMDZJRlJQVGtOc2FXVnVkRkJzWVhSbWIzSnRLU0I3WEc0Z0lDQWdJQ0FnSUZSUFRrTnNhV1Z1ZEM1amJHbGxiblJRYkdGMFptOXliU0E5SUdOc2FXVnVkRkJzWVhSbWIzSnRPMXh1SUNBZ0lIMWNibHh1WEc0Z0lDQWdMeThnVUhWaWJHbGpYRzRnSUNBZ1kyOXVabWxuT2lCVVQwNURiMjVtYVdkTmIyUjFiR1U3WEc0Z0lDQWdZM0o1Y0hSdk9pQlVUMDVEY25sd2RHODdYRzRnSUNBZ1kyOXVkSEpoWTNSek9pQlVUMDVEYjI1MGNtRmpkSE03WEc0Z0lDQWdjWFZsY21sbGN6b2dWRTlPVVhWbGNtbGxjenRjYmlBZ0lDQmZjWFZsY21sbGN6b2dWRTlPVVhWbGNtbGxjMDF2WkhWc1pUdGNiaUFnSUNCZlkyOXVkR1Y0ZERvZ2JuVnRZbVZ5TzF4dUlDQWdJRjlqYjNKbFFuSnBaR2RsT2lBL1ZFOU9RMnhwWlc1MFEyOXlaVUp5YVdSblpUdGNibHh1SUNBZ0lHTnZibk4wY25WamRHOXlLQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbTF2WkhWc1pYTWdQU0J1WlhjZ1RXRndLQ2s3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVZMjl1Wm1sbklEMGdkR2hwY3k1blpYUk5iMlIxYkdVb1ZFOU9RMjl1Wm1sblRXOWtkV3hsS1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVqY25sd2RHOGdQU0IwYUdsekxtZGxkRTF2WkhWc1pTaFVUMDVEY25sd2RHOU5iMlIxYkdVcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1OdmJuUnlZV04wY3lBOUlIUm9hWE11WjJWMFRXOWtkV3hsS0ZSUFRrTnZiblJ5WVdOMGMwMXZaSFZzWlNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDNGMVpYSnBaWE1nUFNCMGFHbHpMbWRsZEUxdlpIVnNaU2hVVDA1UmRXVnlhV1Z6VFc5a2RXeGxLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXhkV1Z5YVdWeklEMGdkR2hwY3k1ZmNYVmxjbWxsY3p0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVmWTI5dWRHVjRkQ0E5SURBN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDJOdmNtVkNjbWxrWjJVZ1BTQnVkV3hzTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzhxS2x4dUlDQWdJQ0FxSUVOdmJuWmxibWxsYm5RZ2QyRjVJSFJ2SUdOeVpXRjBaU0JqYjI1bWFXZDFjbVZrSUdsdWMzUmhibU5sSUc5bUlIUm9aU0JVVDA0Z1EyeHBaVzUwWEc0Z0lDQWdJQ29nUUhCaGNtRnRJSHRVVDA1RGIyNW1hV2RFWVhSaGZTQmpiMjVtYVdkY2JpQWdJQ0FnS2lCQWNtVjBkWEp1SUh0UWNtOXRhWE5sUEZSUFRrTnNhV1Z1ZEQ1OVhHNGdJQ0FnSUNvdlhHNGdJQ0FnYzNSaGRHbGpJR0Z6ZVc1aklHTnlaV0YwWlNoamIyNW1hV2M2SUZSUFRrTnZibVpwWjBSaGRHRXBPaUJRY205dGFYTmxQRlJQVGtOc2FXVnVkRDRnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0JqYkdsbGJuUWdQU0J1WlhjZ1ZFOU9RMnhwWlc1MEtDazdYRzRnSUNBZ0lDQWdJR05zYVdWdWRDNWpiMjVtYVdjdWMyVjBSR0YwWVNoamIyNW1hV2NwTzF4dUlDQWdJQ0FnSUNCaGQyRnBkQ0JqYkdsbGJuUXVjMlYwZFhBb0tUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHTnNhV1Z1ZER0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2S2lwY2JpQWdJQ0FnS2lCVFpYUWdkWEFnZEdobElHTnNhV1Z1ZENCcGJuTjBZVzVqWlZ4dUlDQWdJQ0FxSUVCeVpYUjFjbTRnZTFCeWIyMXBjMlU4ZG05cFpENTlYRzRnSUNBZ0lDb3ZYRzRnSUNBZ1lYTjVibU1nYzJWMGRYQW9LVG9nVUhKdmJXbHpaVHgyYjJsa1BpQjdYRzRnSUNBZ0lDQWdJR0YzWVdsMElIUm9hWE11WjJWMFEyOXlaVUp5YVdSblpTZ3BPMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQnRiMlIxYkdWek9pQlVUMDVOYjJSMWJHVmJYU0E5SUZzdUxpNTBhR2x6TG0xdlpIVnNaWE11ZG1Gc2RXVnpLQ2xkTzF4dUlDQWdJQ0FnSUNCbWIzSWdLR052Ym5OMElHMXZaSFZzWlNCdlppQnRiMlIxYkdWektTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaGQyRnBkQ0J0YjJSMWJHVXVjMlYwZFhBb0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lDOHFLbHh1SUNBZ0lDQXFJRlJsWVhJZ1pHOTNiaUIwYUdseklHTnNhV1Z1ZENCcGJuTjBZVzVqWlM1Y2JpQWdJQ0FnS2lCT2IzUmxJSFJvWVhRZ1lXWjBaWElnZVc5MUlHaGhkbVVnWTJGc2JHVmtJSFJvYVhNZ2JXVjBhRzlrSUdGc2JDQm1kWFIxY21VZ2RYTmxJRzltSUhSb2FYTWdhVzV6ZEdGdVkyVWdkMmxzYkNCbVlXbHNYRzRnSUNBZ0lDb2dRSEpsZEhWeWJpQjdVSEp2YldselpUeDJiMmxrUG4xY2JpQWdJQ0FnS2k5Y2JpQWdJQ0JoYzNsdVl5QmpiRzl6WlNncE9pQlFjbTl0YVhObFBIWnZhV1ErSUh0Y2JpQWdJQ0FnSUNBZ1lYZGhhWFFnZEdocGN5NXhkV1Z5YVdWekxtTnNiM05sS0NrN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUd4cFluSmhjbmtnUFNCVVQwNURiR2xsYm5RdVkyOXlaVXhwWW5KaGNuazdYRzRnSUNBZ0lDQWdJR2xtSUNoMGFHbHpMbDlqYjI1MFpYaDBJRDRnTUNBbUppQnNhV0p5WVhKNUlDRTlQU0J1ZFd4c0lDWW1JR3hwWW5KaGNua2dJVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdZMjl1ZEdWNGRDQTlJSFJvYVhNdVgyTnZiblJsZUhRN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOWpiM0psUW5KcFpHZGxJRDBnYm5Wc2JEdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMk52Ym5SbGVIUWdQU0F3TzF4dUlDQWdJQ0FnSUNBZ0lDQWdZWGRoYVhRZ2JtVjNJRkJ5YjIxcGMyVW9jbVZ6YjJ4MlpTQTlQaUJzYVdKeVlYSjVMbU52Y21WRVpYTjBjbTk1UTI5dWRHVjRkQ2hqYjI1MFpYaDBMQ0J5WlhOdmJIWmxLU2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCVVQwNU5iMlIxYkdWRGIyNTBaWGgwWEc1Y2JpQWdJQ0JoYzNsdVl5QmpiMjF3YkdWMFpVVnljbTl5UkdGMFlTaGtZWFJoUHpvZ2V5QmJjM1J5YVc1blhUb2dZVzU1SUgwcE9pQlFjbTl0YVhObFBGUlBUa1Z5Y205eVJHRjBZVDRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdMaTR1WkdGMFlTeGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmNtVmZkbVZ5YzJsdmJqb2dZWGRoYVhRZ2RHaHBjeTVqYjI1bWFXY3VaMlYwVm1WeWMybHZiaWdwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1Wm1sblgzTmxjblpsY2pvZ2RHaHBjeTVqYjI1bWFXY3VaMlYwUTI5dVptbG5VMlZ5ZG1WeUtDa3NYRzRnSUNBZ0lDQWdJQ0FnSUNCeGRXVnllVjkxY213NklIUm9hWE11WDNGMVpYSnBaWE11WjJWMFVYVmxjbmxWY213b0tTeGNiaUFnSUNBZ0lDQWdmVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCMGNubERjbVZoZEdWTWFXSnlZWEo1S0NrZ2UxeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCd2JHRjBabTl5YlNBOUlGUlBUa05zYVdWdWRDNWpiR2xsYm5SUWJHRjBabTl5YlR0Y2JpQWdJQ0FnSUNBZ2FXWWdLSEJzWVhSbWIzSnRJRDA5UFNCdWRXeHNJSHg4SUhCc1lYUm1iM0p0SUQwOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCdWRXeHNPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUZSUFRrTnNhV1Z1ZEM1amIzSmxUR2xpY21GeWVTQTlJR0YzWVdsMElIQnNZWFJtYjNKdExtTnlaV0YwWlV4cFluSmhjbmtvS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUZSUFRrTnNhV1Z1ZEM1amIzSmxUR2xpY21GeWVUdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUIwY25sRGNtVmhkR1ZEYjNKbFFuSnBaR2RsS0NrZ2UxeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCc2FXSnlZWEo1SUQwZ1ZFOU9RMnhwWlc1MExtTnZjbVZNYVdKeVlYSjVJSHg4SUdGM1lXbDBJSFJvYVhNdWRISjVRM0psWVhSbFRHbGljbUZ5ZVNncE8xeHVJQ0FnSUNBZ0lDQnBaaUFvSVd4cFluSmhjbmtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JwWmlBb2JHbGljbUZ5ZVM1amIzSmxRM0psWVhSbFEyOXVkR1Y0ZENrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWZZMjl1ZEdWNGRDQTlJR0YzWVdsMElHNWxkeUJRY205dGFYTmxLQ2h5WlhOdmJIWmxLU0E5UGlCc2FXSnlZWEo1TG1OdmNtVkRjbVZoZEdWRGIyNTBaWGgwS0hKbGMyOXNkbVVwS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyTnZjbVZDY21sa1oyVWdQU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WeGRXVnpkRG9nS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRaWFJvYjJRNklITjBjbWx1Wnl4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjR0Z5WVcxelNuTnZiam9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdmJsSmxjM1ZzZERvZ0tISmxjM1ZzZEVwemIyNDZJSE4wY21sdVp5d2daWEp5YjNKS2MyOXVPaUJ6ZEhKcGJtY3BJRDArSUhadmFXUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdLVG9nZG05cFpDQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hVVDA1RGJHbGxiblF1WTI5eVpVeHBZbkpoY25rcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGUlBUa05zYVdWdWRDNWpiM0psVEdsaWNtRnllUzVqYjNKbFVtVnhkV1Z6ZENoY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5amIyNTBaWGgwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHMWxkR2h2WkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQndZWEpoYlhOS2MyOXVMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUc5dVVtVnpkV3gwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVmWTI5eVpVSnlhV1JuWlNBOUlHeHBZbkpoY25rN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUJuWlhSRGIzSmxRbkpwWkdkbEtDazZJRkJ5YjIxcGMyVThQMVJQVGtOc2FXVnVkRU52Y21WQ2NtbGtaMlUrSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0YwYUdsekxsOWpiM0psUW5KcFpHZGxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhkMkZwZENCMGFHbHpMblJ5ZVVOeVpXRjBaVU52Y21WQ2NtbGtaMlVvS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTVmWTI5eVpVSnlhV1JuWlR0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JuWlhSTmIyUjFiR1U4VkQ0b1RXOWtkV3hsUTJ4aGMzTTZJSFI1Y0dWdlppQlVUMDVOYjJSMWJHVXBPaUJVSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYm1GdFpTQTlJRTF2WkhWc1pVTnNZWE56TG0xdlpIVnNaVTVoYldVN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUdWNGFYTjBhVzVuVFc5a2RXeGxJRDBnZEdocGN5NXRiMlIxYkdWekxtZGxkQ2h1WVcxbEtUdGNiaUFnSUNBZ0lDQWdhV1lnS0dWNGFYTjBhVzVuVFc5a2RXeGxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0tHVjRhWE4wYVc1blRXOWtkV3hsT2lCaGJua3BPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJRzF2WkhWc1pTQTlJRzVsZHlCTmIyUjFiR1ZEYkdGemN5aDBhR2x6S1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTV0YjJSMWJHVnpMbk5sZENodVlXMWxMQ0J0YjJSMWJHVXBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdLRzF2WkhWc1pUb2dZVzU1S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6WlhKMlpYSlVhVzFsUkdWc2RHRW9LVG9nVUhKdmJXbHpaVHh1ZFcxaVpYSStJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdVgzRjFaWEpwWlhNdWMyVnlkbVZ5VkdsdFpVUmxiSFJoS0NrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzJWeWRtVnlUbTkzS0NrNklGQnliMjFwYzJVOGJuVnRZbVZ5UGlCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbDl4ZFdWeWFXVnpMbk5sY25abGNrNXZkeWdwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklHZGxkRTFoYm1GblpXMWxiblJCWTJObGMzTkxaWGtvS1RvZ1VISnZiV2x6WlR4emRISnBibWMrSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY21WemRXeDBJRDBnWVhkaGFYUWdkR2hwY3k1ZmNYVmxjbWxsY3k1eGRXVnllU2duY1hWbGNubDdaMlYwVFdGdVlXZGxiV1Z1ZEVGalkyVnpjMHRsZVgwbktUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlISmxjM1ZzZEM1a1lYUmhMbWRsZEUxaGJtRm5aVzFsYm5SQlkyTmxjM05MWlhrN1hHNGdJQ0FnZlZ4dVhHNWNiaUFnSUNCaGMzbHVZeUJmY21WemIyeDJaVk5wWjI1bFpFMWhibUZuWlcxbGJuUkJZMk5sYzNOTFpYa29YRzRnSUNBZ0lDQWdJSEJoY21GdGN6b2dWRTlPUVdOalpYTnpTMlY1YzAxaGJtRm5aVzFsYm5SUVlYSmhiWE1zWEc0Z0lDQWdLVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tIQmhjbUZ0Y3k1emFXZHVaV1JOWVc1aFoyVnRaVzUwUVdOalpYTnpTMlY1S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdjR0Z5WVcxekxuTnBaMjVsWkUxaGJtRm5aVzFsYm5SQlkyTmxjM05MWlhrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2MybG5ia3RsZVhNZ1BTQndZWEpoYlhNdVlXTmpiM1Z1ZEV0bGVYTTdYRzRnSUNBZ0lDQWdJR2xtSUNoemFXZHVTMlY1Y3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdiV0Z1WVdkbGJXVnVkRUZqWTJWemMwdGxlU0E5SUdGM1lXbDBJSFJvYVhNdVoyVjBUV0Z1WVdkbGJXVnVkRUZqWTJWemMwdGxlU2dwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11WTNKNWNIUnZMbTVoWTJ4VGFXZHVLRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSHNnZEdWNGREb2diV0Z1WVdkbGJXVnVkRUZqWTJWemMwdGxlU0I5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdBa2UzTnBaMjVMWlhsekxuTmxZM0psZEgwa2UzTnBaMjVMWlhsekxuQjFZbXhwWTMxZ0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDZElaWGduTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnSnljN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdjbVZuYVhOMFpYSkJZMk5sYzNOTFpYbHpLRnh1SUNBZ0lDQWdJQ0J3WVhKaGJYTTZJRlJQVGxKbFoybHpkR1Z5UVdOalpYTnpTMlY1YzFCaGNtRnRjeXhjYmlBZ0lDQXBPaUJRY205dGFYTmxQRzUxYldKbGNqNGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQnphV2R1WldSTllXNWhaMlZ0Wlc1MFFXTmpaWE56UzJWNUlEMGdZWGRoYVhRZ2RHaHBjeTVmY21WemIyeDJaVk5wWjI1bFpFMWhibUZuWlcxbGJuUkJZMk5sYzNOTFpYa29jR0Z5WVcxektUdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NtVnpkV3gwSUQwZ1lYZGhhWFFnZEdocGN5NWZjWFZsY21sbGN5NXRkWFJoZEdsdmJpaGNiaUFnSUNBZ0lDQWdJQ0FnSUdCdGRYUmhkR2x2YmlCeVpXZHBjM1JsY2tGalkyVnpjMHRsZVhNb0pHRmpZMjkxYm5RNklGTjBjbWx1Wnl3Z0pHdGxlWE02SUZ0QlkyTmxjM05MWlhsZExDQWtjMmxuYm1Wa1RXRnVZV2RsYldWdWRFRmpZMlZ6YzB0bGVUb2dVM1J5YVc1bktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbFoybHpkR1Z5UVdOalpYTnpTMlY1Y3loaFkyTnZkVzUwT2lBa1lXTmpiM1Z1ZEN3Z2EyVjVjem9nSkd0bGVYTXNJSE5wWjI1bFpFMWhibUZuWlcxbGJuUkJZMk5sYzNOTFpYazZJQ1J6YVdkdVpXUk5ZVzVoWjJWdFpXNTBRV05qWlhOelMyVjVLVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFnTENCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lXTmpiM1Z1ZERvZ2NHRnlZVzF6TG1GalkyOTFiblFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYTJWNWN6b2djR0Z5WVcxekxtdGxlWE1zWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJsbmJtVmtUV0Z1WVdkbGJXVnVkRUZqWTJWemMwdGxlU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIMHNYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ5WlhOMWJIUXVaR0YwWVM1eVpXZHBjM1JsY2tGalkyVnpjMHRsZVhNN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdjbVYyYjJ0bFFXTmpaWE56UzJWNWN5aGNiaUFnSUNBZ0lDQWdjR0Z5WVcxek9pQlVUMDVTWlhadmEyVkJZMk5sYzNOTFpYbHpVR0Z5WVcxekxGeHVJQ0FnSUNrNklGQnliMjFwYzJVOGJuVnRZbVZ5UGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhOcFoyNWxaRTFoYm1GblpXMWxiblJCWTJObGMzTkxaWGtnUFNCaGQyRnBkQ0IwYUdsekxsOXlaWE52YkhabFUybG5ibVZrVFdGdVlXZGxiV1Z1ZEVGalkyVnpjMHRsZVNod1lYSmhiWE1wTzF4dUlDQWdJQ0FnSUNCamIyNXpkQ0J5WlhOMWJIUWdQU0JoZDJGcGRDQjBhR2x6TGw5eGRXVnlhV1Z6TG0xMWRHRjBhVzl1S0Z4dUlDQWdJQ0FnSUNBZ0lDQWdZRzExZEdGMGFXOXVJSEpsZG05clpVRmpZMlZ6YzB0bGVYTW9KR0ZqWTI5MWJuUTZJRk4wY21sdVp5d2dKR3RsZVhNNklGdFRkSEpwYm1kZExDQWtjMmxuYm1Wa1RXRnVZV2RsYldWdWRFRmpZMlZ6YzB0bGVUb2dVM1J5YVc1bktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRtOXJaVUZqWTJWemMwdGxlWE1vWVdOamIzVnVkRG9nSkdGalkyOTFiblFzSUd0bGVYTTZJQ1JyWlhsekxDQnphV2R1WldSTllXNWhaMlZ0Wlc1MFFXTmpaWE56UzJWNU9pQWtjMmxuYm1Wa1RXRnVZV2RsYldWdWRFRmpZMlZ6YzB0bGVTbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlZQ3dnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdGalkyOTFiblE2SUhCaGNtRnRjeTVoWTJOdmRXNTBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3RsZVhNNklIQmhjbUZ0Y3k1clpYbHpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSE5wWjI1bFpFMWhibUZuWlcxbGJuUkJZMk5sYzNOTFpYa3NYRzRnSUNBZ0lDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdjbVZ6ZFd4MExtUmhkR0V1Y21WMmIydGxRV05qWlhOelMyVjVjenRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0Z5ZEZKdmIzUlRjR0Z1S0hSeVlXTmxTV1E2SUhOMGNtbHVaeXdnYzNCaGJrbGtPaUJ6ZEhKcGJtY3NJRzl3WlhKaGRHbHZiazVoYldVNklITjBjbWx1WnlrNklGTndZVzRnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0IwY21GalpYSWdQU0IwYUdsekxtTnZibVpwWnk1MGNtRmpaWEk3WEc0Z0lDQWdJQ0FnSUd4bGRDQnpjR0Z1T2lBL1UzQmhiaUE5SUc1MWJHdzdYRzRnSUNBZ0lDQWdJR2xtSUNoMGNtRmpaWEl1WDNOMFlYSjBTVzUwWlhKdVlXeFRjR0Z1S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdOMGVDQTlJSFJ5WVdObGNpNWxlSFJ5WVdOMEtFWlBVazFCVkY5VVJWaFVYMDFCVUN3Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FuZFdKbGNpMTBjbUZqWlMxcFpDYzZJR0FrZTNSeVlXTmxTV1I5T2lSN2MzQmhia2xrZlRvd09qRmdMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaGpkSGdwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjM0JoYmlBOUlIUm9hWE11WTI5dVptbG5MblJ5WVdObGNpNWZjM1JoY25SSmJuUmxjbTVoYkZOd1lXNG9YRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpkSGdzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J2Y0dWeVlYUnBiMjVPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1JHRjBaUzV1YjNjb0tTd2dMeThnYzNSaGNuUlVhVzFsWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IxYm1SbFptbHVaV1FzSUM4dklIVnpaWEpVWVdkelhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCN2ZTd2dMeThnYVc1MFpYSnVZV3hVWVdkelhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYlhTd2dMeThnY21WbVpYSmxibU5sYzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWm1Gc2MyVXNJQzh2SUdoaGMxWmhiR2xrVUdGeVpXNTBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1ZV3h6WlN3Z0x5OGdhWE5TY0dOVFpYSjJaWEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCOUlHTmhkR05vSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QjBjbUZqWlhJZ1kyRnVKM1FnWTNKbFlYUmxJRzFsYzNOaFoyVWdjM0JoYmlCMWMybHVaeUJ3Y21sMllYUmxJRzFsZEdodlpDeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJ6YnlCM1pTQmhjbVVnWm1Gc2JHSmhZMnNnZEc4Z1kzSmxZWFJsSUhOd1lXNGdkWE5wYm1jZ2NtVm5kV3hoY2lCdFpYUm9iMlJjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdjM0JoYmlCOGZDQjBjbUZqWlhJdWMzUmhjblJUY0dGdUtHOXdaWEpoZEdsdmJrNWhiV1VwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklIUnlZV05sUEZRK0tGeHVJQ0FnSUNBZ0lDQnVZVzFsT2lCemRISnBibWNzWEc0Z0lDQWdJQ0FnSUdZNklDaHpjR0Z1T2lCVGNHRnVLU0E5UGlCUWNtOXRhWE5sUEZRK0xGeHVJQ0FnSUNBZ0lDQndZWEpsYm5SVGNHRnVQem9nS0ZOd1lXNGdmQ0JUY0dGdVEyOXVkR1Y0ZENrc1hHNGdJQ0FnS1RvZ1VISnZiV2x6WlR4VVBpQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElITndZVzRnUFNCMGFHbHpMbU52Ym1acFp5NTBjbUZqWlhJdWMzUmhjblJUY0dGdUtHNWhiV1VzSUhzZ1kyaHBiR1JQWmpvZ2NHRnlaVzUwVTNCaGJpQjlLVHRjYmlBZ0lDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhOd1lXNHVjMlYwVkdGbktGUmhaM011VTFCQlRsOUxTVTVFTENBblkyeHBaVzUwSnlrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnlaWE4xYkhRZ1BTQmhkMkZwZENCbUtITndZVzRwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hKbGMzVnNkQ0FoUFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjM0JoYmk1elpYUlVZV2NvSjNKbGMzVnNkQ2NzSUhKbGMzVnNkQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCemNHRnVMbVpwYm1semFDZ3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhKbGMzVnNkRHRjYmlBZ0lDQWdJQ0FnZlNCallYUmphQ0FvWlhKeWIzSXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lITndZVzR1Ykc5bktIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxkbVZ1ZERvZ0oyWmhhV3hsWkNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NHRjViRzloWkRvZ1pYSnliM0lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lITndZVzR1Wm1sdWFYTm9LQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCbGNuSnZjanRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUVsdWRHVnlibUZzYzF4dVhHNGdJQ0FnYzNSaGRHbGpJR05zYVdWdWRGQnNZWFJtYjNKdE9pQS9WRTlPUTJ4cFpXNTBVR3hoZEdadmNtMGdQU0J1ZFd4c08xeHVJQ0FnSUhOMFlYUnBZeUJqYjNKbFRHbGljbUZ5ZVRvZ1AxUlBUa05zYVdWdWRFTnZjbVZNYVdKeVlYSjVJRDBnYm5Wc2JEdGNibHh1SUNBZ0lHMXZaSFZzWlhNNklFMWhjRHh6ZEhKcGJtY3NJRlJQVGsxdlpIVnNaVDQ3WEc1OVhHNGlYWDA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRPTkNsaWVudEVycm9yID0gZXhwb3J0cy5UT05Db250cmFjdEV4aXRDb2RlID0gZXhwb3J0cy5UT05FcnJvckNvZGUgPSBleHBvcnRzLlRPTkVycm9yU291cmNlID0gZXhwb3J0cy5lbXB0eVRPTkVycm9yRGF0YSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGVtcHR5VE9ORXJyb3JEYXRhID0ge1xuICBjb3JlX3ZlcnNpb246ICcnLFxuICBjb25maWdfc2VydmVyOiAnJyxcbiAgcXVlcnlfdXJsOiAnJ1xufTtcbmV4cG9ydHMuZW1wdHlUT05FcnJvckRhdGEgPSBlbXB0eVRPTkVycm9yRGF0YTtcbnZhciBUT05FcnJvclNvdXJjZSA9IHtcbiAgQ0xJRU5UOiAnY2xpZW50JyxcbiAgTk9ERTogJ25vZGUnXG59O1xuZXhwb3J0cy5UT05FcnJvclNvdXJjZSA9IFRPTkVycm9yU291cmNlO1xudmFyIFRPTkVycm9yQ29kZSA9IHtcbiAgQ0xJRU5UX0lTX05PVF9TRVRVUDogMTAwMCxcbiAgU0VORF9OT0RFX1JFUVVFU1RfRkFJTEVEOiAxMDAxLFxuICBNRVNTQUdFX0FMUkVBRFlfRVhQSVJFRDogMTAwMSxcbiAgUlVOX0xPQ0FMX0FDQ09VTlRfRE9FU19OT1RfRVhJU1RTOiAxMDAyLFxuICBXQUlUX0ZPUl9USU1FT1VUOiAxMDAzLFxuICBJTlRFUk5BTF9FUlJPUjogMTAwNCxcbiAgUVVFUllfRkFJTEVEOiAxMDA1LFxuICBNRVNTQUdFX0VYUElSRUQ6IDEwMDYsXG4gIFNFUlZFUl9ET0VTTlRfU1VQUE9SVF9BR0dSRUdBVElPTlM6IDEwMDcsXG4gIElOVkFMSURfQ09OUzogMTAwOCxcbiAgQUREUkVTU19SRVFVSVJFRF9GT1JfUlVOX0xPQ0FMOiAxMDA5LFxuICBORVRXT1JLX1NJTEVOVDogMTAxMCxcbiAgVFJBTlNBQ1RJT05fTEFHOiAxMDExLFxuICBUUkFOU0FDVElPTl9XQUlUX1RJTUVPVVQ6IDEwMTIsXG4gIENMT0NLX09VVF9PRl9TWU5DOiAxMDEzLFxuICBBQ0NPVU5UX01JU1NJTkc6IDEwMTQsXG4gIEFDQ09VTlRfQ09ERV9NSVNTSU5HOiAxMDE1LFxuICBBQ0NPVU5UX0JBTEFOQ0VfVE9PX0xPVzogMTAxNixcbiAgQUNDT1VOVF9GUk9aRU5fT1JfREVMRVRFRDogMTAxNyxcbiAgLy8gQ3J5cHRvXG4gIFNJR05JTkdfU09VUkNFX0lTX05PVF9TUEVDSUZJRUQ6IDIwMjEsXG4gIElOVkFMSURfQ1JZUFRPX0JPWF9QQVJBTVM6IDIwMzAsXG4gIC8vIENvbnRyYWN0c1xuICBDT05UUkFDVF9FWEVDVVRJT05fRkFJTEVEOiAzMDI1LFxuICAvLyBRdWVyaWVzXG4gIFFVRVJZX0ZPUkNJQkxZX0FCT1JURUQ6IDQwMDVcbn07XG5leHBvcnRzLlRPTkVycm9yQ29kZSA9IFRPTkVycm9yQ29kZTtcbnZhciBUT05Db250cmFjdEV4aXRDb2RlID0ge1xuICBSRVBMQVlfUFJPVEVDVElPTjogNTIsXG4gIE1FU1NBR0VfRVhQSVJFRDogNTcsXG4gIE5PX0dBUzogMTNcbn07XG5leHBvcnRzLlRPTkNvbnRyYWN0RXhpdENvZGUgPSBUT05Db250cmFjdEV4aXRDb2RlO1xuXG52YXIgVE9OQ2xpZW50RXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUT05DbGllbnRFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhLCBzb3VyY2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVE9OQ2xpZW50RXJyb3IpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic291cmNlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSB8fCBUT05FcnJvclNvdXJjZS5DTElFTlQ7XG4gIH0gLy8gVGVzdGVyc1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRPTkNsaWVudEVycm9yLCBudWxsLCBbe1xuICAgIGtleTogXCJpc0NsaWVudEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ2xpZW50RXJyb3IoZXJyb3IsIGNvZGUpIHtcbiAgICAgIHJldHVybiBlcnJvci5zb3VyY2UgPT09IFRPTkVycm9yU291cmNlLkNMSUVOVCAmJiBlcnJvci5jb2RlID09PSBjb2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc05vZGVFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc05vZGVFcnJvcihlcnJvciwgY29kZSkge1xuICAgICAgcmV0dXJuIGVycm9yLnNvdXJjZSA9PT0gVE9ORXJyb3JTb3VyY2UuTk9ERSAmJiBlcnJvci5jb2RlID09PSBjb2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0NvbnRyYWN0RXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDb250cmFjdEVycm9yKGVycm9yLCBleGl0Q29kZSkge1xuICAgICAgcmV0dXJuIGVycm9yLnNvdXJjZSA9PT0gVE9ORXJyb3JTb3VyY2UuTk9ERSAmJiBlcnJvci5jb2RlID09PSBUT05FcnJvckNvZGUuQ09OVFJBQ1RfRVhFQ1VUSU9OX0ZBSUxFRCAmJiBlcnJvci5kYXRhICYmIGVycm9yLmRhdGEuZXhpdF9jb2RlID09PSBleGl0Q29kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPcmlnaW5hbENvbnRyYWN0RXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcmlnaW5hbENvbnRyYWN0RXJyb3IoZXJyb3IsIGV4aXRDb2RlKSB7XG4gICAgICB2YXIgX2Vycm9yJGRhdGE7XG5cbiAgICAgIHJldHVybiBUT05DbGllbnRFcnJvci5pc0NvbnRyYWN0RXJyb3IoZXJyb3IsIGV4aXRDb2RlKSAmJiAhKChfZXJyb3IkZGF0YSA9IGVycm9yLmRhdGEpID09PSBudWxsIHx8IF9lcnJvciRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3IkZGF0YS5vcmlnaW5hbF9lcnJvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUmVzb2x2ZWRDb250cmFjdEVycm9yQWZ0ZXJFeHBpcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZXNvbHZlZENvbnRyYWN0RXJyb3JBZnRlckV4cGlyZShlcnJvciwgZXhpdENvZGUpIHtcbiAgICAgIHJldHVybiBUT05DbGllbnRFcnJvci5pc0NvbnRyYWN0RXJyb3IoZXJyb3IsIGV4aXRDb2RlKSAmJiBlcnJvci5kYXRhICYmIGVycm9yLmRhdGEub3JpZ2luYWxfZXJyb3IgJiYgVE9OQ2xpZW50RXJyb3IuaXNNZXNzYWdlRXhwaXJlZChlcnJvci5kYXRhLm9yaWdpbmFsX2Vycm9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNNZXNzYWdlRXhwaXJlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01lc3NhZ2VFeHBpcmVkKGVycm9yKSB7XG4gICAgICByZXR1cm4gVE9OQ2xpZW50RXJyb3IuaXNDbGllbnRFcnJvcihlcnJvciwgVE9ORXJyb3JDb2RlLk1FU1NBR0VfRVhQSVJFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzV2FpdEZvclRpbWVvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNXYWl0Rm9yVGltZW91dChlcnJvcikge1xuICAgICAgcmV0dXJuIFRPTkNsaWVudEVycm9yLmlzQ2xpZW50RXJyb3IoZXJyb3IsIFRPTkVycm9yQ29kZS5XQUlUX0ZPUl9USU1FT1VUKTtcbiAgICB9IC8vIEJ1aWxkZXJzXG5cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcm5hbEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVybmFsRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihUT05FcnJvckNvZGUuSU5URVJOQUxfRVJST1IsIFwiSW50ZXJuYWwgZXJyb3I6IFwiLmNvbmNhdChtZXNzYWdlKSwgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRDb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRDb25zKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLklOVkFMSURfQ09OUywgJ0ludmFsaWQgQ09OUyBzdHJ1Y3R1cmUuIEVhY2ggQ09OUyBpdGVtIG11c3QgY29udGFpbnMgb2YgdHdvIGVsZW1lbnRzLicsIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kTm9kZVJlcXVlc3RGYWlsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZE5vZGVSZXF1ZXN0RmFpbGVkKHJlc3BvbnNlVGV4dCwgZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihUT05FcnJvckNvZGUuU0VORF9OT0RFX1JFUVVFU1RfRkFJTEVELCBcIlNlbmQgbm9kZSByZXF1ZXN0IGZhaWxlZDogXCIuY29uY2F0KHJlc3BvbnNlVGV4dCksIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJydW5Mb2NhbEFjY291bnREb2VzTm90RXhpc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bkxvY2FsQWNjb3VudERvZXNOb3RFeGlzdHMoZnVuY3Rpb25OYW1lLCBhZGRyZXNzLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5SVU5fTE9DQUxfQUNDT1VOVF9ET0VTX05PVF9FWElTVFMsIFwiW1wiLmNvbmNhdChmdW5jdGlvbk5hbWUsIFwiXSBydW4gbG9jYWwgZmFpbGVkOiBhY2NvdW50IFtcIikuY29uY2F0KGFkZHJlc3MsIFwiXSBkb2VzIG5vdCBleGlzdHNcIiksIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YWl0Rm9yVGltZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YWl0Rm9yVGltZW91dChkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5XQUlUX0ZPUl9USU1FT1VULCAnV2FpdCBmb3Igb3BlcmF0aW9uIHJlamVjdGVkIG9uIHRpbWVvdXQnLCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVlcnlGYWlsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcXVlcnlGYWlsZWQoZXJyb3JzLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5RVUVSWV9GQUlMRUQsIFwiUXVlcnkgZmFpbGVkOiBcIi5jb25jYXQoZXJyb3JzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5tZXNzYWdlIHx8IHgudG9TdHJpbmcoKTtcbiAgICAgIH0pLmpvaW4oJ1xcbicpKSwgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0VGltZSh0aW1lKSB7XG4gICAgICBpZiAodGltZSkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQobmV3IERhdGUodGltZSAqIDEwMDApLnRvSVNPU3RyaW5nKCksIFwiIChcIikuY29uY2F0KHRpbWUsIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lc3NhZ2VFeHBpcmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lc3NhZ2VFeHBpcmVkKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLk1FU1NBR0VfRVhQSVJFRCwgJ01lc3NhZ2UgZXhwaXJlZCcsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGF0YSksIHt9LCB7XG4gICAgICAgIHNlbmRpbmdfdGltZTogVE9OQ2xpZW50RXJyb3IuZm9ybWF0VGltZShkYXRhLnNlbmRpbmdfdGltZSksXG4gICAgICAgIGV4cGlyYXRpb25fdGltZTogVE9OQ2xpZW50RXJyb3IuZm9ybWF0VGltZShkYXRhLmV4cGlyZSksXG4gICAgICAgIGJsb2NrX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5ibG9ja190aW1lKVxuICAgICAgfSksIFRPTkVycm9yU291cmNlLkNMSUVOVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcnZlckRvZXNudFN1cHBvcnRBZ2dyZWdhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VydmVyRG9lc250U3VwcG9ydEFnZ3JlZ2F0aW9ucyhkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5TRVJWRVJfRE9FU05UX1NVUFBPUlRfQUdHUkVHQVRJT05TLCAnU2VydmVyIGRvZXNuXFwndCBzdXBwb3J0IGFnZ3JlZ2F0aW9ucycsIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRyZXNzUmVxdWlyZWRGb3JSdW5Mb2NhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRyZXNzUmVxdWlyZWRGb3JSdW5Mb2NhbChkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5BRERSRVNTX1JFUVVJUkVEX0ZPUl9SVU5fTE9DQUwsICdBZGRyZXNzIHJlcXVpcmVkIGZvciBydW4gbG9jYWwuIFlvdSBoYXZlblxcJ3Qgc3BlY2lmaWVkIGNvbnRyYWN0IGNvZGUgb3IgZGF0YSAnICsgJ3NvIGFkZHJlc3MgaXMgcmVxdWlyZWQgdG8gbG9hZCBtaXNzaW5nIHBhcnRzIGZyb20gbmV0d29yay4nLCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV0d29ya1NpbGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXR3b3JrU2lsZW50KGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLk5FVFdPUktfU0lMRU5ULCAnTmV0d29yayBzaWxlbnQ6IG5vIGJsb2NrcyBwcm9kdWNlZCBkdXJpbmcgdGltZW91dC4nLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRhdGEpLCB7fSwge1xuICAgICAgICBzZW5kaW5nX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5zZW5kaW5nX3RpbWUpLFxuICAgICAgICBleHBpcmF0aW9uX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5leHBpcmUpXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zYWN0aW9uV2FpdFRpbWVvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNhY3Rpb25XYWl0VGltZW91dChkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5UUkFOU0FDVElPTl9XQUlUX1RJTUVPVVQsICdUcmFuc2FjdGlvbiBkaWQgbm90IHByb2R1Y2VkIGR1cmluZyBzcGVjaWZpZWQgdGltZW91dCcsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGF0YSksIHt9LCB7XG4gICAgICAgIHNlbmRpbmdfdGltZTogVE9OQ2xpZW50RXJyb3IuZm9ybWF0VGltZShkYXRhLnNlbmRpbmdfdGltZSlcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvY2tPdXRPZlN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvY2tPdXRPZlN5bmMoZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihUT05FcnJvckNvZGUuQ0xPQ0tfT1VUX09GX1NZTkMsICdZb3UgbG9jYWwgY2xvY2sgaXMgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmVyIHRpbWUuICcgKyAnSXQgaXMgYSBjcml0aWNhbCBjb25kaXRpb24gZm9yIHNlbmRpbmcgbWVzc2FnZXMgdG8gdGhlIGJsb2NrY2hhaW4uICcgKyAnUGxlYXNlIHN5bmMgeW91IGNsb2NrIHdpdGggdGhlIGludGVybmV0IHRpbWUuJywgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFjY291bnRNaXNzaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY291bnRNaXNzaW5nKGFkZHJlc3MsIGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLkFDQ09VTlRfTUlTU0lORywgXCJBY2NvdW50IHdpdGggYWRkcmVzcyBbXCIuY29uY2F0KGFkZHJlc3MsIFwiXSBkb2Vzbid0IGV4aXN0cy4gXCIpICsgJ1lvdSBoYXZlIHRvIHByZXBhaWQgdGhpcyBhY2NvdW50IHRvIGhhdmUgYSBwb3NpdGl2ZSBiYWxhbmNlIG9uIHRoZW0gYW5kIHRoZW4gZGVwbG95ICcgKyAnYSBjb250cmFjdCBjb2RlIGZvciB0aGlzIGFjY291bnQuJyArICdTZWUgU0RLIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbGVkIGluc3RydWN0aW9ucy4nLCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWNjb3VudENvZGVNaXNzaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY291bnRDb2RlTWlzc2luZyhhZGRyZXNzLCBiYWxhbmNlLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5BQ0NPVU5UX0NPREVfTUlTU0lORywgXCJBY2NvdW50IHdpdGggYWRkcmVzcyBbXCIuY29uY2F0KGFkZHJlc3MsIFwiXSBleGlzdHMgYnV0IGhhdmVuJ3QgYSBjb250cmFjdCBjb2RlIHlldC4gXCIpICsgJ1lvdSBoYXZlIHRvIGVuc3VyZSB0aGF0IGFuIGFjY291bnQgaGFzIGFuIGVub3VnaCBiYWxhbmNlIGZvciBkZXBsb3lpbmcgJyArICdhIGNvbnRyYWN0IGNvZGUgYW5kIHRoZW4gZGVwbG95IGEgY29udHJhY3QgY29kZSBmb3IgdGhpcyBhY2NvdW50LiAnICsgXCJDdXJyZW50IGFjY291bnQgYmFsYW5jZSBpcyBbXCIuY29uY2F0KGJhbGFuY2UsIFwiXS4gXCIpICsgJ1NlZSBTREsgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlsZWQgaW5zdHJ1Y3Rpb25zLicsIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhY2NvdW50QmFsYW5jZVRvb0xvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NvdW50QmFsYW5jZVRvb0xvdyhhZGRyZXNzLCBiYWxhbmNlLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5BQ0NPVU5UX0JBTEFOQ0VfVE9PX0xPVywgXCJBY2NvdW50IHdpdGggYWRkcmVzcyBbXCIuY29uY2F0KGFkZHJlc3MsIFwiXSBoYXMgdG9vIGxvdyBiYWxhbmNlIFtcIikuY29uY2F0KGJhbGFuY2UsIFwiXS4gXCIpICsgJ1lvdSBoYXZlIHRvIHNlbmQgc29tZSB2YWx1ZSB0byBhY2NvdW50IGJhbGFuY2UgZnJvbSBvdGhlciBjb250cmFjdCAnICsgJyhlLmcuIFdhbGxldCBjb250cmFjdCkuICcgKyAnU2VlIFNESyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxlZCBpbnN0cnVjdGlvbnMuJywgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vQmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vQmxvY2tzKHdvcmtjaGFpbiwgZGF0YSkge1xuICAgICAgdmFyIHdvcmtjaGFpbk5hbWUgPSB3b3JrY2hhaW4gPT09IC0xID8gJ21hc3RlcmNoYWluJyA6IFwid29ya2NoYWluIFwiLmNvbmNhdCh3b3JrY2hhaW4pO1xuICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihUT05FcnJvckNvZGUuTkVUV09SS19TSUxFTlQsIFwiXFxcIk5vIGJsb2NrcyBmb3IgXCIuY29uY2F0KHdvcmtjaGFpbk5hbWUsIFwiIGZvdW5kXFxcIi5cIiksIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkQmxvY2tjaGFpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkQmxvY2tjaGFpbihtZXNzYWdlLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFRPTkVycm9yQ29kZS5ORVRXT1JLX1NJTEVOVCwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInF1ZXJ5Rm9yY2libHlBYm9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5Rm9yY2libHlBYm9ydGVkKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLlFVRVJZX0ZPUkNJQkxZX0FCT1JURUQsICdHcmFwaFFMIHF1ZXJ5IHdhcyBmb3JjaWJseSBhYm9ydGVkIG9uIHRpbWVvdXQuJywgZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpZ25pbmdTb3VyY2VJc05vdFNwZWNpZmllZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduaW5nU291cmNlSXNOb3RTcGVjaWZpZWQoKSB7XG4gICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIHNpZ25pbmcga2V5cyBvciBzaWduaW5nIGJveCB0byBzaWduIHlvdSBtZXNzYWdlLicsIFRPTkVycm9yQ29kZS5TSUdOSU5HX1NPVVJDRV9JU19OT1RfU1BFQ0lGSUVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZENyeXB0b0JveFBhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkQ3J5cHRvQm94UGFyYW1zKGVuY3J5cHRlZFNlZWRQaHJhc2UpIHtcbiAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBlbmNyeXB0ZWQgc2VlZCBwaHJhc2UgdG8gY3JlYXRlIGEgY29yZSBjcnlwdG8gYm94LiAnICsgXCJQcm92aWRlZCBwaHJhc2UgaXM6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShlbmNyeXB0ZWRTZWVkUGhyYXNlKSwgXCIuXCIpLCBUT05FcnJvckNvZGUuSU5WQUxJRF9DUllQVE9fQk9YX1BBUkFNUyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsaWVudElzTm90U2V0dXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpZW50SXNOb3RTZXR1cCgpIHtcbiAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLkNMSUVOVF9JU19OT1RfU0VUVVAsICdUT04gQ2xpZW50IExpYnJhcnkgaXNuXFwndCBzZXQgdXAgcHJvcGVybHknLCBlbXB0eVRPTkVycm9yRGF0YSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRPTkNsaWVudEVycm9yO1xufSgpO1xuXG5leHBvcnRzLlRPTkNsaWVudEVycm9yID0gVE9OQ2xpZW50RXJyb3I7XG5cbl9kZWZpbmVQcm9wZXJ0eShUT05DbGllbnRFcnJvciwgXCJzb3VyY2VcIiwgVE9ORXJyb3JTb3VyY2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoVE9OQ2xpZW50RXJyb3IsIFwiY29kZVwiLCBUT05FcnJvckNvZGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTlVVDA1RGJHbGxiblJGY25KdmNpNXFjeUpkTENKdVlXMWxjeUk2V3lKbGJYQjBlVlJQVGtWeWNtOXlSR0YwWVNJc0ltTnZjbVZmZG1WeWMybHZiaUlzSW1OdmJtWnBaMTl6WlhKMlpYSWlMQ0p4ZFdWeWVWOTFjbXdpTENKVVQwNUZjbkp2Y2xOdmRYSmpaU0lzSWtOTVNVVk9WQ0lzSWs1UFJFVWlMQ0pVVDA1RmNuSnZja052WkdVaUxDSkRURWxGVGxSZlNWTmZUazlVWDFORlZGVlFJaXdpVTBWT1JGOU9UMFJGWDFKRlVWVkZVMVJmUmtGSlRFVkVJaXdpVFVWVFUwRkhSVjlCVEZKRlFVUlpYMFZZVUVsU1JVUWlMQ0pTVlU1ZlRFOURRVXhmUVVORFQxVk9WRjlFVDBWVFgwNVBWRjlGV0VsVFZGTWlMQ0pYUVVsVVgwWlBVbDlVU1UxRlQxVlVJaXdpU1U1VVJWSk9RVXhmUlZKU1QxSWlMQ0pSVlVWU1dWOUdRVWxNUlVRaUxDSk5SVk5UUVVkRlgwVllVRWxTUlVRaUxDSlRSVkpXUlZKZlJFOUZVMDVVWDFOVlVGQlBVbFJmUVVkSFVrVkhRVlJKVDA1VElpd2lTVTVXUVV4SlJGOURUMDVUSWl3aVFVUkVVa1ZUVTE5U1JWRlZTVkpGUkY5R1QxSmZVbFZPWDB4UFEwRk1JaXdpVGtWVVYwOVNTMTlUU1V4RlRsUWlMQ0pVVWtGT1UwRkRWRWxQVGw5TVFVY2lMQ0pVVWtGT1UwRkRWRWxQVGw5WFFVbFVYMVJKVFVWUFZWUWlMQ0pEVEU5RFMxOVBWVlJmVDBaZlUxbE9ReUlzSWtGRFEwOVZUbFJmVFVsVFUwbE9SeUlzSWtGRFEwOVZUbFJmUTA5RVJWOU5TVk5UU1U1SElpd2lRVU5EVDFWT1ZGOUNRVXhCVGtORlgxUlBUMTlNVDFjaUxDSkJRME5QVlU1VVgwWlNUMXBGVGw5UFVsOUVSVXhGVkVWRUlpd2lVMGxIVGtsT1IxOVRUMVZTUTBWZlNWTmZUazlVWDFOUVJVTkpSa2xGUkNJc0lrbE9Wa0ZNU1VSZlExSlpVRlJQWDBKUFdGOVFRVkpCVFZNaUxDSkRUMDVVVWtGRFZGOUZXRVZEVlZSSlQwNWZSa0ZKVEVWRUlpd2lVVlZGVWxsZlJrOVNRMGxDVEZsZlFVSlBVbFJGUkNJc0lsUlBUa052Ym5SeVlXTjBSWGhwZEVOdlpHVWlMQ0pTUlZCTVFWbGZVRkpQVkVWRFZFbFBUaUlzSWs1UFgwZEJVeUlzSWxSUFRrTnNhV1Z1ZEVWeWNtOXlJaXdpWTI5a1pTSXNJbTFsYzNOaFoyVWlMQ0prWVhSaElpd2ljMjkxY21ObElpd2laWEp5YjNJaUxDSmxlR2wwUTI5a1pTSXNJbVY0YVhSZlkyOWtaU0lzSW1selEyOXVkSEpoWTNSRmNuSnZjaUlzSW05eWFXZHBibUZzWDJWeWNtOXlJaXdpYVhOTlpYTnpZV2RsUlhod2FYSmxaQ0lzSW1selEyeHBaVzUwUlhKeWIzSWlMQ0p5WlhOd2IyNXpaVlJsZUhRaUxDSm1kVzVqZEdsdmJrNWhiV1VpTENKaFpHUnlaWE56SWl3aVpYSnliM0p6SWl3aWJXRndJaXdpZUNJc0luUnZVM1J5YVc1bklpd2lhbTlwYmlJc0luUnBiV1VpTENKRVlYUmxJaXdpZEc5SlUwOVRkSEpwYm1jaUxDSnpaVzVrYVc1blgzUnBiV1VpTENKbWIzSnRZWFJVYVcxbElpd2laWGh3YVhKaGRHbHZibDkwYVcxbElpd2laWGh3YVhKbElpd2lZbXh2WTJ0ZmRHbHRaU0lzSW1KaGJHRnVZMlVpTENKM2IzSnJZMmhoYVc0aUxDSjNiM0pyWTJoaGFXNU9ZVzFsSWl3aVpXNWpjbmx3ZEdWa1UyVmxaRkJvY21GelpTSXNJa3BUVDA0aUxDSnpkSEpwYm1kcFpua2lYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3pzN096czdPenM3T3pzN1FVRlRUeXhKUVVGTlFTeHBRa0ZCSzBJc1IwRkJSenRCUVVNelEwTXNSVUZCUVVFc1dVRkJXU3hGUVVGRkxFVkJSRFpDTzBGQlJUTkRReXhGUVVGQlFTeGhRVUZoTEVWQlFVVXNSVUZHTkVJN1FVRkhNME5ETEVWQlFVRkJMRk5CUVZNc1JVRkJSVHRCUVVoblF5eERRVUY0UXpzN1FVRk5RU3hKUVVGTlF5eGpRVUZqTEVkQlFVYzdRVUZETVVKRExFVkJRVUZCTEUxQlFVMHNSVUZCUlN4UlFVUnJRanRCUVVVeFFrTXNSVUZCUVVFc1NVRkJTU3hGUVVGRk8wRkJSbTlDTEVOQlFYWkNPenRCUVV0QkxFbEJRVTFETEZsQlFWa3NSMEZCUnp0QlFVTjRRa01zUlVGQlFVRXNiVUpCUVcxQ0xFVkJRVVVzU1VGRVJ6dEJRVVY0UWtNc1JVRkJRVUVzZDBKQlFYZENMRVZCUVVVc1NVRkdSanRCUVVkNFFrTXNSVUZCUVVFc2RVSkJRWFZDTEVWQlFVVXNTVUZJUkR0QlFVbDRRa01zUlVGQlFVRXNhVU5CUVdsRExFVkJRVVVzU1VGS1dEdEJRVXQ0UWtNc1JVRkJRVUVzWjBKQlFXZENMRVZCUVVVc1NVRk1UVHRCUVUxNFFrTXNSVUZCUVVFc1kwRkJZeXhGUVVGRkxFbEJUbEU3UVVGUGVFSkRMRVZCUVVGQkxGbEJRVmtzUlVGQlJTeEpRVkJWTzBGQlVYaENReXhGUVVGQlFTeGxRVUZsTEVWQlFVVXNTVUZTVHp0QlFWTjRRa01zUlVGQlFVRXNhME5CUVd0RExFVkJRVVVzU1VGVVdqdEJRVlY0UWtNc1JVRkJRVUVzV1VGQldTeEZRVUZGTEVsQlZsVTdRVUZYZUVKRExFVkJRVUZCTERoQ1FVRTRRaXhGUVVGRkxFbEJXRkk3UVVGWmVFSkRMRVZCUVVGQkxHTkJRV01zUlVGQlJTeEpRVnBSTzBGQllYaENReXhGUVVGQlFTeGxRVUZsTEVWQlFVVXNTVUZpVHp0QlFXTjRRa01zUlVGQlFVRXNkMEpCUVhkQ0xFVkJRVVVzU1VGa1JqdEJRV1Y0UWtNc1JVRkJRVUVzYVVKQlFXbENMRVZCUVVVc1NVRm1TenRCUVdkQ2VFSkRMRVZCUVVGQkxHVkJRV1VzUlVGQlJTeEpRV2hDVHp0QlFXbENlRUpETEVWQlFVRkJMRzlDUVVGdlFpeEZRVUZGTEVsQmFrSkZPMEZCYTBKNFFrTXNSVUZCUVVFc2RVSkJRWFZDTEVWQlFVVXNTVUZzUWtRN1FVRnRRbmhDUXl4RlFVRkJRU3g1UWtGQmVVSXNSVUZCUlN4SlFXNUNTRHRCUVhGQ2VFSTdRVUZGUVVNc1JVRkJRVUVzSzBKQlFTdENMRVZCUVVVc1NVRjJRbFE3UVVGM1FuaENReXhGUVVGQlFTeDVRa0ZCZVVJc1JVRkJSU3hKUVhoQ1NEdEJRVEJDZUVJN1FVRkZRVU1zUlVGQlFVRXNlVUpCUVhsQ0xFVkJRVVVzU1VFMVFrZzdRVUU0UW5oQ08wRkJSVUZETEVWQlFVRkJMSE5DUVVGelFpeEZRVUZGTzBGQmFFTkJMRU5CUVhKQ096dEJRVzFEUVN4SlFVRk5ReXh0UWtGQmJVSXNSMEZCUnp0QlFVTXZRa01zUlVGQlFVRXNhVUpCUVdsQ0xFVkJRVVVzUlVGRVdUdEJRVVV2UW1wQ0xFVkJRVUZCTEdWQlFXVXNSVUZCUlN4RlFVWmpPMEZCUnk5Q2EwSXNSVUZCUVVFc1RVRkJUU3hGUVVGRk8wRkJTSFZDTEVOQlFUVkNPenM3U1VGTlRVTXNZenRCUVZOVUxEQkNRVU5KUXl4SlFVUktMRVZCUlVsRExFOUJSa29zUlVGSFNVTXNTVUZJU2l4RlFVbEpReXhOUVVwS0xFVkJTMFU3UVVGQlFUczdRVUZCUVRzN1FVRkJRVHM3UVVGQlFUczdRVUZCUVRzN1FVRkRSU3hUUVVGTFNDeEpRVUZNTEVkQlFWbEJMRWxCUVZvN1FVRkRRU3hUUVVGTFF5eFBRVUZNTEVkQlFXVkJMRTlCUVdZN1FVRkRRU3hUUVVGTFF5eEpRVUZNTEVkQlFWbEJMRWxCUVZvN1FVRkRRU3hUUVVGTFF5eE5RVUZNTEVkQlFXTkJMRTFCUVUwc1NVRkJTV3hETEdOQlFXTXNRMEZCUTBNc1RVRkJka003UVVGRFNDeEhMRU5CUlVRN096czdPMnREUVVWeFFtdERMRXNzUlVGQldVb3NTU3hGUVVGMVFqdEJRVU53UkN4aFFVRlJTU3hMUVVGTExFTkJRVU5FTEUxQlFVNHNTMEZCYVVKc1F5eGpRVUZqTEVOQlFVTkRMRTFCUVdwRExFbEJRME5yUXl4TFFVRkxMRU5CUVVOS0xFbEJRVTRzUzBGQlpVRXNTVUZFZGtJN1FVRkZTRHM3TzJkRFFVVnJRa2tzU3l4RlFVRlpTaXhKTEVWQlFYVkNPMEZCUTJ4RUxHRkJRVkZKTEV0QlFVc3NRMEZCUTBRc1RVRkJUaXhMUVVGcFFteERMR05CUVdNc1EwRkJRMFVzU1VGQmFrTXNTVUZEUTJsRExFdEJRVXNzUTBGQlEwb3NTVUZCVGl4TFFVRmxRU3hKUVVSMlFqdEJRVVZJT3pzN2IwTkJSWE5DU1N4TExFVkJRVmxETEZFc1JVRkJNa0k3UVVGRE1VUXNZVUZCVVVRc1MwRkJTeXhEUVVGRFJDeE5RVUZPTEV0QlFXbENiRU1zWTBGQll5eERRVUZEUlN4SlFVRnFReXhKUVVORGFVTXNTMEZCU3l4RFFVRkRTaXhKUVVGT0xFdEJRV1UxUWl4WlFVRlpMRU5CUVVOelFpeDVRa0ZFTjBJc1NVRkZRMVVzUzBGQlN5eERRVUZEUml4SlFVRk9MRWxCUVdORkxFdEJRVXNzUTBGQlEwWXNTVUZCVGl4RFFVRlhTU3hUUVVGWUxFdEJRWGxDUkN4UlFVWXZRenRCUVVkSU96czdORU5CUlRoQ1JDeExMRVZCUVZsRExGRXNSVUZCTWtJN1FVRkJRVHM3UVVGRGJFVXNZVUZCVDA0c1kwRkJZeXhEUVVGRFVTeGxRVUZtTEVOQlFTdENTQ3hMUVVFdlFpeEZRVUZ6UTBNc1VVRkJkRU1zUzBGRFF5eHBRa0ZCUTBRc1MwRkJTeXhEUVVGRFJpeEpRVUZRTEdkRVFVRkRMRmxCUVZsTkxHTkJRV0lzUTBGRVVqdEJRVVZJT3pzN2RVUkJSWGxEU2l4TExFVkJRVmxETEZFc1JVRkJNa0k3UVVGRE4wVXNZVUZCVDA0c1kwRkJZeXhEUVVGRFVTeGxRVUZtTEVOQlFTdENTQ3hMUVVFdlFpeEZRVUZ6UTBNc1VVRkJkRU1zUzBGRFEwUXNTMEZCU3l4RFFVRkRSaXhKUVVGT0xFbEJRV05GTEV0QlFVc3NRMEZCUTBZc1NVRkJUaXhEUVVGWFRTeGpRVUY2UWl4SlFVTkhWQ3hqUVVGakxFTkJRVU5WTEdkQ1FVRm1MRU5CUVdkRFRDeExRVUZMTEVOQlFVTkdMRWxCUVU0c1EwRkJWMDBzWTBGQk0wTXNRMEZHV0R0QlFVZElPenM3Y1VOQlJYVkNTaXhMTEVWQlFYRkNPMEZCUTNwRExHRkJRVTlNTEdOQlFXTXNRMEZCUTFjc1lVRkJaaXhEUVVFMlFrNHNTMEZCTjBJc1JVRkJiME5vUXl4WlFVRlpMRU5CUVVOUkxHVkJRV3BFTEVOQlFWQTdRVUZEU0RzN08zRkRRVVYxUW5kQ0xFc3NSVUZCY1VJN1FVRkRla01zWVVGQlQwd3NZMEZCWXl4RFFVRkRWeXhoUVVGbUxFTkJRVFpDVGl4TFFVRTNRaXhGUVVGdlEyaERMRmxCUVZrc1EwRkJRMHNzWjBKQlFXcEVMRU5CUVZBN1FVRkRTQ3hMTEVOQlJVUTdPenM3YTBOQlIwbDNRaXhQTEVWQlEwRkRMRWtzUlVGRFl6dEJRVU5rTEdGQlFVOHNTVUZCU1Vnc1kwRkJTaXhEUVVOSU0wSXNXVUZCV1N4RFFVRkRUU3hqUVVSV0xEUkNRVVZuUW5WQ0xFOUJSbWhDTEVkQlIwaERMRWxCU0Vjc1EwRkJVRHRCUVV0SU96czdaME5CUld0Q1FTeEpMRVZCUVc5RE8wRkJRMjVFTEdGQlFVOHNTVUZCU1Vnc1kwRkJTaXhEUVVOSU0wSXNXVUZCV1N4RFFVRkRWU3haUVVSV0xFVkJSVWdzZFVWQlJrY3NSVUZIU0c5Q0xFbEJTRWNzUTBGQlVEdEJRVXRJT3pzN01FTkJSMGRUTEZrc1JVRkRRVlFzU1N4RlFVTmpPMEZCUTJRc1lVRkJUeXhKUVVGSlNDeGpRVUZLTEVOQlEwZ3pRaXhaUVVGWkxFTkJRVU5GTEhkQ1FVUldMSE5EUVVVd1FuRkRMRmxCUmpGQ0xFZEJSMGhVTEVsQlNFY3NRMEZCVUR0QlFVdElPenM3YVVSQlIwZFZMRmtzUlVGRFFVTXNUeXhGUVVOQldDeEpMRVZCUTJNN1FVRkRaQ3hoUVVGUExFbEJRVWxJTEdOQlFVb3NRMEZEU0ROQ0xGbEJRVmtzUTBGQlEwa3NhVU5CUkZZc1lVRkZRMjlETEZsQlJrUXNNRU5CUlRaRFF5eFBRVVkzUXl4M1FrRkhTRmdzU1VGSVJ5eERRVUZRTzBGQlMwZzdPenR0UTBGRmNVSkJMRWtzUlVGQmIwSTdRVUZEZEVNc1lVRkJUeXhKUVVGSlNDeGpRVUZLTEVOQlEwZ3pRaXhaUVVGWkxFTkJRVU5MTEdkQ1FVUldMRVZCUlVnc2QwTkJSa2NzUlVGSFNIbENMRWxCU0Vjc1EwRkJVRHRCUVV0SU96czdaME5CUjBkWkxFMHNSVUZEUVZvc1NTeEZRVU5HTzBGQlEwVXNZVUZCVHl4SlFVRkpTQ3hqUVVGS0xFTkJRMGd6UWl4WlFVRlpMRU5CUVVOUExGbEJSRllzTUVKQlJXTnRReXhOUVVGTkxFTkJRVU5ETEVkQlFWQXNRMEZCVnl4VlFVRkJReXhEUVVGRE8wRkJRVUVzWlVGQlNVRXNRMEZCUXl4RFFVRkRaaXhQUVVGR0xFbEJRV0ZsTEVOQlFVTXNRMEZCUTBNc1VVRkJSaXhGUVVGcVFqdEJRVUZCTEU5QlFWb3NSVUZCTWtORExFbEJRVE5ETEVOQlFXZEVMRWxCUVdoRUxFTkJSbVFzUjBGSFNHaENMRWxCU0Vjc1EwRkJVRHRCUVV0SU96czdLMEpCUldsQ2FVSXNTU3hGUVVGM1FqdEJRVU4wUXl4VlFVRkpRU3hKUVVGS0xFVkJRVlU3UVVGRFRpeDVRa0ZCVlN4SlFVRkpReXhKUVVGS0xFTkJRVk5FTEVsQlFVa3NSMEZCUnl4SlFVRm9RaXhGUVVGelFrVXNWMEZCZEVJc1JVRkJWaXhsUVVGclJFWXNTVUZCYkVRN1FVRkRTRHM3UVVGRFJDeGhRVUZQTEVsQlFWQTdRVUZEU0RzN08yMURRVWRIYWtJc1NTeEZRVTlHTzBGQlEwVXNZVUZCVHl4SlFVRkpTQ3hqUVVGS0xFTkJRMGd6UWl4WlFVRlpMRU5CUVVOUkxHVkJSRllzUlVGRlNDeHBRa0ZHUnl4clEwRkpTWE5DTEVsQlNrbzdRVUZMUTI5Q0xGRkJRVUZCTEZsQlFWa3NSVUZCUlhaQ0xHTkJRV01zUTBGQlEzZENMRlZCUVdZc1EwRkJNRUp5UWl4SlFVRkpMRU5CUVVOdlFpeFpRVUV2UWl4RFFVeG1PMEZCVFVORkxGRkJRVUZCTEdWQlFXVXNSVUZCUlhwQ0xHTkJRV01zUTBGQlEzZENMRlZCUVdZc1EwRkJNRUp5UWl4SlFVRkpMRU5CUVVOMVFpeE5RVUV2UWl4RFFVNXNRanRCUVU5RFF5eFJRVUZCUVN4VlFVRlZMRVZCUVVVelFpeGpRVUZqTEVOQlFVTjNRaXhWUVVGbUxFTkJRVEJDY2tJc1NVRkJTU3hEUVVGRGQwSXNWVUZCTDBJN1FVRlFZaXhWUVZOSWVrUXNZMEZCWXl4RFFVRkRReXhOUVZSYUxFTkJRVkE3UVVGWFNEczdPMjlFUVVWelEyZERMRWtzUlVGQmIwSTdRVUZEZGtRc1lVRkJUeXhKUVVGSlNDeGpRVUZLTEVOQlEwZ3pRaXhaUVVGWkxFTkJRVU5UTEd0RFFVUldMRVZCUlVnc2MwTkJSa2NzUlVGSFNIRkNMRWxCU0Vjc1EwRkJVRHRCUVV0SU96czdLME5CUldsRFFTeEpMRVZCUVc5Q08wRkJRMnhFTEdGQlFVOHNTVUZCU1Vnc1kwRkJTaXhEUVVOSU0wSXNXVUZCV1N4RFFVRkRWeXc0UWtGRVZpeEZRVVZJTEd0R1FVTkZMRFJFUVVoRExFVkJTVWh0UWl4SlFVcEhMRU5CUVZBN1FVRk5TRHM3TzJ0RFFVZEhRU3hKTEVWQlVVWTdRVUZEUlN4aFFVRlBMRWxCUVVsSUxHTkJRVW9zUTBGRFNETkNMRmxCUVZrc1EwRkJRMWtzWTBGRVZpeEZRVVZJTEc5RVFVWkhMR3REUVVsSmEwSXNTVUZLU2p0QlFVdERiMElzVVVGQlFVRXNXVUZCV1N4RlFVRkZka0lzWTBGQll5eERRVUZEZDBJc1ZVRkJaaXhEUVVFd1FuSkNMRWxCUVVrc1EwRkJRMjlDTEZsQlFTOUNMRU5CVEdZN1FVRk5RMFVzVVVGQlFVRXNaVUZCWlN4RlFVRkZla0lzWTBGQll5eERRVUZEZDBJc1ZVRkJaaXhEUVVFd1FuSkNMRWxCUVVrc1EwRkJRM1ZDTEUxQlFTOUNPMEZCVG14Q0xGTkJRVkE3UVVGVFNEczdPekpEUVVkSGRrSXNTU3hGUVUxR08wRkJRMFVzWVVGQlR5eEpRVUZKU0N4alFVRktMRU5CUTBnelFpeFpRVUZaTEVOQlFVTmpMSGRDUVVSV0xFVkJSVWdzZFVSQlJrY3NhME5CU1VsblFpeEpRVXBLTzBGQlMwTnZRaXhSUVVGQlFTeFpRVUZaTEVWQlFVVjJRaXhqUVVGakxFTkJRVU4zUWl4VlFVRm1MRU5CUVRCQ2NrSXNTVUZCU1N4RFFVRkRiMElzV1VGQkwwSTdRVUZNWml4VFFVRlFPMEZCVVVnN096dHRRMEZGY1VKd1FpeEpMRVZCUVc5Q08wRkJRM1JETEdGQlFVOHNTVUZCU1Vnc1kwRkJTaXhEUVVOSU0wSXNXVUZCV1N4RFFVRkRaU3hwUWtGRVZpeEZRVVZJTERCRVFVTkZMSEZGUVVSR0xFZEJSVVVzSzBOQlNrTXNSVUZMU0dVc1NVRk1SeXhEUVVGUU8wRkJUMGc3T3p0dFEwRkhSMWNzVHl4RlFVTkJXQ3hKTEVWQlEwWTdRVUZEUlN4aFFVRlBMRWxCUVVsSUxHTkJRVW9zUTBGRFNETkNMRmxCUVZrc1EwRkJRMmRDTEdWQlJGWXNSVUZGU0N4blEwRkJlVUo1UWl4UFFVRjZRaXd3UWtGRFJTeHpSa0ZFUml4SFFVVkZMRzFEUVVaR0xFZEJSMFVzYTBSQlRFTXNSVUZOU0Znc1NVRk9SeXhEUVVGUU8wRkJVVWc3T3p0MVEwRkhSMWNzVHl4RlFVTkJZeXhQTEVWQlEwRjZRaXhKTEVWQlEwWTdRVUZEUlN4aFFVRlBMRWxCUVVsSUxHTkJRVW9zUTBGRFNETkNMRmxCUVZrc1EwRkJRMmxDTEc5Q1FVUldMRVZCUlVnc1owTkJRWGxDZDBJc1QwRkJla0lzYTBSQlEwVXNlVVZCUkVZc1IwRkZSU3h2UlVGR1JpeDVRMEZIYVVOakxFOUJTR3BETEZkQlNVVXNhMFJCVGtNc1JVRlBTSHBDTEVsQlVFY3NRMEZCVUR0QlFWTklPenM3ZVVOQlIwZFhMRThzUlVGRFFXTXNUeXhGUVVOQmVrSXNTU3hGUVVOR08wRkJRMFVzWVVGQlR5eEpRVUZKU0N4alFVRktMRU5CUTBnelFpeFpRVUZaTEVOQlFVTnJRaXgxUWtGRVZpeEZRVVZJTEdkRFFVRjVRblZDTEU5QlFYcENMRzlEUVVFd1JHTXNUMEZCTVVRc1YwRkRSU3h4UlVGRVJpeEhRVVZGTERCQ1FVWkdMRWRCUjBVc2EwUkJURU1zUlVGTlNIcENMRWxCVGtjc1EwRkJVRHRCUVZGSU96czdOa0pCUjBjd1FpeFRMRVZCUTBFeFFpeEpMRVZCUTBZN1FVRkRSU3hWUVVGTk1rSXNZVUZCWVN4SFFVRkhSQ3hUUVVGVExFdEJRVXNzUTBGQlF5eERRVUZtTEVkQlFXMUNMR0ZCUVc1Q0xIVkNRVUZuUkVFc1UwRkJhRVFzUTBGQmRFSTdRVUZEUVN4aFFVRlBMRWxCUVVrM1FpeGpRVUZLTEVOQlEwZ3pRaXhaUVVGWkxFTkJRVU5aTEdOQlJGWXNORUpCUldVMlF5eGhRVVptTEdkQ1FVZElNMElzU1VGSVJ5eERRVUZRTzBGQlMwZzdPenR6UTBGSFIwUXNUeXhGUVVOQlF5eEpMRVZCUTBZN1FVRkRSU3hoUVVGUExFbEJRVWxJTEdOQlFVb3NRMEZCYlVJelFpeFpRVUZaTEVOQlFVTlpMR05CUVdoRExFVkJRV2RFYVVJc1QwRkJhRVFzUlVGQmVVUkRMRWxCUVhwRUxFTkJRVkE3UVVGRFNEczdPM2xEUVVVeVFrRXNTU3hGUVVGdlFqdEJRVU0xUXl4aFFVRlBMRWxCUVVsSUxHTkJRVW9zUTBGRFNETkNMRmxCUVZrc1EwRkJRM1ZDTEhOQ1FVUldMRVZCUlVnc1owUkJSa2NzUlVGSFNFOHNTVUZJUnl4RFFVRlFPMEZCUzBnN096dHJSRUZGYjBNN1FVRkRha01zWVVGQlR5eEpRVUZKU0N4alFVRktMRU5CUTBnc2JVVkJSRWNzUlVGRlNETkNMRmxCUVZrc1EwRkJRMjlDTEN0Q1FVWldMRU5CUVZBN1FVRkpTRHM3T3pKRFFVVTJRbk5ETEcxQ0xFVkJRWE5ETzBGQlEyaEZMR0ZCUVU4c1NVRkJTUzlDTEdOQlFVb3NRMEZEU0N3clIwRkRlVUpuUXl4SlFVRkpMRU5CUVVORExGTkJRVXdzUTBGQlpVWXNiVUpCUVdZc1EwRkVla0lzVFVGRVJ5eEZRVWRJTVVRc1dVRkJXU3hEUVVGRGNVSXNlVUpCU0ZZc1EwRkJVRHRCUVV0SU96czdkVU5CUlhsQ08wRkJRM1JDTEdGQlFVOHNTVUZCU1Uwc1kwRkJTaXhEUVVOSU0wSXNXVUZCV1N4RFFVRkRReXh0UWtGRVZpeEZRVVZJTERKRFFVWkhMRVZCUjBoU0xHbENRVWhITEVOQlFWQTdRVUZMU0RzN096czdPenM3WjBKQmNsUlJhME1zWXl4WlFVTlBPVUlzWXpzN1owSkJSRkE0UWl4akxGVkJSVXN6UWl4Wklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElIUjVjR1VnZXlCVVQwNUpibkIxZEUxbGMzTmhaMlVzSUZSUFRrMWxjM05oWjJWUWNtOWpaWE56YVc1blUzUmhkR1VnZlNCbWNtOXRJQ2N1TGk5MGVYQmxjeWM3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRlJQVGtWeWNtOXlSR0YwWVNBOUlIdGNiaUFnSUNCamIzSmxYM1psY25OcGIyNDZJSE4wY21sdVp6dGNiaUFnSUNCamIyNW1hV2RmYzJWeWRtVnlPaUJ6ZEhKcGJtYzdYRzRnSUNBZ2NYVmxjbmxmZFhKc09pQnpkSEpwYm1jN1hHNGdJQ0FnVzNOMGNtbHVaMTA2SUdGdWVUdGNibjFjYmx4dVpYaHdiM0owSUdOdmJuTjBJR1Z0Y0hSNVZFOU9SWEp5YjNKRVlYUmhPaUJVVDA1RmNuSnZja1JoZEdFZ1BTQjdYRzRnSUNBZ1kyOXlaVjkyWlhKemFXOXVPaUFuSnl4Y2JpQWdJQ0JqYjI1bWFXZGZjMlZ5ZG1WeU9pQW5KeXhjYmlBZ0lDQnhkV1Z5ZVY5MWNtdzZJQ2NuTEZ4dWZUdGNibHh1Wlhod2IzSjBJR052Ym5OMElGUlBUa1Z5Y205eVUyOTFjbU5sSUQwZ2UxeHVJQ0FnSUVOTVNVVk9WRG9nSjJOc2FXVnVkQ2NzWEc0Z0lDQWdUazlFUlRvZ0oyNXZaR1VuTEZ4dWZUdGNibHh1Wlhod2IzSjBJR052Ym5OMElGUlBUa1Z5Y205eVEyOWtaU0E5SUh0Y2JpQWdJQ0JEVEVsRlRsUmZTVk5mVGs5VVgxTkZWRlZRT2lBeE1EQXdMRnh1SUNBZ0lGTkZUa1JmVGs5RVJWOVNSVkZWUlZOVVgwWkJTVXhGUkRvZ01UQXdNU3hjYmlBZ0lDQk5SVk5UUVVkRlgwRk1Va1ZCUkZsZlJWaFFTVkpGUkRvZ01UQXdNU3hjYmlBZ0lDQlNWVTVmVEU5RFFVeGZRVU5EVDFWT1ZGOUVUMFZUWDA1UFZGOUZXRWxUVkZNNklERXdNRElzWEc0Z0lDQWdWMEZKVkY5R1QxSmZWRWxOUlU5VlZEb2dNVEF3TXl4Y2JpQWdJQ0JKVGxSRlVrNUJURjlGVWxKUFVqb2dNVEF3TkN4Y2JpQWdJQ0JSVlVWU1dWOUdRVWxNUlVRNklERXdNRFVzWEc0Z0lDQWdUVVZUVTBGSFJWOUZXRkJKVWtWRU9pQXhNREEyTEZ4dUlDQWdJRk5GVWxaRlVsOUVUMFZUVGxSZlUxVlFVRTlTVkY5QlIwZFNSVWRCVkVsUFRsTTZJREV3TURjc1hHNGdJQ0FnU1U1V1FVeEpSRjlEVDA1VE9pQXhNREE0TEZ4dUlDQWdJRUZFUkZKRlUxTmZVa1ZSVlVsU1JVUmZSazlTWDFKVlRsOU1UME5CVERvZ01UQXdPU3hjYmlBZ0lDQk9SVlJYVDFKTFgxTkpURVZPVkRvZ01UQXhNQ3hjYmlBZ0lDQlVVa0ZPVTBGRFZFbFBUbDlNUVVjNklERXdNVEVzWEc0Z0lDQWdWRkpCVGxOQlExUkpUMDVmVjBGSlZGOVVTVTFGVDFWVU9pQXhNREV5TEZ4dUlDQWdJRU5NVDBOTFgwOVZWRjlQUmw5VFdVNURPaUF4TURFekxGeHVJQ0FnSUVGRFEwOVZUbFJmVFVsVFUwbE9Sem9nTVRBeE5DeGNiaUFnSUNCQlEwTlBWVTVVWDBOUFJFVmZUVWxUVTBsT1J6b2dNVEF4TlN4Y2JpQWdJQ0JCUTBOUFZVNVVYMEpCVEVGT1EwVmZWRTlQWDB4UFZ6b2dNVEF4Tml4Y2JpQWdJQ0JCUTBOUFZVNVVYMFpTVDFwRlRsOVBVbDlFUlV4RlZFVkVPaUF4TURFM0xGeHVYRzRnSUNBZ0x5OGdRM0o1Y0hSdlhHNWNiaUFnSUNCVFNVZE9TVTVIWDFOUFZWSkRSVjlKVTE5T1QxUmZVMUJGUTBsR1NVVkVPaUF5TURJeExGeHVJQ0FnSUVsT1ZrRk1TVVJmUTFKWlVGUlBYMEpQV0Y5UVFWSkJUVk02SURJd016QXNYRzVjYmlBZ0lDQXZMeUJEYjI1MGNtRmpkSE5jYmx4dUlDQWdJRU5QVGxSU1FVTlVYMFZZUlVOVlZFbFBUbDlHUVVsTVJVUTZJRE13TWpVc1hHNWNiaUFnSUNBdkx5QlJkV1Z5YVdWelhHNWNiaUFnSUNCUlZVVlNXVjlHVDFKRFNVSk1XVjlCUWs5U1ZFVkVPaUEwTURBMUxGeHVmVHRjYmx4dVpYaHdiM0owSUdOdmJuTjBJRlJQVGtOdmJuUnlZV04wUlhocGRFTnZaR1VnUFNCN1hHNGdJQ0FnVWtWUVRFRlpYMUJTVDFSRlExUkpUMDQ2SURVeUxGeHVJQ0FnSUUxRlUxTkJSMFZmUlZoUVNWSkZSRG9nTlRjc1hHNGdJQ0FnVGs5ZlIwRlRPaUF4TXl4Y2JuMDdYRzVjYm1WNGNHOXlkQ0JqYkdGemN5QlVUMDVEYkdsbGJuUkZjbkp2Y2lCN1hHNGdJQ0FnYzNSaGRHbGpJSE52ZFhKalpTQTlJRlJQVGtWeWNtOXlVMjkxY21ObE8xeHVJQ0FnSUhOMFlYUnBZeUJqYjJSbElEMGdWRTlPUlhKeWIzSkRiMlJsTzF4dVhHNGdJQ0FnYldWemMyRm5aVG9nYzNSeWFXNW5PMXh1SUNBZ0lITnZkWEpqWlRvZ2MzUnlhVzVuTzF4dUlDQWdJR052WkdVNklHNTFiV0psY2p0Y2JpQWdJQ0JrWVhSaE9pQlVUMDVGY25KdmNrUmhkR0U3WEc1Y2JpQWdJQ0JqYjI1emRISjFZM1J2Y2loY2JpQWdJQ0FnSUNBZ1kyOWtaVG9nYm5WdFltVnlMRnh1SUNBZ0lDQWdJQ0J0WlhOellXZGxPaUJ6ZEhKcGJtY3NYRzRnSUNBZ0lDQWdJR1JoZEdFNklGUlBUa1Z5Y205eVJHRjBZU3hjYmlBZ0lDQWdJQ0FnYzI5MWNtTmxQem9nYzNSeWFXNW5MRnh1SUNBZ0lDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtTnZaR1VnUFNCamIyUmxPMXh1SUNBZ0lDQWdJQ0IwYUdsekxtMWxjM05oWjJVZ1BTQnRaWE56WVdkbE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1SaGRHRWdQU0JrWVhSaE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5OdmRYSmpaU0E5SUhOdmRYSmpaU0I4ZkNCVVQwNUZjbkp2Y2xOdmRYSmpaUzVEVEVsRlRsUTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdWR1Z6ZEdWeWMxeHVYRzRnSUNBZ2MzUmhkR2xqSUdselEyeHBaVzUwUlhKeWIzSW9aWEp5YjNJNklHRnVlU3dnWTI5a1pUb2diblZ0WW1WeUtUb2dZbTl2YkdWaGJpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQW9aWEp5YjNJdWMyOTFjbU5sSUQwOVBTQlVUMDVGY25KdmNsTnZkWEpqWlM1RFRFbEZUbFFwWEc0Z0lDQWdJQ0FnSUNBZ0lDQW1KaUFvWlhKeWIzSXVZMjlrWlNBOVBUMGdZMjlrWlNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzNSaGRHbGpJR2x6VG05a1pVVnljbTl5S0dWeWNtOXlPaUJoYm5rc0lHTnZaR1U2SUc1MWJXSmxjaWs2SUdKdmIyeGxZVzRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnS0dWeWNtOXlMbk52ZFhKalpTQTlQVDBnVkU5T1JYSnliM0pUYjNWeVkyVXVUazlFUlNsY2JpQWdJQ0FnSUNBZ0lDQWdJQ1ltSUNobGNuSnZjaTVqYjJSbElEMDlQU0JqYjJSbEtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCemRHRjBhV01nYVhORGIyNTBjbUZqZEVWeWNtOXlLR1Z5Y205eU9pQmhibmtzSUdWNGFYUkRiMlJsT2lCdWRXMWlaWElwT2lCaWIyOXNaV0Z1SUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUNobGNuSnZjaTV6YjNWeVkyVWdQVDA5SUZSUFRrVnljbTl5VTI5MWNtTmxMazVQUkVVcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FtSmlBb1pYSnliM0l1WTI5a1pTQTlQVDBnVkU5T1JYSnliM0pEYjJSbExrTlBUbFJTUVVOVVgwVllSVU5WVkVsUFRsOUdRVWxNUlVRcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FtSmlBb1pYSnliM0l1WkdGMFlTQW1KaUJsY25KdmNpNWtZWFJoTG1WNGFYUmZZMjlrWlNBOVBUMGdaWGhwZEVOdlpHVXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lITjBZWFJwWXlCcGMwOXlhV2RwYm1Gc1EyOXVkSEpoWTNSRmNuSnZjaWhsY25KdmNqb2dZVzU1TENCbGVHbDBRMjlrWlRvZ2JuVnRZbVZ5S1RvZ1ltOXZiR1ZoYmlCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCVVQwNURiR2xsYm5SRmNuSnZjaTVwYzBOdmJuUnlZV04wUlhKeWIzSW9aWEp5YjNJc0lHVjRhWFJEYjJSbEtWeHVJQ0FnSUNBZ0lDQWdJQ0FnSmlZZ0tDRmxjbkp2Y2k1a1lYUmhQeTV2Y21sbmFXNWhiRjlsY25KdmNpazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2MzUmhkR2xqSUdselVtVnpiMngyWldSRGIyNTBjbUZqZEVWeWNtOXlRV1owWlhKRmVIQnBjbVVvWlhKeWIzSTZJR0Z1ZVN3Z1pYaHBkRU52WkdVNklHNTFiV0psY2lrNklHSnZiMnhsWVc0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1ZFOU9RMnhwWlc1MFJYSnliM0l1YVhORGIyNTBjbUZqZEVWeWNtOXlLR1Z5Y205eUxDQmxlR2wwUTI5a1pTbGNiaUFnSUNBZ0lDQWdJQ0FnSUNZbUlDaGxjbkp2Y2k1a1lYUmhJQ1ltSUdWeWNtOXlMbVJoZEdFdWIzSnBaMmx1WVd4ZlpYSnliM0pjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FtSmlCVVQwNURiR2xsYm5SRmNuSnZjaTVwYzAxbGMzTmhaMlZGZUhCcGNtVmtLR1Z5Y205eUxtUmhkR0V1YjNKcFoybHVZV3hmWlhKeWIzSXBLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0YwYVdNZ2FYTk5aWE56WVdkbFJYaHdhWEpsWkNobGNuSnZjam9nWVc1NUtUb2dZbTl2YkdWaGJpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQlVUMDVEYkdsbGJuUkZjbkp2Y2k1cGMwTnNhV1Z1ZEVWeWNtOXlLR1Z5Y205eUxDQlVUMDVGY25KdmNrTnZaR1V1VFVWVFUwRkhSVjlGV0ZCSlVrVkVLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0YwYVdNZ2FYTlhZV2wwUm05eVZHbHRaVzkxZENobGNuSnZjam9nWVc1NUtUb2dZbTl2YkdWaGJpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQlVUMDVEYkdsbGJuUkZjbkp2Y2k1cGMwTnNhV1Z1ZEVWeWNtOXlLR1Z5Y205eUxDQlVUMDVGY25KdmNrTnZaR1V1VjBGSlZGOUdUMUpmVkVsTlJVOVZWQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnUW5WcGJHUmxjbk5jYmx4dUlDQWdJSE4wWVhScFl5QnBiblJsY201aGJFVnljbTl5S0Z4dUlDQWdJQ0FnSUNCdFpYTnpZV2RsT2lCemRISnBibWNzWEc0Z0lDQWdJQ0FnSUdSaGRHRTZJRlJQVGtWeWNtOXlSR0YwWVN4Y2JpQWdJQ0FwT2lCVVQwNURiR2xsYm5SRmNuSnZjaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ1WlhjZ1ZFOU9RMnhwWlc1MFJYSnliM0lvWEc0Z0lDQWdJQ0FnSUNBZ0lDQlVUMDVGY25KdmNrTnZaR1V1U1U1VVJWSk9RVXhmUlZKU1QxSXNYRzRnSUNBZ0lDQWdJQ0FnSUNCZ1NXNTBaWEp1WVd3Z1pYSnliM0k2SUNSN2JXVnpjMkZuWlgxZ0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnWkdGMFlTeGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0YwYVdNZ2FXNTJZV3hwWkVOdmJuTW9aR0YwWVRvZ1ZFOU9SWEp5YjNKRVlYUmhLVG9nVkU5T1EyeHBaVzUwUlhKeWIzSWdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdibVYzSUZSUFRrTnNhV1Z1ZEVWeWNtOXlLRnh1SUNBZ0lDQWdJQ0FnSUNBZ1ZFOU9SWEp5YjNKRGIyUmxMa2xPVmtGTVNVUmZRMDlPVXl4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ2RKYm5aaGJHbGtJRU5QVGxNZ2MzUnlkV04wZFhKbExpQkZZV05vSUVOUFRsTWdhWFJsYlNCdGRYTjBJR052Ym5SaGFXNXpJRzltSUhSM2J5QmxiR1Z0Wlc1MGN5NG5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pHRjBZU3hjYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6ZEdGMGFXTWdjMlZ1WkU1dlpHVlNaWEYxWlhOMFJtRnBiR1ZrS0Z4dUlDQWdJQ0FnSUNCeVpYTndiMjV6WlZSbGVIUTZJSE4wY21sdVp5eGNiaUFnSUNBZ0lDQWdaR0YwWVRvZ1ZFOU9SWEp5YjNKRVlYUmhMRnh1SUNBZ0lDazZJRlJQVGtOc2FXVnVkRVZ5Y205eUlIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHNWxkeUJVVDA1RGJHbGxiblJGY25KdmNpaGNiaUFnSUNBZ0lDQWdJQ0FnSUZSUFRrVnljbTl5UTI5a1pTNVRSVTVFWDA1UFJFVmZVa1ZSVlVWVFZGOUdRVWxNUlVRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JnVTJWdVpDQnViMlJsSUhKbGNYVmxjM1FnWm1GcGJHVmtPaUFrZTNKbGMzQnZibk5sVkdWNGRIMWdMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pHRjBZU3hjYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6ZEdGMGFXTWdjblZ1VEc5allXeEJZMk52ZFc1MFJHOWxjMDV2ZEVWNGFYTjBjeWhjYmlBZ0lDQWdJQ0FnWm5WdVkzUnBiMjVPWVcxbE9pQnpkSEpwYm1jc1hHNGdJQ0FnSUNBZ0lHRmtaSEpsYzNNNklITjBjbWx1Wnl4Y2JpQWdJQ0FnSUNBZ1pHRjBZVG9nVkU5T1JYSnliM0pFWVhSaExGeHVJQ0FnSUNrNklGUlBUa05zYVdWdWRFVnljbTl5SUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUc1bGR5QlVUMDVEYkdsbGJuUkZjbkp2Y2loY2JpQWdJQ0FnSUNBZ0lDQWdJRlJQVGtWeWNtOXlRMjlrWlM1U1ZVNWZURTlEUVV4ZlFVTkRUMVZPVkY5RVQwVlRYMDVQVkY5RldFbFRWRk1zWEc0Z0lDQWdJQ0FnSUNBZ0lDQmdXeVI3Wm5WdVkzUnBiMjVPWVcxbGZWMGdjblZ1SUd4dlkyRnNJR1poYVd4bFpEb2dZV05qYjNWdWRDQmJKSHRoWkdSeVpYTnpmVjBnWkc5bGN5QnViM1FnWlhocGMzUnpZQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHUmhkR0VzWEc0Z0lDQWdJQ0FnSUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzNSaGRHbGpJSGRoYVhSR2IzSlVhVzFsYjNWMEtHUmhkR0U2SUZSUFRrVnljbTl5UkdGMFlTa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdibVYzSUZSUFRrTnNhV1Z1ZEVWeWNtOXlLRnh1SUNBZ0lDQWdJQ0FnSUNBZ1ZFOU9SWEp5YjNKRGIyUmxMbGRCU1ZSZlJrOVNYMVJKVFVWUFZWUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBblYyRnBkQ0JtYjNJZ2IzQmxjbUYwYVc5dUlISmxhbVZqZEdWa0lHOXVJSFJwYldWdmRYUW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pHRjBZU3hjYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6ZEdGMGFXTWdjWFZsY25sR1lXbHNaV1FvWEc0Z0lDQWdJQ0FnSUdWeWNtOXljem9nUlhKeWIzSmJYU3hjYmlBZ0lDQWdJQ0FnWkdGMFlUb2dWRTlPUlhKeWIzSkVZWFJoTEZ4dUlDQWdJQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lGUlBUa05zYVdWdWRFVnljbTl5S0Z4dUlDQWdJQ0FnSUNBZ0lDQWdWRTlPUlhKeWIzSkRiMlJsTGxGVlJWSlpYMFpCU1V4RlJDeGNiaUFnSUNBZ0lDQWdJQ0FnSUdCUmRXVnllU0JtWVdsc1pXUTZJQ1I3WlhKeWIzSnpMbTFoY0NoNElEMCtJSGd1YldWemMyRm5aU0I4ZkNCNExuUnZVM1J5YVc1bktDa3BMbXB2YVc0b0oxeGNiaWNwZldBc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JrWVhSaExGeHVJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lITjBZWFJwWXlCbWIzSnRZWFJVYVcxbEtIUnBiV1U2SUQ5dWRXMWlaWElwT2lBL2MzUnlhVzVuSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLSFJwYldVcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJnSkh0dVpYY2dSR0YwWlNoMGFXMWxJQ29nTVRBd01Da3VkRzlKVTA5VGRISnBibWNvS1gwZ0tDUjdkR2x0WlgwcFlEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiblZzYkR0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6ZEdGMGFXTWdiV1Z6YzJGblpVVjRjR2x5WldRb1hHNGdJQ0FnSUNBZ0lHUmhkR0U2SUZSUFRrVnljbTl5UkdGMFlTQW1JSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJWZmFXUTZJSE4wY21sdVp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUhObGJtUnBibWRmZEdsdFpUb2diblZ0WW1WeUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWlhod2FYSmxQem9nYm5WdFltVnlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lteHZZMnRmZEdsdFpUODZJRzUxYldKbGNpeGNiaUFnSUNBZ0lDQWdJQ0FnSUdKc2IyTnJYMmxrUHpvZ2MzUnlhVzVuTEZ4dUlDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjNJRlJQVGtOc2FXVnVkRVZ5Y205eUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnVkU5T1JYSnliM0pEYjJSbExrMUZVMU5CUjBWZlJWaFFTVkpGUkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ2ROWlhOellXZGxJR1Y0Y0dseVpXUW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDNHVMbVJoZEdFc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MyVnVaR2x1WjE5MGFXMWxPaUJVVDA1RGJHbGxiblJGY25KdmNpNW1iM0p0WVhSVWFXMWxLR1JoZEdFdWMyVnVaR2x1WjE5MGFXMWxLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JsZUhCcGNtRjBhVzl1WDNScGJXVTZJRlJQVGtOc2FXVnVkRVZ5Y205eUxtWnZjbTFoZEZScGJXVW9aR0YwWVM1bGVIQnBjbVVwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKc2IyTnJYM1JwYldVNklGUlBUa05zYVdWdWRFVnljbTl5TG1admNtMWhkRlJwYldVb1pHRjBZUzVpYkc5amExOTBhVzFsS1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQlVUMDVGY25KdmNsTnZkWEpqWlM1RFRFbEZUbFFzWEc0Z0lDQWdJQ0FnSUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzNSaGRHbGpJSE5sY25abGNrUnZaWE51ZEZOMWNIQnZjblJCWjJkeVpXZGhkR2x2Ym5Nb1pHRjBZVG9nVkU5T1JYSnliM0pFWVhSaEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnVaWGNnVkU5T1EyeHBaVzUwUlhKeWIzSW9YRzRnSUNBZ0lDQWdJQ0FnSUNCVVQwNUZjbkp2Y2tOdlpHVXVVMFZTVmtWU1gwUlBSVk5PVkY5VFZWQlFUMUpVWDBGSFIxSkZSMEZVU1U5T1V5eGNiaUFnSUNBZ0lDQWdJQ0FnSUNkVFpYSjJaWElnWkc5bGMyNWNYQ2QwSUhOMWNIQnZjblFnWVdkbmNtVm5ZWFJwYjI1ekp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUdSaGRHRXNYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjM1JoZEdsaklHRmtaSEpsYzNOU1pYRjFhWEpsWkVadmNsSjFia3h2WTJGc0tHUmhkR0U2SUZSUFRrVnljbTl5UkdGMFlTa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdibVYzSUZSUFRrTnNhV1Z1ZEVWeWNtOXlLRnh1SUNBZ0lDQWdJQ0FnSUNBZ1ZFOU9SWEp5YjNKRGIyUmxMa0ZFUkZKRlUxTmZVa1ZSVlVsU1JVUmZSazlTWDFKVlRsOU1UME5CVEN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ2RCWkdSeVpYTnpJSEpsY1hWcGNtVmtJR1p2Y2lCeWRXNGdiRzlqWVd3dUlGbHZkU0JvWVhabGJseGNKM1FnYzNCbFkybG1hV1ZrSUdOdmJuUnlZV04wSUdOdlpHVWdiM0lnWkdGMFlTQW5YRzRnSUNBZ0lDQWdJQ0FnSUNBcklDZHpieUJoWkdSeVpYTnpJR2x6SUhKbGNYVnBjbVZrSUhSdklHeHZZV1FnYldsemMybHVaeUJ3WVhKMGN5Qm1jbTl0SUc1bGRIZHZjbXN1Snl4Y2JpQWdJQ0FnSUNBZ0lDQWdJR1JoZEdFc1hHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2MzUmhkR2xqSUc1bGRIZHZjbXRUYVd4bGJuUW9YRzRnSUNBZ0lDQWdJR1JoZEdFNklGUlBUa1Z5Y205eVJHRjBZU0FtSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzFsYzNOaFoyVmZhV1E2SUhOMGNtbHVaeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lITmxibVJwYm1kZmRHbHRaVG9nYm5WdFltVnlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pYaHdhWEpsT2lCdWRXMWlaWElzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhVzFsYjNWME9pQnVkVzFpWlhJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JpYkc5amExOXBaRDg2SUhOMGNtbHVaeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJWZmNISnZZMlZ6YzJsdVoxOXpkR0YwWlQ4NklGUlBUazFsYzNOaFoyVlFjbTlqWlhOemFXNW5VM1JoZEdVc1hHNGdJQ0FnSUNBZ0lIMHNYRzRnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnVaWGNnVkU5T1EyeHBaVzUwUlhKeWIzSW9YRzRnSUNBZ0lDQWdJQ0FnSUNCVVQwNUZjbkp2Y2tOdlpHVXVUa1ZVVjA5U1MxOVRTVXhGVGxRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FuVG1WMGQyOXlheUJ6YVd4bGJuUTZJRzV2SUdKc2IyTnJjeUJ3Y205a2RXTmxaQ0JrZFhKcGJtY2dkR2x0Wlc5MWRDNG5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDNHVMbVJoZEdFc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MyVnVaR2x1WjE5MGFXMWxPaUJVVDA1RGJHbGxiblJGY25KdmNpNW1iM0p0WVhSVWFXMWxLR1JoZEdFdWMyVnVaR2x1WjE5MGFXMWxLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JsZUhCcGNtRjBhVzl1WDNScGJXVTZJRlJQVGtOc2FXVnVkRVZ5Y205eUxtWnZjbTFoZEZScGJXVW9aR0YwWVM1bGVIQnBjbVVwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6ZEdGMGFXTWdkSEpoYm5OaFkzUnBiMjVYWVdsMFZHbHRaVzkxZENoY2JpQWdJQ0FnSUNBZ1pHRjBZVG9nVkU5T1JYSnliM0pFWVhSaElDWWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JXVnpjMkZuWlY5cFpEb2djM1J5YVc1bkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnYzJWdVpHbHVaMTkwYVcxbE9pQnVkVzFpWlhJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYVcxbGIzVjBPaUJ1ZFcxaVpYSXNYRzRnSUNBZ0lDQWdJQ0FnSUNCdFpYTnpZV2RsWDNCeWIyTmxjM05wYm1kZmMzUmhkR1UvT2lCVVQwNU5aWE56WVdkbFVISnZZMlZ6YzJsdVoxTjBZWFJsTEZ4dUlDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjNJRlJQVGtOc2FXVnVkRVZ5Y205eUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnVkU5T1JYSnliM0pEYjJSbExsUlNRVTVUUVVOVVNVOU9YMWRCU1ZSZlZFbE5SVTlWVkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ2RVY21GdWMyRmpkR2x2YmlCa2FXUWdibTkwSUhCeWIyUjFZMlZrSUdSMWNtbHVaeUJ6Y0dWamFXWnBaV1FnZEdsdFpXOTFkQ2NzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMaTR1WkdGMFlTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnpaVzVrYVc1blgzUnBiV1U2SUZSUFRrTnNhV1Z1ZEVWeWNtOXlMbVp2Y20xaGRGUnBiV1VvWkdGMFlTNXpaVzVrYVc1blgzUnBiV1VwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6ZEdGMGFXTWdZMnh2WTJ0UGRYUlBabE41Ym1Nb1pHRjBZVG9nVkU5T1JYSnliM0pFWVhSaEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnVaWGNnVkU5T1EyeHBaVzUwUlhKeWIzSW9YRzRnSUNBZ0lDQWdJQ0FnSUNCVVQwNUZjbkp2Y2tOdlpHVXVRMHhQUTB0ZlQxVlVYMDlHWDFOWlRrTXNYRzRnSUNBZ0lDQWdJQ0FnSUNBbldXOTFJR3h2WTJGc0lHTnNiMk5ySUdseklHOTFkQ0J2WmlCemVXNWpJSGRwZEdnZ2RHaGxJSE5sY25abGNpQjBhVzFsTGlBblhHNGdJQ0FnSUNBZ0lDQWdJQ0FySUNkSmRDQnBjeUJoSUdOeWFYUnBZMkZzSUdOdmJtUnBkR2x2YmlCbWIzSWdjMlZ1WkdsdVp5QnRaWE56WVdkbGN5QjBieUIwYUdVZ1lteHZZMnRqYUdGcGJpNGdKMXh1SUNBZ0lDQWdJQ0FnSUNBZ0t5QW5VR3hsWVhObElITjVibU1nZVc5MUlHTnNiMk5ySUhkcGRHZ2dkR2hsSUdsdWRHVnlibVYwSUhScGJXVXVKeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lHUmhkR0VzWEc0Z0lDQWdJQ0FnSUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzNSaGRHbGpJR0ZqWTI5MWJuUk5hWE56YVc1bktGeHVJQ0FnSUNBZ0lDQmhaR1J5WlhOek9pQnpkSEpwYm1jc1hHNGdJQ0FnSUNBZ0lHUmhkR0U2SUZSUFRrVnljbTl5UkdGMFlTeGNiaUFnSUNBcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHNWxkeUJVVDA1RGJHbGxiblJGY25KdmNpaGNiaUFnSUNBZ0lDQWdJQ0FnSUZSUFRrVnljbTl5UTI5a1pTNUJRME5QVlU1VVgwMUpVMU5KVGtjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JnUVdOamIzVnVkQ0IzYVhSb0lHRmtaSEpsYzNNZ1d5UjdZV1JrY21WemMzMWRJR1J2WlhOdUozUWdaWGhwYzNSekxpQmdYRzRnSUNBZ0lDQWdJQ0FnSUNBcklDZFpiM1VnYUdGMlpTQjBieUJ3Y21Wd1lXbGtJSFJvYVhNZ1lXTmpiM1Z1ZENCMGJ5Qm9ZWFpsSUdFZ2NHOXphWFJwZG1VZ1ltRnNZVzVqWlNCdmJpQjBhR1Z0SUdGdVpDQjBhR1Z1SUdSbGNHeHZlU0FuWEc0Z0lDQWdJQ0FnSUNBZ0lDQXJJQ2RoSUdOdmJuUnlZV04wSUdOdlpHVWdabTl5SUhSb2FYTWdZV05qYjNWdWRDNG5YRzRnSUNBZ0lDQWdJQ0FnSUNBcklDZFRaV1VnVTBSTElHUnZZM1Z0Wlc1MFlYUnBiMjRnWm05eUlHUmxkR0ZwYkdWa0lHbHVjM1J5ZFdOMGFXOXVjeTRuTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdaR0YwWVN4Y2JpQWdJQ0FnSUNBZ0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNCemRHRjBhV01nWVdOamIzVnVkRU52WkdWTmFYTnphVzVuS0Z4dUlDQWdJQ0FnSUNCaFpHUnlaWE56T2lCemRISnBibWNzWEc0Z0lDQWdJQ0FnSUdKaGJHRnVZMlU2SUhOMGNtbHVaeXhjYmlBZ0lDQWdJQ0FnWkdGMFlUb2dWRTlPUlhKeWIzSkVZWFJoTEZ4dUlDQWdJQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lGUlBUa05zYVdWdWRFVnljbTl5S0Z4dUlDQWdJQ0FnSUNBZ0lDQWdWRTlPUlhKeWIzSkRiMlJsTGtGRFEwOVZUbFJmUTA5RVJWOU5TVk5UU1U1SExGeHVJQ0FnSUNBZ0lDQWdJQ0FnWUVGalkyOTFiblFnZDJsMGFDQmhaR1J5WlhOeklGc2tlMkZrWkhKbGMzTjlYU0JsZUdsemRITWdZblYwSUdoaGRtVnVKM1FnWVNCamIyNTBjbUZqZENCamIyUmxJSGxsZEM0Z1lGeHVJQ0FnSUNBZ0lDQWdJQ0FnS3lBbldXOTFJR2hoZG1VZ2RHOGdaVzV6ZFhKbElIUm9ZWFFnWVc0Z1lXTmpiM1Z1ZENCb1lYTWdZVzRnWlc1dmRXZG9JR0poYkdGdVkyVWdabTl5SUdSbGNHeHZlV2x1WnlBblhHNGdJQ0FnSUNBZ0lDQWdJQ0FySUNkaElHTnZiblJ5WVdOMElHTnZaR1VnWVc1a0lIUm9aVzRnWkdWd2JHOTVJR0VnWTI5dWRISmhZM1FnWTI5a1pTQm1iM0lnZEdocGN5QmhZMk52ZFc1MExpQW5YRzRnSUNBZ0lDQWdJQ0FnSUNBcklHQkRkWEp5Wlc1MElHRmpZMjkxYm5RZ1ltRnNZVzVqWlNCcGN5QmJKSHRpWVd4aGJtTmxmVjB1SUdCY2JpQWdJQ0FnSUNBZ0lDQWdJQ3NnSjFObFpTQlRSRXNnWkc5amRXMWxiblJoZEdsdmJpQm1iM0lnWkdWMFlXbHNaV1FnYVc1emRISjFZM1JwYjI1ekxpY3NYRzRnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhMRnh1SUNBZ0lDQWdJQ0FwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSE4wWVhScFl5QmhZMk52ZFc1MFFtRnNZVzVqWlZSdmIweHZkeWhjYmlBZ0lDQWdJQ0FnWVdSa2NtVnpjem9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0JpWVd4aGJtTmxPaUJ6ZEhKcGJtY3NYRzRnSUNBZ0lDQWdJR1JoZEdFNklGUlBUa1Z5Y205eVJHRjBZU3hjYmlBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzVsZHlCVVQwNURiR2xsYm5SRmNuSnZjaWhjYmlBZ0lDQWdJQ0FnSUNBZ0lGUlBUa1Z5Y205eVEyOWtaUzVCUTBOUFZVNVVYMEpCVEVGT1EwVmZWRTlQWDB4UFZ5eGNiaUFnSUNBZ0lDQWdJQ0FnSUdCQlkyTnZkVzUwSUhkcGRHZ2dZV1JrY21WemN5QmJKSHRoWkdSeVpYTnpmVjBnYUdGeklIUnZieUJzYjNjZ1ltRnNZVzVqWlNCYkpIdGlZV3hoYm1ObGZWMHVJR0JjYmlBZ0lDQWdJQ0FnSUNBZ0lDc2dKMWx2ZFNCb1lYWmxJSFJ2SUhObGJtUWdjMjl0WlNCMllXeDFaU0IwYnlCaFkyTnZkVzUwSUdKaGJHRnVZMlVnWm5KdmJTQnZkR2hsY2lCamIyNTBjbUZqZENBblhHNGdJQ0FnSUNBZ0lDQWdJQ0FySUNjb1pTNW5MaUJYWVd4c1pYUWdZMjl1ZEhKaFkzUXBMaUFuWEc0Z0lDQWdJQ0FnSUNBZ0lDQXJJQ2RUWldVZ1UwUkxJR1J2WTNWdFpXNTBZWFJwYjI0Z1ptOXlJR1JsZEdGcGJHVmtJR2x1YzNSeWRXTjBhVzl1Y3k0bkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWkdGMFlTeGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0YwYVdNZ2JtOUNiRzlqYTNNb1hHNGdJQ0FnSUNBZ0lIZHZjbXRqYUdGcGJqb2diblZ0WW1WeUxGeHVJQ0FnSUNBZ0lDQmtZWFJoT2lCVVQwNUZjbkp2Y2tSaGRHRXNYRzRnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElIZHZjbXRqYUdGcGJrNWhiV1VnUFNCM2IzSnJZMmhoYVc0Z1BUMDlJQzB4SUQ4Z0oyMWhjM1JsY21Ob1lXbHVKeUE2SUdCM2IzSnJZMmhoYVc0Z0pIdDNiM0pyWTJoaGFXNTlZRHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzVsZHlCVVQwNURiR2xsYm5SRmNuSnZjaWhjYmlBZ0lDQWdJQ0FnSUNBZ0lGUlBUa1Z5Y205eVEyOWtaUzVPUlZSWFQxSkxYMU5KVEVWT1ZDeGNiaUFnSUNBZ0lDQWdJQ0FnSUdCY0lrNXZJR0pzYjJOcmN5Qm1iM0lnSkh0M2IzSnJZMmhoYVc1T1lXMWxmU0JtYjNWdVpGd2lMbUFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmtZWFJoTEZ4dUlDQWdJQ0FnSUNBcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhOMFlYUnBZeUJwYm5aaGJHbGtRbXh2WTJ0amFHRnBiaWhjYmlBZ0lDQWdJQ0FnYldWemMyRm5aVG9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0JrWVhSaE9pQlVUMDVGY25KdmNrUmhkR0VzWEc0Z0lDQWdLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ1WlhjZ1ZFOU9RMnhwWlc1MFJYSnliM0lvVkU5T1JYSnliM0pEYjJSbExrNUZWRmRQVWt0ZlUwbE1SVTVVTENCdFpYTnpZV2RsTENCa1lYUmhLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0YwYVdNZ2NYVmxjbmxHYjNKamFXSnNlVUZpYjNKMFpXUW9aR0YwWVRvZ1ZFOU9SWEp5YjNKRVlYUmhLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ1WlhjZ1ZFOU9RMnhwWlc1MFJYSnliM0lvWEc0Z0lDQWdJQ0FnSUNBZ0lDQlVUMDVGY25KdmNrTnZaR1V1VVZWRlVsbGZSazlTUTBsQ1RGbGZRVUpQVWxSRlJDeGNiaUFnSUNBZ0lDQWdJQ0FnSUNkSGNtRndhRkZNSUhGMVpYSjVJSGRoY3lCbWIzSmphV0pzZVNCaFltOXlkR1ZrSUc5dUlIUnBiV1Z2ZFhRdUp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUdSaGRHRXNYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjM1JoZEdsaklITnBaMjVwYm1kVGIzVnlZMlZKYzA1dmRGTndaV05wWm1sbFpDZ3BJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzVsZHlCVVQwNURiR2xsYm5SRmNuSnZjaWhjYmlBZ0lDQWdJQ0FnSUNBZ0lDZFpiM1VnYlhWemRDQndjbTkyYVdSbElITnBaMjVwYm1jZ2EyVjVjeUJ2Y2lCemFXZHVhVzVuSUdKdmVDQjBieUJ6YVdkdUlIbHZkU0J0WlhOellXZGxMaWNzWEc0Z0lDQWdJQ0FnSUNBZ0lDQlVUMDVGY25KdmNrTnZaR1V1VTBsSFRrbE9SMTlUVDFWU1EwVmZTVk5mVGs5VVgxTlFSVU5KUmtsRlJDeGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0YwYVdNZ2FXNTJZV3hwWkVOeWVYQjBiMEp2ZUZCaGNtRnRjeWhsYm1OeWVYQjBaV1JUWldWa1VHaHlZWE5sT2lCVVQwNUpibkIxZEUxbGMzTmhaMlVwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUc1bGR5QlVUMDVEYkdsbGJuUkZjbkp2Y2loY2JpQWdJQ0FnSUNBZ0lDQWdJQ2RaYjNVZ2JYVnpkQ0J3Y205MmFXUmxJR0VnZG1Gc2FXUWdaVzVqY25sd2RHVmtJSE5sWldRZ2NHaHlZWE5sSUhSdklHTnlaV0YwWlNCaElHTnZjbVVnWTNKNWNIUnZJR0p2ZUM0Z0oxeHVJQ0FnSUNBZ0lDQWdJQ0FnS3lCZ1VISnZkbWxrWldRZ2NHaHlZWE5sSUdsek9pQWtlMHBUVDA0dWMzUnlhVzVuYVdaNUtHVnVZM0o1Y0hSbFpGTmxaV1JRYUhKaGMyVXBmUzVnTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdWRTlPUlhKeWIzSkRiMlJsTGtsT1ZrRk1TVVJmUTFKWlVGUlBYMEpQV0Y5UVFWSkJUVk1zWEc0Z0lDQWdJQ0FnSUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzNSaGRHbGpJR05zYVdWdWRFbHpUbTkwVTJWMGRYQW9LU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ1WlhjZ1ZFOU9RMnhwWlc1MFJYSnliM0lvWEc0Z0lDQWdJQ0FnSUNBZ0lDQlVUMDVGY25KdmNrTnZaR1V1UTB4SlJVNVVYMGxUWDA1UFZGOVRSVlJWVUN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ2RVVDA0Z1EyeHBaVzUwSUV4cFluSmhjbmtnYVhOdVhGd25kQ0J6WlhRZ2RYQWdjSEp2Y0dWeWJIa25MRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pXMXdkSGxVVDA1RmNuSnZja1JoZEdFc1hHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ2ZWeHVmVnh1SWwxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UT05Nb2R1bGUgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfb3BlbnRyYWNpbmcgPSByZXF1aXJlKFwib3BlbnRyYWNpbmdcIik7XG5cbnZhciBfVE9OQ2xpZW50RXJyb3IgPSByZXF1aXJlKFwiLi9UT05DbGllbnRFcnJvclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBUT04gQ2xpZW50IG1vZHVsZVxuICogRWFjaCBtb2R1bGUgbXVzdCBwcm92aWRlcyBhIGNvbW1vbiBjb25zdHJ1Y3RvciBhbmQgYSBgc2V0dXBgIG1ldGhvZC5cbiAqIEFsc28gZWFjaCBzcGVjaWZpYyBtb2R1bGUgcHJvdmlkZXMgc3BlY2lmaWMgc2V0IG9mIG1ldGhvZHMuXG4gKi9cbnZhciBUT05Nb2R1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ29udGV4dCB0byB3aGljaCB0aGlzIG1vZHVsZSBpcyBib3VuZFxuICAgKi9cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBtb2R1bGUgaW5zdGFuY2UuXG4gICAqIE5vdGUgdGhhdCBtb2R1bGUgbXVzdCBub3QgZ2V0cyByZWZlcmVuY2VzIHRvIG90aGVyIG1vZHVsZXMgaGVyZVxuICAgKiAoZm9yIHRoaXMgcHVycG9zZSB0aGVyZSBpcyBhIGBzZXR1cGAgbWV0aG9kKS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIFRPTk1vZHVsZShjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRPTk1vZHVsZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IC8vIE1vZHVsZVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBuZWNlc3Nhcnkgc2V0dXAgb2YgdGhpcyBtb2R1bGUuXG4gICAqIFRoZSBtZXRob2QgaXMgYSBzYWZlIHBsYWNlIHRvIGdldCBhIHJlZmVyZW5jZXMgdG8gb3RoZXIgbW9kdWxlcyBmcm9tIHRoZSBgY29udGV4dGAuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuXG4gIF9jcmVhdGVDbGFzcyhUT05Nb2R1bGUsIFt7XG4gICAga2V5OiBcInNldHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0dXAgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgICAgcmV0dXJuIF9zZXR1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0dXA7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGxldGVFcnJvckRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb21wbGV0ZUVycm9yRGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5jb250ZXh0LmNvbXBsZXRlRXJyb3JEYXRhKGRhdGEpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY29tcGxldGVFcnJvckRhdGEoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9jb21wbGV0ZUVycm9yRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcGxldGVFcnJvckRhdGE7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYSBjb3JlIGZvciBzcGVjaWZpZWQgbWV0aG9kIGFuZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE1ldGhvZCBwYXJhbWV0ZXJzIHdpbGwgYmUgc3RyaW5naWZpZWQgaW50byBKU09OXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWVzdENvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZXF1ZXN0Q29yZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBjb3JlQnJpZGdlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDb3JlQnJpZGdlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNvcmVCcmlkZ2UgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChjb3JlQnJpZGdlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3IuY2xpZW50SXNOb3RTZXR1cCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICBjb3JlQnJpZGdlLnJlcXVlc3QobWV0aG9kLCBwYXJhbXMgIT09IHVuZGVmaW5lZCA/IEpTT04uc3RyaW5naWZ5KHBhcmFtcykgfHwgJycgOiAnJywgZnVuY3Rpb24gKHJlc3VsdEpzb24sIGVycm9ySnNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KEpTT04ucGFyc2UoZXJyb3JKc29uKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0SnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZShyZXN1bHRKc29uKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVxdWVzdENvcmUoX3gyLCBfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9yZXF1ZXN0Q29yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWVzdENvcmU7XG4gICAgfSgpXG4gIH1dKTtcblxuICByZXR1cm4gVE9OTW9kdWxlO1xufSgpO1xuXG5leHBvcnRzLlRPTk1vZHVsZSA9IFRPTk1vZHVsZTtcblxuX2RlZmluZVByb3BlcnR5KFRPTk1vZHVsZSwgXCJtb2R1bGVOYW1lXCIsIHZvaWQgMCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OVVUMDVOYjJSMWJHVXVhbk1pWFN3aWJtRnRaWE1pT2xzaVZFOU9UVzlrZFd4bElpd2lZMjl1ZEdWNGRDSXNJbVJoZEdFaUxDSmpiMjF3YkdWMFpVVnljbTl5UkdGMFlTSXNJbTFsZEdodlpDSXNJbkJoY21GdGN5SXNJbWRsZEVOdmNtVkNjbWxrWjJVaUxDSmpiM0psUW5KcFpHZGxJaXdpVkU5T1EyeHBaVzUwUlhKeWIzSWlMQ0pqYkdsbGJuUkpjMDV2ZEZObGRIVndJaXdpVUhKdmJXbHpaU0lzSW5KbGMyOXNkbVVpTENKeVpXcGxZM1FpTENKeVpYRjFaWE4wSWl3aWRXNWtaV1pwYm1Wa0lpd2lTbE5QVGlJc0luTjBjbWx1WjJsbWVTSXNJbkpsYzNWc2RFcHpiMjRpTENKbGNuSnZja3B6YjI0aUxDSndZWEp6WlNKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPMEZCYjBKQk96dEJRVU5CT3pzN096czdPenM3T3pzN096czdPMEZCTkVaQk96czdPenRKUVV0aFFTeFRPMEZCUjFRN096czdRVUZMUVRzN096czdPenRCUVU5QkxIRkNRVUZaUXl4UFFVRmFMRVZCUVhWRE8wRkJRVUU3TzBGQlFVRTdPMEZCUTI1RExGTkJRVXRCTEU5QlFVd3NSMEZCWlVFc1QwRkJaanRCUVVOSUxFY3NRMEZGUkRzN1FVRkZRVHM3T3pzN1FVRkxRVHM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPemhIUVVsM1FrTXNTVHM3T3pzN2EwUkJRMklzUzBGQlMwUXNUMEZCVEN4RFFVRmhSU3hwUWtGQllpeERRVUVyUWtRc1NVRkJMMElzUXpzN096czdPenM3T3pzN096czdPenRCUVVkWU96czdPenM3T3pzN08zZEhRVTFyUTBVc1RTeEZRVUZuUWtNc1RUczdPenM3T3p0MVFrRkRja0lzUzBGQlMwb3NUMEZCVEN4RFFVRmhTeXhoUVVGaUxFVTdPenRCUVVGdVFrTXNaMEpCUVVGQkxGVTdPMjlDUVVORVFTeFZPenM3T3p0elFrRkRTME1zSzBKQlFXVkRMR2RDUVVGbUxFVTdPenRyUkVGRlNDeEpRVUZKUXl4UFFVRktMRU5CUVZrc1ZVRkJRME1zVDBGQlJDeEZRVUUwUWtNc1RVRkJOVUlzUlVGQmQwUTdRVUZEZGtWTUxHdENRVUZCUVN4VlFVRlZMRU5CUVVOTkxFOUJRVmdzUTBGRFNWUXNUVUZFU2l4RlFVVkpReXhOUVVGTkxFdEJRVXRUTEZOQlFWZ3NSMEZCZDBKRExFbEJRVWtzUTBGQlEwTXNVMEZCVEN4RFFVRmxXQ3hOUVVGbUxFdEJRVEJDTEVWQlFXeEVMRWRCUVhkRUxFVkJSalZFTEVWQlIwa3NWVUZCUTFrc1ZVRkJSQ3hGUVVGaFF5eFRRVUZpTEVWQlFUSkNPMEZCUTNaQ0xIZENRVUZKUVN4VFFVRktMRVZCUVdVN1FVRkRXRTRzYzBKQlFVRkJMRTFCUVUwc1EwRkJRMGNzU1VGQlNTeERRVUZEU1N4TFFVRk1MRU5CUVZkRUxGTkJRVmdzUTBGQlJDeERRVUZPTzBGQlEwZ3NjVUpCUmtRc1RVRkZUeXhKUVVGSlJDeFZRVUZLTEVWQlFXZENPMEZCUTI1Q1RpeHpRa0ZCUVVFc1QwRkJUeXhEUVVGRFNTeEpRVUZKTEVOQlFVTkpMRXRCUVV3c1EwRkJWMFlzVlVGQldDeERRVUZFTEVOQlFWQTdRVUZEU0N4eFFrRkdUU3hOUVVWQk8wRkJRMGhPTEhOQ1FVRkJRU3hQUVVGUExFTkJRVVVzUlVGQlJpeERRVUZRTzBGQlEwZzdRVUZEU2l4dFFrRllURHRCUVdGSUxHbENRV1JOTEVNN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMmRDUVRkRFJsZ3NVeUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cVhHNGdLaUJEYjNCNWNtbG5hSFFnTWpBeE9DMHlNREl3SUZSUFRpQkVSVllnVTA5TVZWUkpUMDVUSUV4VVJDNWNiaUFxWEc0Z0tpQk1hV05sYm5ObFpDQjFibVJsY2lCMGFHVWdVMDlHVkZkQlVrVWdSVlpCVEZWQlZFbFBUaUJNYVdObGJuTmxJQ2gwYUdVZ1hDSk1hV05sYm5ObFhDSXBPeUI1YjNVZ2JXRjVJRzV2ZENCMWMyVmNiaUFxSUhSb2FYTWdabWxzWlNCbGVHTmxjSFFnYVc0Z1kyOXRjR3hwWVc1alpTQjNhWFJvSUhSb1pTQk1hV05sYm5ObExpQWdXVzkxSUcxaGVTQnZZblJoYVc0Z1lTQmpiM0I1SUc5bUlIUm9aVnh1SUNvZ1RHbGpaVzV6WlNCaGREcGNiaUFxWEc0Z0tpQm9kSFJ3T2k4dmQzZDNMblJ2Ymk1a1pYWXZiR2xqWlc1elpYTmNiaUFxWEc0Z0tpQlZibXhsYzNNZ2NtVnhkV2x5WldRZ1lua2dZWEJ3YkdsallXSnNaU0JzWVhjZ2IzSWdZV2R5WldWa0lIUnZJR2x1SUhkeWFYUnBibWNzSUhOdlpuUjNZWEpsWEc0Z0tpQmthWE4wY21saWRYUmxaQ0IxYm1SbGNpQjBhR1VnVEdsalpXNXpaU0JwY3lCa2FYTjBjbWxpZFhSbFpDQnZiaUJoYmlCY0lrRlRJRWxUWENJZ1FrRlRTVk1zWEc0Z0tpQlhTVlJJVDFWVUlGZEJVbEpCVGxSSlJWTWdUMUlnUTA5T1JFbFVTVTlPVXlCUFJpQkJUbGtnUzBsT1JDd2daV2wwYUdWeUlHVjRjSEpsYzNNZ2IzSWdhVzF3YkdsbFpDNWNiaUFxSUZObFpTQjBhR1VnVEdsalpXNXpaU0JtYjNJZ2RHaGxJSE53WldOcFptbGpJRlJQVGlCRVJWWWdjMjltZEhkaGNtVWdaMjkyWlhKdWFXNW5JSEJsY20xcGMzTnBiMjV6SUdGdVpGeHVJQ29nYkdsdGFYUmhkR2x2Ym5NZ2RXNWtaWElnZEdobElFeHBZMlZ1YzJVdVhHNGdLaTljYmx4dUx5OGdRR1pzYjNkY2JpOHFJR1Z6YkdsdWRDMWthWE5oWW14bElHTnNZWE56TFcxbGRHaHZaSE10ZFhObExYUm9hWE1zSUc1dkxYVnpaUzFpWldadmNtVXRaR1ZtYVc1bExDQnVieTExYm1SbFppQXFMMXh1WEc0dkx5QkVaWEJ5WldOaGRHVmtPaUJVVDA1RGJHbGxiblJEYjNKbElIWXdMakUzTGpCY2JtbHRjRzl5ZENCN0lGTndZVzRzSUZOd1lXNURiMjUwWlhoMElIMGdabkp2YlNBbmIzQmxiblJ5WVdOcGJtY25PMXh1YVcxd2IzSjBJSHNnVkU5T1EyeHBaVzUwUlhKeWIzSWdmU0JtY205dElDY3VMMVJQVGtOc2FXVnVkRVZ5Y205eUp6dGNibWx0Y0c5eWRDQjBlWEJsSUhzZ1ZFOU9SWEp5YjNKRVlYUmhJSDBnWm5KdmJTQW5MaTlVVDA1RGJHbGxiblJGY25KdmNpYzdYRzVjYmk4cUtseHVJQ29nVkU5T1EyeHBaVzUwUTI5eVpVSnlhV1JuWlZ4dUlDb2dUV2x1YVcxaGJHbHpkR2xqSUd4bFoyRmplU0JwYm5SbGNtWmhZMlVnZEc4Z1kyOXlaU0JzYVdKeVlYSjVMbHh1SUNvZ1QyeGtJSE4wZVd4bElHTnZjbVZ6SUdScFpDQndjbTkyYVdSbElHOXViSGtnZEdocGN5QkJVRWt1WEc0Z0tpQkdiM0lnYm1WM0lITjBlV3hsSUdOdmNtVnpJRlJQVGtOc2FXVnVkQ0JqY21WaGRHVnpJR052Ym5SbGVIUWdZbTkxYm1RZ2QzSmhjSEJsY2lCM2FYUm9JSFJvYVhNZ2FXNTBaWEptWVdObExseHVJQ292WEc1bGVIQnZjblFnYVc1MFpYSm1ZV05sSUZSUFRrTnNhV1Z1ZEVOdmNtVkNjbWxrWjJVZ2UxeHVJQ0FnSUM4cUtseHVJQ0FnSUNBcUlFSmhZMnQzWVhKa0lHTnZiWEJoZEdsaWFXeHBkSGxjYmlBZ0lDQWdLaUJBY0dGeVlXMGdiV1YwYUc5a1hHNGdJQ0FnSUNvZ1FIQmhjbUZ0SUhCaGNtRnRjMHB6YjI1Y2JpQWdJQ0FnS2lCQWNHRnlZVzBnYjI1U1pYTjFiSFJjYmlBZ0lDQWdLaTljYmlBZ0lDQnlaWEYxWlhOMEtGeHVJQ0FnSUNBZ0lDQnRaWFJvYjJRNklITjBjbWx1Wnl4Y2JpQWdJQ0FnSUNBZ2NHRnlZVzF6U25OdmJqb2djM1J5YVc1bkxGeHVJQ0FnSUNBZ0lDQnZibEpsYzNWc2REb2dLSEpsYzNWc2RFcHpiMjQ2SUhOMGNtbHVaeXdnWlhKeWIzSktjMjl1T2lCemRISnBibWNwSUQwK0lIWnZhV1FzWEc0Z0lDQWdLVG9nZG05cFpEdGNibjFjYmx4dUx5b3FYRzRnS2lCVVQwNGdRMnhwWlc1MElFTnZjbVVnUVZCSlhHNGdLaUJEYkdsbGJuUWdRMjl5WlNCd1pYSm1iM0p0Y3lCamJHbGxiblFnZEdGemEzTWdkR2h5YjNWbmFDQnphVzVuYkdVZ1NsTlBUaTFpWVhObFpDQjBkVzV1Wld4cGJtY2diV1YwYUc5a0lHTmhiR3hsWkNCZ1kyOXlaVkpsY1hWbGMzUmdYRzRnS2lCRmRtVnllU0JqYjNKbElISmxjWFZsYzNRZ1kyRnVJR0psSUhCbGNtWnZjbTFsWkNCcGJpQjBkMjhnZDJGNWN6cGNiaUFxSUMwZ1lYTjVibU1nY21WeGRXVnpkQ0IzYVhSb0lHQmpiM0psVW1WeGRXVnpkR0FnYldWMGFHOWtYRzRnS2lCRGJHbGxiblFnYVhNZ1lTQnpkR0YwWldaMWJDQnZZbXBsWTNRdUlFVmhZMmdnWTJ4cFpXNTBJSE4wWVhSbElHTmhiR3hsWkNCaElHQmpiMjUwWlhoMFlDNWNiaUFxSUZOdklIbHZkU0J0ZFhOMElIVnpaU0JtYjJ4c2IzZHBibWNnY25Wc1pYTWdkMmhsYmlCM2IzSnJhVzVuSUhkcGRHZ2dZU0JqYjNKbE9seHVJQ29nTFNCamNtVmhkR1VnWVNCamIyNTBaWGgwSUc5aWFtVmpkQ0JoYm1RZ2NtVmpaV2wyWlNCamIyNTBaWGgwSUdoaGJtUnNaU0IzYVhSb0lHQmpiM0psUTNKbFlYUmxRMjl1ZEdWNGRHQmNiaUFxSUMwZ1kyOXVabWxuZFhKbElHQmpiMjUwWlhoMFlDQjNhWFJvSUdCamIyNW1hV2RnSUdsdWRtOWpZWFJwYjI0Z2JXVjBhRzlrWEc0Z0tpQXRJSEJoYzNNZ1kyOXVkR1Y0ZENCb1lXNWtiR1VnZEc4Z1lHTnZjbVZTWlhGMVpYTjBZRnh1SUNvZ0xTQjNhR1Z1SUhsdmRTQmtiMjRuZENCdVpXVmtJR052Ym5SbGVIUWdlVzkxSUcxMWMzUWdaR1Z6ZEhKdmVTQnBkQ0IzYVhSb0lHQmpiM0psUkdWemRISnZlVU52Ym5SbGVIUmdYRzRnS2k5Y2JtVjRjRzl5ZENCcGJuUmxjbVpoWTJVZ1ZFOU9RMnhwWlc1MFEyOXlaVXhwWW5KaGNua2daWGgwWlc1a2N5QlVUMDVEYkdsbGJuUkRiM0psUW5KcFpHZGxJSHRjYmlBZ0lDQXZLaXBjYmlBZ0lDQWdLaUJEY21WaGRHVWdibVYzSUdOdmJuUmxlSFFnWVc1a0lISmxkSFZ5Ym5NZ2FHRnVaR3hsSUhSdklHbDBYRzRnSUNBZ0lDb2dRSEJoY21GdElIdG1kVzVqZEdsdmJuMGdiMjVEYjI1MFpYaDBYRzRnSUNBZ0lDb3ZYRzRnSUNBZ1kyOXlaVU55WldGMFpVTnZiblJsZUhRb2IyNURiMjUwWlhoME9pQW9ZMjl1ZEdWNGREb2diblZ0WW1WeUtTQTlQaUIyYjJsa0tUb2dkbTlwWkR0Y2JseHVJQ0FnSUM4cUtseHVJQ0FnSUNBcUlFUmxjM1J5YjNrZ1kyOXVkR1Y0ZENCM2FYUm9JSE53WldOcFptbGxaQ0JvWVc1a2JHVmNiaUFnSUNBZ0tpQkFjR0Z5WVcwZ1kyOXVkR1Y0ZEZ4dUlDQWdJQ0FxSUVCd1lYSmhiU0J2YmtOdmJYQnNaWFJsWEc0Z0lDQWdJQ292WEc0Z0lDQWdZMjl5WlVSbGMzUnliM2xEYjI1MFpYaDBLR052Ym5SbGVIUTZJRzUxYldKbGNpd2diMjVEYjIxd2JHVjBaVG9nS0NrZ1BUNGdkbTlwWkNrNklIWnZhV1E3WEc1Y2JpQWdJQ0F2S2lwY2JpQWdJQ0FnS2lCUWIzTjBJR0Z6ZVc1aklISmxjWFZsYzNRZ2RHOGdZMjl5WlZ4dUlDQWdJQ0FxSUVCd1lYSmhiU0I3Ym5WdFltVnlmU0JqYjI1MFpYaDBYRzRnSUNBZ0lDb2dRSEJoY21GdElIdHpkSEpwYm1kOUlHMWxkR2h2WkZ4dUlDQWdJQ0FxSUVCd1lYSmhiU0I3YzNSeWFXNW5mU0J3WVhKaGJYTktjMjl1WEc0Z0lDQWdJQ29nUUhCaGNtRnRJSHRtZFc1amRHbHZibjBnYjI1U1pYTjFiSFJjYmlBZ0lDQWdLaTljYmlBZ0lDQmpiM0psVW1WeGRXVnpkQ2hjYmlBZ0lDQWdJQ0FnWTI5dWRHVjRkRG9nYm5WdFltVnlMRnh1SUNBZ0lDQWdJQ0J0WlhSb2IyUTZJSE4wY21sdVp5eGNiaUFnSUNBZ0lDQWdjR0Z5WVcxelNuTnZiam9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0J2YmxKbGMzVnNkRG9nS0hKbGMzVnNkRXB6YjI0NklITjBjbWx1Wnl3Z1pYSnliM0pLYzI5dU9pQnpkSEpwYm1jcElEMCtJSFp2YVdRc1hHNGdJQ0FnS1RvZ2RtOXBaRHRjYm4xY2JseHVMeW9xWEc0Z0tpQkRiMjUwWlhoMElHbHVJSGRvYVdOb0lHMXZaSFZzWlhNZ1lYSmxJSGR2Y210cGJtZGNiaUFxSUVGc2JDQnRiMlIxYkdVZ2FXNXpkR0Z1WTJWeklHRnlaU0JpYjNWdVpDQjBieUJ6YVc1bmJHVWdZMjl1ZEdWNGRGeHVJQ29nWVc1a0lHTmhiaUJqYjIxdGRXNXBZMkYwWlNCM2FYUm9JSE5wWW14cGJtY2diVzlrZFd4bGN5NWNiaUFxSUVOdmJuUmxlSFFnY0hKdmRtbGtaWE1nWW05MWJtUmxaQ0J0YjJSMWJHVnpJSGRwZEdnNlhHNGdLaUF0SUdGalkyVnpjeUIwYnlCamIyMXRiMjRnWTJ4cFpXNTBJR052Y21VZ1lXNWtJSEJ5WldOdmJtWnBaM1Z5WldRZ1kyOXlaU0JqYjI1MFpYaDBYRzRnS2lBdElHRmpZMlZ6Y3lCMGJ5QnphV0pzYVc1bklHMXZaSFZzWlhNZ0tIVnphVzVuSUdFZ2JXOWtkV3hsSUdOc1lYTnpJR0Z6SUdGdUlHbGtLVnh1SUNvdlhHNWxlSEJ2Y25RZ2FXNTBaWEptWVdObElGUlBUazF2WkhWc1pVTnZiblJsZUhRZ2UxeHVJQ0FnSUdkbGRFTnZjbVZDY21sa1oyVW9LVG9nVUhKdmJXbHpaVHcvVkU5T1EyeHBaVzUwUTI5eVpVSnlhV1JuWlQ0c1hHNWNiaUFnSUNCamIyMXdiR1YwWlVWeWNtOXlSR0YwWVNoa1lYUmhQem9nZXlCYmMzUnlhVzVuWFRvZ1lXNTVJSDBwT2lCUWNtOXRhWE5sUEZSUFRrVnljbTl5UkdGMFlUNHNYRzVjYmlBZ0lDQm5aWFJOYjJSMWJHVThWRDRvVFc5a2RXeGxRMnhoYzNNNklIUjVjR1Z2WmlCVVQwNU5iMlIxYkdVcE9pQlVMRnh1WEc0Z0lDQWdjMlZ5ZG1WeVZHbHRaVVJsYkhSaEtDazZJRkJ5YjIxcGMyVThiblZ0WW1WeVBpeGNibHh1SUNBZ0lITmxjblpsY2s1dmR5Z3BPaUJRY205dGFYTmxQRzUxYldKbGNqNHNYRzVjYmlBZ0lDQnpkR0Z5ZEZKdmIzUlRjR0Z1S0hSeVlXTmxTV1E2SUhOMGNtbHVaeXdnYzNCaGJrbGtPaUJ6ZEhKcGJtY3NJRzVoYldVNklITjBjbWx1WnlrNklGTndZVzRzWEc1Y2JpQWdJQ0IwY21GalpUeFVQaWhjYmlBZ0lDQWdJQ0FnYm1GdFpUb2djM1J5YVc1bkxGeHVJQ0FnSUNBZ0lDQm1PaUFvYzNCaGJqb2dVM0JoYmlrZ1BUNGdVSEp2YldselpUeFVQaXhjYmlBZ0lDQWdJQ0FnY0dGeVpXNTBVM0JoYmo4NklDaFRjR0Z1SUh3Z1UzQmhia052Ym5SbGVIUXBMRnh1SUNBZ0lDazZJRkJ5YjIxcGMyVThWRDRzWEc1OVhHNWNiaThxS2x4dUlDb2dWRTlPSUVOc2FXVnVkQ0J0YjJSMWJHVmNiaUFxSUVWaFkyZ2diVzlrZFd4bElHMTFjM1FnY0hKdmRtbGtaWE1nWVNCamIyMXRiMjRnWTI5dWMzUnlkV04wYjNJZ1lXNWtJR0VnWUhObGRIVndZQ0J0WlhSb2IyUXVYRzRnS2lCQmJITnZJR1ZoWTJnZ2MzQmxZMmxtYVdNZ2JXOWtkV3hsSUhCeWIzWnBaR1Z6SUhOd1pXTnBabWxqSUhObGRDQnZaaUJ0WlhSb2IyUnpMbHh1SUNvdlhHNWxlSEJ2Y25RZ1kyeGhjM01nVkU5T1RXOWtkV3hsSUh0Y2JpQWdJQ0J6ZEdGMGFXTWdiVzlrZFd4bFRtRnRaVG9nYzNSeWFXNW5PMXh1WEc0Z0lDQWdMeW9xWEc0Z0lDQWdJQ29nUTI5dWRHVjRkQ0IwYnlCM2FHbGphQ0IwYUdseklHMXZaSFZzWlNCcGN5QmliM1Z1WkZ4dUlDQWdJQ0FxTDF4dUlDQWdJR052Ym5SbGVIUTZJRlJQVGsxdlpIVnNaVU52Ym5SbGVIUTdYRzVjYmlBZ0lDQXZLaXBjYmlBZ0lDQWdLaUJKYm1sMGFXRnNhWHBsSUcxdlpIVnNaU0JwYm5OMFlXNWpaUzVjYmlBZ0lDQWdLaUJPYjNSbElIUm9ZWFFnYlc5a2RXeGxJRzExYzNRZ2JtOTBJR2RsZEhNZ2NtVm1aWEpsYm1ObGN5QjBieUJ2ZEdobGNpQnRiMlIxYkdWeklHaGxjbVZjYmlBZ0lDQWdLaUFvWm05eUlIUm9hWE1nY0hWeWNHOXpaU0IwYUdWeVpTQnBjeUJoSUdCelpYUjFjR0FnYldWMGFHOWtLUzVjYmlBZ0lDQWdLbHh1SUNBZ0lDQXFJRUJ3WVhKaGJTQmpiMjUwWlhoMFhHNGdJQ0FnSUNvdlhHNGdJQ0FnWTI5dWMzUnlkV04wYjNJb1kyOXVkR1Y0ZERvZ1ZFOU9UVzlrZFd4bFEyOXVkR1Y0ZENrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG1OdmJuUmxlSFFnUFNCamIyNTBaWGgwTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUUxdlpIVnNaVnh1WEc0Z0lDQWdMeW9xWEc0Z0lDQWdJQ29nVUdWeVptOXliWE1nYm1WalpYTnpZWEo1SUhObGRIVndJRzltSUhSb2FYTWdiVzlrZFd4bExseHVJQ0FnSUNBcUlGUm9aU0J0WlhSb2IyUWdhWE1nWVNCellXWmxJSEJzWVdObElIUnZJR2RsZENCaElISmxabVZ5Wlc1alpYTWdkRzhnYjNSb1pYSWdiVzlrZFd4bGN5Qm1jbTl0SUhSb1pTQmdZMjl1ZEdWNGRHQXVYRzRnSUNBZ0lDb2dRSEpsZEhWeWJpQjdVSEp2YldselpUeDJiMmxrUG4xY2JpQWdJQ0FnS2k5Y2JpQWdJQ0F2THlCbGMyeHBiblF0WkdsellXSnNaUzF1WlhoMExXeHBibVVnYm04dFpXMXdkSGt0Wm5WdVkzUnBiMjVjYmlBZ0lDQmhjM2x1WXlCelpYUjFjQ2dwSUh0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QmpiMjF3YkdWMFpVVnljbTl5UkdGMFlTaGtZWFJoUHpvZ2V5QmJjM1J5YVc1blhUb2dZVzU1SUgwcE9pQlFjbTl0YVhObFBGUlBUa1Z5Y205eVJHRjBZVDRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NWpiMjUwWlhoMExtTnZiWEJzWlhSbFJYSnliM0pFWVhSaEtHUmhkR0VwTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzhxS2x4dUlDQWdJQ0FxSUZKbGNYVmxjM1J6SUdFZ1kyOXlaU0JtYjNJZ2MzQmxZMmxtYVdWa0lHMWxkR2h2WkNCaGJtUWdjR0Z5WVcxbGRHVnljeTVjYmlBZ0lDQWdLaUJBY0dGeVlXMGdlM04wY21sdVozMGdiV1YwYUc5a0lFMWxkR2h2WkNCdVlXMWxYRzRnSUNBZ0lDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlIQmhjbUZ0Y3lCTlpYUm9iMlFnY0dGeVlXMWxkR1Z5Y3lCM2FXeHNJR0psSUhOMGNtbHVaMmxtYVdWa0lHbHVkRzhnU2xOUFRseHVJQ0FnSUNBcUlFQnlaWFIxY200Z2UxQnliMjFwYzJVOFQySnFaV04wUG4xY2JpQWdJQ0FnS2k5Y2JpQWdJQ0JoYzNsdVl5QnlaWEYxWlhOMFEyOXlaVHhRWVhKaGJYTXNJRkpsYzNWc2RENG9iV1YwYUc5a09pQnpkSEpwYm1jc0lIQmhjbUZ0Y3o4NklGQmhjbUZ0Y3lrNklGQnliMjFwYzJVOFVtVnpkV3gwUGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUdOdmNtVkNjbWxrWjJVZ1BTQmhkMkZwZENCMGFHbHpMbU52Ym5SbGVIUXVaMlYwUTI5eVpVSnlhV1JuWlNncE8xeHVJQ0FnSUNBZ0lDQnBaaUFvSVdOdmNtVkNjbWxrWjJVcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRlJQVGtOc2FXVnVkRVZ5Y205eUxtTnNhV1Z1ZEVselRtOTBVMlYwZFhBb0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdibVYzSUZCeWIyMXBjMlVvS0hKbGMyOXNkbVU2SUNoU1pYTjFiSFFwSUQwK0lIWnZhV1FzSUhKbGFtVmpkRG9nS0VWeWNtOXlLU0E5UGlCMmIybGtLU0E5UGlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjNKbFFuSnBaR2RsTG5KbGNYVmxjM1FvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYldWMGFHOWtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEJoY21GdGN5QWhQVDBnZFc1a1pXWnBibVZrSUQ4Z0tFcFRUMDR1YzNSeWFXNW5hV1o1S0hCaGNtRnRjeWtnZkh3Z0p5Y3BJRG9nSnljc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0tISmxjM1ZzZEVwemIyNHNJR1Z5Y205eVNuTnZiaWtnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1pYSnliM0pLYzI5dUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaV3BsWTNRb1NsTlBUaTV3WVhKelpTaGxjbkp2Y2twemIyNHBLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHlaWE4xYkhSS2MyOXVLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxLRXBUVDA0dWNHRnljMlVvY21WemRXeDBTbk52YmlrcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVZ6YjJ4MlpTZ29lMzA2SUdGdWVTa3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lIMWNibjFjYmlKZGZRPT0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5VUkxQYXJ0cyA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9UT05Nb2R1bGUyID0gcmVxdWlyZShcIi4uL1RPTk1vZHVsZVwiKTtcblxudmFyIF9vcGVudHJhY2luZyA9IHJlcXVpcmUoXCJvcGVudHJhY2luZ1wiKTtcblxudmFyIF9ub29wID0gcmVxdWlyZShcIm9wZW50cmFjaW5nL2xpYi9ub29wXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgREVGQVVMVF9NRVNTQUdFX1JFVFJJRVNfQ09VTlQgPSAxMDtcbnZhciBERUZBVUxUX01FU1NBR0VfUFJPQ0VTU0lOR19USU1FT1VUID0gNDAwMDA7XG52YXIgREVGQVVMVF9XQUlUX0ZPUl9USU1FT1VUID0gNDAwMDA7XG52YXIgREVGQVVMVF9ORVRXT1JLX1RJTUVPVVQgPSAwO1xudmFyIERFRkFVTFRfT1VUX09GX1NZTkNfVEhSRVNIT0xEID0gMTUwMDA7XG5cbnZhciBVUkxQYXJ0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhVUkxQYXJ0cywgW3tcbiAgICBrZXk6IFwiZml4UHJvdG9jb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4UHJvdG9jb2woZml4KSB7XG4gICAgICB0aGlzLnByb3RvY29sID0gZml4KHRoaXMucHJvdG9jb2wpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpeEhvc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4SG9zdChmaXgpIHtcbiAgICAgIHRoaXMuaG9zdCA9IGZpeCh0aGlzLmhvc3QpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpeFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4UGF0aChmaXgpIHtcbiAgICAgIHRoaXMucGF0aCA9IGZpeCh0aGlzLnBhdGgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpeFF1ZXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeFF1ZXJ5KGZpeCkge1xuICAgICAgdGhpcy5xdWVyeSA9IGZpeCh0aGlzLnF1ZXJ5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHVybCkge1xuICAgICAgdmFyIHByb3RvY29sU2VwYXJhdG9yUG9zID0gdXJsLmluZGV4T2YoJzovLycpO1xuICAgICAgdmFyIHByb3RvY29sRW5kID0gcHJvdG9jb2xTZXBhcmF0b3JQb3MgPj0gMCA/IHByb3RvY29sU2VwYXJhdG9yUG9zICsgMyA6IDA7XG4gICAgICB2YXIgcXVlc3Rpb25Qb3MgPSB1cmwuaW5kZXhPZignPycsIHByb3RvY29sRW5kKTtcbiAgICAgIHZhciBxdWVyeVN0YXJ0ID0gcXVlc3Rpb25Qb3MgPj0gMCA/IHF1ZXN0aW9uUG9zICsgMSA6IHVybC5sZW5ndGg7XG4gICAgICB2YXIgcGF0aEVuZCA9IHF1ZXN0aW9uUG9zID49IDAgPyBxdWVzdGlvblBvcyA6IHVybC5sZW5ndGg7XG4gICAgICB2YXIgcGF0aFNlcGFyYXRvclBvcyA9IHVybC5pbmRleE9mKCcvJywgcHJvdG9jb2xFbmQpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcblxuICAgICAgdmFyIHBhdGhTdGFydCA9IHBhdGhTZXBhcmF0b3JQb3MgPj0gMCA/IHBhdGhTZXBhcmF0b3JQb3MgPCBwYXRoRW5kID8gcGF0aFNlcGFyYXRvclBvcyA6IHBhdGhFbmQgOiBxdWVzdGlvblBvcyA+PSAwID8gcXVlc3Rpb25Qb3MgOiB1cmwubGVuZ3RoO1xuICAgICAgcmV0dXJuIG5ldyBVUkxQYXJ0cyh1cmwuc3Vic3RyaW5nKDAsIHByb3RvY29sRW5kKSwgdXJsLnN1YnN0cmluZyhwcm90b2NvbEVuZCwgcGF0aFN0YXJ0KSwgdXJsLnN1YnN0cmluZyhwYXRoU3RhcnQsIHBhdGhFbmQpLCB1cmwuc3Vic3RyaW5nKHF1ZXJ5U3RhcnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlVXJsKGJhc2VVcmwsIHVybCkge1xuICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFBhcnRzLnBhcnNlKGJhc2VVcmwpO1xuICAgICAgcmV0dXJuIFVSTFBhcnRzLnBhcnNlKHVybCkuZml4UHJvdG9jb2woZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggfHwgYmFzZVBhcnRzLnByb3RvY29sO1xuICAgICAgfSkuZml4SG9zdChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCB8fCBiYXNlUGFydHMuaG9zdDtcbiAgICAgIH0pLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gVVJMUGFydHMocHJvdG9jb2wsIGhvc3QsIHBhdGgsIHF1ZXJ5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVSTFBhcnRzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3RvY29sXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJob3N0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXRoXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWVyeVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVVJMUGFydHMsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIHdoaWxlIChwYXRoLmluZGV4T2YoJy8vJykgPj0gMCkge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoICE9PSAnJyAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcGF0aCA9IFwiL1wiLmNvbmNhdChwYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMucHJvdG9jb2wpLmNvbmNhdCh0aGlzLmhvc3QpLmNvbmNhdChwYXRoKS5jb25jYXQodGhpcy5xdWVyeSAhPT0gJycgPyAnPycgOiAnJykuY29uY2F0KHRoaXMucXVlcnkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVUkxQYXJ0cztcbn0oKTtcblxuZXhwb3J0cy5VUkxQYXJ0cyA9IFVSTFBhcnRzO1xudmFyIGRlZmF1bHRTZXJ2ZXIgPSAnaHR0cDovL2xvY2FsaG9zdCc7XG5cbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cblxudmFyIFRPTkNvbmZpZ01vZHVsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RPTk1vZHVsZSkge1xuICBfaW5oZXJpdHMoVE9OQ29uZmlnTW9kdWxlLCBfVE9OTW9kdWxlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRPTkNvbmZpZ01vZHVsZSk7XG5cbiAgZnVuY3Rpb24gVE9OQ29uZmlnTW9kdWxlKGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVE9OQ29uZmlnTW9kdWxlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZGF0YVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInRyYWNlclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9sb2dWZXJib3NlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2VyckxvZ1ZlcmJvc2VcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfcHJvZmlsZVN0YXJ0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3Byb2ZpbGVQcmV2XCIsIHZvaWQgMCk7XG5cbiAgICBfdGhpcy5kYXRhID0ge1xuICAgICAgc2VydmVyczogW2RlZmF1bHRTZXJ2ZXJdXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVE9OQ29uZmlnTW9kdWxlLCBbe1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCB0aGlzLmRhdGE7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuc2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5kYXRhLnNlcnZlcnMucHVzaChkZWZhdWx0U2VydmVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFjZXIgPSBkYXRhLnRyYWNlciB8fCBfbm9vcC50cmFjZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbmZpZ1NlcnZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25maWdTZXJ2ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkZGF0YSwgX3RoaXMkZGF0YSRzZXJ2ZXJzO1xuXG4gICAgICByZXR1cm4gKChfdGhpcyRkYXRhID0gdGhpcy5kYXRhKSA9PT0gbnVsbCB8fCBfdGhpcyRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXMkZGF0YSRzZXJ2ZXJzID0gX3RoaXMkZGF0YS5zZXJ2ZXJzKSA9PT0gbnVsbCB8fCBfdGhpcyRkYXRhJHNlcnZlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGRhdGEkc2VydmVyc1swXSkgfHwgJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dE9mU3luY1RocmVzaG9sZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRPZlN5bmNUaHJlc2hvbGQoKSB7XG4gICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGhpcy5kYXRhLm91dE9mU3luY1RocmVzaG9sZCwgREVGQVVMVF9PVVRfT0ZfU1lOQ19USFJFU0hPTEQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXNzYWdlUmV0cmllc0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lc3NhZ2VSZXRyaWVzQ291bnQoKSB7XG4gICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGhpcy5kYXRhLm1lc3NhZ2VSZXRyaWVzQ291bnQsIERFRkFVTFRfTUVTU0FHRV9SRVRSSUVTX0NPVU5UKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVzc2FnZVByb2Nlc3NpbmdUaW1lb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lc3NhZ2VQcm9jZXNzaW5nVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5kYXRhLm1lc3NhZ2VQcm9jZXNzaW5nVGltZW91dDtcbiAgICAgIHJldHVybiB0aW1lb3V0ID09PSAwID8gMCA6IHRpbWVvdXQgfHwgREVGQVVMVF9NRVNTQUdFX1BST0NFU1NJTkdfVElNRU9VVDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2FpdEZvclRpbWVvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FpdEZvclRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGhpcy5kYXRhLndhaXRGb3JUaW1lb3V0LCBERUZBVUxUX1dBSVRfRk9SX1RJTUVPVVQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXR3b3JrVGltZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXR3b3JrVGltZW91dCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aGlzLmRhdGEubmV0d29ya1RpbWVvdXQsIERFRkFVTFRfTkVUV09SS19USU1FT1VUKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNOZXR3b3JrVGltZW91dEV4cGlyZWRTaW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc05ldHdvcmtUaW1lb3V0RXhwaXJlZFNpbmNlKHN0YXJ0VGltZSkge1xuICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLm5ldHdvcmtUaW1lb3V0KCk7XG5cbiAgICAgIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERhdGUubm93KCkgPiBzdGFydFRpbWUgKyB0aW1lb3V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nKCkge1xuICAgICAgdmFyIHByb2ZpbGUgPSAodGhpcy5fcHJvZmlsZVN0YXJ0IHx8IDApICE9PSAwO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgdmFyIHRpbWVTdHJpbmcgPSBcIlwiLmNvbmNhdChTdHJpbmcoY3VycmVudC50b0ZpeGVkKDMpKSwgXCIgXCIpLmNvbmNhdChTdHJpbmcoKGN1cnJlbnQgLSB0aGlzLl9wcm9maWxlU3RhcnQpLnRvRml4ZWQoMykpLCBcIiBcIikuY29uY2F0KFN0cmluZygoY3VycmVudCAtIHRoaXMuX3Byb2ZpbGVQcmV2KS50b0ZpeGVkKDMpKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvZ1ZlcmJvc2UpIHtcbiAgICAgICAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAgICAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIFtcIltcIi5jb25jYXQodGltZVN0cmluZywgXCJdXFxuXCIpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1wiLmNvbmNhdCh0aW1lU3RyaW5nLCBcIl1cXG5cIiksIGFyZ3NbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJvZmlsZVByZXYgPSBjdXJyZW50O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb2dWZXJib3NlKSB7XG4gICAgICAgIHZhciBfY29uc29sZTI7XG5cbiAgICAgICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZTIsIFtcIltcIi5jb25jYXQoRGF0ZS5ub3coKSAvIDEwMDAsIFwiXVwiKV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRQcm9maWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0UHJvZmlsZSgpIHtcbiAgICAgIHRoaXMuX3Byb2ZpbGVTdGFydCA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgdGhpcy5fcHJvZmlsZVByZXYgPSB0aGlzLl9wcm9maWxlU3RhcnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BQcm9maWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BQcm9maWxlKCkge1xuICAgICAgdGhpcy5fcHJvZmlsZVN0YXJ0ID0gdGhpcy5fcHJvZmlsZVByZXYgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0VmVyc2lvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCd2ZXJzaW9uJykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRWZXJzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRWZXJzaW9uO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0dXAgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIGNvcmVDb25maWc7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb3JlQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kYXRhKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29yZUNvbmZpZy50cmFjZXI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdzZXR1cCcsIGNvcmVDb25maWcpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dWZXJib3NlID0gdGhpcy5kYXRhLmxvZ192ZXJib3NlIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvZ1ZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQcm9maWxlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyTG9nVmVyYm9zZSA9IHRoaXMuZGF0YS5lcnJfbG9nX3ZlcmJvc2UgfHwgdHJ1ZTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAgIHJldHVybiBfc2V0dXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldHVwO1xuICAgIH0oKVxuICB9XSk7XG5cbiAgcmV0dXJuIFRPTkNvbmZpZ01vZHVsZTtcbn0oX1RPTk1vZHVsZTIuVE9OTW9kdWxlKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUT05Db25maWdNb2R1bGU7XG5UT05Db25maWdNb2R1bGUubW9kdWxlTmFtZSA9ICdUT05Db25maWdNb2R1bGUnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5dGIyUjFiR1Z6TDFSUFRrTnZibVpwWjAxdlpIVnNaUzVxY3lKZExDSnVZVzFsY3lJNld5SkVSVVpCVlV4VVgwMUZVMU5CUjBWZlVrVlVVa2xGVTE5RFQxVk9WQ0lzSWtSRlJrRlZURlJmVFVWVFUwRkhSVjlRVWs5RFJWTlRTVTVIWDFSSlRVVlBWVlFpTENKRVJVWkJWVXhVWDFkQlNWUmZSazlTWDFSSlRVVlBWVlFpTENKRVJVWkJWVXhVWDA1RlZGZFBVa3RmVkVsTlJVOVZWQ0lzSWtSRlJrRlZURlJmVDFWVVgwOUdYMU5aVGtOZlZFaFNSVk5JVDB4RUlpd2lWVkpNVUdGeWRITWlMQ0ptYVhnaUxDSndjbTkwYjJOdmJDSXNJbWh2YzNRaUxDSndZWFJvSWl3aWNYVmxjbmtpTENKMWNtd2lMQ0p3Y205MGIyTnZiRk5sY0dGeVlYUnZjbEJ2Y3lJc0ltbHVaR1Y0VDJZaUxDSndjbTkwYjJOdmJFVnVaQ0lzSW5GMVpYTjBhVzl1VUc5eklpd2ljWFZsY25sVGRHRnlkQ0lzSW14bGJtZDBhQ0lzSW5CaGRHaEZibVFpTENKd1lYUm9VMlZ3WVhKaGRHOXlVRzl6SWl3aWNHRjBhRk4wWVhKMElpd2ljM1ZpYzNSeWFXNW5JaXdpWW1GelpWVnliQ0lzSW1KaGMyVlFZWEowY3lJc0luQmhjbk5sSWl3aVptbDRVSEp2ZEc5amIyd2lMQ0o0SWl3aVptbDRTRzl6ZENJc0luUnZVM1J5YVc1bklpd2ljbVZ3YkdGalpTSXNJbk4wWVhKMGMxZHBkR2dpTENKa1pXWmhkV3gwVTJWeWRtVnlJaXdpZG1Gc2RXVlBja1JsWm1GMWJIUWlMQ0oyWVd4MVpTSXNJbVJsWm1GMWJIUldZV3gxWlNJc0luVnVaR1ZtYVc1bFpDSXNJbFJQVGtOdmJtWnBaMDF2WkhWc1pTSXNJbU52Ym5SbGVIUWlMQ0prWVhSaElpd2ljMlZ5ZG1WeWN5SXNJbkIxYzJnaUxDSjBjbUZqWlhJaUxDSnViMjl3VkhKaFkyVnlJaXdpYjNWMFQyWlRlVzVqVkdoeVpYTm9iMnhrSWl3aWJXVnpjMkZuWlZKbGRISnBaWE5EYjNWdWRDSXNJblJwYldWdmRYUWlMQ0p0WlhOellXZGxVSEp2WTJWemMybHVaMVJwYldWdmRYUWlMQ0ozWVdsMFJtOXlWR2x0Wlc5MWRDSXNJbTVsZEhkdmNtdFVhVzFsYjNWMElpd2ljM1JoY25SVWFXMWxJaXdpUkdGMFpTSXNJbTV2ZHlJc0luQnliMlpwYkdVaUxDSmZjSEp2Wm1sc1pWTjBZWEowSWl3aVlYSm5jeUlzSW1OMWNuSmxiblFpTENKMGFXMWxVM1J5YVc1bklpd2lVM1J5YVc1bklpd2lkRzlHYVhobFpDSXNJbDl3Y205bWFXeGxVSEpsZGlJc0lsOXNiMmRXWlhKaWIzTmxJaXdpWTI5dWMyOXNaU0lzSW14dlp5SXNJbkpsY1hWbGMzUkRiM0psSWl3aVkyOXlaVU52Ym1acFp5SXNJazlpYW1WamRDSXNJbUZ6YzJsbmJpSXNJbXh2WjE5MlpYSmliM05sSWl3aWMzUmhjblJRY205bWFXeGxJaXdpWDJWeWNreHZaMVpsY21KdmMyVWlMQ0psY25KZmJHOW5YM1psY21KdmMyVWlMQ0pVVDA1TmIyUjFiR1VpTENKdGIyUjFiR1ZPWVcxbElsMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3UVVGUFFUczdRVUZEUVRzN1FVRkRRVHM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN1FVRkZRU3hKUVVGTlFTdzJRa0ZCTmtJc1IwRkJSeXhGUVVGMFF6dEJRVU5CTEVsQlFVMURMR3REUVVGclF5eEhRVUZITEV0QlFUTkRPMEZCUTBFc1NVRkJUVU1zZDBKQlFYZENMRWRCUVVjc1MwRkJha003UVVGRFFTeEpRVUZOUXl4MVFrRkJkVUlzUjBGQlJ5eERRVUZvUXp0QlFVVkJMRWxCUVUxRExEWkNRVUUyUWl4SFFVRkhMRXRCUVhSRE96dEpRVVZoUXl4Uk96czdaME5CTkVKSFF5eEhMRVZCUVhORE8wRkJRemxETEZkQlFVdERMRkZCUVV3c1IwRkJaMEpFTEVkQlFVY3NRMEZCUXl4TFFVRkxReXhSUVVGT0xFTkJRVzVDTzBGQlEwRXNZVUZCVHl4SlFVRlFPMEZCUTBnN096czBRa0ZGVDBRc1J5eEZRVUZ6UXp0QlFVTXhReXhYUVVGTFJTeEpRVUZNTEVkQlFWbEdMRWRCUVVjc1EwRkJReXhMUVVGTFJTeEpRVUZPTEVOQlFXWTdRVUZEUVN4aFFVRlBMRWxCUVZBN1FVRkRTRHM3T3pSQ1FVVlBSaXhITEVWQlFYTkRPMEZCUXpGRExGZEJRVXRITEVsQlFVd3NSMEZCV1Vnc1IwRkJSeXhEUVVGRExFdEJRVXRITEVsQlFVNHNRMEZCWmp0QlFVTkJMR0ZCUVU4c1NVRkJVRHRCUVVOSU96czdOa0pCUlZGSUxFY3NSVUZCYzBNN1FVRkRNME1zVjBGQlMwa3NTMEZCVEN4SFFVRmhTaXhIUVVGSExFTkJRVU1zUzBGQlMwa3NTMEZCVGl4RFFVRm9RanRCUVVOQkxHRkJRVThzU1VGQlVEdEJRVU5JT3pzN01FSkJOME5aUXl4SExFVkJRWFZDTzBGQlEyaERMRlZCUVUxRExHOUNRVUZ2UWl4SFFVRkhSQ3hIUVVGSExFTkJRVU5GTEU5QlFVb3NRMEZCV1N4TFFVRmFMRU5CUVRkQ08wRkJRMEVzVlVGQlRVTXNWMEZCVnl4SFFVRkhSaXh2UWtGQmIwSXNTVUZCU1N4RFFVRjRRaXhIUVVFMFFrRXNiMEpCUVc5Q0xFZEJRVWNzUTBGQmJrUXNSMEZCZFVRc1EwRkJNMFU3UVVGRFFTeFZRVUZOUnl4WFFVRlhMRWRCUVVkS0xFZEJRVWNzUTBGQlEwVXNUMEZCU2l4RFFVRlpMRWRCUVZvc1JVRkJhVUpETEZkQlFXcENMRU5CUVhCQ08wRkJRMEVzVlVGQlRVVXNWVUZCVlN4SFFVRkhSQ3hYUVVGWExFbEJRVWtzUTBGQlppeEhRVUZ0UWtFc1YwRkJWeXhIUVVGSExFTkJRV3BETEVkQlFYRkRTaXhIUVVGSExFTkJRVU5OTEUxQlFUVkVPMEZCUTBFc1ZVRkJUVU1zVDBGQlR5eEhRVUZIU0N4WFFVRlhMRWxCUVVrc1EwRkJaaXhIUVVGdFFrRXNWMEZCYmtJc1IwRkJhVU5LTEVkQlFVY3NRMEZCUTAwc1RVRkJja1E3UVVGRFFTeFZRVUZOUlN4blFrRkJaMElzUjBGQlIxSXNSMEZCUnl4RFFVRkRSU3hQUVVGS0xFTkJRVmtzUjBGQldpeEZRVUZwUWtNc1YwRkJha0lzUTBGQmVrSXNRMEZPWjBNc1EwRlBhRU03TzBGQlEwRXNWVUZCVFUwc1UwRkJVeXhIUVVGSFJDeG5Ra0ZCWjBJc1NVRkJTU3hEUVVGd1FpeEhRVU5ZUVN4blFrRkJaMElzUjBGQlIwUXNUMEZCYmtJc1IwRkJOa0pETEdkQ1FVRTNRaXhIUVVGblJFUXNUMEZFY2tNc1IwRkZXRWdzVjBGQlZ5eEpRVUZKTEVOQlFXWXNSMEZCYlVKQkxGZEJRVzVDTEVkQlFXbERTaXhIUVVGSExFTkJRVU5OTEUxQlJqVkRPMEZCUjBFc1lVRkJUeXhKUVVGSldpeFJRVUZLTEVOQlEwaE5MRWRCUVVjc1EwRkJRMVVzVTBGQlNpeERRVUZqTEVOQlFXUXNSVUZCYVVKUUxGZEJRV3BDTEVOQlJFY3NSVUZGU0Vnc1IwRkJSeXhEUVVGRFZTeFRRVUZLTEVOQlFXTlFMRmRCUVdRc1JVRkJNa0pOTEZOQlFUTkNMRU5CUmtjc1JVRkhTRlFzUjBGQlJ5eERRVUZEVlN4VFFVRktMRU5CUVdORUxGTkJRV1FzUlVGQmVVSkdMRTlCUVhwQ0xFTkJTRWNzUlVGSlNGQXNSMEZCUnl4RFFVRkRWU3hUUVVGS0xFTkJRV05NTEZWQlFXUXNRMEZLUnl4RFFVRlFPMEZCVFVnN096c3JRa0ZGYVVKTkxFOHNSVUZCYVVKWUxFY3NSVUZCY1VJN1FVRkRjRVFzVlVGQlRWa3NVMEZCVXl4SFFVRkhiRUlzVVVGQlVTeERRVUZEYlVJc1MwRkJWQ3hEUVVGbFJpeFBRVUZtTEVOQlFXeENPMEZCUTBFc1lVRkJUMnBDTEZGQlFWRXNRMEZCUTIxQ0xFdEJRVlFzUTBGQlpXSXNSMEZCWml4RlFVTkdZeXhYUVVSRkxFTkJRMVVzVlVGQlFVTXNRMEZCUXp0QlFVRkJMR1ZCUVVsQkxFTkJRVU1zU1VGQlNVZ3NVMEZCVXl4RFFVRkRhRUlzVVVGQmJrSTdRVUZCUVN4UFFVUllMRVZCUlVadlFpeFBRVVpGTEVOQlJVMHNWVUZCUVVRc1EwRkJRenRCUVVGQkxHVkJRVWxCTEVOQlFVTXNTVUZCU1Vnc1UwRkJVeXhEUVVGRFppeEpRVUZ1UWp0QlFVRkJMRTlCUmxBc1JVRkhSbTlDTEZGQlNFVXNSVUZCVUR0QlFVbElPenM3UVVFclFrUXNiMEpCUVZseVFpeFJRVUZhTEVWQlFUaENReXhKUVVFNVFpeEZRVUUwUTBNc1NVRkJOVU1zUlVGQk1FUkRMRXRCUVRGRUxFVkJRWGxGTzBGQlFVRTdPMEZCUVVFN08wRkJRVUU3TzBGQlFVRTdPMEZCUVVFN08wRkJRM0pGTEZOQlFVdElMRkZCUVV3c1IwRkJaMEpCTEZGQlFXaENPMEZCUTBFc1UwRkJTME1zU1VGQlRDeEhRVUZaUVN4SlFVRmFPMEZCUTBFc1UwRkJTME1zU1VGQlRDeEhRVUZaUVN4SlFVRmFPMEZCUTBFc1UwRkJTME1zUzBGQlRDeEhRVUZoUVN4TFFVRmlPMEZCUTBnN096czdLMEpCUjJ0Q08wRkJRVUVzVlVGRFZFUXNTVUZFVXl4SFFVTkJMRWxCUkVFc1EwRkRWRUVzU1VGRVV6czdRVUZGWml4aFFVRlBRU3hKUVVGSkxFTkJRVU5KTEU5QlFVd3NRMEZCWVN4SlFVRmlMRXRCUVhOQ0xFTkJRVGRDTEVWQlFXZERPMEZCUXpWQ1NpeFJRVUZCUVN4SlFVRkpMRWRCUVVkQkxFbEJRVWtzUTBGQlEyOUNMRTlCUVV3c1EwRkJZU3hKUVVGaUxFVkJRVzFDTEVkQlFXNUNMRU5CUVZBN1FVRkRTRHM3UVVGRFJDeFZRVUZKY0VJc1NVRkJTU3hMUVVGTExFVkJRVlFzU1VGQlpTeERRVUZEUVN4SlFVRkpMRU5CUVVOeFFpeFZRVUZNTEVOQlFXZENMRWRCUVdoQ0xFTkJRWEJDTEVWQlFUQkRPMEZCUTNSRGNrSXNVVUZCUVVFc1NVRkJTU3hqUVVGUFFTeEpRVUZRTEVOQlFVbzdRVUZEU0RzN1FVRkRSQ3gxUWtGQlZTeExRVUZMUml4UlFVRm1MRk5CUVRCQ0xFdEJRVXRETEVsQlFTOUNMRk5CUVhORFF5eEpRVUYwUXl4VFFVRTJReXhMUVVGTFF5eExRVUZNTEV0QlFXVXNSVUZCWml4SFFVRnZRaXhIUVVGd1FpeEhRVUV3UWl4RlFVRjJSU3hUUVVFMFJTeExRVUZMUVN4TFFVRnFSanRCUVVOSU96czdPenM3TzBGQlJVd3NTVUZCVFhGQ0xHRkJRV0VzUjBGQlJ5eHJRa0ZCZEVJN08wRkJRMEVzVTBGQlUwTXNZMEZCVkN4RFFVRjNRa01zUzBGQmVFSXNSVUZCSzBKRExGbEJRUzlDTEVWQlFUWkRPMEZCUTNwRExGTkJRVkZFTEV0QlFVc3NTMEZCUzBVc1UwRkJWaXhKUVVGMVFrWXNTMEZCU3l4TFFVRkxMRWxCUVd4RExFZEJRVEJEUXl4WlFVRXhReXhIUVVGNVJFUXNTMEZCYUVVN1FVRkRTRHM3U1VGRmIwSkhMR1U3T3pzN08wRkJTV3BDTERKQ1FVRlpReXhQUVVGYUxFVkJRWFZETzBGQlFVRTdPMEZCUVVFN08wRkJRMjVETERoQ1FVRk5RU3hQUVVGT096dEJRVVJ0UXpzN1FVRkJRVHM3UVVGQlFUczdRVUZCUVRzN1FVRkJRVHM3UVVGQlFUczdRVUZGYmtNc1ZVRkJTME1zU1VGQlRDeEhRVUZaTzBGQlExSkRMRTFCUVVGQkxFOUJRVThzUlVGQlJTeERRVUZEVWl4aFFVRkVPMEZCUkVRc1MwRkJXanRCUVVadFF6dEJRVXQwUXpzN096czBRa0ZGVDA4c1NTeEZRVUZ4UWp0QlFVTjZRaXhYUVVGTFFTeEpRVUZNTEVkQlFWbEJMRWxCUVVrc1NVRkJTU3hMUVVGTFFTeEpRVUY2UWpzN1FVRkRRU3hWUVVGSkxFdEJRVXRCTEVsQlFVd3NRMEZCVlVNc1QwRkJWaXhEUVVGclFuUkNMRTFCUVd4Q0xFdEJRVFpDTEVOQlFXcERMRVZCUVc5RE8wRkJRMmhETEdGQlFVdHhRaXhKUVVGTUxFTkJRVlZETEU5QlFWWXNRMEZCYTBKRExFbEJRV3hDTEVOQlFYVkNWQ3hoUVVGMlFqdEJRVU5JT3p0QlFVTkVMRmRCUVV0VkxFMUJRVXdzUjBGQlkwZ3NTVUZCU1N4RFFVRkRSeXhOUVVGTUxFbEJRV1ZETEZsQlFUZENPMEZCUTBnN096dHpRMEZGZVVJN1FVRkJRVHM3UVVGRGRFSXNZVUZCVHl4dlFrRkJTMG9zU1VGQlRDeG5Sa0ZCVjBNc1QwRkJXQ3d3UlVGQmNVSXNRMEZCY2tJc1RVRkJNa0lzUlVGQmJFTTdRVUZEU0RzN08zbERRVVUwUWp0QlFVTjZRaXhoUVVGUFVDeGpRVUZqTEVOQlFVTXNTMEZCUzAwc1NVRkJUQ3hEUVVGVlN5eHJRa0ZCV0N4RlFVRXJRblpETERaQ1FVRXZRaXhEUVVGeVFqdEJRVU5JT3pzN01FTkJSVFpDTzBGQlF6RkNMR0ZCUVU4MFFpeGpRVUZqTEVOQlFVTXNTMEZCUzAwc1NVRkJUQ3hEUVVGVlRTeHRRa0ZCV0N4RlFVRm5RelZETERaQ1FVRm9ReXhEUVVGeVFqdEJRVU5JT3pzN0swTkJSV3RETzBGQlF5OUNMRlZCUVUwMlF5eFBRVUZQTEVkQlFVY3NTMEZCUzFBc1NVRkJUQ3hEUVVGVlVTeDNRa0ZCTVVJN1FVRkRRU3hoUVVGUFJDeFBRVUZQTEV0QlFVc3NRMEZCV2l4SFFVRm5RaXhEUVVGb1FpeEhRVUZ4UWtFc1QwRkJUeXhKUVVGSk5VTXNhME5CUVhaRE8wRkJRMGc3T3p0eFEwRkZkMEk3UVVGRGNrSXNZVUZCVHl0Q0xHTkJRV01zUTBGQlF5eExRVUZMVFN4SlFVRk1MRU5CUVZWVExHTkJRVmdzUlVGQk1rSTNReXgzUWtGQk0wSXNRMEZCY2tJN1FVRkRTRHM3TzNGRFFVVjNRanRCUVVOeVFpeGhRVUZQT0VJc1kwRkJZeXhEUVVGRExFdEJRVXROTEVsQlFVd3NRMEZCVlZVc1kwRkJXQ3hGUVVFeVFqZERMSFZDUVVFelFpeERRVUZ5UWp0QlFVTklPenM3YVVSQlJUUkNPRU1zVXl4RlFVRTBRanRCUVVOeVJDeFZRVUZOU2l4UFFVRlBMRWRCUVVjc1MwRkJTMGNzWTBGQlRDeEZRVUZvUWpzN1FVRkRRU3hWUVVGSlNDeFBRVUZQTEV0QlFVc3NRMEZCYUVJc1JVRkJiVUk3UVVGRFppeGxRVUZQTEV0QlFWQTdRVUZEU0RzN1FVRkRSQ3hoUVVGUFN5eEpRVUZKTEVOQlFVTkRMRWRCUVV3c1MwRkJZMFlzVTBGQlV5eEhRVUZIU2l4UFFVRnFRenRCUVVOSU96czdNRUpCUlcxQ08wRkJRMmhDTEZWQlFVMVBMRTlCUVU4c1IwRkJSeXhEUVVGRExFdEJRVXRETEdGQlFVd3NTVUZCYzBJc1EwRkJka0lzVFVGQk9FSXNRMEZCT1VNN08wRkJSR2RDTEhkRFFVRmlReXhKUVVGaE8wRkJRV0pCTEZGQlFVRkJMRWxCUVdFN1FVRkJRVHM3UVVGRmFFSXNWVUZCU1VZc1QwRkJTaXhGUVVGaE8wRkJRMVFzV1VGQlRVY3NUMEZCVHl4SFFVRkhUQ3hKUVVGSkxFTkJRVU5ETEVkQlFVd3NTMEZCWVN4SlFVRTNRanRCUVVOQkxGbEJRVTFMTEZWQlFWVXNZVUZCVFVNc1RVRkJUU3hEUVVGRFJpeFBRVUZQTEVOQlFVTkhMRTlCUVZJc1EwRkJaMElzUTBGQmFFSXNRMEZCUkN4RFFVRmFMR05CUTFwRUxFMUJRVTBzUTBGQlF5eERRVUZEUml4UFFVRlBMRWRCUVVjc1MwRkJTMFlzWVVGQmFFSXNSVUZCSzBKTExFOUJRUzlDTEVOQlFYVkRMRU5CUVhaRExFTkJRVVFzUTBGRVRTeGpRVVZhUkN4TlFVRk5MRU5CUVVNc1EwRkJRMFlzVDBGQlR5eEhRVUZITEV0QlFVdEpMRmxCUVdoQ0xFVkJRVGhDUkN4UFFVRTVRaXhEUVVGelF5eERRVUYwUXl4RFFVRkVMRU5CUmswc1EwRkJhRUk3TzBGQlIwRXNXVUZCU1N4TFFVRkxSU3hYUVVGVUxFVkJRWE5DTzBGQlFVRTdPMEZCUTJ4Q0xITkNRVUZCUXl4UFFVRlBMRVZCUVVORExFZEJRVklzTmtKQlFXZENUaXhWUVVGb1FpeHBRa0ZCYjBOR0xFbEJRWEJETzBGQlEwZ3NVMEZHUkN4TlFVVlBPMEZCUTBoUExGVkJRVUZCTEU5QlFVOHNRMEZCUTBNc1IwRkJVaXhaUVVGblFrNHNWVUZCYUVJc1ZVRkJhVU5HTEVsQlFVa3NRMEZCUXl4RFFVRkVMRU5CUVhKRE8wRkJRMGc3TzBGQlEwUXNZVUZCUzBzc1dVRkJUQ3hIUVVGdlFrb3NUMEZCY0VJN1FVRkRTQ3hQUVZoRUxFMUJWMDhzU1VGQlNTeExRVUZMU3l4WFFVRlVMRVZCUVhOQ08wRkJRVUU3TzBGQlEzcENMSEZDUVVGQlF5eFBRVUZQTEVWQlFVTkRMRWRCUVZJc09FSkJRV2RDV2l4SlFVRkpMRU5CUVVORExFZEJRVXdzUzBGQllTeEpRVUUzUWl4bFFVRjVRMGNzU1VGQmVrTTdRVUZEU0R0QlFVTktPenM3YlVOQlJXTTdRVUZEV0N4WFFVRkxSQ3hoUVVGTUxFZEJRWEZDU0N4SlFVRkpMRU5CUVVORExFZEJRVXdzUzBGQllTeEpRVUZzUXp0QlFVTkJMRmRCUVV0UkxGbEJRVXdzUjBGQmIwSXNTMEZCUzA0c1lVRkJla0k3UVVGRFNEczdPMnREUVVWaE8wRkJRMVlzVjBGQlMwRXNZVUZCVEN4SFFVRnhRaXhMUVVGTFRTeFpRVUZNTEVkQlFXOUNMRU5CUVhwRE8wRkJRMGc3T3pzN096czdPenRwUkVGSFZTeExRVUZMU1N4WFFVRk1MRU5CUVdsQ0xGTkJRV3BDTEVNN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3Y1VKQlMwZ3NTMEZCUzNwQ0xFazdPenM3TzBGQlEwTXdRaXhuUWtGQlFVRXNWU3hIUVVGaFF5eE5RVUZOTEVOQlFVTkRMRTFCUVZBc1EwRkJZeXhGUVVGa0xFVkJRV3RDTEV0QlFVczFRaXhKUVVGMlFpeERPMEZCUTI1Q0xIVkNRVUZQTUVJc1ZVRkJWU3hEUVVGRGRrSXNUVUZCYkVJN08zVkNRVU5OTEV0QlFVdHpRaXhYUVVGTUxFTkJRV2xDTEU5QlFXcENMRVZCUVRCQ1F5eFZRVUV4UWl4RE96czdRVUZGVml4eFFrRkJTMG9zVjBGQlRDeEhRVUZ0UWl4TFFVRkxkRUlzU1VGQlRDeERRVUZWTmtJc1YwRkJWaXhKUVVGNVFpeExRVUUxUXpzN1FVRkRRU3h2UWtGQlNTeExRVUZMVUN4WFFVRlVMRVZCUVhOQ08wRkJRMnhDTEhWQ1FVRkxVU3haUVVGTU8wRkJRMGc3TzBGQlEwUXNjVUpCUVV0RExHTkJRVXdzUjBGQmMwSXNTMEZCU3k5Q0xFbEJRVXdzUTBGQlZXZERMR1ZCUVZZc1NVRkJOa0lzU1VGQmJrUTdPenM3T3pzN096czdPenM3T3pzN096czdSVUU1Um5GRFF5eHhRanM3TzBGQmQwYzNRMjVETEdWQlFXVXNRMEZCUTI5RExGVkJRV2hDTEVkQlFUWkNMR2xDUVVFM1FpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxWEc0Z0tpQkRiM0I1Y21sbmFIUWdNakF4T0MweU1ESXdJRlJQVGlCRVJWWWdVMDlNVlZSSlQwNVRJRXhVUkM1Y2JpQXFMMXh1WEc0dkx5QkFabXh2ZDF4dWFXMXdiM0owSUhSNWNHVWdleUJVVDA1RGIyNW1hV2RFWVhSaElIMGdabkp2YlNCY0lpNHVMeTR1TDNSNWNHVnpYQ0k3WEc1cGJYQnZjblFnZEhsd1pTQjdJRlJQVGsxdlpIVnNaVU52Ym5SbGVIUWdmU0JtY205dElGd2lMaTR2VkU5T1RXOWtkV3hsWENJN1hHNXBiWEJ2Y25RZ2V5QlVUMDVOYjJSMWJHVWdmU0JtY205dElDY3VMaTlVVDA1TmIyUjFiR1VuTzF4dWFXMXdiM0owSUhzZ1ZISmhZMlZ5SUgwZ1puSnZiU0FuYjNCbGJuUnlZV05wYm1jbk8xeHVhVzF3YjNKMElIc2dkSEpoWTJWeUlHRnpJRzV2YjNCVWNtRmpaWElnZlNCbWNtOXRJRndpYjNCbGJuUnlZV05wYm1jdmJHbGlMMjV2YjNCY0lqdGNibHh1WTI5dWMzUWdSRVZHUVZWTVZGOU5SVk5UUVVkRlgxSkZWRkpKUlZOZlEwOVZUbFFnUFNBeE1EdGNibU52Ym5OMElFUkZSa0ZWVEZSZlRVVlRVMEZIUlY5UVVrOURSVk5UU1U1SFgxUkpUVVZQVlZRZ1BTQTBNREF3TUR0Y2JtTnZibk4wSUVSRlJrRlZURlJmVjBGSlZGOUdUMUpmVkVsTlJVOVZWQ0E5SURRd01EQXdPMXh1WTI5dWMzUWdSRVZHUVZWTVZGOU9SVlJYVDFKTFgxUkpUVVZQVlZRZ1BTQXdPMXh1WEc1amIyNXpkQ0JFUlVaQlZVeFVYMDlWVkY5UFJsOVRXVTVEWDFSSVVrVlRTRTlNUkNBOUlERTFNREF3TzF4dVhHNWxlSEJ2Y25RZ1kyeGhjM01nVlZKTVVHRnlkSE1nZTF4dUlDQWdJSE4wWVhScFl5QndZWEp6WlNoMWNtdzZJSE4wY21sdVp5azZJRlZTVEZCaGNuUnpJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdjSEp2ZEc5amIyeFRaWEJoY21GMGIzSlFiM01nUFNCMWNtd3VhVzVrWlhoUFppZ25PaTh2SnlrN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhCeWIzUnZZMjlzUlc1a0lEMGdjSEp2ZEc5amIyeFRaWEJoY21GMGIzSlFiM01nUGowZ01DQS9JSEJ5YjNSdlkyOXNVMlZ3WVhKaGRHOXlVRzl6SUNzZ015QTZJREE3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSEYxWlhOMGFXOXVVRzl6SUQwZ2RYSnNMbWx1WkdWNFQyWW9KejhuTENCd2NtOTBiMk52YkVWdVpDazdYRzRnSUNBZ0lDQWdJR052Ym5OMElIRjFaWEo1VTNSaGNuUWdQU0J4ZFdWemRHbHZibEJ2Y3lBK1BTQXdJRDhnY1hWbGMzUnBiMjVRYjNNZ0t5QXhJRG9nZFhKc0xteGxibWQwYUR0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY0dGMGFFVnVaQ0E5SUhGMVpYTjBhVzl1VUc5eklENDlJREFnUHlCeGRXVnpkR2x2YmxCdmN5QTZJSFZ5YkM1c1pXNW5kR2c3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSEJoZEdoVFpYQmhjbUYwYjNKUWIzTWdQU0IxY213dWFXNWtaWGhQWmlnbkx5Y3NJSEJ5YjNSdlkyOXNSVzVrS1R0Y2JpQWdJQ0FnSUNBZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJtVjRkQzFzYVc1bElHNXZMVzVsYzNSbFpDMTBaWEp1WVhKNVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhCaGRHaFRkR0Z5ZENBOUlIQmhkR2hUWlhCaGNtRjBiM0pRYjNNZ1BqMGdNRnh1SUNBZ0lDQWdJQ0FnSUNBZ1B5QW9jR0YwYUZObGNHRnlZWFJ2Y2xCdmN5QThJSEJoZEdoRmJtUWdQeUJ3WVhSb1UyVndZWEpoZEc5eVVHOXpJRG9nY0dGMGFFVnVaQ2xjYmlBZ0lDQWdJQ0FnSUNBZ0lEb2dLSEYxWlhOMGFXOXVVRzl6SUQ0OUlEQWdQeUJ4ZFdWemRHbHZibEJ2Y3lBNklIVnliQzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdibVYzSUZWU1RGQmhjblJ6S0Z4dUlDQWdJQ0FnSUNBZ0lDQWdkWEpzTG5OMVluTjBjbWx1Wnlnd0xDQndjbTkwYjJOdmJFVnVaQ2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjFjbXd1YzNWaWMzUnlhVzVuS0hCeWIzUnZZMjlzUlc1a0xDQndZWFJvVTNSaGNuUXBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2RYSnNMbk4xWW5OMGNtbHVaeWh3WVhSb1UzUmhjblFzSUhCaGRHaEZibVFwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdkWEpzTG5OMVluTjBjbWx1WnloeGRXVnllVk4wWVhKMEtTeGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpkR0YwYVdNZ2NtVnpiMngyWlZWeWJDaGlZWE5sVlhKc09pQnpkSEpwYm1jc0lIVnliRG9nYzNSeWFXNW5LVG9nYzNSeWFXNW5JSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZbUZ6WlZCaGNuUnpJRDBnVlZKTVVHRnlkSE11Y0dGeWMyVW9ZbUZ6WlZWeWJDazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQlZVa3hRWVhKMGN5NXdZWEp6WlNoMWNtd3BYRzRnSUNBZ0lDQWdJQ0FnSUNBdVptbDRVSEp2ZEc5amIyd29lQ0E5UGlCNElIeDhJR0poYzJWUVlYSjBjeTV3Y205MGIyTnZiQ2xjYmlBZ0lDQWdJQ0FnSUNBZ0lDNW1hWGhJYjNOMEtIZ2dQVDRnZUNCOGZDQmlZWE5sVUdGeWRITXVhRzl6ZENsY2JpQWdJQ0FnSUNBZ0lDQWdJQzUwYjFOMGNtbHVaeWdwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR1pwZUZCeWIzUnZZMjlzS0dacGVEb2dLSEE2SUhOMGNtbHVaeWtnUFQ0Z2MzUnlhVzVuS1RvZ1ZWSk1VR0Z5ZEhNZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5CeWIzUnZZMjlzSUQwZ1ptbDRLSFJvYVhNdWNISnZkRzlqYjJ3cE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjenRjYmlBZ0lDQjlYRzVjYmlBZ0lDQm1hWGhJYjNOMEtHWnBlRG9nS0hBNklITjBjbWx1WnlrZ1BUNGdjM1J5YVc1bktUb2dWVkpNVUdGeWRITWdlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtaHZjM1FnUFNCbWFYZ29kR2hwY3k1b2IzTjBLVHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWm1sNFVHRjBhQ2htYVhnNklDaHdPaUJ6ZEhKcGJtY3BJRDArSUhOMGNtbHVaeWs2SUZWU1RGQmhjblJ6SUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTV3WVhSb0lEMGdabWw0S0hSb2FYTXVjR0YwYUNrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHWnBlRkYxWlhKNUtHWnBlRG9nS0hFNklITjBjbWx1WnlrZ1BUNGdjM1J5YVc1bktUb2dWVkpNVUdGeWRITWdlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuRjFaWEo1SUQwZ1ptbDRLSFJvYVhNdWNYVmxjbmtwTzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN6dGNiaUFnSUNCOVhHNWNibHh1SUNBZ0lIQnliM1J2WTI5c09pQnpkSEpwYm1jN1hHNWNiaUFnSUNCb2IzTjBPaUJ6ZEhKcGJtYzdYRzVjYmlBZ0lDQndZWFJvT2lCemRISnBibWM3WEc1Y2JpQWdJQ0J4ZFdWeWVUb2djM1J5YVc1bk8xeHVYRzRnSUNBZ1kyOXVjM1J5ZFdOMGIzSW9jSEp2ZEc5amIydzZJSE4wY21sdVp5d2dhRzl6ZERvZ2MzUnlhVzVuTENCd1lYUm9PaUJ6ZEhKcGJtY3NJSEYxWlhKNU9pQnpkSEpwYm1jcElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1d2NtOTBiMk52YkNBOUlIQnliM1J2WTI5c08xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1odmMzUWdQU0JvYjNOME8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5CaGRHZ2dQU0J3WVhSb08xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5GMVpYSjVJRDBnY1hWbGNuazdYRzRnSUNBZ2ZWeHVYRzVjYmlBZ0lDQjBiMU4wY21sdVp5Z3BPaUJ6ZEhKcGJtY2dlMXh1SUNBZ0lDQWdJQ0JzWlhRZ2V5QndZWFJvSUgwZ1BTQjBhR2x6TzF4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvY0dGMGFDNXBibVJsZUU5bUtDY3ZMeWNwSUQ0OUlEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIQmhkR2dnUFNCd1lYUm9MbkpsY0d4aFkyVW9KeTh2Snl3Z0p5OG5LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCcFppQW9jR0YwYUNBaFBUMGdKeWNnSmlZZ0lYQmhkR2d1YzNSaGNuUnpWMmwwYUNnbkx5Y3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQndZWFJvSUQwZ1lDOGtlM0JoZEdoOVlEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZQ1I3ZEdocGN5NXdjbTkwYjJOdmJIMGtlM1JvYVhNdWFHOXpkSDBrZTNCaGRHaDlKSHQwYUdsekxuRjFaWEo1SUNFOVBTQW5KeUEvSUNjL0p5QTZJQ2NuZlNSN2RHaHBjeTV4ZFdWeWVYMWdPMXh1SUNBZ0lIMWNibjFjYm1OdmJuTjBJR1JsWm1GMWJIUlRaWEoyWlhJZ1BTQW5hSFIwY0RvdkwyeHZZMkZzYUc5emRDYzdYRzVtZFc1amRHbHZiaUIyWVd4MVpVOXlSR1ZtWVhWc2RDaDJZV3gxWlN3Z1pHVm1ZWFZzZEZaaGJIVmxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlDaDJZV3gxWlNBOVBUMGdkVzVrWldacGJtVmtJSHg4SUhaaGJIVmxJRDA5UFNCdWRXeHNLU0EvSUdSbFptRjFiSFJXWVd4MVpTQTZJSFpoYkhWbE8xeHVmVnh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlVUMDVEYjI1bWFXZE5iMlIxYkdVZ1pYaDBaVzVrY3lCVVQwNU5iMlIxYkdVZ2UxeHVJQ0FnSUdSaGRHRTZJRlJQVGtOdmJtWnBaMFJoZEdFN1hHNGdJQ0FnZEhKaFkyVnlPaUJVY21GalpYSTdYRzVjYmlBZ0lDQmpiMjV6ZEhKMVkzUnZjaWhqYjI1MFpYaDBPaUJVVDA1TmIyUjFiR1ZEYjI1MFpYaDBLU0I3WEc0Z0lDQWdJQ0FnSUhOMWNHVnlLR052Ym5SbGVIUXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxtUmhkR0VnUFNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J6WlhKMlpYSnpPaUJiWkdWbVlYVnNkRk5sY25abGNsMHNYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnpaWFJFWVhSaEtHUmhkR0U2SUZSUFRrTnZibVpwWjBSaGRHRXBJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWtZWFJoSUQwZ1pHRjBZU0I4ZkNCMGFHbHpMbVJoZEdFN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxtUmhkR0V1YzJWeWRtVnljeTVzWlc1bmRHZ2dQVDA5SURBcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVaR0YwWVM1elpYSjJaWEp6TG5CMWMyZ29aR1ZtWVhWc2RGTmxjblpsY2lrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdkR2hwY3k1MGNtRmpaWElnUFNCa1lYUmhMblJ5WVdObGNpQjhmQ0J1YjI5d1ZISmhZMlZ5TzF4dUlDQWdJSDFjYmx4dUlDQWdJR2RsZEVOdmJtWnBaMU5sY25abGNpZ3BPaUJ6ZEhKcGJtY2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1a1lYUmhQeTV6WlhKMlpYSnpQeTViTUYwZ2ZId2dKeWM3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdiM1YwVDJaVGVXNWpWR2h5WlhOb2IyeGtLQ2s2SUc1MWJXSmxjaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIyWVd4MVpVOXlSR1ZtWVhWc2RDaDBhR2x6TG1SaGRHRXViM1YwVDJaVGVXNWpWR2h5WlhOb2IyeGtMQ0JFUlVaQlZVeFVYMDlWVkY5UFJsOVRXVTVEWDFSSVVrVlRTRTlNUkNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYldWemMyRm5aVkpsZEhKcFpYTkRiM1Z1ZENncE9pQnVkVzFpWlhJZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RtRnNkV1ZQY2tSbFptRjFiSFFvZEdocGN5NWtZWFJoTG0xbGMzTmhaMlZTWlhSeWFXVnpRMjkxYm5Rc0lFUkZSa0ZWVEZSZlRVVlRVMEZIUlY5U1JWUlNTVVZUWDBOUFZVNVVLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnRaWE56WVdkbFVISnZZMlZ6YzJsdVoxUnBiV1Z2ZFhRb0tUb2diblZ0WW1WeUlIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2RHbHRaVzkxZENBOUlIUm9hWE11WkdGMFlTNXRaWE56WVdkbFVISnZZMlZ6YzJsdVoxUnBiV1Z2ZFhRN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFXMWxiM1YwSUQwOVBTQXdJRDhnTUNBNklDaDBhVzFsYjNWMElIeDhJRVJGUmtGVlRGUmZUVVZUVTBGSFJWOVFVazlEUlZOVFNVNUhYMVJKVFVWUFZWUXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIZGhhWFJHYjNKVWFXMWxiM1YwS0NrNklHNTFiV0psY2lCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMllXeDFaVTl5UkdWbVlYVnNkQ2gwYUdsekxtUmhkR0V1ZDJGcGRFWnZjbFJwYldWdmRYUXNJRVJGUmtGVlRGUmZWMEZKVkY5R1QxSmZWRWxOUlU5VlZDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2JtVjBkMjl5YTFScGJXVnZkWFFvS1RvZ2JuVnRZbVZ5SUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhaaGJIVmxUM0pFWldaaGRXeDBLSFJvYVhNdVpHRjBZUzV1WlhSM2IzSnJWR2x0Wlc5MWRDd2dSRVZHUVZWTVZGOU9SVlJYVDFKTFgxUkpUVVZQVlZRcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdselRtVjBkMjl5YTFScGJXVnZkWFJGZUhCcGNtVmtVMmx1WTJVb2MzUmhjblJVYVcxbE9pQnVkVzFpWlhJcE9pQmliMjlzWldGdUlIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2RHbHRaVzkxZENBOUlIUm9hWE11Ym1WMGQyOXlhMVJwYldWdmRYUW9LVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tIUnBiV1Z2ZFhRZ1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1JHRjBaUzV1YjNjb0tTQStJQ2h6ZEdGeWRGUnBiV1VnS3lCMGFXMWxiM1YwS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzYjJjb0xpNHVZWEpuY3pvZ1lXNTVXMTBwSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY0hKdlptbHNaU0E5SUNoMGFHbHpMbDl3Y205bWFXeGxVM1JoY25RZ2ZId2dNQ2tnSVQwOUlEQTdYRzRnSUNBZ0lDQWdJR2xtSUNod2NtOW1hV3hsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmpkWEp5Wlc1MElEMGdSR0YwWlM1dWIzY29LU0F2SURFd01EQTdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0IwYVcxbFUzUnlhVzVuSUQwZ1lDUjdVM1J5YVc1bktHTjFjbkpsYm5RdWRHOUdhWGhsWkNnektTbDlJQ1I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnVTNSeWFXNW5LQ2hqZFhKeVpXNTBJQzBnZEdocGN5NWZjSEp2Wm1sc1pWTjBZWEowS1M1MGIwWnBlR1ZrS0RNcEtYMGdKSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JUZEhKcGJtY29LR04xY25KbGJuUWdMU0IwYUdsekxsOXdjbTltYVd4bFVISmxkaWt1ZEc5R2FYaGxaQ2d6S1NsOVlEdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaDBhR2x6TGw5c2IyZFdaWEppYjNObEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWUZza2UzUnBiV1ZUZEhKcGJtZDlYVnhjYm1Bc0lDNHVMbUZ5WjNNcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emIyeGxMbXh2WnloZ1d5UjdkR2x0WlZOMGNtbHVaMzFkWEZ4dVlDd2dZWEpuYzFzd1hTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOXdjbTltYVd4bFVISmxkaUE5SUdOMWNuSmxiblE3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RHaHBjeTVmYkc5blZtVnlZbTl6WlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVzYjJjb1lGc2tlMFJoZEdVdWJtOTNLQ2tnTHlBeE1EQXdmVjFnTENBdUxpNWhjbWR6S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUhOMFlYSjBVSEp2Wm1sc1pTZ3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWZjSEp2Wm1sc1pWTjBZWEowSUQwZ1JHRjBaUzV1YjNjb0tTQXZJREV3TURBN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDNCeWIyWnBiR1ZRY21WMklEMGdkR2hwY3k1ZmNISnZabWxzWlZOMFlYSjBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lITjBiM0JRY205bWFXeGxLQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbDl3Y205bWFXeGxVM1JoY25RZ1BTQjBhR2x6TGw5d2NtOW1hV3hsVUhKbGRpQTlJREE3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ1oyVjBWbVZ5YzJsdmJpZ3BPaUJRY205dGFYTmxQSE4wY21sdVp6NGdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpYRjFaWE4wUTI5eVpTZ25kbVZ5YzJsdmJpY3BPMXh1SUNBZ0lIMWNibHh1WEc0Z0lDQWdZWE41Ym1NZ2MyVjBkWEFvS1RvZ1VISnZiV2x6WlR4MmIybGtQaUI3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBhR2x6TG1SaGRHRXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdOdmNtVkRiMjVtYVdjZ1BTQlBZbXBsWTNRdVlYTnphV2R1S0h0OUxDQjBhR2x6TG1SaGRHRXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVnNaWFJsSUdOdmNtVkRiMjVtYVdjdWRISmhZMlZ5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdZWGRoYVhRZ2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNnbmMyVjBkWEFuTENCamIzSmxRMjl1Wm1sbktUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0IwYUdsekxsOXNiMmRXWlhKaWIzTmxJRDBnZEdocGN5NWtZWFJoTG14dloxOTJaWEppYjNObElIeDhJR1poYkhObE8xeHVJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NWZiRzluVm1WeVltOXpaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1emRHRnlkRkJ5YjJacGJHVW9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCMGFHbHpMbDlsY25KTWIyZFdaWEppYjNObElEMGdkR2hwY3k1a1lYUmhMbVZ5Y2w5c2IyZGZkbVZ5WW05elpTQjhmQ0IwY25WbE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUY5c2IyZFdaWEppYjNObE9pQmliMjlzWldGdU8xeHVJQ0FnSUY5bGNuSk1iMmRXWlhKaWIzTmxPaUJpYjI5c1pXRnVPMXh1SUNBZ0lGOXdjbTltYVd4bFUzUmhjblE2SUc1MWJXSmxjanRjYmx4dUlDQWdJRjl3Y205bWFXeGxVSEpsZGpvZ2JuVnRZbVZ5TzF4dWZWeHVYRzVVVDA1RGIyNW1hV2ROYjJSMWJHVXViVzlrZFd4bFRtRnRaU0E5SUNkVVQwNURiMjVtYVdkTmIyUjFiR1VuTzF4dUlsMTkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVtb3ZlUHJvcHMgPSByZW1vdmVQcm9wcztcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5RQm91bmNlVHlwZSA9IGV4cG9ydHMuUVNraXBSZWFzb24gPSBleHBvcnRzLlFDb21wdXRlVHlwZSA9IGV4cG9ydHMuUUFjY291bnRTdGF0dXNDaGFuZ2UgPSBleHBvcnRzLlFBY2NvdW50U3RhdHVzID0gZXhwb3J0cy5RVHJhbnNhY3Rpb25Qcm9jZXNzaW5nU3RhdHVzID0gZXhwb3J0cy5RVHJhbnNhY3Rpb25UeXBlID0gZXhwb3J0cy5RQWNjb3VudFR5cGUgPSBleHBvcnRzLlFTcGxpdFR5cGUgPSBleHBvcnRzLlFCbG9ja1Byb2Nlc3NpbmdTdGF0dXMgPSBleHBvcnRzLlFNZXNzYWdlUHJvY2Vzc2luZ1N0YXR1cyA9IGV4cG9ydHMuUU1lc3NhZ2VUeXBlID0gZXhwb3J0cy5RT3V0TXNnVHlwZSA9IGV4cG9ydHMuUUluTXNnVHlwZSA9IGV4cG9ydHMuVE9OQ2xpZW50U3RvcmFnZVN0YXR1cyA9IGV4cG9ydHMuVE9OQ2xpZW50Q29tcHV0ZVNraXBwZWRTdGF0dXMgPSBleHBvcnRzLlRPTkNsaWVudFRyYW5zYWN0aW9uUGhhc2UgPSBleHBvcnRzLlRPTkFkZHJlc3NTdHJpbmdWYXJpYW50ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX29wZW50cmFjaW5nID0gcmVxdWlyZShcIm9wZW50cmFjaW5nXCIpO1xuXG52YXIgX1RPTkNsaWVudEVycm9yID0gcmVxdWlyZShcIi4uL1RPTkNsaWVudEVycm9yXCIpO1xuXG52YXIgX1RPTk1vZHVsZTIgPSByZXF1aXJlKFwiLi4vVE9OTW9kdWxlXCIpO1xuXG52YXIgX1RPTkNvbmZpZ01vZHVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vVE9OQ29uZmlnTW9kdWxlXCIpKTtcblxudmFyIF9UT05DcnlwdG9Nb2R1bGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9UT05DcnlwdG9Nb2R1bGVcIikpO1xuXG52YXIgX1RPTlF1ZXJpZXNNb2R1bGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9UT05RdWVyaWVzTW9kdWxlXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBUT05BZGRyZXNzU3RyaW5nVmFyaWFudCA9IHtcbiAgQWNjb3VudElkOiAnQWNjb3VudElkJyxcbiAgSGV4OiAnSGV4JyxcbiAgQmFzZTY0OiAnQmFzZTY0J1xufTtcbmV4cG9ydHMuVE9OQWRkcmVzc1N0cmluZ1ZhcmlhbnQgPSBUT05BZGRyZXNzU3RyaW5nVmFyaWFudDtcbnZhciBUT05DbGllbnRUcmFuc2FjdGlvblBoYXNlID0ge1xuICBzdG9yYWdlOiAnc3RvcmFnZScsXG4gIGNvbXB1dGVTa2lwcGVkOiAnY29tcHV0ZVNraXBwZWQnLFxuICBjb21wdXRlVm06ICdjb21wdXRlVm0nLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICB1bmtub3duOiAndW5rbm93bidcbn07XG5leHBvcnRzLlRPTkNsaWVudFRyYW5zYWN0aW9uUGhhc2UgPSBUT05DbGllbnRUcmFuc2FjdGlvblBoYXNlO1xudmFyIFRPTkNsaWVudENvbXB1dGVTa2lwcGVkU3RhdHVzID0ge1xuICBub1N0YXRlOiAwLFxuICBiYWRTdGF0ZTogMSxcbiAgbm9HYXM6IDJcbn07XG5leHBvcnRzLlRPTkNsaWVudENvbXB1dGVTa2lwcGVkU3RhdHVzID0gVE9OQ2xpZW50Q29tcHV0ZVNraXBwZWRTdGF0dXM7XG52YXIgVE9OQ2xpZW50U3RvcmFnZVN0YXR1cyA9IHtcbiAgdW5jaGFuZ2VkOiAwLFxuICBmcm96ZW46IDEsXG4gIGRlbGV0ZWQ6IDJcbn07XG5leHBvcnRzLlRPTkNsaWVudFN0b3JhZ2VTdGF0dXMgPSBUT05DbGllbnRTdG9yYWdlU3RhdHVzO1xudmFyIFFJbk1zZ1R5cGUgPSB7XG4gIGV4dGVybmFsOiAwLFxuICBpaHI6IDEsXG4gIGltbWVkaWF0ZWx5OiAyLFxuICBcImZpbmFsXCI6IDMsXG4gIHRyYW5zaXQ6IDQsXG4gIGRpc2NhcmRlZEZpbmFsOiA1LFxuICBkaXNjYXJkZWRUcmFuc2l0OiA2XG59O1xuZXhwb3J0cy5RSW5Nc2dUeXBlID0gUUluTXNnVHlwZTtcbnZhciBRT3V0TXNnVHlwZSA9IHtcbiAgZXh0ZXJuYWw6IDAsXG4gIGltbWVkaWF0ZWx5OiAxLFxuICBvdXRNc2dOZXc6IDIsXG4gIHRyYW5zaXQ6IDMsXG4gIGRlcXVldWVJbW1lZGlhdGVseTogNCxcbiAgZGVxdWV1ZTogNSxcbiAgdHJhbnNpdFJlcXVpcmVkOiA2LFxuICBub25lOiAtMVxufTtcbmV4cG9ydHMuUU91dE1zZ1R5cGUgPSBRT3V0TXNnVHlwZTtcbnZhciBRTWVzc2FnZVR5cGUgPSB7XG4gIGludGVybmFsOiAwLFxuICBleHRJbjogMSxcbiAgZXh0T3V0OiAyXG59O1xuZXhwb3J0cy5RTWVzc2FnZVR5cGUgPSBRTWVzc2FnZVR5cGU7XG52YXIgUU1lc3NhZ2VQcm9jZXNzaW5nU3RhdHVzID0ge1xuICB1bmtub3duOiAwLFxuICBxdWV1ZWQ6IDEsXG4gIHByb2Nlc3Npbmc6IDIsXG4gIHByZWxpbWluYXJ5OiAzLFxuICBwcm9wb3NlZDogNCxcbiAgZmluYWxpemVkOiA1LFxuICByZWZ1c2VkOiA2LFxuICB0cmFuc2l0aW5nOiA3XG59O1xuZXhwb3J0cy5RTWVzc2FnZVByb2Nlc3NpbmdTdGF0dXMgPSBRTWVzc2FnZVByb2Nlc3NpbmdTdGF0dXM7XG52YXIgUUJsb2NrUHJvY2Vzc2luZ1N0YXR1cyA9IHtcbiAgdW5rbm93bjogMCxcbiAgcHJvcG9zZWQ6IDEsXG4gIGZpbmFsaXplZDogMixcbiAgcmVmdXNlZDogM1xufTtcbmV4cG9ydHMuUUJsb2NrUHJvY2Vzc2luZ1N0YXR1cyA9IFFCbG9ja1Byb2Nlc3NpbmdTdGF0dXM7XG52YXIgUVNwbGl0VHlwZSA9IHtcbiAgbm9uZTogMCxcbiAgc3BsaXQ6IDIsXG4gIG1lcmdlOiAzXG59O1xuZXhwb3J0cy5RU3BsaXRUeXBlID0gUVNwbGl0VHlwZTtcbnZhciBRQWNjb3VudFR5cGUgPSB7XG4gIHVuaW5pdDogMCxcbiAgYWN0aXZlOiAxLFxuICBmcm96ZW46IDJcbn07XG5leHBvcnRzLlFBY2NvdW50VHlwZSA9IFFBY2NvdW50VHlwZTtcbnZhciBRVHJhbnNhY3Rpb25UeXBlID0ge1xuICBvcmRpbmFyeTogMCxcbiAgc3RvcmFnZTogMSxcbiAgdGljazogMixcbiAgdG9jazogMyxcbiAgc3BsaXRQcmVwYXJlOiA0LFxuICBzcGxpdEluc3RhbGw6IDUsXG4gIG1lcmdlUHJlcGFyZTogNixcbiAgbWVyZ2VJbnN0YWxsOiA3XG59O1xuZXhwb3J0cy5RVHJhbnNhY3Rpb25UeXBlID0gUVRyYW5zYWN0aW9uVHlwZTtcbnZhciBRVHJhbnNhY3Rpb25Qcm9jZXNzaW5nU3RhdHVzID0ge1xuICB1bmtub3duOiAwLFxuICBwcmVsaW1pbmFyeTogMSxcbiAgcHJvcG9zZWQ6IDIsXG4gIGZpbmFsaXplZDogMyxcbiAgcmVmdXNlZDogNFxufTtcbmV4cG9ydHMuUVRyYW5zYWN0aW9uUHJvY2Vzc2luZ1N0YXR1cyA9IFFUcmFuc2FjdGlvblByb2Nlc3NpbmdTdGF0dXM7XG52YXIgUUFjY291bnRTdGF0dXMgPSB7XG4gIHVuaW5pdDogMCxcbiAgYWN0aXZlOiAxLFxuICBmcm96ZW46IDIsXG4gIG5vbkV4aXN0OiAzXG59O1xuZXhwb3J0cy5RQWNjb3VudFN0YXR1cyA9IFFBY2NvdW50U3RhdHVzO1xudmFyIFFBY2NvdW50U3RhdHVzQ2hhbmdlID0ge1xuICB1bmNoYW5nZWQ6IDAsXG4gIGZyb3plbjogMSxcbiAgZGVsZXRlZDogMlxufTtcbmV4cG9ydHMuUUFjY291bnRTdGF0dXNDaGFuZ2UgPSBRQWNjb3VudFN0YXR1c0NoYW5nZTtcbnZhciBRQ29tcHV0ZVR5cGUgPSB7XG4gIHNraXBwZWQ6IDAsXG4gIHZtOiAxXG59O1xuZXhwb3J0cy5RQ29tcHV0ZVR5cGUgPSBRQ29tcHV0ZVR5cGU7XG52YXIgUVNraXBSZWFzb24gPSB7XG4gIG5vU3RhdGU6IDAsXG4gIGJhZFN0YXRlOiAxLFxuICBub0dhczogMlxufTtcbmV4cG9ydHMuUVNraXBSZWFzb24gPSBRU2tpcFJlYXNvbjtcbnZhciBRQm91bmNlVHlwZSA9IHtcbiAgbmVnRnVuZHM6IDAsXG4gIG5vRnVuZHM6IDEsXG4gIG9rOiAyXG59O1xuZXhwb3J0cy5RQm91bmNlVHlwZSA9IFFCb3VuY2VUeXBlO1xudmFyIE1BU1RFUkNIQUlOX0lEID0gLTE7XG5cbmZ1bmN0aW9uIHJlbW92ZVR5cGVOYW1lKG9iaikge1xuICBpZiAob2JqLl9fdHlwZW5hbWUpIHtcbiAgICBkZWxldGUgb2JqLl9fdHlwZW5hbWU7XG4gIH1cblxuICBPYmplY3QudmFsdWVzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoISF2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlbW92ZVR5cGVOYW1lKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQcm9wcyhvYmosIHBhdGhzKSB7XG4gIHZhciByZXN1bHQgPSBvYmo7XG4gIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgZG90UG9zID0gcGF0aC5pbmRleE9mKCcuJyk7XG5cbiAgICBpZiAoZG90UG9zIDwgMCkge1xuICAgICAgaWYgKHBhdGggaW4gcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCk7XG4gICAgICAgIGRlbGV0ZSByZXN1bHRbcGF0aF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuYW1lID0gcGF0aC5zdWJzdHIoMCwgZG90UG9zKTtcbiAgICAgIHZhciBjaGlsZCA9IHJlc3VsdFtuYW1lXTtcblxuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIHZhciByZWR1Y2VkQ2hpbGQgPSByZW1vdmVQcm9wcyhjaGlsZCwgW3BhdGguc3Vic3RyKGRvdFBvcyArIDEpXSk7XG5cbiAgICAgICAgaWYgKHJlZHVjZWRDaGlsZCAhPT0gY2hpbGQpIHtcbiAgICAgICAgICByZXN1bHQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHJlZHVjZWRDaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3RhcnRNZXNzYWdlVHJhY2VTcGFuKHRyYWNlciwgbWVzc2FnZUlkLCBvcGVyYXRpb25OYW1lLCB0YWdzKSB7XG4gIGlmICghbWVzc2FnZUlkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgdHJhY2VJZCA9IG1lc3NhZ2VJZC5zdWJzdHIoMCwgMTYpO1xuICB2YXIgc3BhbklkID0gbWVzc2FnZUlkLnN1YnN0cigxNiwgMTYpO1xuICB2YXIgcm9vdENvbnRleHQgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgcm9vdENvbnRleHQgPSB0cmFjZXIuZXh0cmFjdChfb3BlbnRyYWNpbmcuRk9STUFUX1RFWFRfTUFQLCB7XG4gICAgICAndWJlci10cmFjZS1pZCc6IFwiXCIuY29uY2F0KHRyYWNlSWQsIFwiOlwiKS5jb25jYXQoc3BhbklkLCBcIjowOjFcIilcbiAgICB9KTtcbiAgfSBjYXRjaCAoX3VudXNlZCkgey8vIHRyYWNlciBjYW4ndCBjcmVhdGUgamFlZ2VyIGNvbXBhdGlibGUgc3BhbixcbiAgICAvLyBzbyB3ZSBhcmUgZmFsbGJhY2sgdG8gcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICghcm9vdENvbnRleHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0cmFjZXIuc3RhcnRTcGFuKG9wZXJhdGlvbk5hbWUsIHtcbiAgICBjaGlsZE9mOiByb290Q29udGV4dCxcbiAgICB0YWdzOiB0YWdzXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFjZU1lc3NhZ2UodHJhY2VyLCBtZXNzYWdlSWQsIG9wZXJhdGlvbk5hbWUsIHRhZ3MpIHtcbiAgdmFyIHNwYW4gPSBzdGFydE1lc3NhZ2VUcmFjZVNwYW4odHJhY2VyLCBtZXNzYWdlSWQsIG9wZXJhdGlvbk5hbWUsIHRhZ3MpO1xuXG4gIGlmIChzcGFuKSB7XG4gICAgc3Bhbi5maW5pc2goKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTaWduaW5nU291cmNlKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9nZXRTaWduaW5nU291cmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRTaWduaW5nU291cmNlKCkge1xuICBfZ2V0U2lnbmluZ1NvdXJjZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2MShib3gsIGtleXMpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2MSQoX2NvbnRleHQ2MSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYxLnByZXYgPSBfY29udGV4dDYxLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIWJveCkge1xuICAgICAgICAgICAgICBfY29udGV4dDYxLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2MS50MCA9IGJveDtcbiAgICAgICAgICAgIF9jb250ZXh0NjEubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gYm94LmdldFB1YmxpY0tleSgpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQ2MS50MSA9IF9jb250ZXh0NjEuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NjEudDIgPSB7XG4gICAgICAgICAgICAgIHNlY3JldDogJycsXG4gICAgICAgICAgICAgIFwicHVibGljXCI6IF9jb250ZXh0NjEudDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2MS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBib3g6IF9jb250ZXh0NjEudDAsXG4gICAgICAgICAgICAgIGtleXM6IF9jb250ZXh0NjEudDJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKCEoa2V5cyAmJiBrZXlzLnNlY3JldCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2MS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYxLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGJveDogbnVsbCxcbiAgICAgICAgICAgICAga2V5czoga2V5c1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2MS5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYxLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2MSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRTaWduaW5nU291cmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBUT05Db250cmFjdHNNb2R1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UT05Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKFRPTkNvbnRyYWN0c01vZHVsZSwgX1RPTk1vZHVsZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUT05Db250cmFjdHNNb2R1bGUpO1xuXG4gIGZ1bmN0aW9uIFRPTkNvbnRyYWN0c01vZHVsZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVE9OQ29udHJhY3RzTW9kdWxlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY29uZmlnXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY3J5cHRvXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicXVlcmllc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImJpZ0JhbGFuY2VcIiwgJzB4MTAwMDAwMDAwMDAwMDAnKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUT05Db250cmFjdHNNb2R1bGUsIFt7XG4gICAga2V5OiBcInNldHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0dXAgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5jb250ZXh0LmdldE1vZHVsZShfVE9OQ29uZmlnTW9kdWxlW1wiZGVmYXVsdFwiXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyaWVzID0gdGhpcy5jb250ZXh0LmdldE1vZHVsZShfVE9OUXVlcmllc01vZHVsZVtcImRlZmF1bHRcIl0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY3J5cHRvID0gdGhpcy5jb250ZXh0LmdldE1vZHVsZShfVE9OQ3J5cHRvTW9kdWxlW1wiZGVmYXVsdFwiXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgICAgcmV0dXJuIF9zZXR1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0dXA7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvYWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihwYXJhbXMsIHBhcmVudFNwYW4pIHtcbiAgICAgICAgdmFyIGFjY291bnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllcy5hY2NvdW50cy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBlcTogcGFyYW1zLmFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDogJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgcGFyZW50U3BhbjogcGFyZW50U3BhblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBhY2NvdW50cyA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoYWNjb3VudHMgJiYgYWNjb3VudHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGJhbGFuY2VHcmFtczogYWNjb3VudHNbMF0uYmFsYW5jZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGJhbGFuY2VHcmFtczogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsb2FkKF94MywgX3g0KSB7XG4gICAgICAgIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZDtcbiAgICB9KCkgLy8gRmFjYWRlIGZ1bmN0aW9uc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVwbG95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGVwbG95ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocGFyYW1zLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuY29udGV4dC50cmFjZSgnY29udHJhY3RzLmRlcGxveScsIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRUYWcoJ3BhcmFtcycsIHJlbW92ZVByb3BzKHBhcmFtcywgWydrZXlQYWlyLnNlY3JldCddKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX3RoaXMyLmludGVybmFsRGVwbG95SnMocGFyYW1zLCBzcGFuKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMyk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3g3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSwgcGFyZW50U3BhbikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBkZXBsb3koX3g1LCBfeDYpIHtcbiAgICAgICAgcmV0dXJuIF9kZXBsb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlcGxveTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9ydW4gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNihwYXJhbXMsIHBhcmVudFNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5jb250ZXh0LnRyYWNlKCdjb250cmFjdHMucnVuJywgLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRUYWcoJ3BhcmFtcycsIHJlbW92ZVByb3BzKHBhcmFtcywgWydrZXlQYWlyLnNlY3JldCddKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX3RoaXMzLmludGVybmFsUnVuSnMocGFyYW1zLCBzcGFuKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNSk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpLCBwYXJlbnRTcGFuKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJ1bihfeDgsIF94OSkge1xuICAgICAgICByZXR1cm4gX3J1bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVuO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJ1bkxvY2FsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcnVuTG9jYWwgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOChwYXJhbXMsIHBhcmVudFNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5jb250ZXh0LnRyYWNlKCdjb250cmFjdHMucnVuTG9jYWwnLCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoc3Bhbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldFRhZygncGFyYW1zJywgcmVtb3ZlUHJvcHMocGFyYW1zLCBbJ2tleVBhaXIuc2VjcmV0J10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBfdGhpczQuaW50ZXJuYWxSdW5Mb2NhbEpzKHBhcmFtcywgc3BhbikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTcpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSwgcGFyZW50U3BhbikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBydW5Mb2NhbChfeDExLCBfeDEyKSB7XG4gICAgICAgIHJldHVybiBfcnVuTG9jYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bkxvY2FsO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJ1bk1lc3NhZ2VMb2NhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3J1bk1lc3NhZ2VMb2NhbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMChwYXJhbXMsIHBhcmVudFNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCB0aGlzLmNvbnRleHQudHJhY2UoJ3J1bk1lc3NhZ2VMb2NhbCcsIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOShzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0VGFnKCdwYXJhbXMnLCByZW1vdmVQcm9wcyhwYXJhbXMsIFsna2V5UGFpci5zZWNyZXQnXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIF90aGlzNS5pbnRlcm5hbFJ1bk1lc3NhZ2VMb2NhbEpzKHBhcmFtcywgc3BhbikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTkpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSwgcGFyZW50U3BhbikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJ1bk1lc3NhZ2VMb2NhbChfeDE0LCBfeDE1KSB7XG4gICAgICAgIHJldHVybiBfcnVuTWVzc2FnZUxvY2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydW5NZXNzYWdlTG9jYWw7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicnVuR2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcnVuR2V0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKHBhcmFtcykge1xuICAgICAgICB2YXIgY29yZVBhcmFtcywgaGFzQ29kZSwgYWRkcmVzcywgYWNjb3VudCwgcGFyYW1zRnJvbUFjY291bnQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjb3JlUGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIGhhc0NvZGUgPSBwYXJhbXMuYm9jQmFzZTY0IHx8IHBhcmFtcy5jb2RlQmFzZTY0ICYmIHBhcmFtcy5kYXRhQmFzZTY0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0NvZGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHBhcmFtcy5hZGRyZXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS50MCA9IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEudDEgPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxMS50MC5hZGRyZXNzUmVxdWlyZWRGb3JSdW5Mb2NhbC5jYWxsKF9jb250ZXh0MTEudDAsIF9jb250ZXh0MTEudDEpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudChhZGRyZXNzLCBmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWcud2FpdEZvclRpbWVvdXQoKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgYWNjb3VudCA9IF9jb250ZXh0MTEuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LmNvZGVfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDExLnQyID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEudDMgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEudDQgPSBhY2NvdW50LmJhbGFuY2U7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoKTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEudDUgPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxMS50Mi5hY2NvdW50Q29kZU1pc3NpbmcuY2FsbChfY29udGV4dDExLnQyLCBfY29udGV4dDExLnQzLCBfY29udGV4dDExLnQ0LCBfY29udGV4dDExLnQ1KTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIHBhcmFtc0Zyb21BY2NvdW50ID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudC5ib2MpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmFtc0Zyb21BY2NvdW50LmJvY0Jhc2U2NCA9IGFjY291bnQuYm9jO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50Lmxhc3RfcGFpZCkge1xuICAgICAgICAgICAgICAgICAgcGFyYW1zRnJvbUFjY291bnQubGFzdF9wYWlkID0gYWNjb3VudC5sYXN0X3BhaWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnQuYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgcGFyYW1zRnJvbUFjY291bnQuYmFsYW5jZSA9IGFjY291bnQuYmFsYW5jZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb3JlUGFyYW1zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJhbXNGcm9tQWNjb3VudCksIHBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgndHZtLmdldCcsIGNvcmVQYXJhbXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTExLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcnVuR2V0KF94MTcpIHtcbiAgICAgICAgcmV0dXJuIF9ydW5HZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bkdldDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJhcnJheUZyb21DT05TXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFycmF5RnJvbUNPTlMoY29ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGl0ZW0gPSBjb25zO1xuXG4gICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdGhyb3cgX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yLmludmFsaWRDb25zKF9UT05DbGllbnRFcnJvci5lbXB0eVRPTkVycm9yRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtWzBdKTtcbiAgICAgICAgaXRlbSA9IGl0ZW1bMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSAvLyBNZXNzYWdlIGNyZWF0aW9uXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVEZXBsb3lNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY3JlYXRlRGVwbG95TWVzc2FnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMihwYXJhbXMsIHJldHJ5SW5kZXgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSwgdW5zaWduZWRNZXNzYWdlLCBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKCdjcmVhdGVEZXBsb3lNZXNzYWdlJywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTaWduaW5nU291cmNlKHBhcmFtcy5zaWduaW5nQm94LCBwYXJhbXMua2V5UGFpcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IF9jb250ZXh0MTIuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVW5zaWduZWREZXBsb3lNZXNzYWdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyYW1zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIGtleVBhaXI6IHNvdXJjZS5rZXlzXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB1bnNpZ25lZE1lc3NhZ2UgPSBfY29udGV4dDEyLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi50MCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi50MSA9IF9vYmplY3RTcHJlYWQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi50MiA9IF9vYmplY3RTcHJlYWQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi50MyA9IHt9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU2lnbih1bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcywgc291cmNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIudDQgPSBfY29udGV4dDEyLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi50NSA9ICgwLCBfY29udGV4dDEyLnQyKShfY29udGV4dDEyLnQzLCBfY29udGV4dDEyLnQ0KTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLnQ2ID0ge307XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi50NyA9IHtcbiAgICAgICAgICAgICAgICAgIHVuc2lnbmVkTWVzc2FnZTogdW5zaWduZWRNZXNzYWdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLnQ4ID0gKDAsIF9jb250ZXh0MTIudDEpKF9jb250ZXh0MTIudDUsIF9jb250ZXh0MTIudDYsIF9jb250ZXh0MTIudDcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEyLnQwLmNyZWF0ZVNpZ25lZERlcGxveU1lc3NhZ2UuY2FsbChfY29udGV4dDEyLnQwLCBfY29udGV4dDEyLnQ4KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmRlcGxveS5tZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgYWJpOiBwYXJhbXNbXCJwYWNrYWdlXCJdLmFiaSxcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9ySGVhZGVyOiBwYXJhbXMuY29uc3RydWN0b3JIZWFkZXIsXG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvclBhcmFtczogcGFyYW1zLmNvbnN0cnVjdG9yUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtczogcGFyYW1zLmluaXRQYXJhbXMsXG4gICAgICAgICAgICAgICAgICBpbWFnZUJhc2U2NDogcGFyYW1zW1wicGFja2FnZVwiXS5pbWFnZUJhc2U2NCxcbiAgICAgICAgICAgICAgICAgIGtleVBhaXI6IHBhcmFtcy5rZXlQYWlyLFxuICAgICAgICAgICAgICAgICAgd29ya2NoYWluSWQ6IHBhcmFtcy53b3JrY2hhaW5JZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9jb250ZXh0MTIuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogbWVzc2FnZS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVEZXBsb3lNZXNzYWdlKF94MTgsIF94MTkpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBsb3lNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVEZXBsb3lNZXNzYWdlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVJ1bk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jcmVhdGVSdW5NZXNzYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEzKHBhcmFtcywgcmV0cnlJbmRleCkge1xuICAgICAgICB2YXIgc291cmNlLCB1bnNpZ25lZE1lc3NhZ2UsIG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ2NyZWF0ZVJ1bk1lc3NhZ2UnLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpZ25pbmdTb3VyY2UocGFyYW1zLnNpZ25pbmdCb3gsIHBhcmFtcy5rZXlQYWlyKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgc291cmNlID0gX2NvbnRleHQxMy5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVVbnNpZ25lZFJ1bk1lc3NhZ2UocGFyYW1zKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdW5zaWduZWRNZXNzYWdlID0gX2NvbnRleHQxMy5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMudDAgPSB0aGlzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMudDEgPSBfb2JqZWN0U3ByZWFkO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMudDIgPSBfb2JqZWN0U3ByZWFkO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMudDMgPSB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFNpZ24odW5zaWduZWRNZXNzYWdlLnNpZ25QYXJhbXMsIHNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLnQ0ID0gX2NvbnRleHQxMy5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMudDUgPSAoMCwgX2NvbnRleHQxMy50MikoX2NvbnRleHQxMy50MywgX2NvbnRleHQxMy50NCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy50NiA9IHt9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMudDcgPSB7XG4gICAgICAgICAgICAgICAgICB1bnNpZ25lZE1lc3NhZ2U6IHVuc2lnbmVkTWVzc2FnZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy50OCA9ICgwLCBfY29udGV4dDEzLnQxKShfY29udGV4dDEzLnQ1LCBfY29udGV4dDEzLnQ2LCBfY29udGV4dDEzLnQ3KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMy50MC5jcmVhdGVTaWduZWRSdW5NZXNzYWdlLmNhbGwoX2NvbnRleHQxMy50MCwgX2NvbnRleHQxMy50OCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4ubWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgYWJpOiBwYXJhbXMuYWJpLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyOiBwYXJhbXMuaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgdHJ5SW5kZXg6IHJldHJ5SW5kZXgsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogcGFyYW1zLmlucHV0LFxuICAgICAgICAgICAgICAgICAga2V5UGFpcjogcGFyYW1zLmtleVBhaXJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dDEzLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgYWJpOiBwYXJhbXMuYWJpLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVSdW5NZXNzYWdlKF94MjAsIF94MjEpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSdW5NZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVSdW5NZXNzYWdlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVVuc2lnbmVkRGVwbG95TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NyZWF0ZVVuc2lnbmVkRGVwbG95TWVzc2FnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNChwYXJhbXMsIHJldHJ5SW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTQkKF9jb250ZXh0MTQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE0LnByZXYgPSBfY29udGV4dDE0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5kZXBsb3kuZW5jb2RlX3Vuc2lnbmVkX21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICBhYmk6IHBhcmFtc1tcInBhY2thZ2VcIl0uYWJpLFxuICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3JIZWFkZXI6IHBhcmFtcy5jb25zdHJ1Y3RvckhlYWRlcixcbiAgICAgICAgICAgICAgICAgIHRyeUluZGV4OiByZXRyeUluZGV4LFxuICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3JQYXJhbXM6IHBhcmFtcy5jb25zdHJ1Y3RvclBhcmFtcyxcbiAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXM6IHBhcmFtcy5pbml0UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgaW1hZ2VCYXNlNjQ6IHBhcmFtc1tcInBhY2thZ2VcIl0uaW1hZ2VCYXNlNjQsXG4gICAgICAgICAgICAgICAgICBwdWJsaWNLZXlIZXg6IHBhcmFtcy5rZXlQYWlyW1wicHVibGljXCJdLFxuICAgICAgICAgICAgICAgICAgd29ya2NoYWluSWQ6IHBhcmFtcy53b3JrY2hhaW5JZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDE0LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlc3VsdC5hZGRyZXNzSGV4LFxuICAgICAgICAgICAgICAgICAgc2lnblBhcmFtczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQuZW5jb2RlZCksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIGFiaTogcGFyYW1zW1wicGFja2FnZVwiXS5hYmlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlVW5zaWduZWREZXBsb3lNZXNzYWdlKF94MjIsIF94MjMpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVVbnNpZ25lZERlcGxveU1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZVVuc2lnbmVkRGVwbG95TWVzc2FnZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVVbnNpZ25lZFJ1bk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jcmVhdGVVbnNpZ25lZFJ1bk1lc3NhZ2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTUocGFyYW1zLCByZXRyeUluZGV4KSB7XG4gICAgICAgIHZhciBfaGVhZGVyO1xuXG4gICAgICAgIHZhciBoZWFkZXIsIF95aWVsZCRnZXRTaWduaW5nU291ciwga2V5cywgc2lnblBhcmFtcztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNSQoX2NvbnRleHQxNSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTUucHJldiA9IF9jb250ZXh0MTUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaGVhZGVyID0gcGFyYW1zLmhlYWRlcjtcblxuICAgICAgICAgICAgICAgIGlmICghKChwYXJhbXMuYWJpLmhlYWRlciB8fCBbXSkuaW5jbHVkZXMoJ3B1YmtleScpICYmICEoKF9oZWFkZXIgPSBoZWFkZXIpID09PSBudWxsIHx8IF9oZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oZWFkZXIucHVia2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTUubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2lnbmluZ1NvdXJjZShwYXJhbXMuc2lnbmluZ0JveCwgcGFyYW1zLmtleVBhaXIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE1LnQxID0gX3lpZWxkJGdldFNpZ25pbmdTb3VyID0gX2NvbnRleHQxNS5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTUudDAgPSBfY29udGV4dDE1LnQxID09PSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0MTUudDApIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDE1LnQwID0gX3lpZWxkJGdldFNpZ25pbmdTb3VyID09PSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQxNS50MCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDE1LnQyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTUubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNS50MiA9IF95aWVsZCRnZXRTaWduaW5nU291ci5rZXlzO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAga2V5cyA9IF9jb250ZXh0MTUudDI7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgICAgaGVhZGVyID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBoZWFkZXIpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IGtleXNbXCJwdWJsaWNcIl1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTUubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLmVuY29kZV91bnNpZ25lZF9tZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBhYmk6IHBhcmFtcy5hYmksXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICAgICAgICAgIHRyeUluZGV4OiByZXRyeUluZGV4LFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcy5pbnB1dFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgc2lnblBhcmFtcyA9IF9jb250ZXh0MTUuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICBzaWduUGFyYW1zOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNpZ25QYXJhbXMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICBhYmk6IHBhcmFtcy5hYmlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVVuc2lnbmVkUnVuTWVzc2FnZShfeDI0LCBfeDI1KSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlVW5zaWduZWRSdW5NZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVVbnNpZ25lZFJ1bk1lc3NhZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU2lnbmVkTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NyZWF0ZVNpZ25lZE1lc3NhZ2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE2JChfY29udGV4dDE2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNi5wcmV2ID0gX2NvbnRleHQxNi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmVuY29kZV9tZXNzYWdlX3dpdGhfc2lnbicsIHBhcmFtcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNpZ25lZE1lc3NhZ2UoX3gyNikge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVNpZ25lZE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZVNpZ25lZE1lc3NhZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU2lnbmVkRGVwbG95TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NyZWF0ZVNpZ25lZERlcGxveU1lc3NhZ2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTcocGFyYW1zKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNyQoX2NvbnRleHQxNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaWduZWRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgIGFiaTogcGFyYW1zLnVuc2lnbmVkTWVzc2FnZS5zaWduUGFyYW1zLmFiaSxcbiAgICAgICAgICAgICAgICAgIHVuc2lnbmVkQnl0ZXNCYXNlNjQ6IHBhcmFtcy51bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcy51bnNpZ25lZEJ5dGVzQmFzZTY0LFxuICAgICAgICAgICAgICAgICAgc2lnbkJ5dGVzQmFzZTY0OiBwYXJhbXMuc2lnbkJ5dGVzQmFzZTY0LFxuICAgICAgICAgICAgICAgICAgcHVibGljS2V5SGV4OiBwYXJhbXMucHVibGljS2V5SGV4XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dDE3LnNlbnQ7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5leHBpcmUgPSBwYXJhbXMudW5zaWduZWRNZXNzYWdlLnNpZ25QYXJhbXMuZXhwaXJlO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMudW5zaWduZWRNZXNzYWdlLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE3LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlU2lnbmVkRGVwbG95TWVzc2FnZShfeDI3KSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlU2lnbmVkRGVwbG95TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlU2lnbmVkRGVwbG95TWVzc2FnZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVTaWduZWRSdW5NZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY3JlYXRlU2lnbmVkUnVuTWVzc2FnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxOChwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE4JChfY29udGV4dDE4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxOC5wcmV2ID0gX2NvbnRleHQxOC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpZ25lZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgYWJpOiBwYXJhbXMudW5zaWduZWRNZXNzYWdlLnNpZ25QYXJhbXMuYWJpLFxuICAgICAgICAgICAgICAgICAgdW5zaWduZWRCeXRlc0Jhc2U2NDogcGFyYW1zLnVuc2lnbmVkTWVzc2FnZS5zaWduUGFyYW1zLnVuc2lnbmVkQnl0ZXNCYXNlNjQsXG4gICAgICAgICAgICAgICAgICBzaWduQnl0ZXNCYXNlNjQ6IHBhcmFtcy5zaWduQnl0ZXNCYXNlNjQsXG4gICAgICAgICAgICAgICAgICBwdWJsaWNLZXlIZXg6IHBhcmFtcy5wdWJsaWNLZXlIZXhcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9jb250ZXh0MTguc2VudDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmV4cGlyZSA9IHBhcmFtcy51bnNpZ25lZE1lc3NhZ2Uuc2lnblBhcmFtcy5leHBpcmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy51bnNpZ25lZE1lc3NhZ2UuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGFiaTogcGFyYW1zLnVuc2lnbmVkTWVzc2FnZS5zaWduUGFyYW1zLmFiaSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLnVuc2lnbmVkTWVzc2FnZS5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlU2lnbmVkUnVuTWVzc2FnZShfeDI4KSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlU2lnbmVkUnVuTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlU2lnbmVkUnVuTWVzc2FnZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRDb2RlRnJvbUltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0Q29kZUZyb21JbWFnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxOShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTkkKF9jb250ZXh0MTkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE5LnByZXYgPSBfY29udGV4dDE5Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMuaW1hZ2UuY29kZScsIHBhcmFtcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldENvZGVGcm9tSW1hZ2UoX3gyOSkge1xuICAgICAgICByZXR1cm4gX2dldENvZGVGcm9tSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldENvZGVGcm9tSW1hZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVwbG95RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldERlcGxveURhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIwJChfY29udGV4dDIwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMC5wcmV2ID0gX2NvbnRleHQyMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmRlcGxveS5kYXRhJywgcGFyYW1zKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0RGVwbG95RGF0YShfeDMwKSB7XG4gICAgICAgIHJldHVybiBfZ2V0RGVwbG95RGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0RGVwbG95RGF0YTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVSdW5Cb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY3JlYXRlUnVuQm9keSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjEkKF9jb250ZXh0MjEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIxLnByZXYgPSBfY29udGV4dDIxLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLmJvZHknLCBwYXJhbXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVSdW5Cb2R5KF94MzEpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSdW5Cb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVSdW5Cb2R5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bmN0aW9uSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRGdW5jdGlvbklkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIyKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMiQoX2NvbnRleHQyMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjIucHJldiA9IF9jb250ZXh0MjIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjIuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5mdW5jdGlvbi5pZCcsIHBhcmFtcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZ1bmN0aW9uSWQoX3gzMikge1xuICAgICAgICByZXR1cm4gX2dldEZ1bmN0aW9uSWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldEZ1bmN0aW9uSWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9jSGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEJvY0hhc2ggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIzJChfY29udGV4dDIzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMy5wcmV2ID0gX2NvbnRleHQyMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLmJvYy5oYXNoJywgcGFyYW1zKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0Qm9jSGFzaChfeDMzKSB7XG4gICAgICAgIHJldHVybiBfZ2V0Qm9jSGFzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0Qm9jSGFzaDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJwYXJzZU1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wYXJzZU1lc3NhZ2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI0JChfY29udGV4dDI0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNC5wcmV2ID0gX2NvbnRleHQyNC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLnBhcnNlLm1lc3NhZ2UnLCBwYXJhbXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBwYXJzZU1lc3NhZ2UoX3gzNCkge1xuICAgICAgICByZXR1cm4gX3BhcnNlTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VNZXNzYWdlO1xuICAgIH0oKSAvLyBNZXNzYWdlIHBhcnNpbmdcblxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZVJ1bk91dHB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2RlY29kZVJ1bk91dHB1dCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjUkKF9jb250ZXh0MjUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI1LnByZXYgPSBfY29udGV4dDI1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI1LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLm91dHB1dCcsIHBhcmFtcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGRlY29kZVJ1bk91dHB1dChfeDM1KSB7XG4gICAgICAgIHJldHVybiBfZGVjb2RlUnVuT3V0cHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNvZGVSdW5PdXRwdXQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlSW5wdXRNZXNzYWdlQm9keVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2RlY29kZUlucHV0TWVzc2FnZUJvZHkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjYocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI2JChfY29udGV4dDI2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNi5wcmV2ID0gX2NvbnRleHQyNi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY29udHJhY3RzLnJ1bi51bmtub3duLmlucHV0JywgcGFyYW1zKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZGVjb2RlSW5wdXRNZXNzYWdlQm9keShfeDM2KSB7XG4gICAgICAgIHJldHVybiBfZGVjb2RlSW5wdXRNZXNzYWdlQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVjb2RlSW5wdXRNZXNzYWdlQm9keTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVPdXRwdXRNZXNzYWdlQm9keVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2RlY29kZU91dHB1dE1lc3NhZ2VCb2R5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI3KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNyQoX2NvbnRleHQyNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjcucHJldiA9IF9jb250ZXh0MjcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4udW5rbm93bi5vdXRwdXQnLCBwYXJhbXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBkZWNvZGVPdXRwdXRNZXNzYWdlQm9keShfeDM3KSB7XG4gICAgICAgIHJldHVybiBfZGVjb2RlT3V0cHV0TWVzc2FnZUJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY29kZU91dHB1dE1lc3NhZ2VCb2R5O1xuICAgIH0oKSAvLyBNZXNzYWdlIHByb2Nlc3NpbmdcblxuICB9LCB7XG4gICAga2V5OiBcImVuc3VyZU1lc3NhZ2VJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Vuc3VyZU1lc3NhZ2VJZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyOShtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI5JChfY29udGV4dDI5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyOS5wcmV2ID0gX2NvbnRleHQyOS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDI5LnQwID0gbWVzc2FnZS5tZXNzYWdlSWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2NvbnRleHQyOS50MCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjkubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyOCgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI4JChfY29udGV4dDI4KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI4LnByZXYgPSBfY29udGV4dDI4Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNi5nZXRCb2NIYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2NCYXNlNjQ6IG1lc3NhZ2UubWVzc2FnZUJvZHlCYXNlNjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBfY29udGV4dDI4LnNlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlSWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjguYWJydXB0KFwicmV0dXJuXCIsIGlkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMjgpO1xuICAgICAgICAgICAgICAgIH0pKSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDI5LnQwID0gX2NvbnRleHQyOS5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyOS50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI5KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZW5zdXJlTWVzc2FnZUlkKF94MzgpIHtcbiAgICAgICAgcmV0dXJuIF9lbnN1cmVNZXNzYWdlSWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuc3VyZU1lc3NhZ2VJZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzZW5kTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NlbmRNZXNzYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMwKHBhcmFtcywgcGFyZW50U3Bhbikge1xuICAgICAgICB2YXIgZXhwaXJlLCBzZXJ2ZXJUaW1lRGVsdGEsIGxhc3RCbG9ja0lkLCBpZCwgaWRCYXNlNjQsIG1lc3NhZ2VTcGFuO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMCQoX2NvbnRleHQzMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzAucHJldiA9IF9jb250ZXh0MzAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZXhwaXJlID0gcGFyYW1zLmV4cGlyZTtcblxuICAgICAgICAgICAgICAgIGlmICghKGV4cGlyZSAmJiBEYXRlLm5vdygpID4gZXhwaXJlICogMTAwMCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzAubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDMwLnQwID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzAubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBwYXJhbXMubWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzAudDEgPSBfY29udGV4dDMwLnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzMC50MC5zZW5kTm9kZVJlcXVlc3RGYWlsZWQuY2FsbChfY29udGV4dDMwLnQwLCAnTWVzc2FnZSBhbHJlYWR5IGV4cGlyZWQnLCBfY29udGV4dDMwLnQxKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMC50MiA9IE1hdGg7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllcy5zZXJ2ZXJUaW1lRGVsdGEocGFyZW50U3Bhbik7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMwLnQzID0gX2NvbnRleHQzMC5zZW50O1xuICAgICAgICAgICAgICAgIHNlcnZlclRpbWVEZWx0YSA9IF9jb250ZXh0MzAudDIuYWJzLmNhbGwoX2NvbnRleHQzMC50MiwgX2NvbnRleHQzMC50Myk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShzZXJ2ZXJUaW1lRGVsdGEgPiB0aGlzLmNvbmZpZy5vdXRPZlN5bmNUaHJlc2hvbGQoKSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzAubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyaWVzLmRyb3BTZXJ2ZXJUaW1lRGVsdGEoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMwLnQ0ID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzAubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMwLnQ1ID0gX2NvbnRleHQzMC5zZW50O1xuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzAudDQuY2xvY2tPdXRPZlN5bmMuY2FsbChfY29udGV4dDMwLnQ0LCBfY29udGV4dDMwLnQ1KTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzAubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRMYXN0U2hhcmRCbG9jayhwYXJhbXMuYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICBsYXN0QmxvY2tJZCA9IF9jb250ZXh0MzAuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMwLm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNZXNzYWdlSWQocGFyYW1zKTtcblxuICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgIGlkID0gX2NvbnRleHQzMC5zZW50O1xuICAgICAgICAgICAgICAgIGlkQmFzZTY0ID0gQnVmZmVyLmZyb20oaWQsICdoZXgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVNwYW4gPSB0aGlzLmNvbnRleHQuc3RhcnRSb290U3BhbihpZC5zdWJzdHIoMCwgMTYpLCBpZC5zdWJzdHIoMTYsIDE2KSwgJ21lc3NhZ2VQcm9jZXNzaW5nJyk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVNwYW4uYWRkVGFncyh7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZVNpemU6IE1hdGguY2VpbChwYXJhbXMubWVzc2FnZUJvZHlCYXNlNjQubGVuZ3RoICogMyAvIDQpLFxuICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBleHBpcmU6IHBhcmFtcy5leHBpcmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMwLm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyaWVzLnBvc3RSZXF1ZXN0cyhbe1xuICAgICAgICAgICAgICAgICAgaWQ6IGlkQmFzZTY0LFxuICAgICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLm1lc3NhZ2VCb2R5QmFzZTY0XG4gICAgICAgICAgICAgICAgfV0sIHBhcmVudFNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZVNwYW4uZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKCdzZW5kTWVzc2FnZS4gUmVxdWVzdCBwb3N0ZWQnLCBpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzAuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja0lkOiBsYXN0QmxvY2tJZCxcbiAgICAgICAgICAgICAgICAgIHNlbmRpbmdUaW1lOiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMzAsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZW5kTWVzc2FnZShfeDM5LCBfeDQwKSB7XG4gICAgICAgIHJldHVybiBfc2VuZE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbmRNZXNzYWdlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcHJvY2Vzc01lc3NhZ2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMzEobWVzc2FnZSwgcmVzdWx0RmllbGRzLCBwYXJlbnRTcGFuLCByZXRyeUluZGV4LCBhZGRyZXNzLCBhYmksIGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2luZywgX3lpZWxkJHRoaXMkd2FpdEZvclRyLCB0cmFuc2FjdGlvbjtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMSQoX2NvbnRleHQzMSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzEucHJldiA9IF9jb250ZXh0MzEubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShtZXNzYWdlLCBwYXJlbnRTcGFuKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZyA9IF9jb250ZXh0MzEuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMxLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZVByb2Nlc3NpbmdTdGF0ZTogcHJvY2Vzc2luZyxcbiAgICAgICAgICAgICAgICAgIHBhcmVudFNwYW46IHBhcmVudFNwYW4sXG4gICAgICAgICAgICAgICAgICBhYmk6IGFiaSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF95aWVsZCR0aGlzJHdhaXRGb3JUciA9IF9jb250ZXh0MzEuc2VudDtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IF95aWVsZCR0aGlzJHdhaXRGb3JUci50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMS5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJhbnNhY3Rpb24pO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMxLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKF94NDEsIF94NDIsIF94NDMsIF94NDQsIF94NDUsIF94NDYsIF94NDcpIHtcbiAgICAgICAgcmV0dXJuIF9wcm9jZXNzTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvY2Vzc01lc3NhZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZExhc3RCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ZpbmRMYXN0QmxvY2sgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMzIoY2hhaW4sIHJlc3VsdCwgYWRkaXRpb25hbEZpbHRlcikge1xuICAgICAgICB2YXIgYmxvY2tzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMiQoX2NvbnRleHQzMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzIucHJldiA9IF9jb250ZXh0MzIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyaWVzLmJsb2Nrcy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICAgICAgICB3b3JrY2hhaW5faWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBlcTogY2hhaW5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgYWRkaXRpb25hbEZpbHRlciB8fCB7fSksXG4gICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgIG9yZGVyQnk6IFt7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICdzZXFfbm8nLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdERVNDJ1xuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBibG9ja3MgPSBfY29udGV4dDMyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzIuYWJydXB0KFwicmV0dXJuXCIsIGJsb2Nrcy5sZW5ndGggPiAwID8gYmxvY2tzWzBdIDogbnVsbCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZmluZExhc3RCbG9jayhfeDQ4LCBfeDQ5LCBfeDUwKSB7XG4gICAgICAgIHJldHVybiBfZmluZExhc3RCbG9jay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmluZExhc3RCbG9jaztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJmaW5kTWF0Y2hpbmdTaGFyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ZpbmRNYXRjaGluZ1NoYXJkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMzKHNoYXJkcywgYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMyQoX2NvbnRleHQzMykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzMucHJldiA9IF9jb250ZXh0MzMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzMuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5maW5kLnNoYXJkJywge1xuICAgICAgICAgICAgICAgICAgc2hhcmRzOiBzaGFyZHMsXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ1NoYXJkKF94NTEsIF94NTIpIHtcbiAgICAgICAgcmV0dXJuIF9maW5kTWF0Y2hpbmdTaGFyZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmluZE1hdGNoaW5nU2hhcmQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZExhc3RTaGFyZEJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmluZExhc3RTaGFyZEJsb2NrID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTM0KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIF9tYXN0ZXJjaGFpbkxhc3RCbG9jaywgX3NoYXJkQmxvY2skZGVzY3I7XG5cbiAgICAgICAgdmFyIGFkZHJlc3NQYXJ0cywgd29ya2NoYWluLCBtYXN0ZXJjaGFpbkxhc3RCbG9jaywgd29ya2NoYWluTGFzdEJsb2NrLCBzaGFyZHMsIHNoYXJkQmxvY2ssIHJvb3RfaGFzaDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMzQkKF9jb250ZXh0MzQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDM0LnByZXYgPSBfY29udGV4dDM0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGFkZHJlc3NQYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICB3b3JrY2hhaW4gPSBhZGRyZXNzUGFydHMubGVuZ3RoID4gMSA/IE51bWJlci5wYXJzZUludChhZGRyZXNzUGFydHNbMF0sIDEwKSA6IDA7IC8vIGlmIGFjY291bnQgcmVzaWRlcyBpbiBtYXN0ZXIgY2hhaW4gdGhlbiBzdGFydGluZyBwb2ludCBpcyBsYXN0IG1hc3RlciBjaGFpbiBibG9ja1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBiZWZvcmUgbWVzc2FnZSB3YXMgc2VudFxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kTGFzdEJsb2NrKE1BU1RFUkNIQUlOX0lELCAnaWQgbWFzdGVyIHsgc2hhcmRfaGFzaGVzIHsgd29ya2NoYWluX2lkIHNoYXJkIGRlc2NyIHsgcm9vdF9oYXNoIH0gfSB9Jyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1hc3RlcmNoYWluTGFzdEJsb2NrID0gX2NvbnRleHQzNC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEod29ya2NoYWluID09PSBNQVNURVJDSEFJTl9JRCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlcmNoYWluTGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQudDAgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC50MSA9IE1BU1RFUkNIQUlOX0lEO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQudDIgPSBfY29udGV4dDM0LnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzNC50MC5ub0Jsb2Nrcy5jYWxsKF9jb250ZXh0MzQudDAsIF9jb250ZXh0MzQudDEsIF9jb250ZXh0MzQudDIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzQuYWJydXB0KFwicmV0dXJuXCIsIG1hc3RlcmNoYWluTGFzdEJsb2NrLmlkKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGlmIChtYXN0ZXJjaGFpbkxhc3RCbG9jaykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kTGFzdEJsb2NrKHdvcmtjaGFpbiwgJ2FmdGVyX21lcmdlIHNoYXJkJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICB3b3JrY2hhaW5MYXN0QmxvY2sgPSBfY29udGV4dDM0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAod29ya2NoYWluTGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQudDMgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC50NCA9IHdvcmtjaGFpbjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0LnQ1ID0gX2NvbnRleHQzNC5zZW50O1xuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzQudDMubm9CbG9ja3MuY2FsbChfY29udGV4dDM0LnQzLCBfY29udGV4dDM0LnQ0LCBfY29udGV4dDM0LnQ1KTtcblxuICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgIGlmICghKHdvcmtjaGFpbkxhc3RCbG9jay5hZnRlcl9tZXJnZSB8fCB3b3JrY2hhaW5MYXN0QmxvY2suc2hhcmQgIT09ICc4MDAwMDAwMDAwMDAwMDAwJykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IDMyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC50NiA9IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0LnQ3ID0gTUFTVEVSQ0hBSU5fSUQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC50OCA9IF9jb250ZXh0MzQuc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDM0LnQ2Lm5vQmxvY2tzLmNhbGwoX2NvbnRleHQzNC50NiwgX2NvbnRleHQzNC50NywgX2NvbnRleHQzNC50OCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAzNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kTGFzdEJsb2NrKHdvcmtjaGFpbiwgJ2lkJywge1xuICAgICAgICAgICAgICAgICAgc2hhcmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZXE6ICc4MDAwMDAwMDAwMDAwMDAwJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgd29ya2NoYWluTGFzdEJsb2NrID0gX2NvbnRleHQzNC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtjaGFpbkxhc3RCbG9jaykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNDE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDM0LnQ5ID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IDM5O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlRXJyb3JEYXRhKHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQudDEwID0gX2NvbnRleHQzNC5zZW50O1xuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzQudDkuaW52YWxpZEJsb2NrY2hhaW4uY2FsbChfY29udGV4dDM0LnQ5LCAnTm8gc3RhcnRpbmcgTm9kZSBTRSBibG9jayBmb3VuZCcsIF9jb250ZXh0MzQudDEwKTtcblxuICAgICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM0LmFicnVwdChcInJldHVyblwiLCB3b3JrY2hhaW5MYXN0QmxvY2suaWQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgc2hhcmRzID0gbWFzdGVyY2hhaW5MYXN0QmxvY2sgPT09IG51bGwgfHwgbWFzdGVyY2hhaW5MYXN0QmxvY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbWFzdGVyY2hhaW5MYXN0QmxvY2sgPSBtYXN0ZXJjaGFpbkxhc3RCbG9jay5tYXN0ZXIpID09PSBudWxsIHx8IF9tYXN0ZXJjaGFpbkxhc3RCbG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hc3RlcmNoYWluTGFzdEJsb2NrLnNoYXJkX2hhc2hlcztcblxuICAgICAgICAgICAgICAgIGlmICghKCFzaGFyZHMgfHwgc2hhcmRzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IDQ5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC50MTEgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC50MTIgPSBfY29udGV4dDM0LnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzNC50MTEuaW52YWxpZEJsb2NrY2hhaW4uY2FsbChfY29udGV4dDM0LnQxMSwgJ05vIGBzaGFyZF9oYXNoZXNgIGZpZWxkIGluIG1hc3RlcmNoYWluIGJsb2NrJywgX2NvbnRleHQzNC50MTIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZE1hdGNoaW5nU2hhcmQoc2hhcmRzLCBhZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDUxOlxuICAgICAgICAgICAgICAgIHNoYXJkQmxvY2sgPSBfY29udGV4dDM0LnNlbnQ7XG4gICAgICAgICAgICAgICAgcm9vdF9oYXNoID0gc2hhcmRCbG9jayA9PT0gbnVsbCB8fCBzaGFyZEJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NoYXJkQmxvY2skZGVzY3IgPSBzaGFyZEJsb2NrLmRlc2NyKSA9PT0gbnVsbCB8fCBfc2hhcmRCbG9jayRkZXNjciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NoYXJkQmxvY2skZGVzY3Iucm9vdF9oYXNoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNTk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDM0LnQxMyA9IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSA1NztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0LnQxNCA9IF9jb250ZXh0MzQuc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDM0LnQxMy5pbnZhbGlkQmxvY2tjaGFpbi5jYWxsKF9jb250ZXh0MzQudDEzLCAnTm8gYHJvb3RfaGFzaGAgZmllbGQgaW4gc2hhcmQgZGVzY3InLCBfY29udGV4dDM0LnQxNCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm9vdF9oYXNoKTtcblxuICAgICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTM0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZmluZExhc3RTaGFyZEJsb2NrKF94NTMpIHtcbiAgICAgICAgcmV0dXJuIF9maW5kTGFzdFNoYXJkQmxvY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmRMYXN0U2hhcmRCbG9jaztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjaGVja1NoYXJkTWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jaGVja1NoYXJkTWF0Y2ggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMzUoYmxvY2ssIGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMzUkKF9jb250ZXh0MzUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDM1LnByZXYgPSBfY29udGV4dDM1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzUubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZE1hdGNoaW5nU2hhcmQoW3tcbiAgICAgICAgICAgICAgICAgIHdvcmtjaGFpbl9pZDogYmxvY2sud29ya2NoYWluX2lkIHx8IDAsXG4gICAgICAgICAgICAgICAgICBzaGFyZDogYmxvY2suc2hhcmQgfHwgJydcbiAgICAgICAgICAgICAgICB9XSwgYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM1LmFicnVwdChcInJldHVyblwiLCAhIV9jb250ZXh0MzUuc2VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTM1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2hlY2tTaGFyZE1hdGNoKF94NTQsIF94NTUpIHtcbiAgICAgICAgcmV0dXJuIF9jaGVja1NoYXJkTWF0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoZWNrU2hhcmRNYXRjaDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJ3YWl0TmV4dEJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfd2FpdE5leHRCbG9jayA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNihjdXJyZW50LCBhZGRyZXNzLCB0aW1lb3V0KSB7XG4gICAgICAgIHZhciBibG9jaztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMzYkKF9jb250ZXh0MzYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDM2LnByZXYgPSBfY29udGV4dDM2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzYubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllcy5ibG9ja3Mud2FpdEZvcih7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldl9yZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICByb290X2hhc2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxOiBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBPUjoge1xuICAgICAgICAgICAgICAgICAgICAgIHByZXZfYWx0X3JlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdF9oYXNoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVxOiBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBCTE9DS19GSUVMRFMsXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJsb2NrID0gX2NvbnRleHQzNi5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzYudDAgPSBibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2suYWZ0ZXJfc3BsaXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0MzYudDApIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzYubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDM2Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrU2hhcmRNYXRjaChibG9jaywgYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzYudDAgPSAhX2NvbnRleHQzNi5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0MzYudDApIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzYubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucXVlcmllcy5ibG9ja3Mud2FpdEZvcih7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBuZTogYmxvY2suaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJldl9yZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICByb290X2hhc2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxOiBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBCTE9DS19GSUVMRFMsXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuYWJydXB0KFwicmV0dXJuXCIsIGJsb2NrKTtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTM2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gd2FpdE5leHRCbG9jayhfeDU2LCBfeDU3LCBfeDU4KSB7XG4gICAgICAgIHJldHVybiBfd2FpdE5leHRCbG9jay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2FpdE5leHRCbG9jaztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJ3YWl0Rm9yVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF93YWl0Rm9yVHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMzcocGFyYW1zKSB7XG4gICAgICAgIHZhciB0b3RhbFN0YXJ0LCBleHBpcmUsIG1lc3NhZ2VJZCwgYWRkcmVzcywgcHJvY2Vzc2luZywgdHJhbnNhY3Rpb24sIHRpbWVSZXBvcnQsIHN0b3BUaW1lLCBpbmZpbml0ZVdhaXQsIGFkZFRpbWVvdXQsIG5vdywgdGltZW91dCwgYmxvY2ssIHN0YXJ0LCBlbmQsIHJlc29sdmVkRXJyb3IsIGluTXNnLCB0cmFuc2FjdGlvbklkLCB0clN0YXJ0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzNyQoX2NvbnRleHQzNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzcucHJldiA9IF9jb250ZXh0MzcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdG90YWxTdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgZXhwaXJlID0gcGFyYW1zLm1lc3NhZ2UuZXhwaXJlIHx8IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNZXNzYWdlSWQocGFyYW1zLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQgPSBfY29udGV4dDM3LnNlbnQ7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHBhcmFtcy5tZXNzYWdlLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZyA9IF9vYmplY3RTcHJlYWQoe30sIHBhcmFtcy5tZXNzYWdlUHJvY2Vzc2luZ1N0YXRlKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy5wcmV2ID0gODtcbiAgICAgICAgICAgICAgICB0aW1lUmVwb3J0ID0gW107XG4gICAgICAgICAgICAgICAgc3RvcFRpbWUgPSBleHBpcmUgfHwgTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSArIHRoaXMuY29uZmlnLm1lc3NhZ2VQcm9jZXNzaW5nVGltZW91dCgpKSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIGluZmluaXRlV2FpdCA9IHBhcmFtcy5pbmZpbml0ZVdhaXQgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFkZFRpbWVvdXQgPSB0aGlzLmNvbmZpZy5tZXNzYWdlUHJvY2Vzc2luZ1RpbWVvdXQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzNy5uZXh0ID0gNzM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBNYXRoLm1heChzdG9wVGltZSwgbm93KSAtIG5vdyArIGFkZFRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgYmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzcucHJldiA9IDE3O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWl0TmV4dEJsb2NrKHByb2Nlc3NpbmcubGFzdEJsb2NrSWQsIGFkZHJlc3MsIHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgYmxvY2sgPSBfY29udGV4dDM3LnNlbnQ7XG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB0aW1lUmVwb3J0LnB1c2goXCJCbG9jayBbXCIuY29uY2F0KGJsb2NrLmlkIHx8ICcnLCBcIl0gXCIpICsgXCJoYXMgYmVlbiByZWNlaXZlZDogXCIuY29uY2F0KGVuZCAtIHN0YXJ0LCBcIiBtcywgXCIpICsgXCJjbGllbnQgdGltZTogXCIuY29uY2F0KE1hdGgucm91bmQoZW5kIC8gMTAwMCksIFwiLCBcIikgKyBcImdlbl91dGltZTogXCIuY29uY2F0KGJsb2NrLmdlbl91dGltZSB8fCAwKSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy5uZXh0ID0gMzk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3LnByZXYgPSAyNjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3LnQwID0gX2NvbnRleHQzN1tcImNhdGNoXCJdKDE3KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ0Jsb2NrIHdhaXRpbmcgZmFpbGVkOiAnLCBfY29udGV4dDM3LnQwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0ZVdhaXQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzcubmV4dCA9IDM4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRFcnJvciA9IF9jb250ZXh0MzcudDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShfY29udGV4dDM3LnQwLmNvZGUgPT09IF9UT05DbGllbnRFcnJvci5UT05FcnJvckNvZGUuV0FJVF9GT1JfVElNRU9VVCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzcubmV4dCA9IDM3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy50MSA9IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSAzNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgYmxvY2tfaWQ6IHByb2Nlc3NpbmcubGFzdEJsb2NrSWQsXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZV9wcm9jZXNzaW5nX3N0YXRlOiBwcm9jZXNzaW5nLFxuICAgICAgICAgICAgICAgICAgZXhwaXJlOiBleHBpcmUsXG4gICAgICAgICAgICAgICAgICBzZW5kaW5nX3RpbWU6IHByb2Nlc3Npbmcuc2VuZGluZ1RpbWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzcudDIgPSBfY29udGV4dDM3LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRFcnJvciA9IF9jb250ZXh0MzcudDEubmV0d29ya1NpbGVudC5jYWxsKF9jb250ZXh0MzcudDEsIF9jb250ZXh0MzcudDIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzb2x2ZWRFcnJvcjtcblxuICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZygnUmV0cnkgd2FpdGluZy4nKTtcblxuICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzcubmV4dCA9IDcxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZy5sYXN0QmxvY2tJZCA9IGJsb2NrLmlkIHx8ICcnO1xuICAgICAgICAgICAgICAgIGluTXNnID0gKGJsb2NrLmluX21zZ19kZXNjciB8fCBbXSkuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHgubXNnX2lkID09PSBtZXNzYWdlSWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluTXNnKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSA1ODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQgPSBpbk1zZy50cmFuc2FjdGlvbl9pZDtcblxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSA1MDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzcudDMgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy5uZXh0ID0gNDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy50NCA9IF9jb250ZXh0Mzcuc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDM3LnQzLmludmFsaWRCbG9ja2NoYWluLmNhbGwoX2NvbnRleHQzNy50MywgJ05vIGZpZWxkIGB0cmFuc2FjdGlvbl9pZGAgaW4gYmxvY2snLCBfY29udGV4dDM3LnQ0KTtcblxuICAgICAgICAgICAgICBjYXNlIDUwOlxuICAgICAgICAgICAgICAgIHRyU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzcubmV4dCA9IDUzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJpZXMudHJhbnNhY3Rpb25zLndhaXRGb3Ioe1xuICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZXE6IHRyYW5zYWN0aW9uSWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDogVFJBTlNBQ1RJT05fRklFTERTX09SRElOQVJZLFxuICAgICAgICAgICAgICAgICAgdGltZW91dDogX1RPTlF1ZXJpZXNNb2R1bGUuTUFYX1RJTUVPVVRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDUzOlxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gX2NvbnRleHQzNy5zZW50O1xuICAgICAgICAgICAgICAgIHRyYWNlTWVzc2FnZSh0aGlzLmNvbmZpZy50cmFjZXIsIG1lc3NhZ2VJZCwgJ3RyYW5zYWN0aW9uUmVjZWl2ZWQnLCB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiB0cmFuc2FjdGlvbklkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGltZVJlcG9ydC5wdXNoKFwiVHJhbnNhY3Rpb24gW1wiLmNvbmNhdCh0cmFuc2FjdGlvbklkLCBcIl0gaGFzIGJlZW4gcmVjZWl2ZWQ6IFwiKS5jb25jYXQoRGF0ZS5ub3coKSAtIHRyU3RhcnQsIFwiIG1zXCIpKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSA3MTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAgIGlmICghKChibG9jay5nZW5fdXRpbWUgfHwgMCkgPiBzdG9wVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzcubmV4dCA9IDcxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFleHBpcmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzcubmV4dCA9IDY2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJhY2VNZXNzYWdlKHRoaXMuY29uZmlnLnRyYWNlciwgbWVzc2FnZUlkLCAnbWVzc2FnZUV4cGlyZWQnLCB7fSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy50NSA9IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSA2NDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgc2VuZGluZ190aW1lOiBwcm9jZXNzaW5nLnNlbmRpbmdUaW1lLFxuICAgICAgICAgICAgICAgICAgZXhwaXJlOiBzdG9wVGltZSxcbiAgICAgICAgICAgICAgICAgIGJsb2NrX3RpbWU6IGJsb2NrLmdlbl91dGltZSxcbiAgICAgICAgICAgICAgICAgIGJsb2NrX2lkOiBwcm9jZXNzaW5nLmxhc3RCbG9ja0lkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3LnQ2ID0gX2NvbnRleHQzNy5zZW50O1xuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzcudDUubWVzc2FnZUV4cGlyZWQuY2FsbChfY29udGV4dDM3LnQ1LCBfY29udGV4dDM3LnQ2KTtcblxuICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzcudDcgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy5uZXh0ID0gNjk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgIHNlbmRpbmdfdGltZTogcHJvY2Vzc2luZy5zZW5kaW5nVGltZSxcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlX3Byb2Nlc3Npbmdfc3RhdGU6IHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDY5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzcudDggPSBfY29udGV4dDM3LnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzNy50Ny50cmFuc2FjdGlvbldhaXRUaW1lb3V0LmNhbGwoX2NvbnRleHQzNy50NywgX2NvbnRleHQzNy50OCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3MTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDczOlxuICAgICAgICAgICAgICAgIHRpbWVSZXBvcnQuc3BsaWNlKDAsIDAsIFwiVHJhbnNhY3Rpb24gd2FpdGluZyB0aW1lOiBcIi5jb25jYXQoRGF0ZS5ub3coKSAtIHRvdGFsU3RhcnQsIFwiIG1zXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2codGltZVJlcG9ydC5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy5uZXh0ID0gODc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA3NzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3LnByZXYgPSA3NztcbiAgICAgICAgICAgICAgICBfY29udGV4dDM3LnQ5ID0gX2NvbnRleHQzN1tcImNhdGNoXCJdKDgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZygnW3dhaXRGb3JUcmFuc2FjdGlvbl0nLCAnRkFJTEVEJywgX2NvbnRleHQzNy50OSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShfY29udGV4dDM3LnQ5LmNvZGUgPT09IF9UT05DbGllbnRFcnJvci5UT05FcnJvckNvZGUuTUVTU0FHRV9FWFBJUkVEIHx8IF9jb250ZXh0MzcudDkuY29kZSA9PT0gX1RPTkNsaWVudEVycm9yLlRPTkVycm9yQ29kZS5UUkFOU0FDVElPTl9XQUlUX1RJTUVPVVQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSA4NjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzcubmV4dCA9IDgzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVEZXRhaWxlZEVycm9yKF9jb250ZXh0MzcudDksIHBhcmFtcy5tZXNzYWdlLm1lc3NhZ2VCb2R5QmFzZTY0LCBwcm9jZXNzaW5nLnNlbmRpbmdUaW1lLCBhZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDgzOlxuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Mzcuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDg2OlxuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzcudDk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4NzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNy5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5wcm9jZXNzVHJhbnNhY3Rpb24oYWRkcmVzcywgdHJhbnNhY3Rpb24sIHBhcmFtcy5hYmksIHBhcmFtcy5mdW5jdGlvbk5hbWUpKTtcblxuICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mzcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTM3LCB0aGlzLCBbWzgsIDc3XSwgWzE3LCAyNl1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gd2FpdEZvclRyYW5zYWN0aW9uKF94NTkpIHtcbiAgICAgICAgcmV0dXJuIF93YWl0Rm9yVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdhaXRGb3JUcmFuc2FjdGlvbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wcm9jZXNzVHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMzgoYWRkcmVzcywgdHJhbnNhY3Rpb24sIGFiaSwgZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGFjY291bnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzOCQoX2NvbnRleHQzOCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzgucHJldiA9IF9jb250ZXh0MzgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzOC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM4Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucHJvY2Vzcy50cmFuc2FjdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgIGFiaTogYWJpLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mzguc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzOC5hYnJ1cHQoXCJyZXR1cm5cIiwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzOC5wcmV2ID0gNztcbiAgICAgICAgICAgICAgICBfY29udGV4dDM4LnQwID0gX2NvbnRleHQzOFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzgubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJpZXMuYWNjb3VudHMucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZXE6IGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDogJ2FjY190eXBlIGJhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgdGltZW91dDogMTAwMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgYWNjb3VudHMgPSBfY29udGV4dDM4LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShhY2NvdW50cy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM4Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzgudDEgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzOC50MiA9IGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzOC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxfZXJyb3I6IF9jb250ZXh0MzgudDAsXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fbmFtZTogZnVuY3Rpb25OYW1lXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM4LnQzID0gX2NvbnRleHQzOC5zZW50O1xuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzgudDEuYWNjb3VudE1pc3NpbmcuY2FsbChfY29udGV4dDM4LnQxLCBfY29udGV4dDM4LnQyLCBfY29udGV4dDM4LnQzKTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzgudDA7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzOCwgdGhpcywgW1swLCA3XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzVHJhbnNhY3Rpb24oX3g2MCwgX3g2MSwgX3g2MiwgX3g2Mykge1xuICAgICAgICByZXR1cm4gX3Byb2Nlc3NUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvY2Vzc1RyYW5zYWN0aW9uO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVEZXRhaWxlZEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVzb2x2ZURldGFpbGVkRXJyb3IgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMzkoZXJyb3IsIG1lc3NhZ2VCYXNlNjQsIHRpbWUsIGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGFjY291bnRzLCBhY2NvdW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzOSQoX2NvbnRleHQzOSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzkucHJldiA9IF9jb250ZXh0MzkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzOS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyaWVzLmFjY291bnRzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgICAgICAgIGVxOiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICByZXN1bHQ6ICdpZCBhY2NfdHlwZSBiYWxhbmNlIGJhbGFuY2Vfb3RoZXIgeyBjdXJyZW5jeSB2YWx1ZSB9IGJvYyBjb2RlX2hhc2ggZGF0YV9oYXNoIGxhc3RfcGFpZCcsXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiAxMDAwXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFjY291bnRzID0gX2NvbnRleHQzOS5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoYWNjb3VudHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzOS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDM5LnQwID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzkudDEgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzkubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIG9yaWdpbmFsX2Vycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM5LnQyID0gX2NvbnRleHQzOS5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM5LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDM5LnQwLmFjY291bnRNaXNzaW5nLmNhbGwoX2NvbnRleHQzOS50MCwgX2NvbnRleHQzOS50MSwgX2NvbnRleHQzOS50MikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgYWNjb3VudCA9IGFjY291bnRzWzBdO1xuICAgICAgICAgICAgICAgIHJlbW92ZVR5cGVOYW1lKGFjY291bnQpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzkucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzkubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucmVzb2x2ZS5lcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZUJhc2U2NDogbWVzc2FnZUJhc2U2NCxcbiAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICBtYWluRXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDM5Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzkucHJldiA9IDE3O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzkudDMgPSBfY29udGV4dDM5W1wiY2F0Y2hcIl0oMTIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM5LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDM5LnQzKTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM5LmFicnVwdChcInJldHVyblwiLCBlcnJvcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzOSwgdGhpcywgW1sxMiwgMTddXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVEZXRhaWxlZEVycm9yKF94NjQsIF94NjUsIF94NjYsIF94NjcpIHtcbiAgICAgICAgcmV0dXJuIF9yZXNvbHZlRGV0YWlsZWRFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzb2x2ZURldGFpbGVkRXJyb3I7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEZXBsb3llZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2lzRGVwbG95ZWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNDAoYWRkcmVzcywgcGFyZW50U3Bhbikge1xuICAgICAgICB2YXIgYWNjb3VudDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNDAkKF9jb250ZXh0NDApIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQwLnByZXYgPSBfY29udGV4dDQwLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NDAubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllcy5hY2NvdW50cy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBlcTogYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhY2NfdHlwZToge1xuICAgICAgICAgICAgICAgICAgICAgIGVxOiBRQWNjb3VudFR5cGUuYWN0aXZlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICByZXN1bHQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRTcGFuOiBwYXJlbnRTcGFuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFjY291bnQgPSBfY29udGV4dDQwLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDAuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnQubGVuZ3RoID4gMCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gaXNEZXBsb3llZChfeDY4LCBfeDY5KSB7XG4gICAgICAgIHJldHVybiBfaXNEZXBsb3llZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNEZXBsb3llZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzRGVwbG95TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Byb2Nlc3NEZXBsb3lNZXNzYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQxKG1lc3NhZ2UsIHBhcmVudFNwYW4sIHJldHJ5SW5kZXgpIHtcbiAgICAgICAgdmFyIHByb2Nlc3Npbmc7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQxJChfY29udGV4dDQxKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0MS5wcmV2ID0gX2NvbnRleHQ0MS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ3Byb2Nlc3NEZXBsb3lNZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0MS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc0RlcGxveWVkKG1lc3NhZ2UuYWRkcmVzcywgcGFyZW50U3Bhbik7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQ0MS5zZW50KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQxLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDEuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IG1lc3NhZ2UuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGFscmVhZHlEZXBsb3llZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQxLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2UubWVzc2FnZSwgcGFyZW50U3Bhbik7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcgPSBfY29udGV4dDQxLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDEuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMud2FpdEZvckRlcGxveVRyYW5zYWN0aW9uKG1lc3NhZ2UsIHByb2Nlc3NpbmcsIHBhcmVudFNwYW4pKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0MS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzRGVwbG95TWVzc2FnZShfeDcwLCBfeDcxLCBfeDcyKSB7XG4gICAgICAgIHJldHVybiBfcHJvY2Vzc0RlcGxveU1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2Nlc3NEZXBsb3lNZXNzYWdlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIndhaXRGb3JEZXBsb3lUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3dhaXRGb3JEZXBsb3lUcmFuc2FjdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0MihkZXBsb3lNZXNzYWdlLCBtZXNzYWdlUHJvY2Vzc2luZ1N0YXRlLCBwYXJlbnRTcGFuLCBpbmZpbml0ZVdhaXQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UsIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNDIkKF9jb250ZXh0NDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQyLnByZXYgPSBfY29udGV4dDQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBkZXBsb3lNZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQcm9jZXNzaW5nU3RhdGU6IG1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRTcGFuOiBwYXJlbnRTcGFuLFxuICAgICAgICAgICAgICAgICAgaW5maW5pdGVXYWl0OiBpbmZpbml0ZVdhaXRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ0Mi5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQyLmFicnVwdChcInJldHVyblwiLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBtZXNzYWdlLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBhbHJlYWR5RGVwbG95ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0MiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHdhaXRGb3JEZXBsb3lUcmFuc2FjdGlvbihfeDczLCBfeDc0LCBfeDc1LCBfeDc2KSB7XG4gICAgICAgIHJldHVybiBfd2FpdEZvckRlcGxveVRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3YWl0Rm9yRGVwbG95VHJhbnNhY3Rpb247XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1J1bk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wcm9jZXNzUnVuTWVzc2FnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0MyhydW5NZXNzYWdlLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBwcm9jZXNzaW5nO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0MyQoX2NvbnRleHQ0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NDMucHJldiA9IF9jb250ZXh0NDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKCdwcm9jZXNzUnVuTWVzc2FnZScsIHJ1bk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UocnVuTWVzc2FnZS5tZXNzYWdlLCBwYXJlbnRTcGFuKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZyA9IF9jb250ZXh0NDMuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy53YWl0Rm9yUnVuVHJhbnNhY3Rpb24ocnVuTWVzc2FnZSwgcHJvY2Vzc2luZywgcGFyZW50U3BhbikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0MywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NSdW5NZXNzYWdlKF94NzcsIF94NzgpIHtcbiAgICAgICAgcmV0dXJuIF9wcm9jZXNzUnVuTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvY2Vzc1J1bk1lc3NhZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwid2FpdEZvclJ1blRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfd2FpdEZvclJ1blRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQ0KHJ1bk1lc3NhZ2UsIG1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUsIHBhcmVudFNwYW4sIGluZmluaXRlV2FpdCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0NCQoX2NvbnRleHQ0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NDQucHJldiA9IF9jb250ZXh0NDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJ1bk1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQcm9jZXNzaW5nU3RhdGU6IG1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRTcGFuOiBwYXJlbnRTcGFuLFxuICAgICAgICAgICAgICAgICAgaW5maW5pdGVXYWl0OiBpbmZpbml0ZVdhaXQsXG4gICAgICAgICAgICAgICAgICBhYmk6IHJ1bk1lc3NhZ2UuYWJpLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBydW5NZXNzYWdlLmZ1bmN0aW9uTmFtZVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB3YWl0Rm9yUnVuVHJhbnNhY3Rpb24oX3g3OSwgX3g4MCwgX3g4MSwgX3g4Mikge1xuICAgICAgICByZXR1cm4gX3dhaXRGb3JSdW5UcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2FpdEZvclJ1blRyYW5zYWN0aW9uO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQuIFVzZSBgcnVuTWVzc2FnZUxvY2FsYCBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gd2FpdFBhcmFtc1xuICAgICAqIEBwYXJhbSBwYXJlbnRTcGFuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzUnVuTWVzc2FnZUxvY2FsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcHJvY2Vzc1J1bk1lc3NhZ2VMb2NhbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0NShwYXJhbXMsIHdhaXRQYXJhbXMsIHBhcmVudFNwYW4pIHtcbiAgICAgICAgdmFyIGFjY291bnQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQ1JChfY29udGV4dDQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0NS5wcmV2ID0gX2NvbnRleHQ0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ3Byb2Nlc3NSdW5NZXNzYWdlTG9jYWwnLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDUubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudChwYXJhbXMuYWRkcmVzcywgdHJ1ZSwgd2FpdFBhcmFtcywgcGFyZW50U3Bhbik7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGFjY291bnQgPSBfY29udGV4dDQ1LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDUuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4ubG9jYWwubXNnJywge1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgYWJpOiBwYXJhbXMuYWJpLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZUJhc2U2NDogcGFyYW1zLm1lc3NhZ2UubWVzc2FnZUJvZHlCYXNlNjRcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQ1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc1J1bk1lc3NhZ2VMb2NhbChfeDgzLCBfeDg0LCBfeDg1KSB7XG4gICAgICAgIHJldHVybiBfcHJvY2Vzc1J1bk1lc3NhZ2VMb2NhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvY2Vzc1J1bk1lc3NhZ2VMb2NhbDtcbiAgICB9KCkgLy8gRmVlIGNhbGN1bGF0aW9uXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjUnVuRmVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NhbGNSdW5GZWVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQ2KHBhcmFtcywgcGFyZW50U3Bhbikge1xuICAgICAgICB2YXIgYWNjb3VudDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNDYkKF9jb250ZXh0NDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQ2LnByZXYgPSBfY29udGV4dDQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZygnY2FsY1J1bkZlZXMnLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDYubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudChwYXJhbXMuYWRkcmVzcywgdHJ1ZSwgcGFyYW1zLndhaXRQYXJhbXMsIHBhcmVudFNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gX2NvbnRleHQ0Ni5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5lbXVsYXRlQmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgYWNjb3VudC5iYWxhbmNlID0gdGhpcy5iaWdCYWxhbmNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQ2LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLmZlZScsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgIGFiaTogcGFyYW1zLmFiaSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXlQYWlyOiBwYXJhbXMua2V5UGFpclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxjUnVuRmVlcyhfeDg2LCBfeDg3KSB7XG4gICAgICAgIHJldHVybiBfY2FsY1J1bkZlZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGNSdW5GZWVzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNhbGNEZXBsb3lGZWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2FsY0RlcGxveUZlZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNDcocGFyYW1zLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0NyQoX2NvbnRleHQ0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NDcucHJldiA9IF9jb250ZXh0NDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKCdjYWxjRGVwbG95RmVlcycsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXBsb3lNZXNzYWdlKHBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dDQ3LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuY2FsY01zZ1Byb2Nlc3NGZWVzKHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IG1lc3NhZ2UuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIGVtdWxhdGVCYWxhbmNlOiBwYXJhbXMuZW11bGF0ZUJhbGFuY2UsXG4gICAgICAgICAgICAgICAgICBuZXdBY2NvdW50OiBwYXJhbXMubmV3QWNjb3VudFxuICAgICAgICAgICAgICAgIH0sIHBhcmVudFNwYW4pKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxjRGVwbG95RmVlcyhfeDg4LCBfeDg5KSB7XG4gICAgICAgIHJldHVybiBfY2FsY0RlcGxveUZlZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGNEZXBsb3lGZWVzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNhbGNNc2dQcm9jZXNzRmVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NhbGNNc2dQcm9jZXNzRmVlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0OChwYXJhbXMsIHBhcmVudFNwYW4pIHtcbiAgICAgICAgdmFyIGFjY291bnQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQ4JChfY29udGV4dDQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0OC5wcmV2ID0gX2NvbnRleHQ0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ2NhbGNNc2dQcm9jZXNzRmVlcycsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAgIGJhbGFuY2U6IHRoaXMuYmlnQmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGxhc3RfcGFpZDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5uZXdBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQ4Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0OC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50KHBhcmFtcy5hZGRyZXNzLCBmYWxzZSwgcGFyYW1zLndhaXRQYXJhbXMsIHBhcmVudFNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gX2NvbnRleHQ0OC5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmVtdWxhdGVCYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50LmJhbGFuY2UgPSB0aGlzLmJpZ0JhbGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDguYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4uZmVlLm1zZycsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCYXNlNjQ6IHBhcmFtcy5tZXNzYWdlLm1lc3NhZ2VCb2R5QmFzZTY0XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0OCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGNNc2dQcm9jZXNzRmVlcyhfeDkwLCBfeDkxKSB7XG4gICAgICAgIHJldHVybiBfY2FsY01zZ1Byb2Nlc3NGZWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxjTXNnUHJvY2Vzc0ZlZXM7XG4gICAgfSgpIC8vIEFkZHJlc3MgcHJvY2Vzc2luZ1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydEFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb252ZXJ0QWRkcmVzcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0OShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNDkkKF9jb250ZXh0NDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQ5LnByZXYgPSBfY29udGV4dDQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQ5LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMuYWRkcmVzcy5jb252ZXJ0JywgcGFyYW1zKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQ5LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY29udmVydEFkZHJlc3MoX3g5Mikge1xuICAgICAgICByZXR1cm4gX2NvbnZlcnRBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb252ZXJ0QWRkcmVzcztcbiAgICB9KCkgLy8gSW50ZXJuYWxzXG5cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcm5hbERlcGxveU5hdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ludGVybmFsRGVwbG95TmF0aXZlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUwKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1MCQoX2NvbnRleHQ1MCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NTAucHJldiA9IF9jb250ZXh0NTAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTAuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5kZXBsb3knLCB7XG4gICAgICAgICAgICAgICAgICBhYmk6IHBhcmFtc1tcInBhY2thZ2VcIl0uYWJpLFxuICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3JIZWFkZXI6IHBhcmFtcy5jb25zdHJ1Y3RvckhlYWRlcixcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yUGFyYW1zOiBwYXJhbXMuY29uc3RydWN0b3JQYXJhbXMsXG4gICAgICAgICAgICAgICAgICBpbml0UGFyYW1zOiBwYXJhbXMuaW5pdFBhcmFtcyxcbiAgICAgICAgICAgICAgICAgIGltYWdlQmFzZTY0OiBwYXJhbXNbXCJwYWNrYWdlXCJdLmltYWdlQmFzZTY0LFxuICAgICAgICAgICAgICAgICAga2V5UGFpcjogcGFyYW1zLmtleVBhaXJcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJuYWxEZXBsb3lOYXRpdmUoX3g5Mykge1xuICAgICAgICByZXR1cm4gX2ludGVybmFsRGVwbG95TmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnRlcm5hbERlcGxveU5hdGl2ZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJpbnRlcm5hbFJ1bk5hdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ludGVybmFsUnVuTmF0aXZlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUxKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1MSQoX2NvbnRleHQ1MSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NTEucHJldiA9IF9jb250ZXh0NTEubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTEuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4nLCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGFiaTogcGFyYW1zLmFiaSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcjogcGFyYW1zLmhlYWRlcixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXlQYWlyOiBwYXJhbXMua2V5UGFpclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1MS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBpbnRlcm5hbFJ1bk5hdGl2ZShfeDk0KSB7XG4gICAgICAgIHJldHVybiBfaW50ZXJuYWxSdW5OYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGludGVybmFsUnVuTmF0aXZlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJldHJ5Q2FsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JldHJ5Q2FsbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1MihjYWxsKSB7XG4gICAgICAgIHZhciByZXRyaWVzQ291bnQsIGksIGlzT3JpZ2luYWxPclJlc29sdmVkLCB1c2VSZXRyeTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNTIkKF9jb250ZXh0NTIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUyLnByZXYgPSBfY29udGV4dDUyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHJpZXNDb3VudCA9IHRoaXMuY29uZmlnLm1lc3NhZ2VSZXRyaWVzQ291bnQoKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8PSByZXRyaWVzQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKFwiUmV0cnkgI1wiLmNvbmNhdChpKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Mi5wcmV2ID0gNDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUyLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKGkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ1Mi5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTIucHJldiA9IDEwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTIudDAgPSBfY29udGV4dDUyW1wiY2F0Y2hcIl0oNCk7XG5cbiAgICAgICAgICAgICAgICAvLyByZXRyeSBpZiBtZXNzYWdlIGV4cGlyZWQgb3IgaWYgcmVzb2x2aW5nIHJldHVybmVkIHRoYXQgbWVzc2FnZSBleHBpcmVkL3JlcGxheVxuICAgICAgICAgICAgICAgIC8vIHByb3RlY3Rpb24gZXJyb3Igb3IgaWYgdHJhbnNhY3Rpb24gd2l0aCBtZXNzYWdlIGV4cGlyZWQvcmVwbGF5IHByb3RlY3Rpb24gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZFxuICAgICAgICAgICAgICAgIGlzT3JpZ2luYWxPclJlc29sdmVkID0gZnVuY3Rpb24gaXNPcmlnaW5hbE9yUmVzb2x2ZWQoZXhpdENvZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3IuaXNPcmlnaW5hbENvbnRyYWN0RXJyb3IoX2NvbnRleHQ1Mi50MCwgZXhpdENvZGUpIHx8IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvci5pc1Jlc29sdmVkQ29udHJhY3RFcnJvckFmdGVyRXhwaXJlKF9jb250ZXh0NTIudDAsIGV4aXRDb2RlKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdXNlUmV0cnkgPSBfY29udGV4dDUyLnQwLmNvZGUgPT09IF9UT05DbGllbnRFcnJvci5UT05FcnJvckNvZGUuTUVTU0FHRV9FWFBJUkVEIHx8IGlzT3JpZ2luYWxPclJlc29sdmVkKF9UT05DbGllbnRFcnJvci5UT05Db250cmFjdEV4aXRDb2RlLlJFUExBWV9QUk9URUNUSU9OKSB8fCBpc09yaWdpbmFsT3JSZXNvbHZlZChfVE9OQ2xpZW50RXJyb3IuVE9OQ29udHJhY3RFeGl0Q29kZS5NRVNTQUdFX0VYUElSRUQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoIXVzZVJldHJ5IHx8IGkgPT09IHJldHJpZXNDb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NTIubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ1Mi50MDtcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Mi50MSA9IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUyLm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUVycm9yRGF0YSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Mi50MiA9IF9jb250ZXh0NTIuc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDUyLnQxLmludGVybmFsRXJyb3IuY2FsbChfY29udGV4dDUyLnQxLCAnQWxsIHJldHJ5IGF0dGVtcHRzIGZhaWxlZCcsIF9jb250ZXh0NTIudDIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTIsIHRoaXMsIFtbNCwgMTBdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJldHJ5Q2FsbChfeDk1KSB7XG4gICAgICAgIHJldHVybiBfcmV0cnlDYWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRyeUNhbGw7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJuYWxEZXBsb3lKc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ludGVybmFsRGVwbG95SnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNTQocGFyYW1zLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTU0JChfY29udGV4dDU0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1NC5wcmV2ID0gX2NvbnRleHQ1NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ0RlcGxveSBzdGFydCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU0LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJldHJ5Q2FsbCggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmNiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1MyhyZXRyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXBsb3lNZXNzYWdlLCBwcm9jZXNzaW5nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1MyQoX2NvbnRleHQ1Mykge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NTMucHJldiA9IF9jb250ZXh0NTMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM3LmNyZWF0ZURlcGxveU1lc3NhZ2UocGFyYW1zLCByZXRyeUluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwbG95TWVzc2FnZSA9IF9jb250ZXh0NTMuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUzLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczcuaXNEZXBsb3llZChkZXBsb3lNZXNzYWdlLmFkZHJlc3MsIHBhcmVudFNwYW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0NTMuc2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1My5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUzLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBkZXBsb3lNZXNzYWdlLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5RGVwbG95ZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM3LnNlbmRNZXNzYWdlKGRlcGxveU1lc3NhZ2UubWVzc2FnZSwgcGFyZW50U3Bhbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcgPSBfY29udGV4dDUzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTMuYWJydXB0KFwicmV0dXJuXCIsIF90aGlzNy53YWl0Rm9yRGVwbG95VHJhbnNhY3Rpb24oZGVwbG95TWVzc2FnZSwgcHJvY2Vzc2luZywgcGFyZW50U3BhbikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNTMpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94OTgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1NCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGludGVybmFsRGVwbG95SnMoX3g5NiwgX3g5Nykge1xuICAgICAgICByZXR1cm4gX2ludGVybmFsRGVwbG95SnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGludGVybmFsRGVwbG95SnM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJuYWxSdW5Kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ludGVybmFsUnVuSnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNTYocGFyYW1zLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTU2JChfY29udGV4dDU2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1Ni5wcmV2ID0gX2NvbnRleHQ1Ni5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2coJ1J1biBzdGFydCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU2LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJldHJ5Q2FsbCggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1NShyZXRyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydW5NZXNzYWdlLCBwcm9jZXNzaW5nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1NSQoX2NvbnRleHQ1NSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NTUucHJldiA9IF9jb250ZXh0NTUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4LmNyZWF0ZVJ1bk1lc3NhZ2UocGFyYW1zLCByZXRyeUluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuTWVzc2FnZSA9IF9jb250ZXh0NTUuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDU1Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczguc2VuZE1lc3NhZ2UocnVuTWVzc2FnZS5tZXNzYWdlLCBwYXJlbnRTcGFuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZyA9IF9jb250ZXh0NTUuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX3RoaXM4LndhaXRGb3JSdW5UcmFuc2FjdGlvbihydW5NZXNzYWdlLCBwcm9jZXNzaW5nLCBwYXJlbnRTcGFuKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTU1KTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDEwMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTU2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJuYWxSdW5KcyhfeDk5LCBfeDEwMCkge1xuICAgICAgICByZXR1cm4gX2ludGVybmFsUnVuSnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGludGVybmFsUnVuSnM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWNjb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEFjY291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNTcoYWRkcmVzcywgYWN0aXZlLCB3YWl0UGFyYW1zLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBmaWx0ZXIsIGFjY291bnRzLCBhY2NvdW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1NyQoX2NvbnRleHQ1Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NTcucHJldiA9IF9jb250ZXh0NTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZmlsdGVyID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZXE6IGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHdhaXRQYXJhbXMgJiYgd2FpdFBhcmFtcy50cmFuc2FjdGlvbkx0KSB7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXIubGFzdF90cmFuc19sdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2U6IHdhaXRQYXJhbXMudHJhbnNhY3Rpb25MdFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXIuYWNjX3R5cGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVxOiBRQWNjb3VudFR5cGUuYWN0aXZlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZygnZ2V0QWNjb3VudC4gRmlsdGVyJywgZmlsdGVyKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDU3Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJpZXMuYWNjb3VudHMucXVlcnkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiAnaWQgYWNjX3R5cGUgYm9jIGNvZGVfaGFzaCBkYXRhX2hhc2ggYmFsYW5jZSBiYWxhbmNlX290aGVyIHsgY3VycmVuY3kgdmFsdWUgfSBsYXN0X3BhaWQnXG4gICAgICAgICAgICAgICAgfSwgd2FpdFBhcmFtcyAmJiB3YWl0UGFyYW1zLnRpbWVvdXQgPyB7XG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB3YWl0UGFyYW1zLnRpbWVvdXRcbiAgICAgICAgICAgICAgICB9IDoge30pLCB7fSwge1xuICAgICAgICAgICAgICAgICAgcGFyZW50U3BhbjogcGFyZW50U3BhblxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgYWNjb3VudHMgPSBfY29udGV4dDU3LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShhY2NvdW50cy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDU3Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTcudDAgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Ny50MSA9IGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Ny5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Ny50MiA9IF9jb250ZXh0NTcuc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDU3LnQwLmFjY291bnRNaXNzaW5nLmNhbGwoX2NvbnRleHQ1Ny50MCwgX2NvbnRleHQ1Ny50MSwgX2NvbnRleHQ1Ny50Mik7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gYWNjb3VudHNbMF07XG4gICAgICAgICAgICAgICAgcmVtb3ZlVHlwZU5hbWUoYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9nKCdnZXRBY2NvdW50LiBBY2NvdW50IHJlY2VpdmVkJywgYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTcuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRBY2NvdW50KF94MTAyLCBfeDEwMywgX3gxMDQsIF94MTA1KSB7XG4gICAgICAgIHJldHVybiBfZ2V0QWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0QWNjb3VudDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJpbnRlcm5hbFJ1bkxvY2FsSnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9pbnRlcm5hbFJ1bkxvY2FsSnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNTgocGFyYW1zLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBhZGRyZXNzLCBhY2NvdW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1OCQoX2NvbnRleHQ1OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NTgucHJldiA9IF9jb250ZXh0NTgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHBhcmFtcy5hZGRyZXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NTgubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDU4LnQwID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTgubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OC50MSA9IF9jb250ZXh0NTguc2VudDtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTgudDAuYWRkcmVzc1JlcXVpcmVkRm9yUnVuTG9jYWwuY2FsbChfY29udGV4dDU4LnQwLCBfY29udGV4dDU4LnQxKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OC50MiA9IHBhcmFtcy5hY2NvdW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0NTgudDIpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NTgubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudChhZGRyZXNzLCBmYWxzZSwgcGFyYW1zLndhaXRQYXJhbXMsIHBhcmVudFNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OC50MiA9IF9jb250ZXh0NTguc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGFjY291bnQgPSBfY29udGV4dDU4LnQyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnQuY29kZV9oYXNoKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDU4Lm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTgudDMgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OC50NCA9IGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OC50NSA9IGFjY291bnQuYmFsYW5jZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDU4Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUVycm9yRGF0YSh7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fbmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OC50NiA9IF9jb250ZXh0NTguc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDU4LnQzLmFjY291bnRDb2RlTWlzc2luZy5jYWxsKF9jb250ZXh0NTgudDMsIF9jb250ZXh0NTgudDQsIF9jb250ZXh0NTgudDUsIF9jb250ZXh0NTgudDYpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTguYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NvbnRyYWN0cy5ydW4ubG9jYWwnLCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgIGFiaTogcGFyYW1zLmFiaSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXlQYWlyOiBwYXJhbXMua2V5UGFpcixcbiAgICAgICAgICAgICAgICAgIGZ1bGxSdW46IHBhcmFtcy5mdWxsUnVuXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1OC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBpbnRlcm5hbFJ1bkxvY2FsSnMoX3gxMDYsIF94MTA3KSB7XG4gICAgICAgIHJldHVybiBfaW50ZXJuYWxSdW5Mb2NhbEpzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnRlcm5hbFJ1bkxvY2FsSnM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJuYWxSdW5NZXNzYWdlTG9jYWxKc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ludGVybmFsUnVuTWVzc2FnZUxvY2FsSnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNTkocGFyYW1zLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBhZGRyZXNzLCBhY2NvdW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1OSQoX2NvbnRleHQ1OSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NTkucHJldiA9IF9jb250ZXh0NTkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHBhcmFtcy5hZGRyZXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NTkubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDU5LnQwID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTkubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OS50MSA9IF9jb250ZXh0NTkuc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDU5LnQwLmFkZHJlc3NSZXF1aXJlZEZvclJ1bkxvY2FsLmNhbGwoX2NvbnRleHQ1OS50MCwgX2NvbnRleHQ1OS50MSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTkudDIgPSBwYXJhbXMuYWNjb3VudDtcblxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDU5LnQyKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDU5Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTkubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjY291bnQoYWRkcmVzcywgZmFsc2UsIHBhcmFtcy53YWl0UGFyYW1zLCBwYXJlbnRTcGFuKTtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTkudDIgPSBfY29udGV4dDU5LnNlbnQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gX2NvbnRleHQ1OS50MjtcblxuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LmNvZGVfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1OS5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDU5LnQzID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTkudDQgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTkudDUgPSBhY2NvdW50LmJhbGFuY2U7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OS5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NTkudDYgPSBfY29udGV4dDU5LnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ1OS50My5hY2NvdW50Q29kZU1pc3NpbmcuY2FsbChfY29udGV4dDU5LnQzLCBfY29udGV4dDU5LnQ0LCBfY29udGV4dDU5LnQ1LCBfY29udGV4dDU5LnQ2KTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU5LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjb250cmFjdHMucnVuLmxvY2FsLm1zZycsIHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgYWJpOiBwYXJhbXMuYWJpLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZUJhc2U2NDogcGFyYW1zLm1lc3NhZ2VCb2R5QmFzZTY0LFxuICAgICAgICAgICAgICAgICAgZnVsbFJ1bjogcGFyYW1zLmZ1bGxSdW5cbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1OSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGludGVybmFsUnVuTWVzc2FnZUxvY2FsSnMoX3gxMDgsIF94MTA5KSB7XG4gICAgICAgIHJldHVybiBfaW50ZXJuYWxSdW5NZXNzYWdlTG9jYWxKcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJuYWxSdW5NZXNzYWdlTG9jYWxKcztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJpbnRlcm5hbFNpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9pbnRlcm5hbFNpZ24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNjAodW5zaWduZWQsIHNvdXJjZSkge1xuICAgICAgICB2YXIgbWVzc2FnZSwgYm94LCBrZXlzLCBzaWduS2V5cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNjAkKF9jb250ZXh0NjApIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYwLnByZXYgPSBfY29udGV4dDYwLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICBiYXNlNjQ6IHVuc2lnbmVkLmJ5dGVzVG9TaWduQmFzZTY0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBib3ggPSBzb3VyY2UuYm94O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFib3gpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NjAubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2MC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94LnNpZ24obWVzc2FnZSwgX1RPTkNyeXB0b01vZHVsZS5UT05PdXRwdXRFbmNvZGluZy5CYXNlNjQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYwLnQwID0gX2NvbnRleHQ2MC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjAubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveC5nZXRQdWJsaWNLZXkoKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2MC50MSA9IF9jb250ZXh0NjAuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2MC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgc2lnbkJ5dGVzQmFzZTY0OiBfY29udGV4dDYwLnQwLFxuICAgICAgICAgICAgICAgICAgcHVibGljS2V5SGV4OiBfY29udGV4dDYwLnQxXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBrZXlzID0gc291cmNlLmtleXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWtleXMpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NjAubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2MC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvLm5hY2xTaWduS2V5cGFpckZyb21TZWNyZXRLZXkoa2V5cy5zZWNyZXQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgc2lnbktleXMgPSBfY29udGV4dDYwLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2MC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvLm5hY2xTaWduRGV0YWNoZWQobWVzc2FnZSwgc2lnbktleXMuc2VjcmV0LCBfVE9OQ3J5cHRvTW9kdWxlLlRPTk91dHB1dEVuY29kaW5nLkJhc2U2NCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYwLnQyID0gX2NvbnRleHQ2MC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjAudDMgPSBzaWduS2V5c1tcInB1YmxpY1wiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2MC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgc2lnbkJ5dGVzQmFzZTY0OiBfY29udGV4dDYwLnQyLFxuICAgICAgICAgICAgICAgICAgcHVibGljS2V5SGV4OiBfY29udGV4dDYwLnQzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICB0aHJvdyBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3Iuc2lnbmluZ1NvdXJjZUlzTm90U3BlY2lmaWVkKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2MCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGludGVybmFsU2lnbihfeDExMCwgX3gxMTEpIHtcbiAgICAgICAgcmV0dXJuIF9pbnRlcm5hbFNpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGludGVybmFsU2lnbjtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBUT05Db250cmFjdHNNb2R1bGU7XG59KF9UT05Nb2R1bGUyLlRPTk1vZHVsZSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVE9OQ29udHJhY3RzTW9kdWxlO1xuVE9OQ29udHJhY3RzTW9kdWxlLm1vZHVsZU5hbWUgPSAnVE9OQ29udHJhY3RzTW9kdWxlJztcbnZhciBCTE9DS19GSUVMRFMgPSBcIlxcbiAgICBpZFxcbiAgICBnZW5fdXRpbWVcXG4gICAgYWZ0ZXJfc3BsaXRcXG4gICAgd29ya2NoYWluX2lkXFxuICAgIHNoYXJkXFxuICAgIGluX21zZ19kZXNjciB7XFxuICAgICAgICBtc2dfaWRcXG4gICAgICAgIHRyYW5zYWN0aW9uX2lkXFxuICAgIH1cXG5cIjtcbnZhciBUUkFOU0FDVElPTl9GSUVMRFNfT1JESU5BUlkgPSBcIlxcbiAgICBpZFxcbiAgICBhYm9ydGVkXFxuICAgIGNvbXB1dGUge1xcbiAgICAgICAgc2tpcHBlZF9yZWFzb25cXG4gICAgICAgIGV4aXRfY29kZVxcbiAgICAgICAgc3VjY2Vzc1xcbiAgICAgICAgZ2FzX2ZlZXNcXG4gICAgfVxcbiAgICBzdG9yYWdlIHtcXG4gICAgICAgc3RhdHVzX2NoYW5nZVxcbiAgICAgICBzdG9yYWdlX2ZlZXNfY29sbGVjdGVkXFxuICAgIH1cXG4gICAgYWN0aW9uIHtcXG4gICAgICAgIHN1Y2Nlc3NcXG4gICAgICAgIHZhbGlkXFxuICAgICAgICBub19mdW5kc1xcbiAgICAgICAgcmVzdWx0X2NvZGVcXG4gICAgICAgIHRvdGFsX2Z3ZF9mZWVzXFxuICAgICAgICB0b3RhbF9hY3Rpb25fZmVlc1xcbiAgICB9XFxuICAgIGluX21zZ1xcbiAgICBub3dcXG4gICAgb3V0X21zZ3NcXG4gICAgb3V0X21lc3NhZ2VzIHtcXG4gICAgICAgIGlkXFxuICAgICAgICBib2R5XFxuICAgICAgICBtc2dfdHlwZVxcbiAgICAgICAgdmFsdWVcXG4gICAgfVxcbiAgICBzdGF0dXNcXG4gICAgdG90YWxfZmVlc1xcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5dGIyUjFiR1Z6TDFSUFRrTnZiblJ5WVdOMGMwMXZaSFZzWlM1cWN5SmRMQ0p1WVcxbGN5STZXeUpVVDA1QlpHUnlaWE56VTNSeWFXNW5WbUZ5YVdGdWRDSXNJa0ZqWTI5MWJuUkpaQ0lzSWtobGVDSXNJa0poYzJVMk5DSXNJbFJQVGtOc2FXVnVkRlJ5WVc1ellXTjBhVzl1VUdoaGMyVWlMQ0p6ZEc5eVlXZGxJaXdpWTI5dGNIVjBaVk5yYVhCd1pXUWlMQ0pqYjIxd2RYUmxWbTBpTENKaFkzUnBiMjRpTENKMWJtdHViM2R1SWl3aVZFOU9RMnhwWlc1MFEyOXRjSFYwWlZOcmFYQndaV1JUZEdGMGRYTWlMQ0p1YjFOMFlYUmxJaXdpWW1Ga1UzUmhkR1VpTENKdWIwZGhjeUlzSWxSUFRrTnNhV1Z1ZEZOMGIzSmhaMlZUZEdGMGRYTWlMQ0oxYm1Ob1lXNW5aV1FpTENKbWNtOTZaVzRpTENKa1pXeGxkR1ZrSWl3aVVVbHVUWE5uVkhsd1pTSXNJbVY0ZEdWeWJtRnNJaXdpYVdoeUlpd2lhVzF0WldScFlYUmxiSGtpTENKMGNtRnVjMmwwSWl3aVpHbHpZMkZ5WkdWa1JtbHVZV3dpTENKa2FYTmpZWEprWldSVWNtRnVjMmwwSWl3aVVVOTFkRTF6WjFSNWNHVWlMQ0p2ZFhSTmMyZE9aWGNpTENKa1pYRjFaWFZsU1cxdFpXUnBZWFJsYkhraUxDSmtaWEYxWlhWbElpd2lkSEpoYm5OcGRGSmxjWFZwY21Wa0lpd2libTl1WlNJc0lsRk5aWE56WVdkbFZIbHdaU0lzSW1sdWRHVnlibUZzSWl3aVpYaDBTVzRpTENKbGVIUlBkWFFpTENKUlRXVnpjMkZuWlZCeWIyTmxjM05wYm1kVGRHRjBkWE1pTENKeGRXVjFaV1FpTENKd2NtOWpaWE56YVc1bklpd2ljSEpsYkdsdGFXNWhjbmtpTENKd2NtOXdiM05sWkNJc0ltWnBibUZzYVhwbFpDSXNJbkpsWm5WelpXUWlMQ0owY21GdWMybDBhVzVuSWl3aVVVSnNiMk5yVUhKdlkyVnpjMmx1WjFOMFlYUjFjeUlzSWxGVGNHeHBkRlI1Y0dVaUxDSnpjR3hwZENJc0ltMWxjbWRsSWl3aVVVRmpZMjkxYm5SVWVYQmxJaXdpZFc1cGJtbDBJaXdpWVdOMGFYWmxJaXdpVVZSeVlXNXpZV04wYVc5dVZIbHdaU0lzSW05eVpHbHVZWEo1SWl3aWRHbGpheUlzSW5Sdlkyc2lMQ0p6Y0d4cGRGQnlaWEJoY21VaUxDSnpjR3hwZEVsdWMzUmhiR3dpTENKdFpYSm5aVkJ5WlhCaGNtVWlMQ0p0WlhKblpVbHVjM1JoYkd3aUxDSlJWSEpoYm5OaFkzUnBiMjVRY205alpYTnphVzVuVTNSaGRIVnpJaXdpVVVGalkyOTFiblJUZEdGMGRYTWlMQ0p1YjI1RmVHbHpkQ0lzSWxGQlkyTnZkVzUwVTNSaGRIVnpRMmhoYm1kbElpd2lVVU52YlhCMWRHVlVlWEJsSWl3aWMydHBjSEJsWkNJc0luWnRJaXdpVVZOcmFYQlNaV0Z6YjI0aUxDSlJRbTkxYm1ObFZIbHdaU0lzSW01bFowWjFibVJ6SWl3aWJtOUdkVzVrY3lJc0ltOXJJaXdpVFVGVFZFVlNRMGhCU1U1ZlNVUWlMQ0p5WlcxdmRtVlVlWEJsVG1GdFpTSXNJbTlpYWlJc0lsOWZkSGx3Wlc1aGJXVWlMQ0pQWW1wbFkzUWlMQ0oyWVd4MVpYTWlMQ0ptYjNKRllXTm9JaXdpZG1Gc2RXVWlMQ0p5WlcxdmRtVlFjbTl3Y3lJc0luQmhkR2h6SWl3aWNtVnpkV3gwSWl3aWNHRjBhQ0lzSW1SdmRGQnZjeUlzSW1sdVpHVjRUMllpTENKdVlXMWxJaXdpYzNWaWMzUnlJaXdpWTJocGJHUWlMQ0p5WldSMVkyVmtRMmhwYkdRaUxDSnpkR0Z5ZEUxbGMzTmhaMlZVY21GalpWTndZVzRpTENKMGNtRmpaWElpTENKdFpYTnpZV2RsU1dRaUxDSnZjR1Z5WVhScGIyNU9ZVzFsSWl3aWRHRm5jeUlzSW5SeVlXTmxTV1FpTENKemNHRnVTV1FpTENKeWIyOTBRMjl1ZEdWNGRDSXNJbVY0ZEhKaFkzUWlMQ0pHVDFKTlFWUmZWRVZZVkY5TlFWQWlMQ0p6ZEdGeWRGTndZVzRpTENKamFHbHNaRTltSWl3aWRISmhZMlZOWlhOellXZGxJaXdpYzNCaGJpSXNJbVpwYm1semFDSXNJbWRsZEZOcFoyNXBibWRUYjNWeVkyVWlMQ0ppYjNnaUxDSnJaWGx6SWl3aVoyVjBVSFZpYkdsalMyVjVJaXdpYzJWamNtVjBJaXdpVkU5T1EyOXVkSEpoWTNSelRXOWtkV3hsSWl3aVkyOXVabWxuSWl3aVkyOXVkR1Y0ZENJc0ltZGxkRTF2WkhWc1pTSXNJbFJQVGtOdmJtWnBaMDF2WkhWc1pTSXNJbkYxWlhKcFpYTWlMQ0pVVDA1UmRXVnlhV1Z6VFc5a2RXeGxJaXdpWTNKNWNIUnZJaXdpVkU5T1EzSjVjSFJ2VFc5a2RXeGxJaXdpY0dGeVlXMXpJaXdpY0dGeVpXNTBVM0JoYmlJc0ltRmpZMjkxYm5Seklpd2ljWFZsY25raUxDSm1hV3gwWlhJaUxDSnBaQ0lzSW1WeElpd2lZV1JrY21WemN5SXNJbXhsYm1kMGFDSXNJbUpoYkdGdVkyVkhjbUZ0Y3lJc0ltSmhiR0Z1WTJVaUxDSjBjbUZqWlNJc0luTmxkRlJoWnlJc0ltbHVkR1Z5Ym1Gc1JHVndiRzk1U25NaUxDSnBiblJsY201aGJGSjFia3B6SWl3aWFXNTBaWEp1WVd4U2RXNU1iMk5oYkVweklpd2lhVzUwWlhKdVlXeFNkVzVOWlhOellXZGxURzlqWVd4S2N5SXNJbU52Y21WUVlYSmhiWE1pTENKb1lYTkRiMlJsSWl3aVltOWpRbUZ6WlRZMElpd2lZMjlrWlVKaGMyVTJOQ0lzSW1SaGRHRkNZWE5sTmpRaUxDSlVUMDVEYkdsbGJuUkZjbkp2Y2lJc0ltTnZiWEJzWlhSbFJYSnliM0pFWVhSaElpd2lZV1JrY21WemMxSmxjWFZwY21Wa1JtOXlVblZ1VEc5allXd2lMQ0puWlhSQlkyTnZkVzUwSWl3aWRHbHRaVzkxZENJc0luZGhhWFJHYjNKVWFXMWxiM1YwSWl3aVlXTmpiM1Z1ZENJc0ltTnZaR1ZmYUdGemFDSXNJbUZqWTI5MWJuUkRiMlJsVFdsemMybHVaeUlzSW5CaGNtRnRjMFp5YjIxQlkyTnZkVzUwSWl3aVltOWpJaXdpYkdGemRGOXdZV2xrSWl3aWNtVnhkV1Z6ZEVOdmNtVWlMQ0pqYjI1eklpd2lhWFJsYlNJc0ltbHVkbUZzYVdSRGIyNXpJaXdpWlcxd2RIbFVUMDVGY25KdmNrUmhkR0VpTENKd2RYTm9JaXdpY21WMGNubEpibVJsZUNJc0lteHZaeUlzSW5OcFoyNXBibWRDYjNnaUxDSnJaWGxRWVdseUlpd2ljMjkxY21ObElpd2lZM0psWVhSbFZXNXphV2R1WldSRVpYQnNiM2xOWlhOellXZGxJaXdpZFc1emFXZHVaV1JOWlhOellXZGxJaXdpYVc1MFpYSnVZV3hUYVdkdUlpd2ljMmxuYmxCaGNtRnRjeUlzSW1OeVpXRjBaVk5wWjI1bFpFUmxjR3h2ZVUxbGMzTmhaMlVpTENKaFlta2lMQ0pqYjI1emRISjFZM1J2Y2tobFlXUmxjaUlzSW1OdmJuTjBjblZqZEc5eVVHRnlZVzF6SWl3aWFXNXBkRkJoY21GdGN5SXNJbWx0WVdkbFFtRnpaVFkwSWl3aWQyOXlhMk5vWVdsdVNXUWlMQ0p0WlhOellXZGxJaXdpWTNKbFlYUmxWVzV6YVdkdVpXUlNkVzVOWlhOellXZGxJaXdpWTNKbFlYUmxVMmxuYm1Wa1VuVnVUV1Z6YzJGblpTSXNJbVoxYm1OMGFXOXVUbUZ0WlNJc0ltaGxZV1JsY2lJc0luUnllVWx1WkdWNElpd2lhVzV3ZFhRaUxDSndkV0pzYVdOTFpYbElaWGdpTENKaFpHUnlaWE56U0dWNElpd2laVzVqYjJSbFpDSXNJbWx1WTJ4MVpHVnpJaXdpY0hWaWEyVjVJaXdpWTNKbFlYUmxVMmxuYm1Wa1RXVnpjMkZuWlNJc0luVnVjMmxuYm1Wa1FubDBaWE5DWVhObE5qUWlMQ0p6YVdkdVFubDBaWE5DWVhObE5qUWlMQ0psZUhCcGNtVWlMQ0puWlhSQ2IyTklZWE5vSWl3aWJXVnpjMkZuWlVKdlpIbENZWE5sTmpRaUxDSm9ZWE5vSWl3aVJHRjBaU0lzSW01dmR5SXNJbTFsYzNOaFoyVmZhV1FpTENKelpXNWtUbTlrWlZKbGNYVmxjM1JHWVdsc1pXUWlMQ0pOWVhSb0lpd2ljMlZ5ZG1WeVZHbHRaVVJsYkhSaElpd2lZV0p6SWl3aWIzVjBUMlpUZVc1alZHaHlaWE5vYjJ4a0lpd2laSEp2Y0ZObGNuWmxjbFJwYldWRVpXeDBZU0lzSW1Oc2IyTnJUM1YwVDJaVGVXNWpJaXdpWm1sdVpFeGhjM1JUYUdGeVpFSnNiMk5ySWl3aWJHRnpkRUpzYjJOclNXUWlMQ0psYm5OMWNtVk5aWE56WVdkbFNXUWlMQ0pwWkVKaGMyVTJOQ0lzSWtKMVptWmxjaUlzSW1aeWIyMGlMQ0owYjFOMGNtbHVaeUlzSW0xbGMzTmhaMlZUY0dGdUlpd2ljM1JoY25SU2IyOTBVM0JoYmlJc0ltRmtaRlJoWjNNaUxDSnRaWE56WVdkbFUybDZaU0lzSW1ObGFXd2lMQ0p3YjNOMFVtVnhkV1Z6ZEhNaUxDSmliMlI1SWl3aWMyVnVaR2x1WjFScGJXVWlMQ0p5YjNWdVpDSXNJbkpsYzNWc2RFWnBaV3hrY3lJc0luTmxibVJOWlhOellXZGxJaXdpZDJGcGRFWnZjbFJ5WVc1ellXTjBhVzl1SWl3aWJXVnpjMkZuWlZCeWIyTmxjM05wYm1kVGRHRjBaU0lzSW5SeVlXNXpZV04wYVc5dUlpd2lZMmhoYVc0aUxDSmhaR1JwZEdsdmJtRnNSbWxzZEdWeUlpd2lZbXh2WTJ0eklpd2lkMjl5YTJOb1lXbHVYMmxrSWl3aWIzSmtaWEpDZVNJc0ltUnBjbVZqZEdsdmJpSXNJbXhwYldsMElpd2ljMmhoY21Seklpd2lZV1JrY21WemMxQmhjblJ6SWl3aWQyOXlhMk5vWVdsdUlpd2lUblZ0WW1WeUlpd2ljR0Z5YzJWSmJuUWlMQ0ptYVc1a1RHRnpkRUpzYjJOcklpd2liV0Z6ZEdWeVkyaGhhVzVNWVhOMFFteHZZMnNpTENKdWIwSnNiMk5yY3lJc0luZHZjbXRqYUdGcGJreGhjM1JDYkc5amF5SXNJbUZtZEdWeVgyMWxjbWRsSWl3aWMyaGhjbVFpTENKcGJuWmhiR2xrUW14dlkydGphR0ZwYmlJc0ltMWhjM1JsY2lJc0luTm9ZWEprWDJoaGMyaGxjeUlzSW1acGJtUk5ZWFJqYUdsdVoxTm9ZWEprSWl3aWMyaGhjbVJDYkc5amF5SXNJbkp2YjNSZmFHRnphQ0lzSW1SbGMyTnlJaXdpWW14dlkyc2lMQ0pqZFhKeVpXNTBJaXdpZDJGcGRFWnZjaUlzSW5CeVpYWmZjbVZtSWl3aVQxSWlMQ0p3Y21WMlgyRnNkRjl5WldZaUxDSkNURTlEUzE5R1NVVk1SRk1pTENKaFpuUmxjbDl6Y0d4cGRDSXNJbU5vWldOclUyaGhjbVJOWVhSamFDSXNJbTVsSWl3aWRHOTBZV3hUZEdGeWRDSXNJblJwYldWU1pYQnZjblFpTENKemRHOXdWR2x0WlNJc0ltMWxjM05oWjJWUWNtOWpaWE56YVc1blZHbHRaVzkxZENJc0ltbHVabWx1YVhSbFYyRnBkQ0lzSW1Ga1pGUnBiV1Z2ZFhRaUxDSnRZWGdpTENKemRHRnlkQ0lzSW5kaGFYUk9aWGgwUW14dlkyc2lMQ0psYm1RaUxDSm5aVzVmZFhScGJXVWlMQ0p5WlhOdmJIWmxaRVZ5Y205eUlpd2lZMjlrWlNJc0lsUlBUa1Z5Y205eVEyOWtaU0lzSWxkQlNWUmZSazlTWDFSSlRVVlBWVlFpTENKaWJHOWphMTlwWkNJc0ltMWxjM05oWjJWZmNISnZZMlZ6YzJsdVoxOXpkR0YwWlNJc0luTmxibVJwYm1kZmRHbHRaU0lzSW01bGRIZHZjbXRUYVd4bGJuUWlMQ0pwYmsxelp5SXNJbWx1WDIxeloxOWtaWE5qY2lJc0ltWnBibVFpTENKNElpd2liWE5uWDJsa0lpd2lkSEpoYm5OaFkzUnBiMjVKWkNJc0luUnlZVzV6WVdOMGFXOXVYMmxrSWl3aWRISlRkR0Z5ZENJc0luUnlZVzV6WVdOMGFXOXVjeUlzSWxSU1FVNVRRVU5VU1U5T1gwWkpSVXhFVTE5UFVrUkpUa0ZTV1NJc0lrMUJXRjlVU1UxRlQxVlVJaXdpWW14dlkydGZkR2x0WlNJc0ltMWxjM05oWjJWRmVIQnBjbVZrSWl3aWRISmhibk5oWTNScGIyNVhZV2wwVkdsdFpXOTFkQ0lzSW5Od2JHbGpaU0lzSW1wdmFXNGlMQ0pOUlZOVFFVZEZYMFZZVUVsU1JVUWlMQ0pVVWtGT1UwRkRWRWxQVGw5WFFVbFVYMVJKVFVWUFZWUWlMQ0p5WlhOdmJIWmxSR1YwWVdsc1pXUkZjbkp2Y2lJc0luQnliMk5sYzNOVWNtRnVjMkZqZEdsdmJpSXNJbTl5YVdkcGJtRnNYMlZ5Y205eUlpd2lablZ1WTNScGIyNWZibUZ0WlNJc0ltRmpZMjkxYm5STmFYTnphVzVuSWl3aVpYSnliM0lpTENKdFpYTnpZV2RsUW1GelpUWTBJaXdpZEdsdFpTSXNJbTFoYVc1RmNuSnZjaUlzSW1GalkxOTBlWEJsSWl3aWFYTkVaWEJzYjNsbFpDSXNJbUZzY21WaFpIbEVaWEJzYjNsbFpDSXNJbmRoYVhSR2IzSkVaWEJzYjNsVWNtRnVjMkZqZEdsdmJpSXNJbVJsY0d4dmVVMWxjM05oWjJVaUxDSnlkVzVOWlhOellXZGxJaXdpZDJGcGRFWnZjbEoxYmxSeVlXNXpZV04wYVc5dUlpd2lkMkZwZEZCaGNtRnRjeUlzSW1WdGRXeGhkR1ZDWVd4aGJtTmxJaXdpWW1sblFtRnNZVzVqWlNJc0ltTnlaV0YwWlVSbGNHeHZlVTFsYzNOaFoyVWlMQ0pqWVd4alRYTm5VSEp2WTJWemMwWmxaWE1pTENKdVpYZEJZMk52ZFc1MElpd2labXh2YjNJaUxDSmpZV3hzSWl3aWNtVjBjbWxsYzBOdmRXNTBJaXdpYldWemMyRm5aVkpsZEhKcFpYTkRiM1Z1ZENJc0lta2lMQ0pwYzA5eWFXZHBibUZzVDNKU1pYTnZiSFpsWkNJc0ltVjRhWFJEYjJSbElpd2lhWE5QY21sbmFXNWhiRU52Ym5SeVlXTjBSWEp5YjNJaUxDSnBjMUpsYzI5c2RtVmtRMjl1ZEhKaFkzUkZjbkp2Y2tGbWRHVnlSWGh3YVhKbElpd2lkWE5sVW1WMGNua2lMQ0pVVDA1RGIyNTBjbUZqZEVWNGFYUkRiMlJsSWl3aVVrVlFURUZaWDFCU1QxUkZRMVJKVDA0aUxDSnBiblJsY201aGJFVnljbTl5SWl3aWNtVjBjbmxEWVd4c0lpd2lZM0psWVhSbFVuVnVUV1Z6YzJGblpTSXNJblJ5WVc1ellXTjBhVzl1VEhRaUxDSnNZWE4wWDNSeVlXNXpYMngwSWl3aVoyVWlMQ0ptZFd4c1VuVnVJaXdpZFc1emFXZHVaV1FpTENKaVlYTmxOalFpTENKaWVYUmxjMVJ2VTJsbmJrSmhjMlUyTkNJc0luTnBaMjRpTENKVVQwNVBkWFJ3ZFhSRmJtTnZaR2x1WnlJc0ltNWhZMnhUYVdkdVMyVjVjR0ZwY2taeWIyMVRaV055WlhSTFpYa2lMQ0p6YVdkdVMyVjVjeUlzSW01aFkyeFRhV2R1UkdWMFlXTm9aV1FpTENKemFXZHVhVzVuVTI5MWNtTmxTWE5PYjNSVGNHVmphV1pwWldRaUxDSlVUMDVOYjJSMWJHVWlMQ0p0YjJSMWJHVk9ZVzFsSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPMEZCUzBFN08wRkJlVVJCT3p0QlFVTkJPenRCUVVOQk96dEJRVU5CT3p0QlFVTkJPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzBGQlJVOHNTVUZCVFVFc2RVSkJRWFZDTEVkQlFVYzdRVUZEYmtORExFVkJRVUZCTEZOQlFWTXNSVUZCUlN4WFFVUjNRanRCUVVWdVEwTXNSVUZCUVVFc1IwRkJSeXhGUVVGRkxFdEJSamhDTzBGQlIyNURReXhGUVVGQlFTeE5RVUZOTEVWQlFVVTdRVUZJTWtJc1EwRkJhRU03TzBGQlRVRXNTVUZCVFVNc2VVSkJRWGxDTEVkQlFVYzdRVUZEY2tORExFVkJRVUZCTEU5QlFVOHNSVUZCUlN4VFFVUTBRanRCUVVWeVEwTXNSVUZCUVVFc1kwRkJZeXhGUVVGRkxHZENRVVp4UWp0QlFVZHlRME1zUlVGQlFVRXNVMEZCVXl4RlFVRkZMRmRCU0RCQ08wRkJTWEpEUXl4RlFVRkJRU3hOUVVGTkxFVkJRVVVzVVVGS05rSTdRVUZMY2tORExFVkJRVUZCTEU5QlFVOHNSVUZCUlR0QlFVdzBRaXhEUVVGc1F6czdRVUZSUVN4SlFVRk5ReXcyUWtGQk5rSXNSMEZCUnp0QlFVTjZRME1zUlVGQlFVRXNUMEZCVHl4RlFVRkZMRU5CUkdkRE8wRkJSWHBEUXl4RlFVRkJRU3hSUVVGUkxFVkJRVVVzUTBGR0swSTdRVUZIZWtORExFVkJRVUZCTEV0QlFVc3NSVUZCUlR0QlFVaHJReXhEUVVGMFF6czdRVUZOUVN4SlFVRk5ReXh6UWtGQmMwSXNSMEZCUnp0QlFVTnNRME1zUlVGQlFVRXNVMEZCVXl4RlFVRkZMRU5CUkhWQ08wRkJSV3hEUXl4RlFVRkJRU3hOUVVGTkxFVkJRVVVzUTBGR01FSTdRVUZIYkVORExFVkJRVUZCTEU5QlFVOHNSVUZCUlR0QlFVaDVRaXhEUVVFdlFqczdRVUZOUVN4SlFVRk5ReXhWUVVGVkxFZEJRVWM3UVVGRGRFSkRMRVZCUVVGQkxGRkJRVkVzUlVGQlJTeERRVVJaTzBGQlJYUkNReXhGUVVGQlFTeEhRVUZITEVWQlFVVXNRMEZHYVVJN1FVRkhkRUpETEVWQlFVRkJMRmRCUVZjc1JVRkJSU3hEUVVoVE8wRkJTWFJDTEZkQlFVOHNRMEZLWlR0QlFVdDBRa01zUlVGQlFVRXNUMEZCVHl4RlFVRkZMRU5CVEdFN1FVRk5kRUpETEVWQlFVRkJMR05CUVdNc1JVRkJSU3hEUVU1Tk8wRkJUM1JDUXl4RlFVRkJRU3huUWtGQlowSXNSVUZCUlR0QlFWQkpMRU5CUVc1Q096dEJRVlZCTEVsQlFVMURMRmRCUVZjc1IwRkJSenRCUVVOMlFrNHNSVUZCUVVFc1VVRkJVU3hGUVVGRkxFTkJSR0U3UVVGRmRrSkZMRVZCUVVGQkxGZEJRVmNzUlVGQlJTeERRVVpWTzBGQlIzWkNTeXhGUVVGQlFTeFRRVUZUTEVWQlFVVXNRMEZJV1R0QlFVbDJRa29zUlVGQlFVRXNUMEZCVHl4RlFVRkZMRU5CU21NN1FVRkxka0pMTEVWQlFVRkJMR3RDUVVGclFpeEZRVUZGTEVOQlRFYzdRVUZOZGtKRExFVkJRVUZCTEU5QlFVOHNSVUZCUlN4RFFVNWpPMEZCVDNaQ1F5eEZRVUZCUVN4bFFVRmxMRVZCUVVVc1EwRlFUVHRCUVZGMlFrTXNSVUZCUVVFc1NVRkJTU3hGUVVGRkxFTkJRVU03UVVGU1owSXNRMEZCY0VJN08wRkJWMEVzU1VGQlRVTXNXVUZCV1N4SFFVRkhPMEZCUTNoQ1F5eEZRVUZCUVN4UlFVRlJMRVZCUVVVc1EwRkVZenRCUVVWNFFrTXNSVUZCUVVFc1MwRkJTeXhGUVVGRkxFTkJSbWxDTzBGQlIzaENReXhGUVVGQlFTeE5RVUZOTEVWQlFVVTdRVUZJWjBJc1EwRkJja0k3TzBGQlRVRXNTVUZCVFVNc2QwSkJRWGRDTEVkQlFVYzdRVUZEY0VNeFFpeEZRVUZCUVN4UFFVRlBMRVZCUVVVc1EwRkVNa0k3UVVGRmNFTXlRaXhGUVVGQlFTeE5RVUZOTEVWQlFVVXNRMEZHTkVJN1FVRkhjRU5ETEVWQlFVRkJMRlZCUVZVc1JVRkJSU3hEUVVoM1FqdEJRVWx3UTBNc1JVRkJRVUVzVjBGQlZ5eEZRVUZGTEVOQlNuVkNPMEZCUzNCRFF5eEZRVUZCUVN4UlFVRlJMRVZCUVVVc1EwRk1NRUk3UVVGTmNFTkRMRVZCUVVGQkxGTkJRVk1zUlVGQlJTeERRVTU1UWp0QlFVOXdRME1zUlVGQlFVRXNUMEZCVHl4RlFVRkZMRU5CVURKQ08wRkJVWEJEUXl4RlFVRkJRU3hWUVVGVkxFVkJRVVU3UVVGU2QwSXNRMEZCYWtNN08wRkJWMEVzU1VGQlRVTXNjMEpCUVhOQ0xFZEJRVWM3UVVGRGJFTnNReXhGUVVGQlFTeFBRVUZQTEVWQlFVVXNRMEZFZVVJN1FVRkZiRU00UWl4RlFVRkJRU3hSUVVGUkxFVkJRVVVzUTBGR2QwSTdRVUZIYkVORExFVkJRVUZCTEZOQlFWTXNSVUZCUlN4RFFVaDFRanRCUVVsc1EwTXNSVUZCUVVFc1QwRkJUeXhGUVVGRk8wRkJTbmxDTEVOQlFTOUNPenRCUVU5QkxFbEJRVTFITEZWQlFWVXNSMEZCUnp0QlFVTjBRbVFzUlVGQlFVRXNTVUZCU1N4RlFVRkZMRU5CUkdkQ08wRkJSWFJDWlN4RlFVRkJRU3hMUVVGTExFVkJRVVVzUTBGR1pUdEJRVWQwUWtNc1JVRkJRVUVzUzBGQlN5eEZRVUZGTzBGQlNHVXNRMEZCYmtJN08wRkJUVUVzU1VGQlRVTXNXVUZCV1N4SFFVRkhPMEZCUTNoQ1F5eEZRVUZCUVN4TlFVRk5MRVZCUVVVc1EwRkVaMEk3UVVGRmVFSkRMRVZCUVVGQkxFMUJRVTBzUlVGQlJTeERRVVpuUWp0QlFVZDRRbXBETEVWQlFVRkJMRTFCUVUwc1JVRkJSVHRCUVVoblFpeERRVUZ5UWpzN1FVRk5RU3hKUVVGTmEwTXNaMEpCUVdkQ0xFZEJRVWM3UVVGRE5VSkRMRVZCUVVGQkxGRkJRVkVzUlVGQlJTeERRVVJyUWp0QlFVVTFRamxETEVWQlFVRkJMRTlCUVU4c1JVRkJSU3hEUVVadFFqdEJRVWMxUWl0RExFVkJRVUZCTEVsQlFVa3NSVUZCUlN4RFFVaHpRanRCUVVrMVFrTXNSVUZCUVVFc1NVRkJTU3hGUVVGRkxFTkJTbk5DTzBGQlN6VkNReXhGUVVGQlFTeFpRVUZaTEVWQlFVVXNRMEZNWXp0QlFVMDFRa01zUlVGQlFVRXNXVUZCV1N4RlFVRkZMRU5CVG1NN1FVRlBOVUpETEVWQlFVRkJMRmxCUVZrc1JVRkJSU3hEUVZCak8wRkJVVFZDUXl4RlFVRkJRU3haUVVGWkxFVkJRVVU3UVVGU1l5eERRVUY2UWpzN1FVRlhRU3hKUVVGTlF5dzBRa0ZCTkVJc1IwRkJSenRCUVVONFEycEVMRVZCUVVGQkxFOUJRVThzUlVGQlJTeERRVVFyUWp0QlFVVjRRelpDTEVWQlFVRkJMRmRCUVZjc1JVRkJSU3hEUVVZeVFqdEJRVWQ0UTBNc1JVRkJRVUVzVVVGQlVTeEZRVUZGTEVOQlNEaENPMEZCU1hoRFF5eEZRVUZCUVN4VFFVRlRMRVZCUVVVc1EwRktOa0k3UVVGTGVFTkRMRVZCUVVGQkxFOUJRVThzUlVGQlJUdEJRVXdyUWl4RFFVRnlRenM3UVVGUlFTeEpRVUZOYTBJc1kwRkJZeXhIUVVGSE8wRkJRekZDV0N4RlFVRkJRU3hOUVVGTkxFVkJRVVVzUTBGRWEwSTdRVUZGTVVKRExFVkJRVUZCTEUxQlFVMHNSVUZCUlN4RFFVWnJRanRCUVVjeFFtcERMRVZCUVVGQkxFMUJRVTBzUlVGQlJTeERRVWhyUWp0QlFVa3hRalJETEVWQlFVRkJMRkZCUVZFc1JVRkJSVHRCUVVwblFpeERRVUYyUWpzN1FVRlBRU3hKUVVGTlF5eHZRa0ZCYjBJc1IwRkJSenRCUVVOb1F6bERMRVZCUVVGQkxGTkJRVk1zUlVGQlJTeERRVVJ4UWp0QlFVVm9RME1zUlVGQlFVRXNUVUZCVFN4RlFVRkZMRU5CUm5kQ08wRkJSMmhEUXl4RlFVRkJRU3hQUVVGUExFVkJRVVU3UVVGSWRVSXNRMEZCTjBJN08wRkJUVUVzU1VGQlRUWkRMRmxCUVZrc1IwRkJSenRCUVVONFFrTXNSVUZCUVVFc1QwRkJUeXhGUVVGRkxFTkJSR1U3UVVGRmVFSkRMRVZCUVVGQkxFVkJRVVVzUlVGQlJUdEJRVVp2UWl4RFFVRnlRanM3UVVGTFFTeEpRVUZOUXl4WFFVRlhMRWRCUVVjN1FVRkRka0owUkN4RlFVRkJRU3hQUVVGUExFVkJRVVVzUTBGRVl6dEJRVVYyUWtNc1JVRkJRVUVzVVVGQlVTeEZRVUZGTEVOQlJtRTdRVUZIZGtKRExFVkJRVUZCTEV0QlFVc3NSVUZCUlR0QlFVaG5RaXhEUVVGd1FqczdRVUZOUVN4SlFVRk5jVVFzVjBGQlZ5eEhRVUZITzBGQlEzWkNReXhGUVVGQlFTeFJRVUZSTEVWQlFVVXNRMEZFWVR0QlFVVjJRa01zUlVGQlFVRXNUMEZCVHl4RlFVRkZMRU5CUm1NN1FVRkhka0pETEVWQlFVRkJMRVZCUVVVc1JVRkJSVHRCUVVodFFpeERRVUZ3UWpzN1FVRk5VQ3hKUVVGTlF5eGpRVUZqTEVkQlFVY3NRMEZCUXl4RFFVRjRRanM3UVVGRlFTeFRRVUZUUXl4alFVRlVMRU5CUVhkQ1F5eEhRVUY0UWl4RlFVRnJRenRCUVVNNVFpeE5RVUZKUVN4SFFVRkhMRU5CUVVORExGVkJRVklzUlVGQmIwSTdRVUZEYUVJc1YwRkJUMFFzUjBGQlJ5eERRVUZEUXl4VlFVRllPMEZCUTBnN08wRkJRMFJETEVWQlFVRkJMRTFCUVUwc1EwRkJRME1zVFVGQlVDeERRVUZqU0N4SFFVRmtMRVZCUTB0SkxFOUJSRXdzUTBGRFlTeFZRVUZEUXl4TFFVRkVMRVZCUVZjN1FVRkRhRUlzVVVGQlNTeERRVUZETEVOQlFVTkJMRXRCUVVZc1NVRkJWeXhSUVVGUFFTeExRVUZRTEUxQlFXbENMRkZCUVdoRExFVkJRVEJETzBGQlEzUkRUaXhOUVVGQlFTeGpRVUZqTEVOQlFVTk5MRXRCUVVRc1EwRkJaRHRCUVVOSU8wRkJRMG9zUjBGTVREdEJRVTFJT3p0QlFVVk5MRk5CUVZORExGZEJRVlFzUTBGQmNVSk9MRWRCUVhKQ0xFVkJRVGhDVHl4TFFVRTVRaXhGUVVGdFJEdEJRVU4wUkN4TlFVRkpReXhOUVVGTkxFZEJRVWRTTEVkQlFXSTdRVUZEUVU4c1JVRkJRVUVzUzBGQlN5eERRVUZEU0N4UFFVRk9MRU5CUVdNc1ZVRkJRMHNzU1VGQlJDeEZRVUZWTzBGQlEzQkNMRkZCUVUxRExFMUJRVTBzUjBGQlIwUXNTVUZCU1N4RFFVRkRSU3hQUVVGTUxFTkJRV0VzUjBGQllpeERRVUZtT3p0QlFVTkJMRkZCUVVsRUxFMUJRVTBzUjBGQlJ5eERRVUZpTEVWQlFXZENPMEZCUTFvc1ZVRkJTVVFzU1VGQlNTeEpRVUZKUkN4TlFVRmFMRVZCUVc5Q08wRkJRMmhDUVN4UlFVRkJRU3hOUVVGTkxIRkNRVUZSUVN4TlFVRlNMRU5CUVU0N1FVRkRRU3hsUVVGUFFTeE5RVUZOTEVOQlFVTkRMRWxCUVVRc1EwRkJZanRCUVVOSU8wRkJRMG9zUzBGTVJDeE5RVXRQTzBGQlEwZ3NWVUZCVFVjc1NVRkJTU3hIUVVGSFNDeEpRVUZKTEVOQlFVTkpMRTFCUVV3c1EwRkJXU3hEUVVGYUxFVkJRV1ZJTEUxQlFXWXNRMEZCWWp0QlFVTkJMRlZCUVUxSkxFdEJRVXNzUjBGQlIwNHNUVUZCVFN4RFFVRkRTU3hKUVVGRUxFTkJRWEJDT3p0QlFVTkJMRlZCUVVsRkxFdEJRVW9zUlVGQlZ6dEJRVU5RTEZsQlFVMURMRmxCUVZrc1IwRkJSMVFzVjBGQlZ5eERRVUZEVVN4TFFVRkVMRVZCUVZFc1EwRkJRMHdzU1VGQlNTeERRVUZEU1N4TlFVRk1MRU5CUVZsSUxFMUJRVTBzUjBGQlJ5eERRVUZ5UWl4RFFVRkVMRU5CUVZJc1EwRkJhRU03TzBGQlEwRXNXVUZCU1Vzc1dVRkJXU3hMUVVGTFJDeExRVUZ5UWl4RlFVRTBRanRCUVVONFFrNHNWVUZCUVVFc1RVRkJUU3h0UTBGRFEwRXNUVUZFUkN3eVFrRkZSRWtzU1VGR1F5eEZRVVZOUnl4WlFVWk9MRVZCUVU0N1FVRkpTRHRCUVVOS08wRkJRMG83UVVGRFNpeEhRWEJDUkR0QlFYRkNRU3hUUVVGUFVDeE5RVUZRTzBGQlEwZzdPMEZCUlVRc1UwRkJVMUVzY1VKQlFWUXNRMEZEU1VNc1RVRkVTaXhGUVVWSlF5eFRRVVpLTEVWQlIwbERMR0ZCU0Vvc1JVRkpTVU1zU1VGS1NpeEZRVXRUTzBGQlEwd3NUVUZCU1N4RFFVRkRSaXhUUVVGTUxFVkJRV2RDTzBGQlExb3NWMEZCVHl4SlFVRlFPMEZCUTBnN08wRkJRMFFzVFVGQlRVY3NUMEZCVHl4SFFVRkhTQ3hUUVVGVExFTkJRVU5NTEUxQlFWWXNRMEZCYVVJc1EwRkJha0lzUlVGQmIwSXNSVUZCY0VJc1EwRkJhRUk3UVVGRFFTeE5RVUZOVXl4TlFVRk5MRWRCUVVkS0xGTkJRVk1zUTBGQlEwd3NUVUZCVml4RFFVRnBRaXhGUVVGcVFpeEZRVUZ4UWl4RlFVRnlRaXhEUVVGbU8wRkJRMEVzVFVGQlNWVXNWMEZCZVVJc1IwRkJSeXhKUVVGb1F6czdRVUZEUVN4TlFVRkpPMEZCUTBGQkxFbEJRVUZCTEZkQlFWY3NSMEZCUjA0c1RVRkJUU3hEUVVGRFR5eFBRVUZRTEVOQlFXVkRMRFJDUVVGbUxFVkJRV2RETzBGQlF6RkRMR2xEUVVGdlFrb3NUMEZCY0VJc1kwRkJLMEpETEUxQlFTOUNPMEZCUkRCRExFdEJRV2hETEVOQlFXUTdRVUZIU0N4SFFVcEVMRU5CU1VVc1owSkJRVTBzUTBGRFNqdEJRVU5CTzBGQlEwZzdPMEZCUTBRc1RVRkJTU3hEUVVGRFF5eFhRVUZNTEVWQlFXdENPMEZCUTJRc1YwRkJUeXhKUVVGUU8wRkJRMGc3TzBGQlEwUXNVMEZCVDA0c1RVRkJUU3hEUVVGRFV5eFRRVUZRTEVOQlFXbENVQ3hoUVVGcVFpeEZRVUZuUXp0QlFVTnVRMUVzU1VGQlFVRXNUMEZCVHl4RlFVRkZTaXhYUVVRd1FqdEJRVVZ1UTBnc1NVRkJRVUVzU1VGQlNTeEZRVUZLUVR0QlFVWnRReXhIUVVGb1F5eERRVUZRTzBGQlNVZzdPMEZCUlVRc1UwRkJVMUVzV1VGQlZDeERRVU5KV0N4TlFVUktMRVZCUlVsRExGTkJSa29zUlVGSFNVTXNZVUZJU2l4RlFVbEpReXhKUVVwS0xFVkJTMFU3UVVGRFJTeE5RVUZOVXl4SlFVRkpMRWRCUVVkaUxIRkNRVUZ4UWl4RFFVRkRReXhOUVVGRUxFVkJRVk5ETEZOQlFWUXNSVUZCYjBKRExHRkJRWEJDTEVWQlFXMURReXhKUVVGdVF5eERRVUZzUXpzN1FVRkRRU3hOUVVGSlV5eEpRVUZLTEVWQlFWVTdRVUZEVGtFc1NVRkJRVUVzU1VGQlNTeERRVUZEUXl4TlFVRk1PMEZCUTBnN1FVRkRTanM3VTBGWlkwTXNaMEk3T3pzN08yMUdRVUZtTEcxQ1FVTkpReXhIUVVSS0xFVkJSVWxETEVsQlJrbzdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQkxHbENRVWxSUkN4SFFVcFNPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVUZCTERSQ1FVMVpRU3hIUVU1YU8wRkJRVUU3UVVGQlFTeHRRa0ZUT0VKQkxFZEJRVWNzUTBGQlEwVXNXVUZCU2l4RlFWUTVRanM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZSWjBKRExHTkJRVUZCTEUxQlVtaENMRVZCVVhkQ0xFVkJVbmhDTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCVFZsSUxHTkJRVUZCTEVkQlRsbzdRVUZQV1VNc1kwRkJRVUVzU1VGUVdqdEJRVUZCT3p0QlFVRkJPMEZCUVVFc2EwSkJZVkZCTEVsQlFVa3NTVUZCU1VFc1NVRkJTU3hEUVVGRFJTeE5RV0p5UWp0QlFVRkJPMEZCUVVFN1FVRkJRVHM3UVVGQlFTd3JRMEZqWlR0QlFVTklTQ3hqUVVGQlFTeEhRVUZITEVWQlFVVXNTVUZFUmp0QlFVVklReXhqUVVGQlFTeEpRVUZKTEVWQlFVcEJPMEZCUmtjc1lVRmtaanM3UVVGQlFUdEJRVUZCTEN0RFFXMUNWeXhKUVc1Q1dEczdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFTeEhPenM3TzBsQmRVSnhRa2NzYTBJN096czdPenM3T3pzN096czdPenM3T3pzN096czdhVVZCT0RKQ1NpeHJRanM3T3pzN096czdPenM3T3p0QlFYZ3lRbFFzY1VKQlFVdERMRTFCUVV3c1IwRkJZeXhMUVVGTFF5eFBRVUZNTEVOQlFXRkRMRk5CUVdJc1EwRkJkVUpETERKQ1FVRjJRaXhEUVVGa08wRkJRMEVzY1VKQlFVdERMRTlCUVV3c1IwRkJaU3hMUVVGTFNDeFBRVUZNTEVOQlFXRkRMRk5CUVdJc1EwRkJkVUpITERSQ1FVRjJRaXhEUVVGbU8wRkJRMEVzY1VKQlFVdERMRTFCUVV3c1IwRkJZeXhMUVVGTFRDeFBRVUZNTEVOQlFXRkRMRk5CUVdJc1EwRkJkVUpMTERKQ1FVRjJRaXhEUVVGa096czdPenM3T3pzN096czdPenM3T3pzN08ybEhRVWxCUXl4TkxFVkJRMEZETEZVN096czdPenM3ZFVKQlJXMURMRXRCUVV0TUxFOUJRVXdzUTBGQllVMHNVVUZCWWl4RFFVRnpRa01zUzBGQmRFSXNRMEZCTkVJN1FVRkRNMFJETEd0Q1FVRkJRU3hOUVVGTkxFVkJRVVU3UVVGRFNrTXNiMEpCUVVGQkxFVkJRVVVzUlVGQlJUdEJRVUZGUXl4elFrRkJRVUVzUlVGQlJTeEZRVUZGVGl4TlFVRk5MRU5CUVVOUE8wRkJRV0k3UVVGRVFTeHRRa0ZFYlVRN1FVRkpNMFExUXl4clFrRkJRVUVzVFVGQlRTeEZRVUZGTEZOQlNtMUVPMEZCU3pORWMwTXNhMEpCUVVGQkxGVkJRVlVzUlVGQlZrRTdRVUZNTWtRc2FVSkJRVFZDTEVNN096dEJRVUUzUWtNc1owSkJRVUZCTEZFN08zTkNRVTlHUVN4UlFVRlJMRWxCUVVsQkxGRkJRVkVzUTBGQlEwMHNUVUZCVkN4SFFVRnJRaXhET3pzN096dHJSRUZEZGtJN1FVRkRTRWdzYTBKQlFVRkJMRVZCUVVVc1JVRkJSVXdzVFVGQlRTeERRVUZEVHl4UFFVUlNPMEZCUlVoRkxHdENRVUZCUVN4WlFVRlpMRVZCUVVWUUxGRkJRVkVzUTBGQlF5eERRVUZFTEVOQlFWSXNRMEZCV1ZFN1FVRkdka0lzYVVJN096dHJSRUZMU2p0QlFVTklUQ3hyUWtGQlFVRXNSVUZCUlN4RlFVRkZMRWxCUkVRN1FVRkZTRWtzYTBKQlFVRkJMRmxCUVZrc1JVRkJSVHRCUVVaWUxHbENPenM3T3pzN096czdPenM3T3pzN1VVRlBXRHM3T3pzN2JVZEJSMGxVTEUwc1JVRkRRVU1zVlRzN096czdPenRyUkVGRlR5eExRVUZMVWl4UFFVRk1MRU5CUVdGclFpeExRVUZpTEVOQlFXMUNMR3RDUVVGdVFqdEJRVUZCTERCR1FVRjFReXhyUWtGQlR6TkNMRWxCUVZBN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU14UTBFc05FSkJRVUZCTEVsQlFVa3NRMEZCUXpSQ0xFMUJRVXdzUTBGQldTeFJRVUZhTEVWQlFYTkNia1FzVjBGQlZ5eERRVUZEZFVNc1RVRkJSQ3hGUVVGVExFTkJRVU1zWjBKQlFVUXNRMEZCVkN4RFFVRnFRenRCUVVRd1F5dzRSRUZGYmtNc1RVRkJTU3hEUVVGRFlTeG5Ra0ZCVEN4RFFVRnpRbUlzVFVGQmRFSXNSVUZCT0VKb1FpeEpRVUU1UWl4RFFVWnRRenM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3h0UWtGQmRrTTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzY1VKQlIwcHBRaXhWUVVoSkxFTTdPenM3T3pzN096czdPenM3T3pzN096czdaMGRCVVZCRUxFMHNSVUZEUVVNc1ZUczdPenM3T3p0clJFRkZUeXhMUVVGTFVpeFBRVUZNTEVOQlFXRnJRaXhMUVVGaUxFTkJRVzFDTEdWQlFXNUNPMEZCUVVFc01rWkJRVzlETEd0Q1FVRlBNMElzU1VGQlVEdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTNaRFFTdzBRa0ZCUVVFc1NVRkJTU3hEUVVGRE5FSXNUVUZCVEN4RFFVRlpMRkZCUVZvc1JVRkJjMEp1UkN4WFFVRlhMRU5CUVVOMVF5eE5RVUZFTEVWQlFWTXNRMEZCUXl4blFrRkJSQ3hEUVVGVUxFTkJRV3BETzBGQlJIVkRMRGhFUVVWb1F5eE5RVUZKTEVOQlFVTmpMR0ZCUVV3c1EwRkJiVUprTEUxQlFXNUNMRVZCUVRKQ2FFSXNTVUZCTTBJc1EwRkdaME03TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzYlVKQlFYQkRPenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEhGQ1FVZEthVUlzVlVGSVNTeERPenM3T3pzN096czdPenM3T3pzN096czdPM0ZIUVU5UVJDeE5MRVZCUTBGRExGVTdPenM3T3pzN2EwUkJSVThzUzBGQlMxSXNUMEZCVEN4RFFVRmhhMElzUzBGQllpeERRVUZ0UWl4dlFrRkJia0k3UVVGQlFTd3lSa0ZCZVVNc2EwSkJRVTh6UWl4SlFVRlFPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRE5VTkJMRFJDUVVGQlFTeEpRVUZKTEVOQlFVTTBRaXhOUVVGTUxFTkJRVmtzVVVGQldpeEZRVUZ6UW01RUxGZEJRVmNzUTBGQlEzVkRMRTFCUVVRc1JVRkJVeXhEUVVGRExHZENRVUZFTEVOQlFWUXNRMEZCYWtNN1FVRkVORU1zT0VSQlJYSkRMRTFCUVVrc1EwRkJRMlVzYTBKQlFVd3NRMEZCZDBKbUxFMUJRWGhDTEVWQlFXZERhRUlzU1VGQmFFTXNRMEZHY1VNN08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc2JVSkJRWHBET3p0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQkxIRkNRVWRLYVVJc1ZVRklTU3hET3pzN096czdPenM3T3pzN096czdPenM3T3paSFFVOVFSQ3hOTEVWQlEwRkRMRlU3T3pzN096czdiVVJCUlU4c1MwRkJTMUlzVDBGQlRDeERRVUZoYTBJc1MwRkJZaXhEUVVGdFFpeHBRa0ZCYmtJN1FVRkJRU3d5UmtGQmMwTXNhMEpCUVU4elFpeEpRVUZRTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkRla05CTERSQ1FVRkJRU3hKUVVGSkxFTkJRVU0wUWl4TlFVRk1MRU5CUVZrc1VVRkJXaXhGUVVGelFtNUVMRmRCUVZjc1EwRkJRM1ZETEUxQlFVUXNSVUZCVXl4RFFVRkRMR2RDUVVGRUxFTkJRVlFzUTBGQmFrTTdRVUZFZVVNc09FUkJSV3hETEUxQlFVa3NRMEZCUTJkQ0xIbENRVUZNTEVOQlFTdENhRUlzVFVGQkwwSXNSVUZCZFVOb1FpeEpRVUYyUXl4RFFVWnJRenM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3h0UWtGQmRFTTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzY1VKQlIwcHBRaXhWUVVoSkxFTTdPenM3T3pzN096czdPenM3T3pzN096czdiMGRCVDFCRUxFMDdPenM3T3p0QlFVVkphVUlzWjBKQlFVRkJMRlVzUjBGQmMwTnFRaXhOTzBGQlEzQkRhMElzWjBKQlFVRkJMRThzUjBGQlZXeENMRTFCUVUwc1EwRkJRMjFDTEZOQlFWQXNTVUZCY1VKdVFpeE5RVUZOTEVOQlFVTnZRaXhWUVVGUUxFbEJRWEZDY0VJc1RVRkJUU3hEUVVGRGNVSXNWVHM3YjBKQlF6VkVTQ3hQT3pzN096dEJRVU5MV0N4blFrRkJRVUVzVHl4SFFVRlZVQ3hOUVVGTkxFTkJRVU5QTEU4N08yOUNRVU5zUWtFc1R6czdPenM3WjBOQlEwdGxMRGhDT3p0MVFrRkJaMFFzUzBGQlMwTXNhVUpCUVV3c1JUczdPenR2UTBGQmFrTkRMREJDT3pzN08zVkNRVVZGTEV0QlFVdERMRlZCUVV3c1EwRkJaMEpzUWl4UFFVRm9RaXhGUVVGNVFpeExRVUY2UWl4RlFVRm5RenRCUVVOMlJHMUNMR3RDUVVGQlFTeFBRVUZQTEVWQlFVVXNTMEZCUzJ4RExFMUJRVXdzUTBGQldXMURMR05CUVZvN1FVRkVPRU1zYVVKQlFXaERMRU03T3p0QlFVRnlRa01zWjBKQlFVRkJMRTg3TzI5Q1FVZEVRU3hQUVVGUExFTkJRVU5ETEZNN096czdPMmREUVVOSVVDdzRRanRuUTBGRFJtWXNUenRuUTBGRFFYRkNMRTlCUVU4c1EwRkJRMnhDTEU4N08zVkNRVU5HTEV0QlFVdGhMR2xDUVVGTUxFVTdPenM3YjBOQlNGZFBMR3RDT3pzN1FVRk5ia0pETEdkQ1FVRkJRU3hwUWl4SFFVRnhSQ3hGT3p0QlFVTXpSQ3h2UWtGQlNVZ3NUMEZCVHl4RFFVRkRTU3hIUVVGYUxFVkJRV2xDTzBGQlEySkVMR3RDUVVGQlFTeHBRa0ZCYVVJc1EwRkJRMW9zVTBGQmJFSXNSMEZCT0VKVExFOUJRVThzUTBGQlEwa3NSMEZCZEVNN1FVRkRTRHM3UVVGRFJDeHZRa0ZCU1Vvc1QwRkJUeXhEUVVGRFN5eFRRVUZhTEVWQlFYVkNPMEZCUTI1Q1JpeHJRa0ZCUVVFc2FVSkJRV2xDTEVOQlFVTkZMRk5CUVd4Q0xFZEJRVGhDVEN4UFFVRlBMRU5CUVVOTExGTkJRWFJETzBGQlEwZzdPMEZCUTBRc2IwSkJRVWxNTEU5QlFVOHNRMEZCUTJ4Q0xFOUJRVm9zUlVGQmNVSTdRVUZEYWtKeFFpeHJRa0ZCUVVFc2FVSkJRV2xDTEVOQlFVTnlRaXhQUVVGc1FpeEhRVUUwUW10Q0xFOUJRVThzUTBGQlEyeENMRTlCUVhCRE8wRkJRMGc3TzBGQlEwUlBMR2RDUVVGQlFTeFZRVUZWTEcxRFFVTklZeXhwUWtGRVJ5eEhRVVZJTDBJc1RVRkdSeXhEUVVGV096czdiVVJCUzBjc1MwRkJTMnRETEZkQlFVd3NRMEZCYVVJc1UwRkJha0lzUlVGQk5FSnFRaXhWUVVFMVFpeERPenM3T3pzN096czdPenM3T3pzN096czdhME5CUjBkclFpeEpMRVZCUVc5Q08wRkJRemxDTEZWQlFVMTRSU3hOUVVGTkxFZEJRVWNzUlVGQlpqdEJRVU5CTEZWQlFVbDVSU3hKUVVGSkxFZEJRVWRFTEVsQlFWZzdPMEZCUTBFc1lVRkJUME1zU1VGQlVDeEZRVUZoTzBGQlExUXNXVUZCU1N4RFFVRkRRU3hKUVVGSkxFTkJRVU0xUWl4TlFVRk9MRXRCUVdsQ0xFTkJRWEpDTEVWQlFYZENPMEZCUTNCQ0xHZENRVUZOWXl3clFrRkJaV1VzVjBGQlppeERRVUV5UWtNc2FVTkJRVE5DTEVOQlFVNDdRVUZEU0RzN1FVRkRSRE5GTEZGQlFVRkJMRTFCUVUwc1EwRkJRelJGTEVsQlFWQXNRMEZCV1Vnc1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGQmFFSTdRVUZEUVVFc1VVRkJRVUVzU1VGQlNTeEhRVUZIUVN4SlFVRkpMRU5CUVVNc1EwRkJSQ3hEUVVGWU8wRkJRMGc3TzBGQlEwUXNZVUZCVDNwRkxFMUJRVkE3UVVGRFNDeExMRU5CUjBRN096czdPMmxJUVVkSmNVTXNUU3hGUVVOQmQwTXNWVHM3T3pzN08wRkJSVUVzY1VKQlFVdG9SQ3hOUVVGTUxFTkJRVmxwUkN4SFFVRmFMRU5CUVdkQ0xIRkNRVUZvUWl4RlFVRjFRM3BETEUxQlFYWkRPenQxUWtGRGNVSmtMR2RDUVVGblFpeERRVUZEWXl4TlFVRk5MRU5CUVVNd1F5eFZRVUZTTEVWQlFXOUNNVU1zVFVGQlRTeERRVUZETWtNc1QwRkJNMElzUXpzN08wRkJRUzlDUXl4blFrRkJRVUVzVFRzN2NVSkJRMFpCTEUwN096czdPenQxUWtGRE9FSXNTMEZCUzBNc01rSkJRVXdzYVVOQlEzWkNOME1zVFVGRWRVSTdRVUZGTVVJeVF5eHJRa0ZCUVVFc1QwRkJUeXhGUVVGRlF5eE5RVUZOTEVOQlFVTjRSRHRCUVVaVkxHMUNPenM3UVVGQmVFSXdSQ3huUWtGQlFVRXNaVHRuUTBGSlF5eEpPenM3T3p0MVFrRkRUeXhMUVVGTFF5eFpRVUZNTEVOQlFXdENSQ3hsUVVGbExFTkJRVU5GTEZWQlFXeERMRVZCUVRoRFNpeE5RVUU1UXl4RE96czdPenM3TzBGQlExWkZMR3RDUVVGQlFTeGxRVUZsTEVWQlFXWkJPenM3YVVWQlJsRkhMSGxDT3pzN08zVkNRVXN3UWl4TFFVRkxaaXhYUVVGTUxFTkJRV2xDTERCQ1FVRnFRaXhGUVVFMlF6dEJRVU51Um1kQ0xHdENRVUZCUVN4SFFVRkhMRVZCUVVWc1JDeE5RVUZOTEZkQlFVNHNRMEZCWld0RUxFZEJSQ3RFTzBGQlJXNUdReXhyUWtGQlFVRXNhVUpCUVdsQ0xFVkJRVVZ1UkN4TlFVRk5MRU5CUVVOdFJDeHBRa0ZHZVVRN1FVRkhia1pETEd0Q1FVRkJRU3hwUWtGQmFVSXNSVUZCUlhCRUxFMUJRVTBzUTBGQlEyOUVMR2xDUVVoNVJEdEJRVWx1UmtNc2EwSkJRVUZCTEZWQlFWVXNSVUZCUlhKRUxFMUJRVTBzUTBGQlEzRkVMRlZCU21kRk8wRkJTMjVHUXl4clFrRkJRVUVzVjBGQlZ5eEZRVUZGZEVRc1RVRkJUU3hYUVVGT0xFTkJRV1Z6UkN4WFFVeDFSRHRCUVUxdVJsZ3NhMEpCUVVGQkxFOUJRVThzUlVGQlJUTkRMRTFCUVUwc1EwRkJRekpETEU5QlRtMUZPMEZCVDI1R1dTeHJRa0ZCUVVFc1YwRkJWeXhGUVVGRmRrUXNUVUZCVFN4RFFVRkRkVVE3UVVGUUswUXNhVUpCUVRkRExFTTdPenRCUVVGd1EwTXNaMEpCUVVGQkxFODdiVVJCVTBNN1FVRkRTR3BFTEd0Q1FVRkJRU3hQUVVGUExFVkJRVVZwUkN4UFFVRlBMRU5CUVVOcVJDeFBRVVJrTzBGQlJVaHBSQ3hyUWtGQlFVRXNUMEZCVHl4RlFVRlFRVHRCUVVaSExHbENPenM3T3pzN096czdPenM3T3pzN096czdPemhIUVZGUWVFUXNUU3hGUVVOQmQwTXNWVHM3T3pzN08wRkJSVUVzY1VKQlFVdG9SQ3hOUVVGTUxFTkJRVmxwUkN4SFFVRmFMRU5CUVdkQ0xHdENRVUZvUWl4RlFVRnZRM3BETEUxQlFYQkRPenQxUWtGRGNVSmtMR2RDUVVGblFpeERRVUZEWXl4TlFVRk5MRU5CUVVNd1F5eFZRVUZTTEVWQlFXOUNNVU1zVFVGQlRTeERRVUZETWtNc1QwRkJNMElzUXpzN08wRkJRUzlDUXl4blFrRkJRVUVzVFRzN2NVSkJRMFpCTEUwN096czdPenQxUWtGRE9FSXNTMEZCUzJFc2QwSkJRVXdzUTBGQk9FSjZSQ3hOUVVFNVFpeERPenM3UVVGQmVFSTRReXhuUWtGQlFVRXNaVHRuUTBGRFF5eEpPenM3T3p0MVFrRkRUeXhMUVVGTFF5eFpRVUZNTEVOQlFXdENSQ3hsUVVGbExFTkJRVU5GTEZWQlFXeERMRVZCUVRoRFNpeE5RVUU1UXl4RE96czdPenM3TzBGQlExWkZMR3RDUVVGQlFTeGxRVUZsTEVWQlFXWkJPenM3YVVWQlJsRlpMSE5DT3pzN08zVkNRVXROTEV0QlFVdDRRaXhYUVVGTUxFTkJRV2xDTEhWQ1FVRnFRaXhGUVVFd1F6dEJRVU0xUkROQ0xHdENRVUZCUVN4UFFVRlBMRVZCUVVWUUxFMUJRVTBzUTBGQlEwOHNUMEZFTkVNN1FVRkZOVVF5UXl4clFrRkJRVUVzUjBGQlJ5eEZRVUZGYkVRc1RVRkJUU3hEUVVGRGEwUXNSMEZHWjBRN1FVRkhOVVJUTEd0Q1FVRkJRU3haUVVGWkxFVkJRVVV6UkN4TlFVRk5MRU5CUVVNeVJDeFpRVWgxUXp0QlFVazFSRU1zYTBKQlFVRkJMRTFCUVUwc1JVRkJSVFZFTEUxQlFVMHNRMEZCUXpSRUxFMUJTalpETzBGQlN6VkVReXhyUWtGQlFVRXNVVUZCVVN4RlFVRkZja0lzVlVGTWEwUTdRVUZOTlVSelFpeHJRa0ZCUVVFc1MwRkJTeXhGUVVGRk9VUXNUVUZCVFN4RFFVRkRPRVFzUzBGT09FTTdRVUZQTlVSdVFpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGRk0wTXNUVUZCVFN4RFFVRkRNa003UVVGUU5FTXNhVUpCUVRGRExFTTdPenRCUVVGb1FtRXNaMEpCUVVGQkxFODdiVVJCVTBNN1FVRkRTR3BFTEd0Q1FVRkJRU3hQUVVGUExFVkJRVVZRTEUxQlFVMHNRMEZCUTA4c1QwRkVZanRCUVVWSU1rTXNhMEpCUVVGQkxFZEJRVWNzUlVGQlJXeEVMRTFCUVUwc1EwRkJRMnRFTEVkQlJsUTdRVUZIU0ZNc2EwSkJRVUZCTEZsQlFWa3NSVUZCUlRORUxFMUJRVTBzUTBGQlF6SkVMRmxCU0d4Q08wRkJTVWhJTEd0Q1FVRkJRU3hQUVVGUExFVkJRVkJCTzBGQlNrY3NhVUk3T3pzN096czdPenM3T3pzN096czdPenM3ZVVoQlUxQjRSQ3hOTEVWQlEwRjNReXhWT3pzN096czdPM1ZDUVV0VkxFdEJRVXRPTEZkQlFVd3NRMEZCYVVJc01FTkJRV3BDTEVWQlFUWkVPMEZCUTI1RlowSXNhMEpCUVVGQkxFZEJRVWNzUlVGQlJXeEVMRTFCUVUwc1YwRkJUaXhEUVVGbGEwUXNSMEZFSzBNN1FVRkZia1ZETEd0Q1FVRkJRU3hwUWtGQmFVSXNSVUZCUlc1RUxFMUJRVTBzUTBGQlEyMUVMR2xDUVVaNVF6dEJRVWR1UlZVc2EwSkJRVUZCTEZGQlFWRXNSVUZCUlhKQ0xGVkJTSGxFTzBGQlNXNUZXU3hyUWtGQlFVRXNhVUpCUVdsQ0xFVkJRVVZ3UkN4TlFVRk5MRU5CUVVOdlJDeHBRa0ZLZVVNN1FVRkxia1ZETEd0Q1FVRkJRU3hWUVVGVkxFVkJRVVZ5UkN4TlFVRk5MRU5CUVVOeFJDeFZRVXhuUkR0QlFVMXVSVU1zYTBKQlFVRkJMRmRCUVZjc1JVRkJSWFJFTEUxQlFVMHNWMEZCVGl4RFFVRmxjMFFzVjBGT2RVTTdRVUZQYmtWVExHdENRVUZCUVN4WlFVRlpMRVZCUVVVdlJDeE5RVUZOTEVOQlFVTXlReXhQUVVGUUxGVkJVSEZFTzBGQlVXNUZXU3hyUWtGQlFVRXNWMEZCVnl4RlFVRkZka1FzVFVGQlRTeERRVUZEZFVRN1FVRlNLME1zYVVKQlFUZEVMRU03T3p0QlFVaEtOVVlzWjBKQlFVRkJMRTA3YlVSQllVTTdRVUZEU0RSRExHdENRVUZCUVN4UFFVRlBMRVZCUVVVMVF5eE5RVUZOTEVOQlFVTnhSeXhWUVVSaU8wRkJSVWhvUWl4clFrRkJRVUVzVlVGQlZTeHJRMEZEU0hKR0xFMUJRVTBzUTBGQlEzTkhMRTlCUkVvN1FVRkZUbVlzYjBKQlFVRkJMRWRCUVVjc1JVRkJSV3hFTEUxQlFVMHNWMEZCVGl4RFFVRmxhMFE3UVVGR1pEdEJRVVpRTEdsQ096czdPenM3T3pzN096czdPenM3T3pzN08zTklRVmRRYkVRc1RTeEZRVU5CZDBNc1ZUczdPenM3T3pzN08wRkJSVWx2UWl4blFrRkJRVUVzVFN4SFFVRlROVVFzVFVGQlRTeERRVUZETkVRc1RUczdjMEpCUTJoQ0xFTkJRVU0xUkN4TlFVRk5MRU5CUVVOclJDeEhRVUZRTEVOQlFWZFZMRTFCUVZnc1NVRkJjVUlzUlVGQmRFSXNSVUZCTUVKTkxGRkJRVEZDTEVOQlFXMURMRkZCUVc1RExFdEJRV2RFTEdGQlFVTk9MRTFCUVVRc05FTkJRVU1zVVVGQlVVOHNUVUZCVkN4RE96czdPenM3ZFVKQlF6VkNha1lzWjBKQlFXZENMRU5CUVVOakxFMUJRVTBzUTBGQlF6QkRMRlZCUVZJc1JVRkJiMEl4UXl4TlFVRk5MRU5CUVVNeVF5eFBRVUV6UWl4RE96czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3WjBOQlFYWkNMSE5DUVVFMlJIWkVMRWs3T3p0QlFVRndSVUVzWjBKQlFVRkJMRWs3TzBGQlEwNHNiMEpCUVVsQkxFbEJRVW9zUlVGQlZUdEJRVU5PZDBVc2EwSkJRVUZCTEUxQlFVMHNiVU5CUTBOQkxFMUJSRVE3UVVGRlJrOHNiMEpCUVVGQkxFMUJRVTBzUlVGQlJTOUZMRWxCUVVrN1FVRkdWaXh2UWtGQlRqdEJRVWxJT3pzN08zVkNRVVZ2UWl4TFFVRkxPRU1zVjBGQlRDeERRVUZwUWl4MVEwRkJha0lzUlVGQk1FUTdRVUZETDBVelFpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGRlVDeE5RVUZOTEVOQlFVTlBMRTlCUkN0RU8wRkJSUzlGTWtNc2EwSkJRVUZCTEVkQlFVY3NSVUZCUld4RUxFMUJRVTBzUTBGQlEydEVMRWRCUm0xRk8wRkJSeTlGVXl4clFrRkJRVUVzV1VGQldTeEZRVUZGTTBRc1RVRkJUU3hEUVVGRE1rUXNXVUZJTUVRN1FVRkpMMFZETEd0Q1FVRkJRU3hOUVVGTkxFVkJRVVZCTEUxQlNuVkZPMEZCU3k5RlF5eHJRa0ZCUVVFc1VVRkJVU3hGUVVGRmNrSXNWVUZNY1VVN1FVRk5MMFZ6UWl4clFrRkJRVUVzUzBGQlN5eEZRVUZGT1VRc1RVRkJUU3hEUVVGRE9FUTdRVUZPYVVVc2FVSkJRVEZFTEVNN096dEJRVUZ1UW1Rc1owSkJRVUZCTEZVN2JVUkJVVU03UVVGRFNIcERMR3RDUVVGQlFTeFBRVUZQTEVWQlFVVlFMRTFCUVUwc1EwRkJRMDhzVDBGRVlqdEJRVVZJYjBRc2EwSkJRVUZCTEZsQlFWa3NSVUZCUlRORUxFMUJRVTBzUTBGQlF6SkVMRmxCUm14Q08wRkJSMGhZTEd0Q1FVRkJRU3hWUVVGVkxHdERRVU5JUVN4VlFVUkhPMEZCUlU1RkxHOUNRVUZCUVN4SFFVRkhMRVZCUVVWc1JDeE5RVUZOTEVOQlFVTnJSRHRCUVVaT08wRkJTRkFzYVVJN096czdPenM3T3pzN096czdPenM3T3pzN2FVaEJXVkJzUkN4Tk96czdPenR0UkVGRlR5eExRVUZMYTBNc1YwRkJUQ3hEUVVGcFFpeHZRMEZCYWtJc1JVRkJkVVJzUXl4TlFVRjJSQ3hET3pzN096czdPenM3T3pzN096czdPenM3TzNWSVFVdFFRU3hOT3pzN096czdPM1ZDUVVWelFpeExRVUZMYjBVc2JVSkJRVXdzUTBGQmVVSTdRVUZETTBOc1FpeHJRa0ZCUVVFc1IwRkJSeXhGUVVGRmJFUXNUVUZCVFN4RFFVRkRPRU1zWlVGQlVDeERRVUYxUWtVc1ZVRkJka0lzUTBGQmEwTkZMRWRCUkVrN1FVRkZNME50UWl4clFrRkJRVUVzYlVKQlFXMUNMRVZCUVVWeVJTeE5RVUZOTEVOQlFVTTRReXhsUVVGUUxFTkJRWFZDUlN4VlFVRjJRaXhEUVVGclEzRkNMRzFDUVVaYU8wRkJSek5EUXl4clFrRkJRVUVzWlVGQlpTeEZRVUZGZEVVc1RVRkJUU3hEUVVGRGMwVXNaVUZJYlVJN1FVRkpNME5RTEd0Q1FVRkJRU3haUVVGWkxFVkJRVVV2UkN4TlFVRk5MRU5CUVVNclJEdEJRVXB6UWl4cFFrRkJla0lzUXpzN08wRkJRV2hDVUN4blFrRkJRVUVzVHp0QlFVMU9RU3huUWtGQlFVRXNUMEZCVHl4RFFVRkRaU3hOUVVGU0xFZEJRV2xDZGtVc1RVRkJUU3hEUVVGRE9FTXNaVUZCVUN4RFFVRjFRa1VzVlVGQmRrSXNRMEZCYTBOMVFpeE5RVUZ1UkR0dFJFRkRUenRCUVVOSWFFVXNhMEpCUVVGQkxFOUJRVThzUlVGQlJWQXNUVUZCVFN4RFFVRkRPRU1zWlVGQlVDeERRVUYxUW5aRExFOUJSRGRDTzBGQlJVaHBSQ3hyUWtGQlFVRXNUMEZCVHl4RlFVRlFRVHRCUVVaSExHbENPenM3T3pzN096czdPenM3T3pzN096czdPMjlJUVZGUWVFUXNUVHM3T3pzN096dDFRa0ZGYzBJc1MwRkJTMjlGTEcxQ1FVRk1MRU5CUVhsQ08wRkJRek5EYkVJc2EwSkJRVUZCTEVkQlFVY3NSVUZCUld4RUxFMUJRVTBzUTBGQlF6aERMR1ZCUVZBc1EwRkJkVUpGTEZWQlFYWkNMRU5CUVd0RFJTeEhRVVJKTzBGQlJUTkRiVUlzYTBKQlFVRkJMRzFDUVVGdFFpeEZRVUZGY2tVc1RVRkJUU3hEUVVGRE9FTXNaVUZCVUN4RFFVRjFRa1VzVlVGQmRrSXNRMEZCYTBOeFFpeHRRa0ZHV2p0QlFVY3pRME1zYTBKQlFVRkJMR1ZCUVdVc1JVRkJSWFJGTEUxQlFVMHNRMEZCUTNORkxHVkJTRzFDTzBGQlNUTkRVQ3hyUWtGQlFVRXNXVUZCV1N4RlFVRkZMMFFzVFVGQlRTeERRVUZESzBRN1FVRktjMElzYVVKQlFYcENMRU03T3p0QlFVRm9RbEFzWjBKQlFVRkJMRTg3UVVGTlRrRXNaMEpCUVVGQkxFOUJRVThzUTBGQlEyVXNUVUZCVWl4SFFVRnBRblpGTEUxQlFVMHNRMEZCUXpoRExHVkJRVkFzUTBGQmRVSkZMRlZCUVhaQ0xFTkJRV3REZFVJc1RVRkJia1E3YlVSQlEwODdRVUZEU0doRkxHdENRVUZCUVN4UFFVRlBMRVZCUVVWUUxFMUJRVTBzUTBGQlF6aERMR1ZCUVZBc1EwRkJkVUoyUXl4UFFVUTNRanRCUVVWSU1rTXNhMEpCUVVGQkxFZEJRVWNzUlVGQlJXeEVMRTFCUVUwc1EwRkJRemhETEdWQlFWQXNRMEZCZFVKRkxGVkJRWFpDTEVOQlFXdERSU3hIUVVad1F6dEJRVWRJVXl4clFrRkJRVUVzV1VGQldTeEZRVUZGTTBRc1RVRkJUU3hEUVVGRE9FTXNaVUZCVUN4RFFVRjFRbUVzV1VGSWJFTTdRVUZKU0Vnc2EwSkJRVUZCTEU5QlFVOHNSVUZCVUVFN1FVRktSeXhwUWpzN096czdPenM3T3pzN096czdPenM3T3pzNFIwRlRVSGhFTEUwN096czdPMjFFUVVWUExFdEJRVXRyUXl4WFFVRk1MRU5CUVdsQ0xITkNRVUZxUWl4RlFVRjVRMnhETEUxQlFYcERMRU03T3pzN096czdPenM3T3pzN096czdPenM3TWtkQlNWQkJMRTA3T3pzN08yMUVRVVZQTEV0QlFVdHJReXhYUVVGTUxFTkJRV2xDTEhWQ1FVRnFRaXhGUVVFd1EyeERMRTFCUVRGRExFTTdPenM3T3pzN096czdPenM3T3pzN096czdNa2RCU1ZCQkxFMDdPenM3TzIxRVFVVlBMRXRCUVV0clF5eFhRVUZNTEVOQlFXbENMRzlDUVVGcVFpeEZRVUYxUTJ4RExFMUJRWFpETEVNN096czdPenM3T3pzN096czdPenM3T3pzN01rZEJTVkJCTEUwN096czdPMjFFUVVWUExFdEJRVXRyUXl4WFFVRk1MRU5CUVdsQ0xIVkNRVUZxUWl4RlFVRXdRMnhETEUxQlFURkRMRU03T3pzN096czdPenM3T3pzN096czdPenM3ZDBkQlNWQkJMRTA3T3pzN08yMUVRVVZQTEV0QlFVdHJReXhYUVVGTUxFTkJRV2xDTEc5Q1FVRnFRaXhGUVVGMVEyeERMRTFCUVhaRExFTTdPenM3T3pzN096czdPenM3T3pzN096czdNRWRCU1ZCQkxFMDdPenM3TzIxRVFVVlBMRXRCUVV0clF5eFhRVUZNTEVOQlFXbENMSGxDUVVGcVFpeEZRVUUwUTJ4RExFMUJRVFZETEVNN096czdPenM3T3pzN096czdPenRSUVVkWU96czdPenMyUjBGSFNVRXNUVHM3T3pzN2JVUkJSVThzUzBGQlMydERMRmRCUVV3c1EwRkJhVUlzYzBKQlFXcENMRVZCUVhsRGJFTXNUVUZCZWtNc1F6czdPenM3T3pzN096czdPenM3T3pzN096dHZTRUZMVUVFc1RUczdPenM3YlVSQlJVOHNTMEZCUzJ0RExGZEJRVXdzUTBGQmFVSXNOa0pCUVdwQ0xFVkJRV2RFYkVNc1RVRkJhRVFzUXpzN096czdPenM3T3pzN096czdPenM3T3p0eFNFRkxVRUVzVFRzN096czdiVVJCUlU4c1MwRkJTMnRETEZkQlFVd3NRMEZCYVVJc09FSkJRV3BDTEVWQlFXbEViRU1zVFVGQmFrUXNRenM3T3pzN096czdPenM3T3pzN08xRkJSMWc3T3pzN096WkhRVVZ6UW5kRUxFODdPenM3T3pzN1owTkJRMWhCTEU5QlFVOHNRMEZCUTI1R0xGTTdPenM3T3pzN08zVkNRVUZ0UWl3MlJFRkJRenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMR2xEUVVOaUxFMUJRVWtzUTBGQlEyMUhMRlZCUVV3c1EwRkJaMEk3UVVGRE9VSnlSQ3cwUWtGQlFVRXNVMEZCVXl4RlFVRkZjVU1zVDBGQlR5eERRVUZEYVVJN1FVRkVWeXd5UWtGQmFFSXNRMEZFWVRzN1FVRkJRVHRCUVVONlFuQkZMREJDUVVGQlFTeEZRVVI1UWl4dFFrRkhNMEp4UlN4SlFVZ3lRanRCUVVrdlFteENMREJDUVVGQlFTeFBRVUZQTEVOQlFVTnVSaXhUUVVGU0xFZEJRVzlDWjBNc1JVRkJjRUk3UVVGS0swSXNOa1JCUzNoQ1FTeEZRVXgzUWpzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVN4cFFrRkJSQ3hKT3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPM2xIUVZWc1Ewd3NUU3hGUVVOQlF5eFZPenM3T3pzN1FVRkZUWE5GTEdkQ1FVRkJRU3hOTEVkQlFWTjJSU3hOUVVGTkxFTkJRVU4xUlN4Tk96dHpRa0ZEYkVKQkxFMUJRVTBzU1VGQlMwa3NTVUZCU1N4RFFVRkRReXhIUVVGTUxFdEJRV0ZNTEUxQlFVMHNSMEZCUnl4Sk96czdPenRuUTBGRE0wSnFSQ3c0UWpzN2RVSkJSVWtzUzBGQlMwTXNhVUpCUVV3c1EwRkJkVUk3UVVGRGVrSm9RaXhyUWtGQlFVRXNUMEZCVHl4RlFVRkZVQ3hOUVVGTkxFTkJRVU5QTEU5QlJGTTdRVUZGZWtKelJTeHJRa0ZCUVVFc1ZVRkJWU3hGUVVGRk4wVXNUVUZCVFN4RFFVRkRNMEk3UVVGR1RTeHBRa0ZCZGtJc1F6czdPenR2UTBGR1YzbEhMSEZDTEhGQ1FVTnFRaXg1UWpzN08yZERRVTluUWtNc1NUczdkVUpCUVdVc1MwRkJTMjVHTEU5QlFVd3NRMEZCWVc5R0xHVkJRV0lzUTBGQk5rSXZSU3hWUVVFM1FpeERPenM3TzBGQlFXcERLMFVzWjBKQlFVRkJMR1VzYVVKQlFYVkNReXhIT3p0elFrRkRla0pFTEdWQlFXVXNSMEZCUnl4TFFVRkxlRVlzVFVGQlRDeERRVUZaTUVZc2EwSkJRVm9zUlRzN096czdRVUZEYkVJc2NVSkJRVXQwUml4UFFVRk1MRU5CUVdGMVJpeHRRa0ZCWWp0blEwRkRUVGRFTERoQ096dDFRa0ZCYjBNc1MwRkJTME1zYVVKQlFVd3NSVHM3T3p0dlEwRkJja0kyUkN4ak96czdPM1ZDUVVWRExFdEJRVXRETEd0Q1FVRk1MRU5CUVhkQ2NrWXNUVUZCVFN4RFFVRkRUeXhQUVVFdlFpeERPenM3UVVGQmNFSXJSU3huUWtGQlFVRXNWenM3ZFVKQlExY3NTMEZCUzBNc1pVRkJUQ3hEUVVGeFFuWkdMRTFCUVhKQ0xFTTdPenRCUVVGWVN5eG5Ra0ZCUVVFc1JUdEJRVU5CYlVZc1owSkJRVUZCTEZFc1IwRkJWME1zVFVGQlRTeERRVUZEUXl4SlFVRlFMRU5CUVZseVJpeEZRVUZhTEVWQlFXZENMRXRCUVdoQ0xFVkJRWFZDYzBZc1VVRkJka0lzUTBGQlowTXNVVUZCYUVNc1F6dEJRVU5ZUXl4blFrRkJRVUVzVnl4SFFVRmpMRXRCUVV0dVJ5eFBRVUZNTEVOQlFXRnZSeXhoUVVGaUxFTkJRMmhDZUVZc1JVRkJSU3hEUVVGRGNrTXNUVUZCU0N4RFFVRlZMRU5CUVZZc1JVRkJZU3hGUVVGaUxFTkJSR2RDTEVWQlJXaENjVU1zUlVGQlJTeERRVUZEY2tNc1RVRkJTQ3hEUVVGVkxFVkJRVllzUlVGQll5eEZRVUZrTEVOQlJtZENMRVZCUjJoQ0xHMUNRVWhuUWl4RE8wRkJTM0JDTkVnc1owSkJRVUZCTEZkQlFWY3NRMEZCUTBVc1QwRkJXaXhEUVVGdlFqdEJRVU5vUW5wSUxHdENRVUZCUVN4VFFVRlRMRVZCUVVWblF5eEZRVVJMTzBGQlJXaENNRVlzYTBKQlFVRkJMRmRCUVZjc1JVRkJSV2hDTEVsQlFVa3NRMEZCUTJsQ0xFbEJRVXdzUTBGQlZXaEhMRTFCUVUwc1EwRkJRM2xGTEdsQ1FVRlFMRU5CUVhsQ2FrVXNUVUZCZWtJc1IwRkJhME1zUTBGQmJFTXNSMEZCYzBNc1EwRkJhRVFzUTBGR1J6dEJRVWRvUWtRc2EwSkJRVUZCTEU5QlFVOHNSVUZCUlZBc1RVRkJUU3hEUVVGRFR5eFBRVWhCTzBGQlNXaENaMFVzYTBKQlFVRkJMRTFCUVUwc1JVRkJSWFpGTEUxQlFVMHNRMEZCUTNWRk8wRkJTa01zYVVKQlFYQkNPenQxUWtGTlRTeExRVUZMTTBVc1QwRkJUQ3hEUVVGaGNVY3NXVUZCWWl4RFFVRXdRaXhEUVVNMVFqdEJRVU5KTlVZc2EwSkJRVUZCTEVWQlFVVXNSVUZCUlcxR0xGRkJSRkk3UVVGRlNWVXNhMEpCUVVGQkxFbEJRVWtzUlVGQlJXeEhMRTFCUVUwc1EwRkJRM2xGTzBGQlJtcENMR2xDUVVRMFFpeERRVUV4UWl4RlFVdEllRVVzVlVGTVJ5eERPenM3UVVGTlRqSkdMR2RDUVVGQlFTeFhRVUZYTEVOQlFVTXpSeXhOUVVGYU8wRkJRMEVzY1VKQlFVdFBMRTFCUVV3c1EwRkJXV2xFTEVkQlFWb3NRMEZCWjBJc05rSkJRV2hDTEVWQlFTdERjRU1zUlVGQkwwTTdiVVJCUTA4N1FVRkRTR2xHTEd0Q1FVRkJRU3hYUVVGWExFVkJRVmhCTEZkQlJFYzdRVUZGU0dFc2EwSkJRVUZCTEZkQlFWY3NSVUZCUlhCQ0xFbEJRVWtzUTBGQlEzRkNMRXRCUVV3c1EwRkJWM3BDTEVsQlFVa3NRMEZCUTBNc1IwRkJUQ3hMUVVGaExFbEJRWGhDTzBGQlJsWXNhVUk3T3pzN096czdPenM3T3pzN096czdPenM3TkVkQlQxQndRaXhQTEVWQlEwRTJReXhaTEVWQlEwRndSeXhWTEVWQlEwRjFReXhWTEVWQlEwRnFReXhQTEVWQlEwRXlReXhITEVWQlEwRlRMRms3T3pzN096czdPM1ZDUVVWNVFpeExRVUZMTWtNc1YwRkJUQ3hEUVVGcFFqbERMRTlCUVdwQ0xFVkJRVEJDZGtRc1ZVRkJNVUlzUXpzN08wRkJRVzVDYWtZc1owSkJRVUZCTEZVN08zVkNRVU4zUWl4TFFVRkxkVXdzYTBKQlFVd3NRMEZCZDBJN1FVRkRiRVF2UXl4clFrRkJRVUVzVDBGQlR5eEZRVUZRUVN4UFFVUnJSRHRCUVVWc1JHZEVMR3RDUVVGQlFTeHpRa0ZCYzBJc1JVRkJSWGhNTEZWQlJqQkNPMEZCUjJ4RWFVWXNhMEpCUVVGQkxGVkJRVlVzUlVGQlZrRXNWVUZJYTBRN1FVRkpiRVJwUkN4clFrRkJRVUVzUjBGQlJ5eEZRVUZJUVN4SFFVcHJSRHRCUVV0c1JGTXNhMEpCUVVGQkxGbEJRVmtzUlVGQldrRTdRVUZNYTBRc2FVSkJRWGhDTEVNN096czdRVUZCZEVJNFF5eG5Ra0ZCUVVFc1Z5eDVRa0ZCUVVFc1Z6dHRSRUZQUkVFc1Z6czdPenM3T3pzN096czdPenM3T3pzN096c3lSMEZKVTBNc1N5eEZRVUZsTDBrc1RTeEZRVUZuUW1kS0xHZENPenM3T3pzN08zVkNRVU14UWl4TFFVRkxMMGNzVDBGQlRDeERRVUZoWjBnc1RVRkJZaXhEUVVGdlFucEhMRXRCUVhCQ0xFTkJRVEJDTzBGQlF6TkRReXhyUWtGQlFVRXNUVUZCVFR0QlFVRkplVWNzYjBKQlFVRkJMRmxCUVZrc1JVRkJSVHRCUVVGRmRrY3NjMEpCUVVGQkxFVkJRVVVzUlVGQlJXOUhPMEZCUVU0N1FVRkJiRUlzY1VKQlFYRkRReXhuUWtGQlowSXNTVUZCU1N4RlFVRjZSQ3hEUVVSeFF6dEJRVVV6UTJoS0xHdENRVUZCUVN4TlFVRk5MRVZCUVU1QkxFMUJSakpETzBGQlJ6TkRiVW9zYTBKQlFVRkJMRTlCUVU4c1JVRkJSU3hEUVVOTU8wRkJRMGxzU2l4dlFrRkJRVUVzU1VGQlNTeEZRVUZGTEZGQlJGWTdRVUZGU1cxS0xHOUNRVUZCUVN4VFFVRlRMRVZCUVVVN1FVRkdaaXh0UWtGRVN5eERRVWhyUXp0QlFWTXpRME1zYTBKQlFVRkJMRXRCUVVzc1JVRkJSVHRCUVZSdlF5eHBRa0ZCTVVJc1F6czdPMEZCUVdaS0xHZENRVUZCUVN4Tk8yMUVRVmREUVN4TlFVRk5MRU5CUVVOd1J5eE5RVUZRTEVkQlFXZENMRU5CUVdoQ0xFZEJRVzlDYjBjc1RVRkJUU3hEUVVGRExFTkJRVVFzUTBGQk1VSXNSMEZCWjBNc1NUczdPenM3T3pzN096czdPenM3T3pzN096c3JSMEZIYmtKTExFMHNSVUZCYzBJeFJ5eFBPenM3T3p0dFJFRkRia01zUzBGQlN6SkNMRmRCUVV3c1EwRkJhVUlzYzBKQlFXcENMRVZCUVhsRE8wRkJRelZESzBVc2EwSkJRVUZCTEUxQlFVMHNSVUZCVGtFc1RVRkVORU03UVVGRk5VTXhSeXhyUWtGQlFVRXNUMEZCVHl4RlFVRlFRVHRCUVVZMFF5eHBRa0ZCZWtNc1F6czdPenM3T3pzN096czdPenM3T3pzN096dG5TRUZOWTBFc1R6czdPenM3T3pzN1FVRkRaakpITEdkQ1FVRkJRU3haTEVkQlFXVXpSeXhQUVVGUExFTkJRVU12UlN4TFFVRlNMRU5CUVdNc1IwRkJaQ3hETzBGQlEyWXlUQ3huUWtGQlFVRXNVeXhIUVVGWlJDeFpRVUZaTEVOQlFVTXhSeXhOUVVGaUxFZEJRWE5DTEVOQlFYUkNMRWRCUVRCQ05FY3NUVUZCVFN4RFFVRkRReXhSUVVGUUxFTkJRV2RDU0N4WlFVRlpMRU5CUVVNc1EwRkJSQ3hEUVVFMVFpeEZRVUZwUXl4RlFVRnFReXhEUVVFeFFpeEhRVUZwUlN4RExFVkJSMjVHTzBGQlEwRTdPenQxUWtGRGJVTXNTMEZCUzBrc1lVRkJUQ3hEUVVNdlFuSkxMR05CUkN0Q0xFVkJSUzlDTEhWRlFVWXJRaXhET3pzN1FVRkJOMEp6U3l4blFrRkJRVUVzYjBJN08zTkNRVTFHU2l4VFFVRlRMRXRCUVV0c1N5eGpPenM3T3p0dlFrRkRWSE5MTEc5Q096czdPenRuUTBGRFMycEhMRGhDTzJkRFFVRjNRbkpGTEdNN08zVkNRVUZ6UWl4TFFVRkxjMFVzYVVKQlFVd3NRMEZCZFVJN1FVRkRka1ZvUWl4clFrRkJRVUVzVDBGQlR5eEZRVUZRUVR0QlFVUjFSU3hwUWtGQmRrSXNRenM3T3p0dlEwRkJMMEpwU0N4Uk96czdiVVJCU1d4Q1JDeHZRa0ZCYjBJc1EwRkJRMnhJTEVVN096dHZRa0ZOTTBKclNDeHZRanM3T3pzN08zVkNRVVU0UWl4TFFVRkxSQ3hoUVVGTUxFTkJRVzFDU0N4VFFVRnVRaXhGUVVFNFFpeHRRa0ZCT1VJc1F6czdPMEZCUVROQ1RTeG5Ra0ZCUVVFc2EwSTdPMjlDUVVORFFTeHJRanM3T3pzN1owTkJRMHR1Unl3NFFqdG5RMEZCZDBJMlJpeFRPenQxUWtGQmFVSXNTMEZCU3pWR0xHbENRVUZNTEVOQlFYVkNPMEZCUTJ4RmFFSXNhMEpCUVVGQkxFOUJRVThzUlVGQlVFRTdRVUZFYTBVc2FVSkJRWFpDTEVNN096czdiME5CUVRGQ2FVZ3NVVHM3TzNOQ1FVOXlRa01zYTBKQlFXdENMRU5CUVVORExGZEJRVzVDTEVsQlFXdERSQ3hyUWtGQmEwSXNRMEZCUTBVc1MwRkJia0lzUzBGQk5rSXNhMEk3T3pzN08yZERRVU42UkhKSExEaENPMmREUVVGM1FuSkZMR003TzNWQ1FVRnpRaXhMUVVGTGMwVXNhVUpCUVV3c1EwRkJkVUk3UVVGRGRrVm9RaXhyUWtGQlFVRXNUMEZCVHl4RlFVRlFRVHRCUVVSMVJTeHBRa0ZCZGtJc1F6czdPenR2UTBGQkwwSnBTQ3hST3pzN08zVkNRVTFGTEV0QlFVdEdMR0ZCUVV3c1EwRkJiVUpJTEZOQlFXNUNMRVZCUVRoQ0xFbEJRVGxDTEVWQlFXOURPMEZCUXpORVVTeHJRa0ZCUVVFc1MwRkJTeXhGUVVGRk8wRkJRVVZ5U0N4dlFrRkJRVUVzUlVGQlJTeEZRVUZGTzBGQlFVNDdRVUZFYjBRc2FVSkJRWEJETEVNN096dEJRVUV6UW0xSUxHZENRVUZCUVN4clFqczdiMEpCUjB0QkxHdENPenM3T3p0blEwRkRTMjVITERoQ096dDFRa0ZGU1N4TFFVRkxReXhwUWtGQlRDeERRVUYxUWp0QlFVTjZRbWhDTEd0Q1FVRkJRU3hQUVVGUExFVkJRVkJCTzBGQlJIbENMR2xDUVVGMlFpeERPenM3TzI5RFFVWlhjVWdzYVVJc2NVSkJRMnBDTEdsRE96czdiVVJCVFVSSUxHdENRVUZyUWl4RFFVRkRjRWdzUlRzN08wRkJSM2hDTkVjc1owSkJRVUZCTEUwc1IwRkJkMEpOTEc5Q0xHRkJRVUZCTEc5Q0xHZEVRVUZCUVN4dlFrRkJiMElzUTBGQlJVMHNUU3d3UkVGQmRFSXNjMEpCUVRoQ1F5eFpPenR6UWtGRGVFUXNRMEZCUTJJc1RVRkJSQ3hKUVVGWFFTeE5RVUZOTEVOQlFVTjZSeXhOUVVGUUxFdEJRV3RDTEVNN096czdPMmxEUVVOMlFtTXNPRUk3TzNWQ1FVVkpMRXRCUVV0RExHbENRVUZNTEVOQlFYVkNPMEZCUTNwQ2FFSXNhMEpCUVVGQkxFOUJRVThzUlVGQlVFRTdRVUZFZVVJc2FVSkJRWFpDTEVNN096czdjVU5CUmxkeFNDeHBRaXh6UWtGRGFrSXNPRU03T3pzN2RVSkJUV2xDTEV0QlFVdEhMR2xDUVVGTUxFTkJRWFZDWkN4TlFVRjJRaXhGUVVFclFqRkhMRTlCUVM5Q0xFTTdPenRCUVVGdVFubElMR2RDUVVGQlFTeFZPMEZCUTBGRExHZENRVUZCUVN4VExFZEJRVmxFTEZVc1lVRkJRVUVzVlN3MFEwRkJRVUVzVlVGQlZTeERRVUZGUlN4TExITkVRVUZhTEd0Q1FVRnRRa1FzVXpzN2IwSkJRMmhEUVN4VE96czdPenRwUTBGRFN6TkhMRGhDT3p0MVFrRkZTU3hMUVVGTFF5eHBRa0ZCVEN4RFFVRjFRanRCUVVONlFtaENMR3RDUVVGQlFTeFBRVUZQTEVWQlFWQkJPMEZCUkhsQ0xHbENRVUYyUWl4RE96czdPM0ZEUVVaWGNVZ3NhVUlzYzBKQlEycENMSEZET3pzN2JVUkJUVVJMTEZNN096czdPenM3T3pzN096czdPenM3T3pzN05rZEJSMWRGTEVzc1JVRkJaVFZJTEU4N096czdPenQxUWtGRGFrSXNTMEZCUzNkSUxHbENRVUZNTEVOQlFYVkNMRU5CUTI1RE8wRkJRMGxzUWl4clFrRkJRVUVzV1VGQldTeEZRVUZGYzBJc1MwRkJTeXhEUVVGRGRFSXNXVUZCVGl4SlFVRnpRaXhEUVVSNFF6dEJRVVZKWXl4clFrRkJRVUVzUzBGQlN5eEZRVUZGVVN4TFFVRkxMRU5CUVVOU0xFdEJRVTRzU1VGQlpUdEJRVVl4UWl4cFFrRkViVU1zUTBGQmRrSXNSVUZMWW5CSUxFOUJUR0VzUXpzN096czdPenM3T3pzN096czdPenM3T3pzN096c3lSMEZSUVRaSUxFOHNSVUZCYVVJM1NDeFBMRVZCUVdsQ2JVSXNUenM3T3pzN096dDFRa0ZET1VJc1MwRkJTemxDTEU5QlFVd3NRMEZCWVdkSUxFMUJRV0lzUTBGQmIwSjVRaXhQUVVGd1FpeERRVUUwUWp0QlFVTTFRMnBKTEd0Q1FVRkJRU3hOUVVGTkxFVkJRVVU3UVVGRFNtdEpMRzlDUVVGQlFTeFJRVUZSTEVWQlFVVTdRVUZEVGt3c2MwSkJRVUZCTEZOQlFWTXNSVUZCUlR0QlFVRkZNMGdzZDBKQlFVRkJMRVZCUVVVc1JVRkJSVGhJTzBGQlFVNDdRVUZFVEN4eFFrRkVUanRCUVVsS1J5eHZRa0ZCUVVFc1JVRkJSU3hGUVVGRk8wRkJRMEZETEhOQ1FVRkJRU3haUVVGWkxFVkJRVVU3UVVGRFZsQXNkMEpCUVVGQkxGTkJRVk1zUlVGQlJUdEJRVUZGTTBnc01FSkJRVUZCTEVWQlFVVXNSVUZCUlRoSU8wRkJRVTQ3UVVGRVJEdEJRVVJrTzBGQlNrRXNiVUpCUkc5RE8wRkJWelZEZWtzc2EwSkJRVUZCTEUxQlFVMHNSVUZCUlRoTExGbEJXRzlETzBGQldUVkRMMGNzYTBKQlFVRkJMRTlCUVU4c1JVRkJVRUU3UVVGYU5FTXNhVUpCUVRWQ0xFTTdPenRCUVVGa2VVY3NaMEpCUVVGQkxFczdaME5CWlVaQkxFc3NZVUZCUVVFc1N5eDFRa0ZCUVVFc1MwRkJTeXhEUVVGRlR5eFhPenM3T3pzN096dDFRa0ZCZFVJc1MwRkJTME1zWlVGQlRDeERRVUZ4UWxJc1MwRkJja0lzUlVGQk5FSTFTQ3hQUVVFMVFpeERPenM3T3pzN096czdPenR0UkVGRGRrSXNTMEZCUzFnc1QwRkJUQ3hEUVVGaFowZ3NUVUZCWWl4RFFVRnZRbmxDTEU5QlFYQkNMRU5CUVRSQ08wRkJReTlDYWtrc2EwSkJRVUZCTEUxQlFVMHNSVUZCUlR0QlFVTktReXh2UWtGQlFVRXNSVUZCUlN4RlFVRkZPMEZCUVVWMVNTeHpRa0ZCUVVFc1JVRkJSU3hGUVVGRlZDeExRVUZMTEVOQlFVTTVTRHRCUVVGYUxIRkNRVVJCTzBGQlJVcHBTU3h2UWtGQlFVRXNVVUZCVVN4RlFVRkZPMEZCUTA1TUxITkNRVUZCUVN4VFFVRlRMRVZCUVVVN1FVRkJSVE5JTEhkQ1FVRkJRU3hGUVVGRkxFVkJRVVU0U0R0QlFVRk9PMEZCUkV3N1FVRkdUaXh0UWtGRWRVSTdRVUZQTDBKNlN5eHJRa0ZCUVVFc1RVRkJUU3hGUVVGRk9Fc3NXVUZRZFVJN1FVRlJMMEl2Unl4clFrRkJRVUVzVDBGQlR5eEZRVUZRUVR0QlFWSXJRaXhwUWtGQk5VSXNRenM3TzIxRVFWZEtlVWNzU3pzN096czdPenM3T3pzN096czdPenM3T3p0blNFRkhZMjVKTEUwN096czdPenRCUVVObU5ra3NaMEpCUVVGQkxGVXNSMEZCWVd4RkxFbEJRVWtzUTBGQlEwTXNSMEZCVEN4Rk8wRkJRMkpNTEdkQ1FVRkJRU3hOTEVkQlFWTjJSU3hOUVVGTkxFTkJRVU4zUkN4UFFVRlFMRU5CUVdWbExFMUJRV1lzU1VGQmVVSXNRenM3ZFVKQlEyaENMRXRCUVV0blFpeGxRVUZNTEVOQlFYRkNka1lzVFVGQlRTeERRVUZEZDBRc1QwRkJOVUlzUXpzN08wRkJRV3hDYmtZc1owSkJRVUZCTEZNN1FVRkRRV3RETEdkQ1FVRkJRU3hQTEVkQlFWVlFMRTFCUVUwc1EwRkJRM2RFTEU5QlFWQXNRMEZCWldwRUxFODdRVUZEZWtKMlJpeG5Ra0ZCUVVFc1ZTeHhRa0ZCYTBKblJpeE5RVUZOTEVOQlFVTjNSeXh6UWp0QlFVTXpRa01zWjBKQlFVRkJMRmNzUjBGQll5eEpPenRCUVVWU2NVTXNaMEpCUVVGQkxGVXNSMEZCWVN4Rk8wRkJSV0pETEdkQ1FVRkJRU3hSTEVkQlFWZDRSU3hOUVVGTkxFbEJRMmhDVVN4SlFVRkpMRU5CUVVOeFFpeExRVUZNTEVOQlFWY3NRMEZCUTNwQ0xFbEJRVWtzUTBGQlEwTXNSMEZCVEN4TFFVRmhMRXRCUVV0d1JpeE5RVUZNTEVOQlFWbDNTaXgzUWtGQldpeEZRVUZrTEVsQlFYZEVMRWxCUVc1RkxFTTdRVUZGUkVNc1owSkJRVUZCTEZrc1IwRkJaV3BLTEUxQlFVMHNRMEZCUTJsS0xGbEJRVkFzUzBGQmQwSXNTenRCUVVOMlEwTXNaMEpCUVVGQkxGVXNSMEZCWVN4TFFVRkxNVW9zVFVGQlRDeERRVUZaZDBvc2QwSkJRVm9zUlRzN08yOUNRVU5ZZGtNc1Z6czdPenM3UVVGRFJUZENMR2RDUVVGQlFTeEhMRWRCUVUxRUxFbEJRVWtzUTBGQlEwTXNSMEZCVEN4Rk8wRkJRMDVzUkN4blFrRkJRVUVzVHl4SFFVRlZjVVFzU1VGQlNTeERRVUZEYjBVc1IwRkJUQ3hEUVVGVFNpeFJRVUZVTEVWQlFXMUNia1VzUjBGQmJrSXNTVUZCTUVKQkxFZEJRVEZDTEVkQlFXZERjMFVzVlR0QlFVTTFRMllzWjBKQlFVRkJMRXNzUjBGQmFVSXNTVHM3UVVGRldHbENMR2RDUVVGQlFTeExMRWRCUVZGNlJTeEpRVUZKTEVOQlFVTkRMRWRCUVV3c1JUczdkVUpCUTBFc1MwRkJTM2xGTEdGQlFVd3NRMEZCYlVKeVR5eFZRVUZWTEVOQlFVTnpTeXhYUVVFNVFpeEZRVUV5UXk5RkxFOUJRVE5ETEVWQlFXOUViVUlzVDBGQmNFUXNRenM3TzBGQlFXUjVSeXhuUWtGQlFVRXNTenRCUVVOTmJVSXNaMEpCUVVGQkxFY3NSMEZCVFRORkxFbEJRVWtzUTBGQlEwTXNSMEZCVEN4Rk8wRkJRMXByUlN4blFrRkJRVUVzVlVGQlZTeERRVUZEZGtjc1NVRkJXQ3hEUVVOSkxHbENRVUZWTkVZc1MwRkJTeXhEUVVGRE9VZ3NSVUZCVGl4SlFVRlpMRVZCUVhSQ0xIVkRRVU4zUW1sS0xFZEJRVWNzUjBGQlIwWXNTMEZFT1VJc2IwTkJSV3RDY2tVc1NVRkJTU3hEUVVGRGNVSXNTMEZCVEN4RFFVRlhhMFFzUjBGQlJ5eEhRVUZITEVsQlFXcENMRU5CUm14Q0xDdENRVWRuUW01Q0xFdEJRVXNzUTBGQlEyOUNMRk5CUVU0c1NVRkJiVUlzUTBGSWJrTXNRMEZFU2pzN096czdPenRCUVU5QkxIRkNRVUZMTDBvc1RVRkJUQ3hEUVVGWmFVUXNSMEZCV2l4RFFVRm5RaXgzUWtGQmFFSTdPMjlDUVVOTGQwY3NXVHM3T3pzN1FVRkRSMDhzWjBKQlFVRkJMR0U3TzNOQ1FVTkJMR05CUVUxRExFbEJRVTRzUzBGQlpVTXNOa0pCUVdGRExHZENPenM3T3p0blEwRkRXbkpKTERoQ096dDFRa0ZEVGl4TFFVRkxReXhwUWtGQlRDeERRVUYxUWp0QlFVTjZRbWhDTEd0Q1FVRkJRU3hQUVVGUExFVkJRVkJCTEU5QlJIbENPMEZCUlhwQ2MwVXNhMEpCUVVGQkxGVkJRVlVzUlVGQlJYaEhMRk5CUm1FN1FVRkhla0oxVEN4clFrRkJRVUVzVVVGQlVTeEZRVUZGTlU4c1ZVRkJWU3hEUVVGRGMwc3NWMEZJU1R0QlFVbDZRalZFTEd0Q1FVRkJRU3hQUVVGUExFVkJRVkJCTEU5QlNubENPMEZCUzNwQ2JVa3NhMEpCUVVGQkxIZENRVUYzUWl4RlFVRkZOMDhzVlVGTVJEdEJRVTE2UW5WS0xHdENRVUZCUVN4TlFVRk5MRVZCUVU1QkxFMUJUbmxDTzBGQlQzcENkVVlzYTBKQlFVRkJMRmxCUVZrc1JVRkJSVGxQTEZWQlFWVXNRMEZCUTIxTU8wRkJVRUVzYVVKQlFYWkNMRU03T3pzN1FVRkVWbkZFTEdkQ1FVRkJRU3hoTEdsQ1FVRXJRazhzWVRzN08zTkNRVmszUWxBc1lUczdPMEZCUlZZc2NVSkJRVXRvU3l4TlFVRk1MRU5CUVZscFJDeEhRVUZhTEVOQlFXZENMR2RDUVVGb1FqczdPM0ZDUVVkQk1FWXNTenM3T3pzN1FVRkRRVzVPTEdkQ1FVRkJRU3hWUVVGVkxFTkJRVU56U3l4WFFVRllMRWRCUVhsQ05rTXNTMEZCU3l4RFFVRkRPVWdzUlVGQlRpeEpRVUZaTEVWQlFYSkRPMEZCUlUweVNpeG5Ra0ZCUVVFc1N5eEhRVUZSTEVOQlFVTTNRaXhMUVVGTExFTkJRVU00UWl4WlFVRk9MRWxCUVhOQ0xFVkJRWFpDTEVWQlFUSkNReXhKUVVFelFpeERRVUZuUXl4VlFVRkJReXhEUVVGRE8wRkJRVUVzZVVKQlFVbEJMRU5CUVVNc1EwRkJRME1zVFVGQlJpeExRVUZoTDB3c1UwRkJha0k3UVVGQlFTeHBRa0ZCYWtNc1F6czdjVUpCUTFZeVRDeExPenM3T3p0QlFVTk5TeXhuUWtGQlFVRXNZU3hIUVVGblFrd3NTMEZCU3l4RFFVRkRUU3hqT3p0dlFrRkRka0pFTEdFN096czdPMmREUVVOTEwwa3NPRUk3TzNWQ1FVVkpMRXRCUVV0RExHbENRVUZNTEVOQlFYVkNPMEZCUTNwQ2FFSXNhMEpCUVVGQkxFOUJRVThzUlVGQlVFRXNUMEZFZVVJN1FVRkZla0p6UlN4clFrRkJRVUVzVlVGQlZTeEZRVUZGZUVjN1FVRkdZU3hwUWtGQmRrSXNRenM3T3p0dlEwRkdWM1ZLTEdsQ0xIRkNRVU5xUWl4dlF6czdPMEZCVDBZeVF5eG5Ra0ZCUVVFc1R5eEhRVUZWTlVZc1NVRkJTU3hEUVVGRFF5eEhRVUZNTEVVN08zVkNRVU5KTEV0QlFVdG9SaXhQUVVGTUxFTkJRV0UwU3l4WlFVRmlMRU5CUVRCQ2JrTXNUMEZCTVVJc1EwRkJhME03UVVGRGJFUnFTU3hyUWtGQlFVRXNUVUZCVFN4RlFVRkZPMEZCUVVWRExHOUNRVUZCUVN4RlFVRkZMRVZCUVVVN1FVRkJSVU1zYzBKQlFVRkJMRVZCUVVVc1JVRkJSU3RLTzBGQlFVNDdRVUZCVGl4dFFrRkVNRU03UVVGRmJFUXhUU3hyUWtGQlFVRXNUVUZCVFN4RlFVRkZPRTBzTWtKQlJqQkRPMEZCUjJ4RUwwa3NhMEpCUVVGQkxFOUJRVThzUlVGQlJXZEtPMEZCU0hsRExHbENRVUZzUXl4RE96czdRVUZCY0VKcVJTeG5Ra0ZCUVVFc1Z6dEJRVXRCTVVnc1owSkJRVUZCTEZsQlFWa3NRMEZCUXl4TFFVRkxVeXhOUVVGTUxFTkJRVmx3UWl4TlFVRmlMRVZCUVhGQ1F5eFRRVUZ5UWl4RlFVRm5ReXh4UWtGQmFFTXNSVUZCZFVRN1FVRkRMMFJuVFN4clFrRkJRVUVzWVVGQllTeEZRVUZpUVR0QlFVUXJSQ3hwUWtGQmRrUXNRMEZCV2p0QlFVZEJka0lzWjBKQlFVRkJMRlZCUVZVc1EwRkJRM1pITEVsQlFWZ3NkMEpCUVdkRE9FZ3NZVUZCYUVNc2EwTkJRWEZGTVVZc1NVRkJTU3hEUVVGRFF5eEhRVUZNTEV0QlFXRXlSaXhQUVVGc1JqczdPenM3YzBKQlEwOHNRMEZCUTNCRExFdEJRVXNzUTBGQlEyOUNMRk5CUVU0c1NVRkJiVUlzUTBGQmNFSXNTVUZCZVVKU0xGRTdPenM3TzNGQ1FVTTFRbmhGTEUwN096czdPMEZCUTBGNFJpeG5Ra0ZCUVVFc1dVRkJXU3hEUVVGRExFdEJRVXRUTEUxQlFVd3NRMEZCV1hCQ0xFMUJRV0lzUlVGQmNVSkRMRk5CUVhKQ0xFVkJRV2RETEdkQ1FVRm9ReXhGUVVGclJDeEZRVUZzUkN4RFFVRmFPMmREUVVOTmFVUXNPRUk3TzNWQ1FVTkpMRXRCUVV0RExHbENRVUZNTEVOQlFYVkNPMEZCUTNwQ2FFSXNhMEpCUVVGQkxFOUJRVThzUlVGQlVFRXNUMEZFZVVJN1FVRkZla0p6UlN4clFrRkJRVUVzVlVGQlZTeEZRVUZGZUVjc1UwRkdZVHRCUVVkNlFubE1MR3RDUVVGQlFTeFpRVUZaTEVWQlFVVTVUeXhWUVVGVkxFTkJRVU50VEN4WFFVaEJPMEZCU1hwQ05VSXNhMEpCUVVGQkxFMUJRVTBzUlVGQlJYZEZMRkZCU21sQ08wRkJTM3BDTkVJc2EwSkJRVUZCTEZWQlFWVXNSVUZCUlhoRExFdEJRVXNzUTBGQlEyOUNMRk5CVEU4N1FVRk5la0pMTEd0Q1FVRkJRU3hSUVVGUkxFVkJRVVUxVHl4VlFVRlZMRU5CUVVOelN6dEJRVTVKTEdsQ1FVRjJRaXhET3pzN08yOURRVVJYYzBZc1l6czdPMmREUVZkdVFuUktMRGhDT3p0MVFrRkRTU3hMUVVGTFF5eHBRa0ZCVEN4RFFVRjFRanRCUVVONlFtaENMR3RDUVVGQlFTeFBRVUZQTEVWQlFWQkJMRTlCUkhsQ08wRkJSWHBDYzBVc2EwSkJRVUZCTEZWQlFWVXNSVUZCUlhoSExGTkJSbUU3UVVGSGVrSjVUQ3hyUWtGQlFVRXNXVUZCV1N4RlFVRkZPVThzVlVGQlZTeERRVUZEYlV3c1YwRklRVHRCUVVsNlFucEZMR3RDUVVGQlFTeFBRVUZQTEVWQlFWQkJMRTlCU25sQ08wRkJTM3BDYlVrc2EwSkJRVUZCTEhkQ1FVRjNRaXhGUVVGRk4wODdRVUZNUkN4cFFrRkJka0lzUXpzN096dHZRMEZFVnpaUUxITkNPenM3T3pzN08wRkJZV3BETDBJc1owSkJRVUZCTEZWQlFWVXNRMEZCUTJkRExFMUJRVmdzUTBGQmEwSXNRMEZCYkVJc1JVRkJjVUlzUTBGQmNrSXNjME5CUVhGRWJrY3NTVUZCU1N4RFFVRkRReXhIUVVGTUxFdEJRV0ZwUlN4VlFVRnNSVHRCUVVOQkxIRkNRVUZMY2tvc1RVRkJUQ3hEUVVGWmFVUXNSMEZCV2l4RFFVRm5RbkZITEZWQlFWVXNRMEZCUTJsRExFbEJRVmdzUTBGQlowSXNTVUZCYUVJc1EwRkJhRUk3T3pzN096czdRVUZGUVN4eFFrRkJTM1pNTEUxQlFVd3NRMEZCV1dsRUxFZEJRVm9zUTBGQlowSXNjMEpCUVdoQ0xFVkJRWGRETEZGQlFYaERPenR6UWtGRFNTeGpRVUZOWjBnc1NVRkJUaXhMUVVGbFF5dzJRa0ZCWVhOQ0xHVkJRVFZDTEVsQlEwY3NZMEZCVFhaQ0xFbEJRVTRzUzBGQlpVTXNOa0pCUVdGMVFpeDNRanM3T3pzN08zVkNRVU51UWl4TFFVRkxReXh2UWtGQlRDeG5Ra0ZGVW14TUxFMUJRVTBzUTBGQlEzZEVMRTlCUVZBc1EwRkJaV2xDTEdsQ1FVWlFMRVZCUjFKNlNpeFZRVUZWTEVOQlFVTnRUQ3hYUVVoSUxFVkJTVkkxUml4UFFVcFJMRU03T3pzN096czdPenR0UkVGWFlpeExRVUZMTkVzc2EwSkJRVXdzUTBGRFNEVkxMRTlCUkVjc1JVRkZTR3RITEZkQlJrY3NSVUZIU0hwSExFMUJRVTBzUTBGQlEydEVMRWRCU0Vvc1JVRkpTR3hFTEUxQlFVMHNRMEZCUXpKRUxGbEJTa29zUXpzN096czdPenM3T3pzN096czdPenM3T3p0blNFRlZVSEJFTEU4c1JVRkRRV3RITEZjc1JVRkRRWFpFTEVjc1JVRkRRVk1zV1RzN096czdPenM3ZFVKQlIzbENMRXRCUVV0NlFpeFhRVUZNTEVOQlFXbENMQ3RDUVVGcVFpeEZRVUZyUkR0QlFVTnVSWFZGTEd0Q1FVRkJRU3hYUVVGWExFVkJRVmhCTEZkQlJHMUZPMEZCUlc1RmRrUXNhMEpCUVVGQkxFZEJRVWNzUlVGQlNFRXNSMEZHYlVVN1FVRkhia1ZUTEd0Q1FVRkJRU3haUVVGWkxFVkJRVnBCTEZsQlNHMUZPMEZCU1c1RmNFUXNhMEpCUVVGQkxFOUJRVThzUlVGQlVFRTdRVUZLYlVVc2FVSkJRV3hFTEVNN096dEJRVUZtTlVNc1owSkJRVUZCTEUwN08wRkJUMFk0U1N4clFrRkJRVUVzVjBGQlZ5eEZRVUZZUVR0dFFrRkRSemxKTEUwN096czdPenQxUWtGSFowSXNTMEZCUzJsRExFOUJRVXdzUTBGQllVMHNVVUZCWWl4RFFVRnpRa01zUzBGQmRFSXNRMEZCTkVJN1FVRkRMME5ETEd0Q1FVRkJRU3hOUVVGTkxFVkJRVVU3UVVGQlJVTXNiMEpCUVVGQkxFVkJRVVVzUlVGQlJUdEJRVUZGUXl4elFrRkJRVUVzUlVGQlJTeEZRVUZGUXp0QlFVRk9PMEZCUVU0c2JVSkJSSFZETzBGQlJTOUROVU1zYTBKQlFVRkJMRTFCUVUwc1JVRkJSU3hyUWtGR2RVTTdRVUZITDBNclJDeHJRa0ZCUVVFc1QwRkJUeXhGUVVGRk8wRkJTSE5ETEdsQ1FVRTFRaXhET3pzN1FVRkJha0o0UWl4blFrRkJRVUVzVVRzN2MwSkJTMFpCTEZGQlFWRXNRMEZCUTAwc1RVRkJWQ3hMUVVGdlFpeERPenM3T3p0blEwRkRaR01zT0VJN1owTkJRMFptTEU4N08zVkNRVU5OTEV0QlFVdG5RaXhwUWtGQlRDeERRVUYxUWp0QlFVTjZRalpLTEd0Q1FVRkJRU3hqUVVGakxHVkJSRmM3UVVGRmVrSTNTeXhyUWtGQlFVRXNUMEZCVHl4RlFVRlFRU3hQUVVaNVFqdEJRVWQ2UWpoTExHdENRVUZCUVN4aFFVRmhMRVZCUVVVeFNEdEJRVWhWTEdsQ1FVRjJRaXhET3pzN08yOURRVVpYTWtnc1l6czdPenM3T3pzN096czdPenM3T3pzN096czdPenRyU0VGak4wSkRMRXNzUlVGRFFVTXNZU3hGUVVOQlF5eEpMRVZCUTBGc1RDeFBPenM3T3pzN08zVkNRVVYxUWl4TFFVRkxXQ3hQUVVGTUxFTkJRV0ZOTEZGQlFXSXNRMEZCYzBKRExFdEJRWFJDTEVOQlFUUkNPMEZCUXk5RFF5eHJRa0ZCUVVFc1RVRkJUU3hGUVVGRk8wRkJRVVZETEc5Q1FVRkJRU3hGUVVGRkxFVkJRVVU3UVVGQlJVTXNjMEpCUVVGQkxFVkJRVVVzUlVGQlJVTTdRVUZCVGp0QlFVRk9MRzFDUVVSMVF6dEJRVVV2UXpWRExHdENRVUZCUVN4TlFVRk5MRVZCUVVVc2QwWkJSblZETzBGQlJ5OURLMFFzYTBKQlFVRkJMRTlCUVU4c1JVRkJSVHRCUVVoelF5eHBRa0ZCTlVJc1F6czdPMEZCUVdwQ2VFSXNaMEpCUVVGQkxGRTdPM05DUVV0R1FTeFJRVUZSTEVOQlFVTk5MRTFCUVZRc1MwRkJiMElzUXpzN096czdaME5CUTJKakxEaENPMmREUVVOSVppeFBPenQxUWtGRFRTeExRVUZMWjBJc2FVSkJRVXdzUTBGQmRVSTdRVUZEZWtKb1FpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGUVFTeFBRVVI1UWp0QlFVVjZRalpMTEd0Q1FVRkJRU3hqUVVGakxFVkJRVVZITzBGQlJsTXNhVUpCUVhaQ0xFTTdPenM3YVVWQlJsbEVMR003T3p0QlFWRndRakZLTEdkQ1FVRkJRU3hQTEVkQlFWVXhRaXhSUVVGUkxFTkJRVU1zUTBGQlJDeERPMEZCUTNoQ2FFUXNaMEpCUVVGQkxHTkJRV01zUTBGQlF6QkZMRTlCUVVRc1EwRkJaRHM3TzNWQ1FVVlZMRXRCUVV0TkxGZEJRVXdzUTBGQmFVSXNlVUpCUVdwQ0xFVkJRVFJETzBGQlF6bERNMElzYTBKQlFVRkJMRTlCUVU4c1JVRkJVRUVzVDBGRU9FTTdRVUZGT1VOeFFpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGUVFTeFBRVVk0UXp0QlFVYzVRelJLTEd0Q1FVRkJRU3hoUVVGaExFVkJRV0pCTEdGQlNEaERPMEZCU1RsRFF5eHJRa0ZCUVVFc1NVRkJTU3hGUVVGS1FTeEpRVW80UXp0QlFVczVRME1zYTBKQlFVRkJMRk5CUVZNc1JVRkJSVWc3UVVGTWJVTXNhVUpCUVRWRExFTTdPenM3T3pzN096czdPenR0UkVGVlNFRXNTenM3T3pzN096czdPenM3T3pzN096czdPenQzUjBGSFRXaE1MRThzUlVGQmFVSk9MRlU3T3pzN096czdkVUpCUTFJc1MwRkJTMHdzVDBGQlRDeERRVUZoVFN4UlFVRmlMRU5CUVhOQ1F5eExRVUYwUWl4RFFVRTBRanRCUVVNNVEwTXNhMEpCUVVGQkxFMUJRVTBzUlVGQlJUdEJRVU5LUXl4dlFrRkJRVUVzUlVGQlJTeEZRVUZGTzBGQlFVVkRMSE5DUVVGQlFTeEZRVUZGTEVWQlFVVkRPMEZCUVU0c2NVSkJSRUU3UVVGRlNtOU1MRzlDUVVGQlFTeFJRVUZSTEVWQlFVVTdRVUZCUlhKTUxITkNRVUZCUVN4RlFVRkZMRVZCUVVVMVJTeFpRVUZaTEVOQlFVTkZPMEZCUVc1Q08wRkJSazRzYlVKQlJITkRPMEZCU3psREswSXNhMEpCUVVGQkxFMUJRVTBzUlVGQlJTeEpRVXh6UXp0QlFVMDVRM05ETEd0Q1FVRkJRU3hWUVVGVkxFVkJRVlpCTzBGQlRqaERMR2xDUVVFMVFpeERPenM3UVVGQmFFSXlRaXhuUWtGQlFVRXNUenR0UkVGUlEwRXNUMEZCVHl4RFFVRkRjRUlzVFVGQlVpeEhRVUZwUWl4RE96czdPenM3T3pzN096czdPenM3T3pzN08ydElRVWw0UW1kRUxFOHNSVUZEUVhaRUxGVXNSVUZEUVhWRExGVTdPenM3T3p0QlFVVkJMSEZDUVVGTGFFUXNUVUZCVEN4RFFVRlphVVFzUjBGQldpeERRVUZuUWl4elFrRkJhRUlzUlVGQmQwTmxMRTlCUVhoRE96dDFRa0ZEVlN4TFFVRkxiMGtzVlVGQlRDeERRVUZuUW5CSkxFOUJRVThzUTBGQlEycEVMRTlCUVhoQ0xFVkJRV2xEVGl4VlFVRnFReXhET3pzN096czdPenR0UkVGRFF6dEJRVU5JVFN4clFrRkJRVUVzVDBGQlR5eEZRVUZGYVVRc1QwRkJUeXhEUVVGRGFrUXNUMEZFWkR0QlFVVkljMHdzYTBKQlFVRkJMR1ZCUVdVc1JVRkJSVHRCUVVaa0xHbENPenM3TzNWQ1FVdGpMRXRCUVV0MlJpeFhRVUZNTEVOQlFXbENPVU1zVDBGQlR5eERRVUZEUVN4UFFVRjZRaXhGUVVGclEzWkVMRlZCUVd4RExFTTdPenRCUVVGdVFtcEdMR2RDUVVGQlFTeFZPMjFFUVVORExFdEJRVXM0VVN4M1FrRkJUQ3hEUVVFNFFuUkpMRTlCUVRsQ0xFVkJRWFZEZUVrc1ZVRkJka01zUlVGQmJVUnBSaXhWUVVGdVJDeERPenM3T3pzN096czdPenM3T3pzN096czdPM05JUVVsUU9Fd3NZU3hGUVVOQmRrWXNjMElzUlVGRFFYWkhMRlVzUlVGRFFXZEtMRms3T3pzN096dEJRVVZOZWtZc1owSkJRVUZCTEU4c1IwRkJWWFZKTEdGQlFXRXNRMEZCUTNaSkxFODdPM1ZDUVVOVUxFdEJRVXNyUXl4clFrRkJUQ3hEUVVGM1FqdEJRVU42UXk5RExHdENRVUZCUVN4UFFVRlBMRVZCUVZCQkxFOUJSSGxETzBGQlJYcERaMFFzYTBKQlFVRkJMSE5DUVVGelFpeEZRVUYwUWtFc2MwSkJSbmxETzBGQlIzcERka2NzYTBKQlFVRkJMRlZCUVZVc1JVRkJWa0VzVlVGSWVVTTdRVUZKZWtOblNpeHJRa0ZCUVVFc1dVRkJXU3hGUVVGYVFUdEJRVXA1UXl4cFFrRkJlRUlzUXpzN08wRkJRV1owVEN4blFrRkJRVUVzVFR0dFJrRlBRMEVzVFR0QlFVTklORU1zYTBKQlFVRkJMRTlCUVU4c1JVRkJSV2xFTEU5QlFVOHNRMEZCUTJwRUxFODdRVUZEYWtKelRDeHJRa0ZCUVVFc1pVRkJaU3hGUVVGRk96czdPenM3T3pzN096czdPenM3T3pzN096c3JSMEZOY2tKSExGVXNSVUZEUVM5TUxGVTdPenM3T3p0QlFVVkJMSEZDUVVGTFZDeE5RVUZNTEVOQlFWbHBSQ3hIUVVGYUxFTkJRV2RDTEcxQ1FVRm9RaXhGUVVGeFEzVktMRlZCUVhKRE96dDFRa0ZEZVVJc1MwRkJTekZHTEZkQlFVd3NRMEZCYVVJd1JpeFZRVUZWTEVOQlFVTjRTU3hQUVVFMVFpeEZRVUZ4UTNaRUxGVkJRWEpETEVNN096dEJRVUZ1UW1wR0xHZENRVUZCUVN4Vk8yMUVRVU5ETEV0QlFVdHBVaXh4UWtGQlRDeERRVUV5UWtRc1ZVRkJNMElzUlVGQmRVTm9VaXhWUVVGMlF5eEZRVUZ0UkdsR0xGVkJRVzVFTEVNN096czdPenM3T3pzN096czdPenM3T3pzN2JVaEJTVkFyVEN4VkxFVkJRMEY0Uml4elFpeEZRVU5CZGtjc1ZTeEZRVU5CWjBvc1dUczdPenM3YlVSQlJVOHNTMEZCU3pGRExHdENRVUZNTEVOQlFYZENPMEZCUXpOQ0wwTXNhMEpCUVVGQkxFOUJRVThzUlVGQlJYZEpMRlZCUVZVc1EwRkJRM2hKTEU5QlJFODdRVUZGTTBKblJDeHJRa0ZCUVVFc2MwSkJRWE5DTEVWQlFYUkNRU3h6UWtGR01rSTdRVUZITTBKMlJ5eHJRa0ZCUVVFc1ZVRkJWU3hGUVVGV1FTeFZRVWd5UWp0QlFVa3pRbWRLTEd0Q1FVRkJRU3haUVVGWkxFVkJRVnBCTEZsQlNqSkNPMEZCU3pOQ0wwWXNhMEpCUVVGQkxFZEJRVWNzUlVGQlJUaEpMRlZCUVZVc1EwRkJRemxKTEVkQlRGYzdRVUZOTTBKVExHdENRVUZCUVN4WlFVRlpMRVZCUVVWeFNTeFZRVUZWTEVOQlFVTnlTVHRCUVU1RkxHbENRVUY0UWl4RE96czdPenM3T3pzN096czdPenM3TzBGQlZWZzdPenM3T3pzN096czdPMjlJUVZGSk0wUXNUU3hGUVVOQmEwMHNWU3hGUVVOQmFrMHNWVHM3T3pzN08wRkJSVUVzY1VKQlFVdFVMRTFCUVV3c1EwRkJXV2xFTEVkQlFWb3NRMEZCWjBJc2QwSkJRV2hDTEVWQlFUQkRla01zVFVGQk1VTTdPM1ZDUVVWelFpeExRVUZMZVVJc1ZVRkJUQ3hEUVVGblFucENMRTFCUVUwc1EwRkJRMDhzVDBGQmRrSXNSVUZCWjBNc1NVRkJhRU1zUlVGQmMwTXlUQ3hWUVVGMFF5eEZRVUZyUkdwTkxGVkJRV3hFTEVNN096dEJRVUZvUWpKQ0xHZENRVUZCUVN4UE8yMUVRVVZETEV0QlFVdE5MRmRCUVV3c1EwRkJhVUlzZVVKQlFXcENMRVZCUVRSRE8wRkJReTlETTBJc2EwSkJRVUZCTEU5QlFVOHNSVUZCUlZBc1RVRkJUU3hEUVVGRFR5eFBRVVFyUWp0QlFVVXZRM0ZDTEd0Q1FVRkJRU3hQUVVGUExFVkJRVkJCTEU5QlJpdERPMEZCUnk5RGMwSXNhMEpCUVVGQkxFZEJRVWNzUlVGQlJXeEVMRTFCUVUwc1EwRkJRMnRFTEVkQlNHMURPMEZCU1M5RFV5eHJRa0ZCUVVFc1dVRkJXU3hGUVVGRk0wUXNUVUZCVFN4RFFVRkRNa1FzV1VGS01FSTdRVUZMTDBNMlNDeHJRa0ZCUVVFc1lVRkJZU3hGUVVGRmVFd3NUVUZCVFN4RFFVRkRkMFFzVDBGQlVDeERRVUZsYVVJN1FVRk1hVUlzYVVKQlFUVkRMRU03T3pzN096czdPenM3T3pzN096dFJRVk5ZT3pzN096dDVSMEZMU1hwRkxFMHNSVUZEUVVNc1ZUczdPenM3TzBGQlJVRXNjVUpCUVV0VUxFMUJRVXdzUTBGQldXbEVMRWRCUVZvc1EwRkJaMElzWVVGQmFFSXNSVUZCSzBKNlF5eE5RVUV2UWpzN2RVSkJSWE5DTEV0QlFVdDVRaXhWUVVGTUxFTkJRV2RDZWtJc1RVRkJUU3hEUVVGRFR5eFBRVUYyUWl4RlFVRm5ReXhKUVVGb1F5eEZRVUZ6UTFBc1RVRkJUU3hEUVVGRGEwMHNWVUZCTjBNc1JVRkJlVVJxVFN4VlFVRjZSQ3hET3pzN1FVRkJhRUl5UWl4blFrRkJRVUVzVHpzN1FVRkZUaXh2UWtGQlNUVkNMRTFCUVUwc1EwRkJRMjFOTEdOQlFWZ3NSVUZCTWtJN1FVRkRka0oyU3l4clFrRkJRVUVzVDBGQlR5eERRVUZEYkVJc1QwRkJVaXhIUVVGclFpeExRVUZMTUV3c1ZVRkJka0k3UVVGRFNEczdiVVJCUlUwc1MwRkJTMnhMTEZkQlFVd3NRMEZCYVVJc2JVSkJRV3BDTEVWQlFYTkRPMEZCUTNwRE0wSXNhMEpCUVVGQkxFOUJRVThzUlVGQlJWQXNUVUZCVFN4RFFVRkRUeXhQUVVSNVFqdEJRVVY2UTNGQ0xHdENRVUZCUVN4UFFVRlBMRVZCUVZCQkxFOUJSbmxETzBGQlIzcERjMElzYTBKQlFVRkJMRWRCUVVjc1JVRkJSV3hFTEUxQlFVMHNRMEZCUTJ0RUxFZEJTRFpDTzBGQlNYcERVeXhyUWtGQlFVRXNXVUZCV1N4RlFVRkZNMFFzVFVGQlRTeERRVUZETWtRc1dVRktiMEk3UVVGTGVrTkhMR3RDUVVGQlFTeExRVUZMTEVWQlFVVTVSQ3hOUVVGTkxFTkJRVU00UkN4TFFVd3lRanRCUVUxNlEyNUNMR3RDUVVGQlFTeFBRVUZQTEVWQlFVVXpReXhOUVVGTkxFTkJRVU15UXp0QlFVNTVRaXhwUWtGQmRFTXNRenM3T3pzN096czdPenM3T3pzN096czdPenMwUjBGWFVETkRMRTBzUlVGRFFVTXNWVHM3T3pzN08wRkJSVUVzY1VKQlFVdFVMRTFCUVV3c1EwRkJXV2xFTEVkQlFWb3NRMEZCWjBJc1owSkJRV2hDTEVWQlFXdERla01zVFVGQmJFTTdPM1ZDUVVWelFpeExRVUZMY1Uwc2JVSkJRVXdzUTBGQmVVSnlUU3hOUVVGNlFpeERPenM3UVVGQmFFSjNSQ3huUWtGQlFVRXNUenR0UkVGRlF5eExRVUZMT0Vrc2EwSkJRVXdzUTBGQmQwSTdRVUZETTBJdlRDeHJRa0ZCUVVFc1QwRkJUeXhGUVVGRmFVUXNUMEZCVHl4RFFVRkRha1FzVDBGRVZUdEJRVVV6UW1sRUxHdENRVUZCUVN4UFFVRlBMRVZCUVVWQkxFOUJRVThzUTBGQlEwRXNUMEZHVlR0QlFVY3pRakpKTEd0Q1FVRkJRU3hqUVVGakxFVkJRVVZ1VFN4TlFVRk5MRU5CUVVOdFRTeGpRVWhKTzBGQlNUTkNTU3hyUWtGQlFVRXNWVUZCVlN4RlFVRkZkazBzVFVGQlRTeERRVUZEZFUwN1FVRktVU3hwUWtGQmVFSXNSVUZMU25STkxGVkJURWtzUXpzN096czdPenM3T3pzN096czdPenM3T3p0blNFRlRVRVFzVFN4RlFVTkJReXhWT3pzN096czdRVUZGUVN4eFFrRkJTMVFzVFVGQlRDeERRVUZaYVVRc1IwRkJXaXhEUVVGblFpeHZRa0ZCYUVJc1JVRkJjME42UXl4TlFVRjBRenRCUVVWSk5FSXNaMEpCUVVGQkxFOHNSMEZCYjBJN1FVRkRjRUpzUWl4clFrRkJRVUVzVDBGQlR5eEZRVUZGTEV0QlFVc3dUQ3hWUVVSTk8wRkJSWEJDTDB3c2EwSkJRVUZCTEVWQlFVVXNSVUZCUlV3c1RVRkJUU3hEUVVGRFR5eFBRVVpUTzBGQlIzQkNNRUlzYTBKQlFVRkJMRk5CUVZNc1JVRkJSVGhETEVsQlFVa3NRMEZCUTNsSUxFdEJRVXdzUTBGQlZ6ZElMRWxCUVVrc1EwRkJRME1zUjBGQlRDeExRVUZoTEVsQlFYaENPMEZCU0ZNc2FVSTdPMjlDUVUxdVFqVkZMRTFCUVUwc1EwRkJRM1ZOTEZVN096czdPenQxUWtGRFVTeExRVUZMT1Vzc1ZVRkJUQ3hEUVVGblFucENMRTFCUVUwc1EwRkJRMDhzVDBGQmRrSXNSVUZCWjBNc1MwRkJhRU1zUlVGQmRVTlFMRTFCUVUwc1EwRkJRMnROTEZWQlFUbERMRVZCUVRCRWFrMHNWVUZCTVVRc1F6czdPMEZCUVdoQ01rSXNaMEpCUVVGQkxFODdPenRCUVVkS0xHOUNRVUZKTlVJc1RVRkJUU3hEUVVGRGJVMHNZMEZCV0N4RlFVRXlRanRCUVVOMlFuWkxMR3RDUVVGQlFTeFBRVUZQTEVOQlFVTnNRaXhQUVVGU0xFZEJRV3RDTEV0QlFVc3dUQ3hWUVVGMlFqdEJRVU5JT3p0dFJFRkZUU3hMUVVGTGJFc3NWMEZCVEN4RFFVRnBRaXgxUWtGQmFrSXNSVUZCTUVNN1FVRkROME16UWl4clFrRkJRVUVzVDBGQlR5eEZRVUZGVUN4TlFVRk5MRU5CUVVOUExFOUJSRFpDTzBGQlJUZERjVUlzYTBKQlFVRkJMRTlCUVU4c1JVRkJVRUVzVDBGR05rTTdRVUZITjBNMFNpeHJRa0ZCUVVFc1lVRkJZU3hGUVVGRmVFd3NUVUZCVFN4RFFVRkRkMFFzVDBGQlVDeERRVUZsYVVJN1FVRklaU3hwUWtGQk1VTXNRenM3T3pzN096czdPenM3T3pzN08xRkJUMWc3T3pzN096UkhRVWRKZWtVc1RUczdPenM3YlVSQlJVOHNTMEZCUzJ0RExGZEJRVXdzUTBGQmFVSXNNa0pCUVdwQ0xFVkJRVGhEYkVNc1RVRkJPVU1zUXpzN096czdPenM3T3pzN096czdPMUZCUjFnN096czdPMnRJUVVVeVFrRXNUVHM3T3pzN2JVUkJRMmhDTEV0QlFVdHJReXhYUVVGTUxFTkJRV2xDTEd0Q1FVRnFRaXhGUVVGeFF6dEJRVU40UTJkQ0xHdENRVUZCUVN4SFFVRkhMRVZCUVVWc1JDeE5RVUZOTEZkQlFVNHNRMEZCWld0RUxFZEJSRzlDTzBGQlJYaERReXhyUWtGQlFVRXNhVUpCUVdsQ0xFVkJRVVZ1UkN4TlFVRk5MRU5CUVVOdFJDeHBRa0ZHWXp0QlFVZDRRME1zYTBKQlFVRkJMR2xDUVVGcFFpeEZRVUZGY0VRc1RVRkJUU3hEUVVGRGIwUXNhVUpCU0dNN1FVRkplRU5ETEd0Q1FVRkJRU3hWUVVGVkxFVkJRVVZ5UkN4TlFVRk5MRU5CUVVOeFJDeFZRVXB4UWp0QlFVdDRRME1zYTBKQlFVRkJMRmRCUVZjc1JVRkJSWFJFTEUxQlFVMHNWMEZCVGl4RFFVRmxjMFFzVjBGTVdUdEJRVTE0UTFnc2EwSkJRVUZCTEU5QlFVOHNSVUZCUlRORExFMUJRVTBzUTBGQlF6SkRPMEZCVG5kQ0xHbENRVUZ5UXl4RE96czdPenM3T3pzN096czdPenM3T3pzN095dEhRVmRoTTBNc1RUczdPenM3YlVSQlEySXNTMEZCUzJ0RExGZEJRVXdzUTBGQmFVSXNaVUZCYWtJc1JVRkJhME03UVVGRGNrTXpRaXhyUWtGQlFVRXNUMEZCVHl4RlFVRkZVQ3hOUVVGTkxFTkJRVU5QTEU5QlJIRkNPMEZCUlhKRE1rTXNhMEpCUVVGQkxFZEJRVWNzUlVGQlJXeEVMRTFCUVUwc1EwRkJRMnRFTEVkQlJubENPMEZCUjNKRFV5eHJRa0ZCUVVFc1dVRkJXU3hGUVVGRk0wUXNUVUZCVFN4RFFVRkRNa1FzV1VGSVowSTdRVUZKY2tORExHdENRVUZCUVN4TlFVRk5MRVZCUVVVMVJDeE5RVUZOTEVOQlFVTTBSQ3hOUVVwelFqdEJRVXR5UTBVc2EwSkJRVUZCTEV0QlFVc3NSVUZCUlRsRUxFMUJRVTBzUTBGQlF6aEVMRXRCVEhWQ08wRkJUWEpEYmtJc2EwSkJRVUZCTEU5QlFVOHNSVUZCUlRORExFMUJRVTBzUTBGQlF6SkRPMEZCVG5GQ0xHbENRVUZzUXl4RE96czdPenM3T3pzN096czdPenM3T3pzN08zVkhRVmRMT0Vvc1NUczdPenM3TzBGQlEwNURMR2RDUVVGQlFTeFpMRWRCUVdVc1MwRkJTMnhPTEUxQlFVd3NRMEZCV1cxT0xHMUNRVUZhTEVVN1FVRkRXa01zWjBKQlFVRkJMRU1zUjBGQlNTeERPenM3YzBKQlFVZEJMRU5CUVVNc1NVRkJTVVlzV1RzN096czdRVUZEYWtJc2IwSkJRVWxGTEVOQlFVTXNSMEZCUnl4RFFVRlNMRVZCUVZjN1FVRkRVQ3gxUWtGQlMzQk9MRTFCUVV3c1EwRkJXV2xFTEVkQlFWb3NhMEpCUVRCQ2JVc3NRMEZCTVVJN1FVRkRTRHM3T3p0MVFrRkZaMEpJTEVsQlFVa3NRMEZCUTBjc1EwRkJSQ3hET3pzN096czdPenM3UVVGRmFrSTdRVUZEUVR0QlFVTkJPMEZCUTAxRExHZENRVUZCUVN4dlFpeEhRVUYxUWl4VFFVRjJRa0VzYjBKQlFYVkNMRU5CUVVGRExGRkJRVkU3UVVGQlFTeDVRa0ZEYWtONFRDd3JRa0ZCWlhsTUxIVkNRVUZtTEdkQ1FVRTRRMFFzVVVGQk9VTXNTMEZEUjNoTUxDdENRVUZsTUV3c2EwTkJRV1lzWjBKQlFYbEVSaXhSUVVGNlJDeERRVVk0UWp0QlFVRkJMR2xDT3p0QlFVa3ZRa2NzWjBKQlFVRkJMRkVzUjBGQlZ5eGpRVUZOZUVRc1NVRkJUaXhMUVVGbFF5dzJRa0ZCWVhOQ0xHVkJRVFZDTEVsQlExWTJRaXh2UWtGQmIwSXNRMEZCUTBzc2IwTkJRVzlDUXl4cFFrRkJja0lzUTBGRVZpeEpRVVZXVGl4dlFrRkJiMElzUTBGQlEwc3NiME5CUVc5Q2JFTXNaVUZCY2tJc1F6czdjMEpCUTNaQ0xFTkJRVU5wUXl4UlFVRkVMRWxCUVdGTUxFTkJRVU1zUzBGQlMwWXNXVHM3T3pzN096czdRVUZxUWtsRkxHZENRVUZCUVN4RFFVRkRMRWxCUVVrc1F6czdPenM3WjBOQmMwSnNRM1JNTERoQ096dDFRa0ZGU1N4TFFVRkxReXhwUWtGQlRDeEZPenM3TzI5RFFVWlhOa3dzWVN4eFFrRkRha0lzTWtJN096czdPenM3T3pzN096czdPenM3T3pzN09FZEJUMHB3VGl4TkxFVkJRMEZETEZVN096czdPenM3UVVGRlFTeHhRa0ZCUzFRc1RVRkJUQ3hEUVVGWmFVUXNSMEZCV2l4RFFVRm5RaXhqUVVGb1FqdHRSRUZEVHl4TFFVRkxORXNzVTBGQlREdEJRVUZCTERKR1FVRmxMRzFDUVVGUE4wc3NWVUZCVUR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEcxRFFVTlZMRTFCUVVrc1EwRkJRelpLTEcxQ1FVRk1MRU5CUVhsQ2NrMHNUVUZCZWtJc1JVRkJhVU4zUXl4VlFVRnFReXhEUVVSV096dEJRVUZCTzBGQlExcDFTaXcwUWtGQlFVRXNZVUZFV1R0QlFVRkJPMEZCUVVFc2JVTkJSVklzVFVGQlNTeERRVUZEU0N4VlFVRk1MRU5CUVdkQ1J5eGhRVUZoTEVOQlFVTjRUQ3hQUVVFNVFpeEZRVUYxUTA0c1ZVRkJka01zUTBGR1VUczdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVUZCTEN0RVFVZFFPMEZCUTBoTkxEaENRVUZCUVN4UFFVRlBMRVZCUVVWM1RDeGhRVUZoTEVOQlFVTjRUQ3hQUVVSd1FqdEJRVVZJYzB3c09FSkJRVUZCTEdWQlFXVXNSVUZCUlR0QlFVWmtMRFpDUVVoUE96dEJRVUZCTzBGQlFVRTdRVUZCUVN4dFEwRlJUeXhOUVVGSkxFTkJRVU4yUml4WFFVRk1MRU5CUVdsQ2VVWXNZVUZCWVN4RFFVRkRka2tzVDBGQkwwSXNSVUZCZDBOMlJDeFZRVUY0UXl4RFFWSlFPenRCUVVGQk8wRkJVVnBxUml3MFFrRkJRVUVzVlVGU1dUdEJRVUZCTEN0RVFWTllMRTFCUVVrc1EwRkJRemhSTEhkQ1FVRk1MRU5CUVRoQ1F5eGhRVUU1UWl4RlFVRTJReTlSTEZWQlFUZERMRVZCUVhsRWFVWXNWVUZCZWtRc1EwRlVWenM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3h0UWtGQlpqczdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3h2UWpzN096czdPenM3T3pzN096czdPenM3T3pzeVIwRmxVRVFzVFN4RlFVTkJReXhWT3pzN096czdPMEZCUlVFc2NVSkJRVXRVTEUxQlFVd3NRMEZCV1dsRUxFZEJRVm9zUTBGQlowSXNWMEZCYUVJN2JVUkJRMDhzUzBGQlN6UkxMRk5CUVV3N1FVRkJRU3d5UmtGQlpTeHRRa0ZCVHpkTExGVkJRVkE3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3h0UTBGRFR5eE5RVUZKTEVOQlFVTTRTeXhuUWtGQlRDeERRVUZ6UW5ST0xFMUJRWFJDTEVWQlFUaENkME1zVlVGQk9VSXNRMEZFVURzN1FVRkJRVHRCUVVOYWQwb3NORUpCUVVGQkxGVkJSRms3UVVGQlFUdEJRVUZCTEcxRFFVVlBMRTFCUVVrc1EwRkJRekZHTEZkQlFVd3NRMEZCYVVJd1JpeFZRVUZWTEVOQlFVTjRTU3hQUVVFMVFpeEZRVUZ4UTNaRUxGVkJRWEpETEVOQlJsQTdPMEZCUVVFN1FVRkZXbXBHTERSQ1FVRkJRU3hWUVVaWk8wRkJRVUVzSzBSQlIxZ3NUVUZCU1N4RFFVRkRhVklzY1VKQlFVd3NRMEZCTWtKRUxGVkJRVE5DTEVWQlFYVkRhRklzVlVGQmRrTXNSVUZCYlVScFJpeFZRVUZ1UkN4RFFVaFhPenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMRzFDUVVGbU96dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMRzlDT3pzN096czdPenM3T3pzN096czdPenM3TzNkSFFWTlFUU3hQTEVWQlEwRXpSU3hOTEVWQlEwRnpVU3hWTEVWQlEwRnFUU3hWT3pzN096czdRVUZGVFVjc1owSkJRVUZCTEUwc1IwRkJORUk3UVVGRE9VSkRMR3RDUVVGQlFTeEZRVUZGTEVWQlFVVTdRVUZCUlVNc2IwSkJRVUZCTEVWQlFVVXNSVUZCUlVNN1FVRkJUanRCUVVRd1FpeHBRanM3UVVGSGJFTXNiMEpCUVVreVRDeFZRVUZWTEVsQlFVbEJMRlZCUVZVc1EwRkJRM0ZDTEdGQlFUZENMRVZCUVRSRE8wRkJRM2hEYms0c2EwSkJRVUZCTEUxQlFVMHNRMEZCUTI5T0xHRkJRVkFzUjBGQmRVSTdRVUZCUlVNc2IwSkJRVUZCTEVWQlFVVXNSVUZCUlhaQ0xGVkJRVlVzUTBGQlEzRkNPMEZCUVdwQ0xHMUNRVUYyUWp0QlFVTklPenRCUVVORUxHOUNRVUZKTTFJc1RVRkJTaXhGUVVGWk8wRkJRMUozUlN4clFrRkJRVUVzVFVGQlRTeERRVUZEZFV3c1VVRkJVQ3hIUVVGclFqdEJRVUZGY2t3c2IwSkJRVUZCTEVWQlFVVXNSVUZCUlRWRkxGbEJRVmtzUTBGQlEwVTdRVUZCYmtJc2JVSkJRV3hDTzBGQlEwZzdPMEZCUlVRc2NVSkJRVXMwUkN4TlFVRk1MRU5CUVZscFJDeEhRVUZhTEVOQlFXZENMRzlDUVVGb1FpeEZRVUZ6UTNKRExFMUJRWFJET3p0MVFrRkRkVUlzUzBGQlMxSXNUMEZCVEN4RFFVRmhUU3hSUVVGaUxFTkJRWE5DUXl4TFFVRjBRanRCUVVOdVFrTXNhMEpCUVVGQkxFMUJRVTBzUlVGQlRrRXNUVUZFYlVJN1FVRkZia0o2UXl4clFrRkJRVUVzVFVGQlRTeEZRVUZGTzBGQlJsY3NiVUpCUjJaMVR5eFZRVUZWTEVsQlFVbEJMRlZCUVZVc1EwRkJRM2hMTEU5QlFYcENMRWRCUVcxRE8wRkJRVVZCTEd0Q1FVRkJRU3hQUVVGUExFVkJRVVYzU3l4VlFVRlZMRU5CUVVONFN6dEJRVUYwUWl4cFFrRkJia01zUjBGQmNVVXNSVUZJZEVRN1FVRkpia0o2UWl4clFrRkJRVUVzVlVGQlZTeEZRVUZXUVR0QlFVcHRRaXh0UWpzN08wRkJRV3BDUXl4blFrRkJRVUVzVVRzN2MwSkJUVVpCTEZGQlFWRXNRMEZCUTAwc1RVRkJWQ3hMUVVGdlFpeERPenM3T3p0blEwRkRaR01zT0VJN1owTkJRMFptTEU4N08zVkNRVU5OTEV0QlFVdG5RaXhwUWtGQlRDeERRVUYxUWp0QlFVTjZRbWhDTEd0Q1FVRkJRU3hQUVVGUExFVkJRVkJCTzBGQlJIbENMR2xDUVVGMlFpeERPenM3TzI5RFFVWlhLMHNzWXpzN08wRkJUMjVDTVVvc1owSkJRVUZCTEU4c1IwRkJWVEZDTEZGQlFWRXNRMEZCUXl4RFFVRkVMRU03UVVGRGVFSm9SQ3huUWtGQlFVRXNZMEZCWXl4RFFVRkRNRVVzVDBGQlJDeERRVUZrTzBGQlEwRXNjVUpCUVV0d1F5eE5RVUZNTEVOQlFWbHBSQ3hIUVVGYUxFTkJRV2RDTERoQ1FVRm9RaXhGUVVGblJHSXNUMEZCYUVRN2JVUkJRMDlCTEU4N096czdPenM3T3pzN096czdPenM3T3pzN1owaEJTVkExUWl4TkxFVkJRMEZETEZVN096czdPenRCUVVWTlRTeG5Ra0ZCUVVFc1R5eEhRVUZWVUN4TlFVRk5MRU5CUVVOUExFODdPMjlDUVVOc1FrRXNUenM3T3pzN1owTkJRMFJsTERoQ096dDFRa0ZEVlN4TFFVRkxReXhwUWtGQlRDeERRVUYxUWp0QlFVTjZRbWhDTEd0Q1FVRkJRU3hQUVVGUExFVkJRVkJCTEU5QlJIbENPMEZCUlhwQ09Fc3NhMEpCUVVGQkxHRkJRV0VzUlVGQlJYSk1MRTFCUVUwc1EwRkJRekpFTzBGQlJrY3NhVUpCUVhaQ0xFTTdPenM3T3poQ1FVUkxia01zTUVJN096dG5RMEZQU0hoQ0xFMUJRVTBzUTBGQlF6UkNMRTg3T3pzN096czdPM1ZDUVVGclFpeExRVUZMU0N4VlFVRk1MRU5CUTNKRGJFSXNUMEZFY1VNc1JVRkZja01zUzBGR2NVTXNSVUZIY2tOUUxFMUJRVTBzUTBGQlEydE5MRlZCU0RoQ0xFVkJTWEpEYWswc1ZVRktjVU1zUXpzN096czdPMEZCUVc1RE1rSXNaMEpCUVVGQkxFODdPMjlDUVUxRVFTeFBRVUZQTEVOQlFVTkRMRk03T3pzN08yZERRVU5JVUN3NFFqdG5RMEZEUm1Zc1R6dG5RMEZEUTNGQ0xFOUJRVVFzUTBGQlpXeENMRTg3TzNWQ1FVTlVMRXRCUVV0aExHbENRVUZNTEVOQlFYVkNPMEZCUTNwQ2FFSXNhMEpCUVVGQkxFOUJRVThzUlVGQlVFRXNUMEZFZVVJN1FVRkZla0k0U3l4clFrRkJRVUVzWVVGQllTeEZRVUZGY2t3c1RVRkJUU3hEUVVGRE1rUTdRVUZHUnl4cFFrRkJka0lzUXpzN096dHZRMEZJVnpkQ0xHdENPenM3YlVSQlUyeENMRXRCUVV0SkxGZEJRVXdzUTBGQmFVSXNjVUpCUVdwQ0xFVkJRWGRETzBGQlF6TkRNMElzYTBKQlFVRkJMRTlCUVU4c1JVRkJVRUVzVDBGRU1rTTdRVUZGTTBOeFFpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGUVFTeFBRVVl5UXp0QlFVY3pRM05DTEd0Q1FVRkJRU3hIUVVGSExFVkJRVVZzUkN4TlFVRk5MRU5CUVVOclJDeEhRVWdyUWp0QlFVa3pRMU1zYTBKQlFVRkJMRmxCUVZrc1JVRkJSVE5FTEUxQlFVMHNRMEZCUXpKRUxGbEJTbk5DTzBGQlN6TkRSeXhyUWtGQlFVRXNTMEZCU3l4RlFVRkZPVVFzVFVGQlRTeERRVUZET0VRc1MwRk1Oa0k3UVVGTk0wTnVRaXhyUWtGQlFVRXNUMEZCVHl4RlFVRkZNME1zVFVGQlRTeERRVUZETWtNc1QwRk9Na0k3UVVGUE0wTXJTeXhyUWtGQlFVRXNUMEZCVHl4RlFVRkZNVTRzVFVGQlRTeERRVUZETUU0N1FVRlFNa0lzYVVKQlFYaERMRU03T3pzN096czdPenM3T3pzN096czdPenM3ZFVoQldWQXhUaXhOTEVWQlEwRkRMRlU3T3pzN096dEJRVVZOVFN4blFrRkJRVUVzVHl4SFFVRlZVQ3hOUVVGTkxFTkJRVU5QTEU4N08yOUNRVU5zUWtFc1R6czdPenM3WjBOQlEwdGxMRGhDT3p0MVFrRkJaMFFzUzBGQlMwTXNhVUpCUVV3c1EwRkJkVUk3UVVGRGVrVm9RaXhyUWtGQlFVRXNUMEZCVHl4RlFVRlFRU3hQUVVSNVJUdEJRVVY2UlRoTExHdENRVUZCUVN4aFFVRmhMRVZCUVVWeVRDeE5RVUZOTEVOQlFVTXlSRHRCUVVadFJDeHBRa0ZCZGtJc1F6czdPenR2UTBGQmFrTnVReXd3UWpzN08yZERRVXRVZUVJc1RVRkJUU3hEUVVGRE5FSXNUenM3T3pzN096czdkVUpCUVd0Q0xFdEJRVXRJTEZWQlFVd3NRMEZEY2tOc1FpeFBRVVJ4UXl4RlFVVnlReXhMUVVaeFF5eEZRVWR5UTFBc1RVRkJUU3hEUVVGRGEwMHNWVUZJT0VJc1JVRkpja05xVFN4VlFVcHhReXhET3pzN096czdRVUZCYmtNeVFpeG5Ra0ZCUVVFc1R6czdiMEpCVFVSQkxFOUJRVThzUTBGQlEwTXNVenM3T3pzN1owTkJRMGhRTERoQ08yZERRVU5HWml4UE8yZERRVU5EY1VJc1QwRkJSQ3hEUVVGbGJFSXNUenM3ZFVKQlExUXNTMEZCUzJFc2FVSkJRVXdzUTBGQmRVSTdRVUZEZWtKb1FpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGUVFTeFBRVVI1UWp0QlFVVjZRamhMTEd0Q1FVRkJRU3hoUVVGaExFVkJRVVZ5VEN4TlFVRk5MRU5CUVVNeVJEdEJRVVpITEdsQ1FVRjJRaXhET3pzN08yOURRVWhYTjBJc2EwSTdPenR0UkVGVGJFSXNTMEZCUzBrc1YwRkJUQ3hEUVVGcFFpeDVRa0ZCYWtJc1JVRkJORU03UVVGREwwTXpRaXhyUWtGQlFVRXNUMEZCVHl4RlFVRlFRU3hQUVVRclF6dEJRVVV2UTNGQ0xHdENRVUZCUVN4UFFVRlBMRVZCUVZCQkxFOUJSaXRETzBGQlJ5OURjMElzYTBKQlFVRkJMRWRCUVVjc1JVRkJSV3hFTEUxQlFVMHNRMEZCUTJ0RUxFZEJTRzFETzBGQlNTOURVeXhyUWtGQlFVRXNXVUZCV1N4RlFVRkZNMFFzVFVGQlRTeERRVUZETWtRc1dVRktNRUk3UVVGTEwwTTJTQ3hyUWtGQlFVRXNZVUZCWVN4RlFVRkZlRXdzVFVGQlRTeERRVUZEZVVVc2FVSkJUSGxDTzBGQlRTOURhVW9zYTBKQlFVRkJMRTlCUVU4c1JVRkJSVEZPTEUxQlFVMHNRMEZCUXpCT08wRkJUaXRDTEdsQ1FVRTFReXhET3pzN096czdPenM3T3pzN096czdPenM3T3pCSFFWZFFReXhSTEVWQlEwRXZTeXhOT3pzN096czdRVUZGVFZrc1owSkJRVUZCTEU4c1IwRkJWVHRCUVVOYWIwc3NhMEpCUVVGQkxFMUJRVTBzUlVGQlJVUXNVVUZCVVN4RFFVRkRSVHRCUVVSTUxHbENPMEZCUjFZeFR5eG5Ra0ZCUVVFc1J5eEhRVUZOZVVRc1RVRkJUU3hEUVVGRGVrUXNSenM3Y1VKQlEyWkJMRWM3T3pzN096dDFRa0ZGTWtKQkxFZEJRVWNzUTBGQlF6SlBMRWxCUVVvc1EwRkJVM1JMTEU5QlFWUXNSVUZCYTBKMVN5eHRRMEZCYTBKcVZpeE5RVUZ3UXl4RE96czdPenQxUWtGRFNIRkhMRWRCUVVjc1EwRkJRMFVzV1VGQlNpeEZPenM3T3p0QlFVUndRbWxHTEd0Q1FVRkJRU3hsTzBGQlEwRlFMR3RDUVVGQlFTeFpPenM3TzBGQlIwWXpSU3huUWtGQlFVRXNTU3hIUVVGUGQwUXNUVUZCVFN4RFFVRkRlRVFzU1RzN2NVSkJRMmhDUVN4Sk96czdPenM3ZFVKQlEzVkNMRXRCUVV0VkxFMUJRVXdzUTBGQldXdFBMRFJDUVVGYUxFTkJRWGxETlU4c1NVRkJTU3hEUVVGRFJTeE5RVUU1UXl4RE96czdRVUZCYWtJeVR5eG5Ra0ZCUVVFc1VUczdkVUpCUlhGQ0xFdEJRVXR1VHl4TlFVRk1MRU5CUVZsdlR5eG5Ra0ZCV2l4RFFVTnVRakZMTEU5QlJHMUNMRVZCUlc1Q2VVc3NVVUZCVVN4RFFVRkRNMDhzVFVGR1ZTeEZRVWR1UW5sUExHMURRVUZyUW1wV0xFMUJTRU1zUXpzN096dG5RMEZMVkcxV0xGRkJRVkVzVlRzN1FVRk1kRUl6U2l4clFrRkJRVUVzWlR0QlFVdEJVQ3hyUWtGQlFVRXNXVHM3T3p0elFrRkhSbnBETEN0Q1FVRmxOazBzTWtKQlFXWXNSVHM3T3pzN096czdPenM3T3pzN096czdPenRGUVRsd1EydERReXh4UWpzN08wRkJhM0ZEYUVRM1R5eHJRa0ZCYTBJc1EwRkJRemhQTEZWQlFXNUNMRWRCUVdkRExHOUNRVUZvUXp0QlFVVkJMRWxCUVUwMVJpeFpRVUZaTEN0SlFVRnNRanRCUVZsQkxFbEJRVTFuUXl3eVFrRkJNa0lzSzJWQlFXcERJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHlwY2JpQXFJRU52Y0hseWFXZG9kQ0F5TURFNExUSXdNakFnVkU5T0lFUkZWaUJUVDB4VlZFbFBUbE1nVEZSRUxseHVJQ292WEc0dkx5QkFabXh2ZDF4dVhHNXBiWEJ2Y25RZ2UxeHVJQ0FnSUZSeVlXTmxjaXdnUms5U1RVRlVYMVJGV0ZSZlRVRlFMQ0JUY0dGdUxDQlRjR0Z1UTI5dWRHVjRkQ3hjYm4wZ1puSnZiU0FuYjNCbGJuUnlZV05wYm1jbk8xeHVhVzF3YjNKMElIUjVjR1VnZTF4dUlDQWdJRkZCWTJOdmRXNTBMRnh1SUNBZ0lGRkNiRzlqYXl4Y2JpQWdJQ0JSVFdWemMyRm5aU3hjYmlBZ0lDQlJWSEpoYm5OaFkzUnBiMjRzWEc0Z0lDQWdWRTlPUTI5dWRISmhZM1JCUWtrc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSQlkyTnZkVzUwVjJGcGRGQmhjbUZ0Y3l4Y2JpQWdJQ0JVVDA1RGIyNTBjbUZqZEVOdmJuWmxjblJCWkdSeVpYTnpVR0Z5WVcxekxGeHVJQ0FnSUZSUFRrTnZiblJ5WVdOMFEyOXVkbVZ5ZEVGa1pISmxjM05TWlhOMWJIUXNYRzRnSUNBZ1ZFOU9RMjl1ZEhKaFkzUkRjbVZoZEdWU2RXNUNiMlI1VUdGeVlXMXpMRnh1SUNBZ0lGUlBUa052Ym5SeVlXTjBRM0psWVhSbFVuVnVRbTlrZVZKbGMzVnNkQ3hjYmlBZ0lDQlVUMDVEYjI1MGNtRmpkRU55WldGMFpWTnBaMjVsWkVSbGNHeHZlVTFsYzNOaFoyVlFZWEpoYlhNc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSRGNtVmhkR1ZUYVdkdVpXUk5aWE56WVdkbFVHRnlZVzF6TEZ4dUlDQWdJRlJQVGtOdmJuUnlZV04wUTNKbFlYUmxVMmxuYm1Wa1VuVnVUV1Z6YzJGblpWQmhjbUZ0Y3l4Y2JpQWdJQ0JVVDA1RGIyNTBjbUZqZEVSbFkyOWtaVTFsYzNOaFoyVkNiMlI1VUdGeVlXMXpMRnh1SUNBZ0lGUlBUa052Ym5SeVlXTjBSR1ZqYjJSbFRXVnpjMkZuWlVKdlpIbFNaWE4xYkhRc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSRVpXTnZaR1ZTZFc1UGRYUndkWFJRWVhKaGJYTXNYRzRnSUNBZ1ZFOU9RMjl1ZEhKaFkzUkVaWEJzYjNsTlpYTnpZV2RsTEZ4dUlDQWdJRlJQVGtOdmJuUnlZV04wUkdWd2JHOTVVR0Z5WVcxekxGeHVJQ0FnSUZSUFRrTnZiblJ5WVdOMFJHVndiRzk1VW1WemRXeDBMRnh1SUNBZ0lGUlBUa052Ym5SeVlXTjBRMkZzWTBSbGNHeHZlVVpsWlZCaGNtRnRjeXhjYmlBZ0lDQlVUMDVEYjI1MGNtRmpkRUp2WXl4Y2JpQWdJQ0JVVDA1RGIyNTBjbUZqZEVkbGRFSnZZMGhoYzJoU1pYTjFiSFFzWEc0Z0lDQWdWRTlPUTI5dWRISmhZM1JIWlhSRGIyUmxSbkp2YlVsdFlXZGxVR0Z5WVcxekxGeHVJQ0FnSUZSUFRrTnZiblJ5WVdOMFIyVjBRMjlrWlVaeWIyMUpiV0ZuWlZKbGMzVnNkQ3hjYmlBZ0lDQlVUMDVEYjI1MGNtRmpkRWRsZEVSbGNHeHZlVVJoZEdGUVlYSmhiWE1zWEc0Z0lDQWdWRTlPUTI5dWRISmhZM1JIWlhSRVpYQnNiM2xFWVhSaFVtVnpkV3gwTEZ4dUlDQWdJRlJQVGtOdmJuUnlZV04wUjJWMFJuVnVZM1JwYjI1SlpGQmhjbUZ0Y3l4Y2JpQWdJQ0JVVDA1RGIyNTBjbUZqZEVkbGRFWjFibU4wYVc5dVNXUlNaWE4xYkhRc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSTWIyRmtVR0Z5WVcxekxGeHVJQ0FnSUZSUFRrTnZiblJ5WVdOMFRHOWhaRkpsYzNWc2RDeGNiaUFnSUNCVVQwNURiMjUwY21GamRFTmhiR05TZFc1R1pXVlFZWEpoYlhNc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSRFlXeGpSbVZsVW1WemRXeDBMRnh1SUNBZ0lGUlBUa052Ym5SeVlXTjBRMkZzWTAxeloxQnliMk5sYzNOcGJtZEdaV1Z6VUdGeVlXMXpMRnh1SUNBZ0lGUlBUa052Ym5SeVlXTjBUV1Z6YzJGblpTeGNiaUFnSUNCVVQwNURiMjUwY21GamRGSjFia3h2WTJGc1VHRnlZVzF6TEZ4dUlDQWdJRlJQVGtOdmJuUnlZV04wVW5WdVRXVnpjMkZuWlN4Y2JpQWdJQ0JVVDA1RGIyNTBjbUZqZEZKMWJsQmhjbUZ0Y3l4Y2JpQWdJQ0JVVDA1RGIyNTBjbUZqZEZKMWJsSmxjM1ZzZEN4Y2JpQWdJQ0JVVDA1RGIyNTBjbUZqZEhNc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSVmJuTnBaMjVsWkVSbGNHeHZlVTFsYzNOaFoyVXNYRzRnSUNBZ1ZFOU9RMjl1ZEhKaFkzUlZibk5wWjI1bFpFMWxjM05oWjJVc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSVmJuTnBaMjVsWkZKMWJrMWxjM05oWjJVc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSU2RXNUhaWFJRWVhKaGJYTXNYRzRnSUNBZ1ZFOU9RMjl1ZEhKaFkzUlNkVzVIWlhSU1pYTjFiSFFzWEc0Z0lDQWdWRTlPUTI5dWRISmhZM1JTZFc1TlpYTnpZV2RsVEc5allXeFFZWEpoYlhNc1hHNGdJQ0FnVkU5T1EyOXVkSEpoWTNSU2RXNU1iMk5oYkZKbGMzVnNkQ3hjYmlBZ0lDQlVUMDVYWVdsMFJtOXlWSEpoYm5OaFkzUnBiMjVRWVhKaGJYTXNYRzRnSUNBZ1VWTm9ZWEprU0dGemFDeGNiaUFnSUNCVVQwNU5aWE56WVdkbFVISnZZMlZ6YzJsdVoxTjBZWFJsTEZ4dUlDQWdJRlJQVGxOcFoyNXBibWRDYjNnc1hHNGdJQ0FnVkU5T1MyVjVVR0ZwY2tSaGRHRXNYRzU5SUdaeWIyMGdKeTR1THk0dUwzUjVjR1Z6Snp0Y2JseHVhVzF3YjNKMElIc2daVzF3ZEhsVVQwNUZjbkp2Y2tSaGRHRXNJRlJQVGtOc2FXVnVkRVZ5Y205eUxDQlVUMDVEYjI1MGNtRmpkRVY0YVhSRGIyUmxMQ0JVVDA1RmNuSnZja052WkdVZ2ZTQm1jbTl0SUNjdUxpOVVUMDVEYkdsbGJuUkZjbkp2Y2ljN1hHNXBiWEJ2Y25RZ2V5QlVUMDVOYjJSMWJHVWdmU0JtY205dElDY3VMaTlVVDA1TmIyUjFiR1VuTzF4dWFXMXdiM0owSUZSUFRrTnZibVpwWjAxdlpIVnNaU0JtY205dElDY3VMMVJQVGtOdmJtWnBaMDF2WkhWc1pTYzdYRzVwYlhCdmNuUWdWRTlPUTNKNWNIUnZUVzlrZFd4bExDQjdJRlJQVGs5MWRIQjFkRVZ1WTI5a2FXNW5JSDBnWm5KdmJTQW5MaTlVVDA1RGNubHdkRzlOYjJSMWJHVW5PMXh1YVcxd2IzSjBJRlJQVGxGMVpYSnBaWE5OYjJSMWJHVXNJSHNnVFVGWVgxUkpUVVZQVlZRZ2ZTQm1jbTl0SUNjdUwxUlBUbEYxWlhKcFpYTk5iMlIxYkdVbk8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1ZFOU9RV1JrY21WemMxTjBjbWx1WjFaaGNtbGhiblFnUFNCN1hHNGdJQ0FnUVdOamIzVnVkRWxrT2lBblFXTmpiM1Z1ZEVsa0p5eGNiaUFnSUNCSVpYZzZJQ2RJWlhnbkxGeHVJQ0FnSUVKaGMyVTJORG9nSjBKaGMyVTJOQ2NzWEc1OU8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1ZFOU9RMnhwWlc1MFZISmhibk5oWTNScGIyNVFhR0Z6WlNBOUlIdGNiaUFnSUNCemRHOXlZV2RsT2lBbmMzUnZjbUZuWlNjc1hHNGdJQ0FnWTI5dGNIVjBaVk5yYVhCd1pXUTZJQ2RqYjIxd2RYUmxVMnRwY0hCbFpDY3NYRzRnSUNBZ1kyOXRjSFYwWlZadE9pQW5ZMjl0Y0hWMFpWWnRKeXhjYmlBZ0lDQmhZM1JwYjI0NklDZGhZM1JwYjI0bkxGeHVJQ0FnSUhWdWEyNXZkMjQ2SUNkMWJtdHViM2R1Snl4Y2JuMDdYRzVjYm1WNGNHOXlkQ0JqYjI1emRDQlVUMDVEYkdsbGJuUkRiMjF3ZFhSbFUydHBjSEJsWkZOMFlYUjFjeUE5SUh0Y2JpQWdJQ0J1YjFOMFlYUmxPaUF3TEZ4dUlDQWdJR0poWkZOMFlYUmxPaUF4TEZ4dUlDQWdJRzV2UjJGek9pQXlMRnh1ZlR0Y2JseHVaWGh3YjNKMElHTnZibk4wSUZSUFRrTnNhV1Z1ZEZOMGIzSmhaMlZUZEdGMGRYTWdQU0I3WEc0Z0lDQWdkVzVqYUdGdVoyVmtPaUF3TEZ4dUlDQWdJR1p5YjNwbGJqb2dNU3hjYmlBZ0lDQmtaV3hsZEdWa09pQXlMRnh1ZlR0Y2JseHVaWGh3YjNKMElHTnZibk4wSUZGSmJrMXpaMVI1Y0dVZ1BTQjdYRzRnSUNBZ1pYaDBaWEp1WVd3NklEQXNYRzRnSUNBZ2FXaHlPaUF4TEZ4dUlDQWdJR2x0YldWa2FXRjBaV3g1T2lBeUxGeHVJQ0FnSUdacGJtRnNPaUF6TEZ4dUlDQWdJSFJ5WVc1emFYUTZJRFFzWEc0Z0lDQWdaR2x6WTJGeVpHVmtSbWx1WVd3NklEVXNYRzRnSUNBZ1pHbHpZMkZ5WkdWa1ZISmhibk5wZERvZ05peGNibjA3WEc1Y2JtVjRjRzl5ZENCamIyNXpkQ0JSVDNWMFRYTm5WSGx3WlNBOUlIdGNiaUFnSUNCbGVIUmxjbTVoYkRvZ01DeGNiaUFnSUNCcGJXMWxaR2xoZEdWc2VUb2dNU3hjYmlBZ0lDQnZkWFJOYzJkT1pYYzZJRElzWEc0Z0lDQWdkSEpoYm5OcGREb2dNeXhjYmlBZ0lDQmtaWEYxWlhWbFNXMXRaV1JwWVhSbGJIazZJRFFzWEc0Z0lDQWdaR1Z4ZFdWMVpUb2dOU3hjYmlBZ0lDQjBjbUZ1YzJsMFVtVnhkV2x5WldRNklEWXNYRzRnSUNBZ2JtOXVaVG9nTFRFc1hHNTlPMXh1WEc1bGVIQnZjblFnWTI5dWMzUWdVVTFsYzNOaFoyVlVlWEJsSUQwZ2UxeHVJQ0FnSUdsdWRHVnlibUZzT2lBd0xGeHVJQ0FnSUdWNGRFbHVPaUF4TEZ4dUlDQWdJR1Y0ZEU5MWREb2dNaXhjYm4wN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCUlRXVnpjMkZuWlZCeWIyTmxjM05wYm1kVGRHRjBkWE1nUFNCN1hHNGdJQ0FnZFc1cmJtOTNiam9nTUN4Y2JpQWdJQ0J4ZFdWMVpXUTZJREVzWEc0Z0lDQWdjSEp2WTJWemMybHVaem9nTWl4Y2JpQWdJQ0J3Y21Wc2FXMXBibUZ5ZVRvZ015eGNiaUFnSUNCd2NtOXdiM05sWkRvZ05DeGNiaUFnSUNCbWFXNWhiR2w2WldRNklEVXNYRzRnSUNBZ2NtVm1kWE5sWkRvZ05peGNiaUFnSUNCMGNtRnVjMmwwYVc1bk9pQTNMRnh1ZlR0Y2JseHVaWGh3YjNKMElHTnZibk4wSUZGQ2JHOWphMUJ5YjJObGMzTnBibWRUZEdGMGRYTWdQU0I3WEc0Z0lDQWdkVzVyYm05M2Jqb2dNQ3hjYmlBZ0lDQndjbTl3YjNObFpEb2dNU3hjYmlBZ0lDQm1hVzVoYkdsNlpXUTZJRElzWEc0Z0lDQWdjbVZtZFhObFpEb2dNeXhjYm4wN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCUlUzQnNhWFJVZVhCbElEMGdlMXh1SUNBZ0lHNXZibVU2SURBc1hHNGdJQ0FnYzNCc2FYUTZJRElzWEc0Z0lDQWdiV1Z5WjJVNklETXNYRzU5TzF4dVhHNWxlSEJ2Y25RZ1kyOXVjM1FnVVVGalkyOTFiblJVZVhCbElEMGdlMXh1SUNBZ0lIVnVhVzVwZERvZ01DeGNiaUFnSUNCaFkzUnBkbVU2SURFc1hHNGdJQ0FnWm5KdmVtVnVPaUF5TEZ4dWZUdGNibHh1Wlhod2IzSjBJR052Ym5OMElGRlVjbUZ1YzJGamRHbHZibFI1Y0dVZ1BTQjdYRzRnSUNBZ2IzSmthVzVoY25rNklEQXNYRzRnSUNBZ2MzUnZjbUZuWlRvZ01TeGNiaUFnSUNCMGFXTnJPaUF5TEZ4dUlDQWdJSFJ2WTJzNklETXNYRzRnSUNBZ2MzQnNhWFJRY21Wd1lYSmxPaUEwTEZ4dUlDQWdJSE53YkdsMFNXNXpkR0ZzYkRvZ05TeGNiaUFnSUNCdFpYSm5aVkJ5WlhCaGNtVTZJRFlzWEc0Z0lDQWdiV1Z5WjJWSmJuTjBZV3hzT2lBM0xGeHVmVHRjYmx4dVpYaHdiM0owSUdOdmJuTjBJRkZVY21GdWMyRmpkR2x2YmxCeWIyTmxjM05wYm1kVGRHRjBkWE1nUFNCN1hHNGdJQ0FnZFc1cmJtOTNiam9nTUN4Y2JpQWdJQ0J3Y21Wc2FXMXBibUZ5ZVRvZ01TeGNiaUFnSUNCd2NtOXdiM05sWkRvZ01peGNiaUFnSUNCbWFXNWhiR2w2WldRNklETXNYRzRnSUNBZ2NtVm1kWE5sWkRvZ05DeGNibjA3WEc1Y2JtVjRjRzl5ZENCamIyNXpkQ0JSUVdOamIzVnVkRk4wWVhSMWN5QTlJSHRjYmlBZ0lDQjFibWx1YVhRNklEQXNYRzRnSUNBZ1lXTjBhWFpsT2lBeExGeHVJQ0FnSUdaeWIzcGxiam9nTWl4Y2JpQWdJQ0J1YjI1RmVHbHpkRG9nTXl4Y2JuMDdYRzVjYm1WNGNHOXlkQ0JqYjI1emRDQlJRV05qYjNWdWRGTjBZWFIxYzBOb1lXNW5aU0E5SUh0Y2JpQWdJQ0IxYm1Ob1lXNW5aV1E2SURBc1hHNGdJQ0FnWm5KdmVtVnVPaUF4TEZ4dUlDQWdJR1JsYkdWMFpXUTZJRElzWEc1OU8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1VVTnZiWEIxZEdWVWVYQmxJRDBnZTF4dUlDQWdJSE5yYVhCd1pXUTZJREFzWEc0Z0lDQWdkbTA2SURFc1hHNTlPMXh1WEc1bGVIQnZjblFnWTI5dWMzUWdVVk5yYVhCU1pXRnpiMjRnUFNCN1hHNGdJQ0FnYm05VGRHRjBaVG9nTUN4Y2JpQWdJQ0JpWVdSVGRHRjBaVG9nTVN4Y2JpQWdJQ0J1YjBkaGN6b2dNaXhjYm4wN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCUlFtOTFibU5sVkhsd1pTQTlJSHRjYmlBZ0lDQnVaV2RHZFc1a2N6b2dNQ3hjYmlBZ0lDQnViMFoxYm1Sek9pQXhMRnh1SUNBZ0lHOXJPaUF5TEZ4dWZUdGNibHh1WTI5dWMzUWdUVUZUVkVWU1EwaEJTVTVmU1VRZ1BTQXRNVHRjYmx4dVpuVnVZM1JwYjI0Z2NtVnRiM1psVkhsd1pVNWhiV1VvYjJKcU9pQmhibmtwSUh0Y2JpQWdJQ0JwWmlBb2IySnFMbDlmZEhsd1pXNWhiV1VwSUh0Y2JpQWdJQ0FnSUNBZ1pHVnNaWFJsSUc5aWFpNWZYM1I1Y0dWdVlXMWxPMXh1SUNBZ0lIMWNiaUFnSUNCUFltcGxZM1F1ZG1Gc2RXVnpLRzlpYWlsY2JpQWdJQ0FnSUNBZ0xtWnZja1ZoWTJnb0tIWmhiSFZsS1NBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9JU0YyWVd4MVpTQW1KaUIwZVhCbGIyWWdkbUZzZFdVZ1BUMDlJQ2R2WW1wbFkzUW5LU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WdGIzWmxWSGx3WlU1aGJXVW9kbUZzZFdVcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUtUdGNibjFjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUhKbGJXOTJaVkJ5YjNCektHOWlham9nZTMwc0lIQmhkR2h6T2lCemRISnBibWRiWFNrNklIdDlJSHRjYmlBZ0lDQnNaWFFnY21WemRXeDBJRDBnYjJKcU8xeHVJQ0FnSUhCaGRHaHpMbVp2Y2tWaFkyZ29LSEJoZEdncElEMCtJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdaRzkwVUc5eklEMGdjR0YwYUM1cGJtUmxlRTltS0NjdUp5azdYRzRnSUNBZ0lDQWdJR2xtSUNoa2IzUlFiM01nUENBd0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9jR0YwYUNCcGJpQnlaWE4xYkhRcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRZ1BTQjdJQzR1TG5KbGMzVnNkQ0I5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdSbGJHVjBaU0J5WlhOMWJIUmJjR0YwYUYwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCdVlXMWxJRDBnY0dGMGFDNXpkV0p6ZEhJb01Dd2daRzkwVUc5ektUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR05vYVd4a0lEMGdjbVZ6ZFd4MFcyNWhiV1ZkTzF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0dOb2FXeGtLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdjbVZrZFdObFpFTm9hV3hrSUQwZ2NtVnRiM1psVUhKdmNITW9ZMmhwYkdRc0lGdHdZWFJvTG5OMVluTjBjaWhrYjNSUWIzTWdLeUF4S1YwcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h5WldSMVkyVmtRMmhwYkdRZ0lUMDlJR05vYVd4a0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGMzVnNkQ0E5SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM0dUxuSmxjM1ZzZEN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZ0dVlXMWxYVG9nY21Wa2RXTmxaRU5vYVd4a0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJSDBwTzF4dUlDQWdJSEpsZEhWeWJpQnlaWE4xYkhRN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhOMFlYSjBUV1Z6YzJGblpWUnlZV05sVTNCaGJpaGNiaUFnSUNCMGNtRmpaWEk2SUZSeVlXTmxjaXhjYmlBZ0lDQnRaWE56WVdkbFNXUTZJSE4wY21sdVp5eGNiaUFnSUNCdmNHVnlZWFJwYjI1T1lXMWxPaUJ6ZEhKcGJtY3NYRzRnSUNBZ2RHRm5jem9nZXlCYmMzUnlhVzVuWFRvZ1lXNTVJSDBzWEc0cE9pQS9VM0JoYmlCN1hHNGdJQ0FnYVdZZ0tDRnRaWE56WVdkbFNXUXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzUxYkd3N1hHNGdJQ0FnZlZ4dUlDQWdJR052Ym5OMElIUnlZV05sU1dRZ1BTQnRaWE56WVdkbFNXUXVjM1ZpYzNSeUtEQXNJREUyS1R0Y2JpQWdJQ0JqYjI1emRDQnpjR0Z1U1dRZ1BTQnRaWE56WVdkbFNXUXVjM1ZpYzNSeUtERTJMQ0F4TmlrN1hHNGdJQ0FnYkdWMElISnZiM1JEYjI1MFpYaDBPaUEvVTNCaGJrTnZiblJsZUhRZ1BTQnVkV3hzTzF4dUlDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lISnZiM1JEYjI1MFpYaDBJRDBnZEhKaFkyVnlMbVY0ZEhKaFkzUW9SazlTVFVGVVgxUkZXRlJmVFVGUUxDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBbmRXSmxjaTEwY21GalpTMXBaQ2M2SUdBa2UzUnlZV05sU1dSOU9pUjdjM0JoYmtsa2ZUb3dPakZnTEZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNCOUlHTmhkR05vSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdkSEpoWTJWeUlHTmhiaWQwSUdOeVpXRjBaU0JxWVdWblpYSWdZMjl0Y0dGMGFXSnNaU0J6Y0dGdUxGeHVJQ0FnSUNBZ0lDQXZMeUJ6YnlCM1pTQmhjbVVnWm1Gc2JHSmhZMnNnZEc4Z2NtVjBkWEp1SUc1MWJHeGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tDRnliMjkwUTI5dWRHVjRkQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYm5Wc2JEdGNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJSFJ5WVdObGNpNXpkR0Z5ZEZOd1lXNG9iM0JsY21GMGFXOXVUbUZ0WlN3Z2UxeHVJQ0FnSUNBZ0lDQmphR2xzWkU5bU9pQnliMjkwUTI5dWRHVjRkQ3hjYmlBZ0lDQWdJQ0FnZEdGbmN5eGNiaUFnSUNCOUtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2RISmhZMlZOWlhOellXZGxLRnh1SUNBZ0lIUnlZV05sY2pvZ1ZISmhZMlZ5TEZ4dUlDQWdJRzFsYzNOaFoyVkpaRG9nYzNSeWFXNW5MRnh1SUNBZ0lHOXdaWEpoZEdsdmJrNWhiV1U2SUhOMGNtbHVaeXhjYmlBZ0lDQjBZV2R6T2lCN0lGdHpkSEpwYm1kZE9pQmhibmtnZlN4Y2Jpa2dlMXh1SUNBZ0lHTnZibk4wSUhOd1lXNGdQU0J6ZEdGeWRFMWxjM05oWjJWVWNtRmpaVk53WVc0b2RISmhZMlZ5TENCdFpYTnpZV2RsU1dRc0lHOXdaWEpoZEdsdmJrNWhiV1VzSUhSaFozTXBPMXh1SUNBZ0lHbG1JQ2h6Y0dGdUtTQjdYRzRnSUNBZ0lDQWdJSE53WVc0dVptbHVhWE5vS0NrN1hHNGdJQ0FnZlZ4dWZWeHVYRzUwZVhCbElGTnBaMjVTWlhOMWJIUWdQU0I3WEc0Z0lDQWdjMmxuYmtKNWRHVnpRbUZ6WlRZME9pQnpkSEpwYm1jc1hHNGdJQ0FnY0hWaWJHbGpTMlY1U0dWNE9pQnpkSEpwYm1jc1hHNTlPMXh1WEc1MGVYQmxJRk5wWjI1cGJtZFRiM1Z5WTJVZ1BTQjdYRzRnSUNBZ1ltOTRPaUEvVkU5T1UybG5ibWx1WjBKdmVDeGNiaUFnSUNCclpYbHpPaUJVVDA1TFpYbFFZV2x5UkdGMFlTeGNibjFjYmx4dVlYTjVibU1nWm5WdVkzUnBiMjRnWjJWMFUybG5ibWx1WjFOdmRYSmpaU2hjYmlBZ0lDQmliM2cvT2lCVVQwNVRhV2R1YVc1blFtOTRMRnh1SUNBZ0lHdGxlWE0vT2lCVVQwNUxaWGxRWVdseVJHRjBZU3hjYmlrNklGQnliMjFwYzJVOFAxTnBaMjVwYm1kVGIzVnlZMlUrSUh0Y2JpQWdJQ0JwWmlBb1ltOTRLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmliM2dzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnJaWGx6T2lCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MyVmpjbVYwT2lBbkp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQndkV0pzYVdNNklHRjNZV2wwSUdKdmVDNW5aWFJRZFdKc2FXTkxaWGtvS1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUgwN1hHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNoclpYbHpJQ1ltSUd0bGVYTXVjMlZqY21WMEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaWIzZzZJRzUxYkd3c1hHNGdJQ0FnSUNBZ0lDQWdJQ0JyWlhsekxGeHVJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnYm5Wc2JEdGNibjFjYmx4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJVVDA1RGIyNTBjbUZqZEhOTmIyUjFiR1VnWlhoMFpXNWtjeUJVVDA1TmIyUjFiR1VnYVcxd2JHVnRaVzUwY3lCVVQwNURiMjUwY21GamRITWdlMXh1SUNBZ0lHTnZibVpwWnpvZ1ZFOU9RMjl1Wm1sblRXOWtkV3hsTzF4dUlDQWdJR055ZVhCMGJ6b2dWRTlPUTNKNWNIUnZUVzlrZFd4bE8xeHVJQ0FnSUhGMVpYSnBaWE02SUZSUFRsRjFaWEpwWlhOTmIyUjFiR1U3WEc1Y2JpQWdJQ0JoYzNsdVl5QnpaWFIxY0NncE9pQlFjbTl0YVhObFBDbytJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWpiMjVtYVdjZ1BTQjBhR2x6TG1OdmJuUmxlSFF1WjJWMFRXOWtkV3hsS0ZSUFRrTnZibVpwWjAxdlpIVnNaU2s3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjWFZsY21sbGN5QTlJSFJvYVhNdVkyOXVkR1Y0ZEM1blpYUk5iMlIxYkdVb1ZFOU9VWFZsY21sbGMwMXZaSFZzWlNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WTNKNWNIUnZJRDBnZEdocGN5NWpiMjUwWlhoMExtZGxkRTF2WkhWc1pTaFVUMDVEY25sd2RHOU5iMlIxYkdVcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJR3h2WVdRb1hHNGdJQ0FnSUNBZ0lIQmhjbUZ0Y3pvZ1ZFOU9RMjl1ZEhKaFkzUk1iMkZrVUdGeVlXMXpMRnh1SUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1UHpvZ0tGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDa3NYRzRnSUNBZ0tUb2dVSEp2YldselpUeFVUMDVEYjI1MGNtRmpkRXh2WVdSU1pYTjFiSFErSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWVdOamIzVnVkSE02SUZGQlkyTnZkVzUwVzEwZ1BTQmhkMkZwZENCMGFHbHpMbkYxWlhKcFpYTXVZV05qYjNWdWRITXVjWFZsY25rb2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWm1sc2RHVnlPaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdRNklIc2daWEU2SUhCaGNtRnRjeTVoWkdSeVpYTnpJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVnpkV3gwT2lBblltRnNZVzVqWlNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1TEZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdhV1lnS0dGalkyOTFiblJ6SUNZbUlHRmpZMjkxYm5SekxteGxibWQwYUNBK0lEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXUTZJSEJoY21GdGN5NWhaR1J5WlhOekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHSmhiR0Z1WTJWSGNtRnRjem9nWVdOamIzVnVkSE5iTUYwdVltRnNZVzVqWlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJSDA3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xrT2lCdWRXeHNMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1ltRnNZVzVqWlVkeVlXMXpPaUJ1ZFd4c0xGeHVJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lIMWNibHh1WEc0Z0lDQWdMeThnUm1GallXUmxJR1oxYm1OMGFXOXVjMXh1WEc0Z0lDQWdZWE41Ym1NZ1pHVndiRzk1S0Z4dUlDQWdJQ0FnSUNCd1lYSmhiWE02SUZSUFRrTnZiblJ5WVdOMFJHVndiRzk1VUdGeVlXMXpMRnh1SUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1UHpvZ0tGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDa3NYRzRnSUNBZ0tUb2dVSEp2YldselpUeFVUMDVEYjI1MGNtRmpkRVJsY0d4dmVWSmxjM1ZzZEQ0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTVqYjI1MFpYaDBMblJ5WVdObEtDZGpiMjUwY21GamRITXVaR1Z3Ykc5NUp5d2dZWE41Ym1NZ0tITndZVzQ2SUZOd1lXNHBJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSE53WVc0dWMyVjBWR0ZuS0Nkd1lYSmhiWE1uTENCeVpXMXZkbVZRY205d2N5aHdZWEpoYlhNc0lGc25hMlY1VUdGcGNpNXpaV055WlhRblhTa3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVhVzUwWlhKdVlXeEVaWEJzYjNsS2N5aHdZWEpoYlhNc0lITndZVzRwTzF4dUlDQWdJQ0FnSUNCOUxDQndZWEpsYm5SVGNHRnVLVHRjYmlBZ0lDQjlYRzVjYmx4dUlDQWdJR0Z6ZVc1aklISjFiaWhjYmlBZ0lDQWdJQ0FnY0dGeVlXMXpPaUJVVDA1RGIyNTBjbUZqZEZKMWJsQmhjbUZ0Y3l4Y2JpQWdJQ0FnSUNBZ2NHRnlaVzUwVTNCaGJqODZJQ2hUY0dGdUlId2dVM0JoYmtOdmJuUmxlSFFwTEZ4dUlDQWdJQ2s2SUZCeWIyMXBjMlU4VkU5T1EyOXVkSEpoWTNSU2RXNVNaWE4xYkhRK0lIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11WTI5dWRHVjRkQzUwY21GalpTZ25ZMjl1ZEhKaFkzUnpMbkoxYmljc0lHRnplVzVqSUNoemNHRnVPaUJUY0dGdUtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnpjR0Z1TG5ObGRGUmhaeWduY0dGeVlXMXpKeXdnY21WdGIzWmxVSEp2Y0hNb2NHRnlZVzF6TENCYkoydGxlVkJoYVhJdWMyVmpjbVYwSjEwcEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxtbHVkR1Z5Ym1Gc1VuVnVTbk1vY0dGeVlXMXpMQ0J6Y0dGdUtUdGNiaUFnSUNBZ0lDQWdmU3dnY0dGeVpXNTBVM0JoYmlrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdjblZ1VEc5allXd29YRzRnSUNBZ0lDQWdJSEJoY21GdGN6b2dWRTlPUTI5dWRISmhZM1JTZFc1TWIyTmhiRkJoY21GdGN5eGNiaUFnSUNBZ0lDQWdjR0Z5Wlc1MFUzQmhiajg2SUNoVGNHRnVJSHdnVTNCaGJrTnZiblJsZUhRcExGeHVJQ0FnSUNrNklGQnliMjFwYzJVOFZFOU9RMjl1ZEhKaFkzUlNkVzVNYjJOaGJGSmxjM1ZzZEQ0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTVqYjI1MFpYaDBMblJ5WVdObEtDZGpiMjUwY21GamRITXVjblZ1VEc5allXd25MQ0JoYzNsdVl5QW9jM0JoYmpvZ1UzQmhiaWtnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYzNCaGJpNXpaWFJVWVdjb0ozQmhjbUZ0Y3ljc0lISmxiVzkyWlZCeWIzQnpLSEJoY21GdGN5d2dXeWRyWlhsUVlXbHlMbk5sWTNKbGRDZGRLU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTVwYm5SbGNtNWhiRkoxYmt4dlkyRnNTbk1vY0dGeVlXMXpMQ0J6Y0dGdUtUdGNiaUFnSUNBZ0lDQWdmU3dnY0dGeVpXNTBVM0JoYmlrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdjblZ1VFdWemMyRm5aVXh2WTJGc0tGeHVJQ0FnSUNBZ0lDQndZWEpoYlhNNklGUlBUa052Ym5SeVlXTjBVblZ1VFdWemMyRm5aVXh2WTJGc1VHRnlZVzF6TEZ4dUlDQWdJQ0FnSUNCd1lYSmxiblJUY0dGdVB6b2dLRk53WVc0Z2ZDQlRjR0Z1UTI5dWRHVjRkQ2tzWEc0Z0lDQWdLVG9nVUhKdmJXbHpaVHhVVDA1RGIyNTBjbUZqZEZKMWJreHZZMkZzVW1WemRXeDBQaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxtTnZiblJsZUhRdWRISmhZMlVvSjNKMWJrMWxjM05oWjJWTWIyTmhiQ2NzSUdGemVXNWpJQ2h6Y0dGdU9pQlRjR0Z1S1NBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCemNHRnVMbk5sZEZSaFp5Z25jR0Z5WVcxekp5d2djbVZ0YjNabFVISnZjSE1vY0dGeVlXMXpMQ0JiSjJ0bGVWQmhhWEl1YzJWamNtVjBKMTBwS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1sdWRHVnlibUZzVW5WdVRXVnpjMkZuWlV4dlkyRnNTbk1vY0dGeVlXMXpMQ0J6Y0dGdUtUdGNiaUFnSUNBZ0lDQWdmU3dnY0dGeVpXNTBVM0JoYmlrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdjblZ1UjJWMEtGeHVJQ0FnSUNBZ0lDQndZWEpoYlhNNklGUlBUa052Ym5SeVlXTjBVblZ1UjJWMFVHRnlZVzF6TEZ4dUlDQWdJQ2s2SUZCeWIyMXBjMlU4VkU5T1EyOXVkSEpoWTNSU2RXNUhaWFJTWlhOMWJIUStJSHRjYmlBZ0lDQWdJQ0FnYkdWMElHTnZjbVZRWVhKaGJYTTZJRlJQVGtOdmJuUnlZV04wVW5WdVIyVjBVR0Z5WVcxeklEMGdjR0Z5WVcxek8xeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCb1lYTkRiMlJsSUQwZ2NHRnlZVzF6TG1KdlkwSmhjMlUyTkNCOGZDQW9jR0Z5WVcxekxtTnZaR1ZDWVhObE5qUWdKaVlnY0dGeVlXMXpMbVJoZEdGQ1lYTmxOalFwTzF4dUlDQWdJQ0FnSUNCcFppQW9JV2hoYzBOdlpHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdGa1pISmxjM01nUFNCd1lYSmhiWE11WVdSa2NtVnpjenRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2doWVdSa2NtVnpjeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRlJQVGtOc2FXVnVkRVZ5Y205eUxtRmtaSEpsYzNOU1pYRjFhWEpsWkVadmNsSjFia3h2WTJGc0tHRjNZV2wwSUhSb2FYTXVZMjl0Y0d4bGRHVkZjbkp2Y2tSaGRHRW9LU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JoWTJOdmRXNTBPaUJoYm5rZ1BTQmhkMkZwZENCMGFHbHpMbWRsZEVGalkyOTFiblFvWVdSa2NtVnpjeXdnWm1Gc2MyVXNJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYVcxbGIzVjBPaUIwYUdsekxtTnZibVpwWnk1M1lXbDBSbTl5VkdsdFpXOTFkQ2dwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvSVdGalkyOTFiblF1WTI5a1pWOW9ZWE5vS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnVkU5T1EyeHBaVzUwUlhKeWIzSXVZV05qYjNWdWRFTnZaR1ZOYVhOemFXNW5LRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhZMk52ZFc1MExtSmhiR0Z1WTJVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0YzWVdsMElIUm9hWE11WTI5dGNHeGxkR1ZGY25KdmNrUmhkR0VvS1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2NHRnlZVzF6Um5KdmJVRmpZMjkxYm5RNklDUlRhR0Z3WlR4VVQwNURiMjUwY21GamRGSjFia2RsZEZCaGNtRnRjejRnUFNCN2ZUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaGhZMk52ZFc1MExtSnZZeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhCaGNtRnRjMFp5YjIxQlkyTnZkVzUwTG1KdlkwSmhjMlUyTkNBOUlHRmpZMjkxYm5RdVltOWpPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHRmpZMjkxYm5RdWJHRnpkRjl3WVdsa0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjR0Z5WVcxelJuSnZiVUZqWTI5MWJuUXViR0Z6ZEY5d1lXbGtJRDBnWVdOamIzVnVkQzVzWVhOMFgzQmhhV1E3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9ZV05qYjNWdWRDNWlZV3hoYm1ObEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjR0Z5WVcxelJuSnZiVUZqWTI5MWJuUXVZbUZzWVc1alpTQTlJR0ZqWTI5MWJuUXVZbUZzWVc1alpUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJR052Y21WUVlYSmhiWE1nUFNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0xpNHVjR0Z5WVcxelJuSnZiVUZqWTI5MWJuUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMaTR1Y0dGeVlXMXpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpYRjFaWE4wUTI5eVpTZ25kSFp0TG1kbGRDY3NJR052Y21WUVlYSmhiWE1wTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z5Y21GNVJuSnZiVU5QVGxNb1kyOXVjem9nWVc1NVcxMHBPaUJoYm5sYlhTQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElISmxjM1ZzZENBOUlGdGRPMXh1SUNBZ0lDQWdJQ0JzWlhRZ2FYUmxiU0E5SUdOdmJuTTdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaHBkR1Z0S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb0lXbDBaVzB1YkdWdVozUm9JRDA5UFNBeUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1ZFOU9RMnhwWlc1MFJYSnliM0l1YVc1MllXeHBaRU52Ym5Nb1pXMXdkSGxVVDA1RmNuSnZja1JoZEdFcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ6ZFd4MExuQjFjMmdvYVhSbGJWc3dYU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBkR1Z0SUQwZ2FYUmxiVnN4WFR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2NtVnpkV3gwTzF4dUlDQWdJSDFjYmx4dVhHNGdJQ0FnTHk4Z1RXVnpjMkZuWlNCamNtVmhkR2x2Ymx4dVhHNGdJQ0FnWVhONWJtTWdZM0psWVhSbFJHVndiRzk1VFdWemMyRm5aU2hjYmlBZ0lDQWdJQ0FnY0dGeVlXMXpPaUJVVDA1RGIyNTBjbUZqZEVSbGNHeHZlVkJoY21GdGN5eGNiaUFnSUNBZ0lDQWdjbVYwY25sSmJtUmxlRDg2SUc1MWJXSmxjaXhjYmlBZ0lDQXBPaUJRY205dGFYTmxQRlJQVGtOdmJuUnlZV04wUkdWd2JHOTVUV1Z6YzJGblpUNGdlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtTnZibVpwWnk1c2IyY29KMk55WldGMFpVUmxjR3h2ZVUxbGMzTmhaMlVuTENCd1lYSmhiWE1wTzF4dUlDQWdJQ0FnSUNCamIyNXpkQ0J6YjNWeVkyVWdQU0JoZDJGcGRDQm5aWFJUYVdkdWFXNW5VMjkxY21ObEtIQmhjbUZ0Y3k1emFXZHVhVzVuUW05NExDQndZWEpoYlhNdWEyVjVVR0ZwY2lrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2h6YjNWeVkyVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhWdWMybG5ibVZrVFdWemMyRm5aU0E5SUdGM1lXbDBJSFJvYVhNdVkzSmxZWFJsVlc1emFXZHVaV1JFWlhCc2IzbE5aWE56WVdkbEtIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXVMaTV3WVhKaGJYTXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdhMlY1VUdGcGNqb2djMjkxY21ObExtdGxlWE1zWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbU55WldGMFpWTnBaMjVsWkVSbGNHeHZlVTFsYzNOaFoyVW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzR1TGloaGQyRnBkQ0IwYUdsekxtbHVkR1Z5Ym1Gc1UybG5iaWgxYm5OcFoyNWxaRTFsYzNOaFoyVXVjMmxuYmxCaGNtRnRjeXdnYzI5MWNtTmxLU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZFc1emFXZHVaV1JOWlhOellXZGxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdiV1Z6YzJGblpUb2dWRTlPUTI5dWRISmhZM1JOWlhOellXZGxJRDBnWVhkaGFYUWdkR2hwY3k1eVpYRjFaWE4wUTI5eVpTZ25ZMjl1ZEhKaFkzUnpMbVJsY0d4dmVTNXRaWE56WVdkbEp5d2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1lXSnBPaUJ3WVhKaGJYTXVjR0ZqYTJGblpTNWhZbWtzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZEhKMVkzUnZja2hsWVdSbGNqb2djR0Z5WVcxekxtTnZibk4wY25WamRHOXlTR1ZoWkdWeUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUnlkV04wYjNKUVlYSmhiWE02SUhCaGNtRnRjeTVqYjI1emRISjFZM1J2Y2xCaGNtRnRjeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lHbHVhWFJRWVhKaGJYTTZJSEJoY21GdGN5NXBibWwwVUdGeVlXMXpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2FXMWhaMlZDWVhObE5qUTZJSEJoY21GdGN5NXdZV05yWVdkbExtbHRZV2RsUW1GelpUWTBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2EyVjVVR0ZwY2pvZ2NHRnlZVzF6TG10bGVWQmhhWElzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjNiM0pyWTJoaGFXNUpaRG9nY0dGeVlXMXpMbmR2Y210amFHRnBia2xrTEZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdGa1pISmxjM002SUcxbGMzTmhaMlV1WVdSa2NtVnpjeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lIMDdYRzRnSUNBZ2ZWeHVYRzVjYmlBZ0lDQmhjM2x1WXlCamNtVmhkR1ZTZFc1TlpYTnpZV2RsS0Z4dUlDQWdJQ0FnSUNCd1lYSmhiWE02SUZSUFRrTnZiblJ5WVdOMFVuVnVVR0Z5WVcxekxGeHVJQ0FnSUNBZ0lDQnlaWFJ5ZVVsdVpHVjRQem9nYm5WdFltVnlMRnh1SUNBZ0lDazZJRkJ5YjIxcGMyVThWRTlPUTI5dWRISmhZM1JTZFc1TlpYTnpZV2RsUGlCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WTI5dVptbG5MbXh2WnlnblkzSmxZWFJsVW5WdVRXVnpjMkZuWlNjc0lIQmhjbUZ0Y3lrN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhOdmRYSmpaU0E5SUdGM1lXbDBJR2RsZEZOcFoyNXBibWRUYjNWeVkyVW9jR0Z5WVcxekxuTnBaMjVwYm1kQ2IzZ3NJSEJoY21GdGN5NXJaWGxRWVdseUtUdGNiaUFnSUNBZ0lDQWdhV1lnS0hOdmRYSmpaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2RXNXphV2R1WldSTlpYTnpZV2RsSUQwZ1lYZGhhWFFnZEdocGN5NWpjbVZoZEdWVmJuTnBaMjVsWkZKMWJrMWxjM05oWjJVb2NHRnlZVzF6S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1OeVpXRjBaVk5wWjI1bFpGSjFiazFsYzNOaFoyVW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzR1TGloaGQyRnBkQ0IwYUdsekxtbHVkR1Z5Ym1Gc1UybG5iaWgxYm5OcFoyNWxaRTFsYzNOaFoyVXVjMmxuYmxCaGNtRnRjeXdnYzI5MWNtTmxLU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZFc1emFXZHVaV1JOWlhOellXZGxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdiV1Z6YzJGblpTQTlJR0YzWVdsMElIUm9hWE11Y21WeGRXVnpkRU52Y21Vb0oyTnZiblJ5WVdOMGN5NXlkVzR1YldWemMyRm5aU2NzSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR0ZrWkhKbGMzTTZJSEJoY21GdGN5NWhaR1J5WlhOekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWVdKcE9pQndZWEpoYlhNdVlXSnBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1puVnVZM1JwYjI1T1lXMWxPaUJ3WVhKaGJYTXVablZ1WTNScGIyNU9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdhR1ZoWkdWeU9pQndZWEpoYlhNdWFHVmhaR1Z5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdkSEo1U1c1a1pYZzZJSEpsZEhKNVNXNWtaWGdzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnBibkIxZERvZ2NHRnlZVzF6TG1sdWNIVjBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2EyVjVVR0ZwY2pvZ2NHRnlZVzF6TG10bGVWQmhhWElzWEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWVdSa2NtVnpjem9nY0dGeVlXMXpMbUZrWkhKbGMzTXNYRzRnSUNBZ0lDQWdJQ0FnSUNCaFltazZJSEJoY21GdGN5NWhZbWtzWEc0Z0lDQWdJQ0FnSUNBZ0lDQm1kVzVqZEdsdmJrNWhiV1U2SUhCaGNtRnRjeTVtZFc1amRHbHZiazVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxMRnh1SUNBZ0lDQWdJQ0I5TzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklHTnlaV0YwWlZWdWMybG5ibVZrUkdWd2JHOTVUV1Z6YzJGblpTaGNiaUFnSUNBZ0lDQWdjR0Z5WVcxek9pQlVUMDVEYjI1MGNtRmpkRVJsY0d4dmVWQmhjbUZ0Y3l4Y2JpQWdJQ0FnSUNBZ2NtVjBjbmxKYm1SbGVEODZJRzUxYldKbGNpeGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGUlBUa052Ym5SeVlXTjBWVzV6YVdkdVpXUkVaWEJzYjNsTlpYTnpZV2RsUGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhKbGMzVnNkRG9nZTF4dUlDQWdJQ0FnSUNBZ0lDQWdaVzVqYjJSbFpEb2dWRTlPUTI5dWRISmhZM1JWYm5OcFoyNWxaRTFsYzNOaFoyVXNYRzRnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56U0dWNE9pQnpkSEpwYm1jc1hHNGdJQ0FnSUNBZ0lIMGdQU0JoZDJGcGRDQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpiMjUwY21GamRITXVaR1Z3Ykc5NUxtVnVZMjlrWlY5MWJuTnBaMjVsWkY5dFpYTnpZV2RsSnl3Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWVdKcE9pQndZWEpoYlhNdWNHRmphMkZuWlM1aFlta3NYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkSEoxWTNSdmNraGxZV1JsY2pvZ2NHRnlZVzF6TG1OdmJuTjBjblZqZEc5eVNHVmhaR1Z5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdkSEo1U1c1a1pYZzZJSEpsZEhKNVNXNWtaWGdzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZEhKMVkzUnZjbEJoY21GdGN6b2djR0Z5WVcxekxtTnZibk4wY25WamRHOXlVR0Z5WVcxekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnYVc1cGRGQmhjbUZ0Y3pvZ2NHRnlZVzF6TG1sdWFYUlFZWEpoYlhNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwYldGblpVSmhjMlUyTkRvZ2NHRnlZVzF6TG5CaFkydGhaMlV1YVcxaFoyVkNZWE5sTmpRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J3ZFdKc2FXTkxaWGxJWlhnNklIQmhjbUZ0Y3k1clpYbFFZV2x5TG5CMVlteHBZeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lIZHZjbXRqYUdGcGJrbGtPaUJ3WVhKaGJYTXVkMjl5YTJOb1lXbHVTV1FzWEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWVdSa2NtVnpjem9nY21WemRXeDBMbUZrWkhKbGMzTklaWGdzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnphV2R1VUdGeVlXMXpPaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTGk0dWNtVnpkV3gwTG1WdVkyOWtaV1FzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWVdKcE9pQndZWEpoYlhNdWNHRmphMkZuWlM1aFlta3NYRzRnSUNBZ0lDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lIMWNibHh1WEc0Z0lDQWdZWE41Ym1NZ1kzSmxZWFJsVlc1emFXZHVaV1JTZFc1TlpYTnpZV2RsS0Z4dUlDQWdJQ0FnSUNCd1lYSmhiWE02SUZSUFRrTnZiblJ5WVdOMFVuVnVVR0Z5WVcxekxGeHVJQ0FnSUNBZ0lDQnlaWFJ5ZVVsdVpHVjRQem9nYm5WdFltVnlMRnh1SUNBZ0lDazZJRkJ5YjIxcGMyVThWRTlPUTI5dWRISmhZM1JWYm5OcFoyNWxaRkoxYmsxbGMzTmhaMlUrSUh0Y2JpQWdJQ0FnSUNBZ2JHVjBJR2hsWVdSbGNpQTlJSEJoY21GdGN5NW9aV0ZrWlhJN1hHNGdJQ0FnSUNBZ0lHbG1JQ2dvY0dGeVlXMXpMbUZpYVM1b1pXRmtaWElnZkh3Z1cxMHBMbWx1WTJ4MVpHVnpLQ2R3ZFdKclpYa25LU0FtSmlBaGFHVmhaR1Z5UHk1d2RXSnJaWGtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHdGxlWE1nUFNBb1lYZGhhWFFnWjJWMFUybG5ibWx1WjFOdmRYSmpaU2h3WVhKaGJYTXVjMmxuYm1sdVowSnZlQ3dnY0dGeVlXMXpMbXRsZVZCaGFYSXBLVDh1YTJWNWN6dGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaHJaWGx6S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FHVmhaR1Z5SUQwZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F1TGk1b1pXRmtaWElzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIQjFZbXRsZVRvZ2EyVjVjeTV3ZFdKc2FXTXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJR052Ym5OMElITnBaMjVRWVhKaGJYTWdQU0JoZDJGcGRDQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpiMjUwY21GamRITXVjblZ1TG1WdVkyOWtaVjkxYm5OcFoyNWxaRjl0WlhOellXZGxKeXdnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZV1JrY21WemN6b2djR0Z5WVcxekxtRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoWW1rNklIQmhjbUZ0Y3k1aFlta3NYRzRnSUNBZ0lDQWdJQ0FnSUNCbWRXNWpkR2x2Yms1aGJXVTZJSEJoY21GdGN5NW1kVzVqZEdsdmJrNWhiV1VzWEc0Z0lDQWdJQ0FnSUNBZ0lDQm9aV0ZrWlhJNklHaGxZV1JsY2l4Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJ5ZVVsdVpHVjRPaUJ5WlhSeWVVbHVaR1Y0TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdhVzV3ZFhRNklIQmhjbUZ0Y3k1cGJuQjFkQ3hjYmlBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoWkdSeVpYTnpPaUJ3WVhKaGJYTXVZV1JrY21WemN5eGNiaUFnSUNBZ0lDQWdJQ0FnSUdaMWJtTjBhVzl1VG1GdFpUb2djR0Z5WVcxekxtWjFibU4wYVc5dVRtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lITnBaMjVRWVhKaGJYTTZJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F1TGk1emFXZHVVR0Z5WVcxekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRmlhVG9nY0dGeVlXMXpMbUZpYVN4Y2JpQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUgwN1hHNGdJQ0FnZlZ4dVhHNWNiaUFnSUNCaGMzbHVZeUJqY21WaGRHVlRhV2R1WldSTlpYTnpZV2RsS0Z4dUlDQWdJQ0FnSUNCd1lYSmhiWE02SUZSUFRrTnZiblJ5WVdOMFEzSmxZWFJsVTJsbmJtVmtUV1Z6YzJGblpWQmhjbUZ0Y3l4Y2JpQWdJQ0FwT2lCUWNtOXRhWE5sUEZSUFRrTnZiblJ5WVdOMFRXVnpjMkZuWlQ0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNnblkyOXVkSEpoWTNSekxtVnVZMjlrWlY5dFpYTnpZV2RsWDNkcGRHaGZjMmxuYmljc0lIQmhjbUZ0Y3lrN1hHNGdJQ0FnZlZ4dVhHNWNiaUFnSUNCaGMzbHVZeUJqY21WaGRHVlRhV2R1WldSRVpYQnNiM2xOWlhOellXZGxLRnh1SUNBZ0lDQWdJQ0J3WVhKaGJYTTZJRlJQVGtOdmJuUnlZV04wUTNKbFlYUmxVMmxuYm1Wa1JHVndiRzk1VFdWemMyRm5aVkJoY21GdGN5eGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGUlBUa052Ym5SeVlXTjBSR1Z3Ykc5NVRXVnpjMkZuWlQ0Z2UxeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCdFpYTnpZV2RsSUQwZ1lYZGhhWFFnZEdocGN5NWpjbVZoZEdWVGFXZHVaV1JOWlhOellXZGxLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHRmlhVG9nY0dGeVlXMXpMblZ1YzJsbmJtVmtUV1Z6YzJGblpTNXphV2R1VUdGeVlXMXpMbUZpYVN4Y2JpQWdJQ0FnSUNBZ0lDQWdJSFZ1YzJsbmJtVmtRbmwwWlhOQ1lYTmxOalE2SUhCaGNtRnRjeTUxYm5OcFoyNWxaRTFsYzNOaFoyVXVjMmxuYmxCaGNtRnRjeTUxYm5OcFoyNWxaRUo1ZEdWelFtRnpaVFkwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjMmxuYmtKNWRHVnpRbUZ6WlRZME9pQndZWEpoYlhNdWMybG5ia0o1ZEdWelFtRnpaVFkwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjSFZpYkdsalMyVjVTR1Y0T2lCd1lYSmhiWE11Y0hWaWJHbGpTMlY1U0dWNExGeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnYldWemMyRm5aUzVsZUhCcGNtVWdQU0J3WVhKaGJYTXVkVzV6YVdkdVpXUk5aWE56WVdkbExuTnBaMjVRWVhKaGJYTXVaWGh3YVhKbE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWVdSa2NtVnpjem9nY0dGeVlXMXpMblZ1YzJsbmJtVmtUV1Z6YzJGblpTNWhaR1J5WlhOekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnYldWemMyRm5aU3hjYmlBZ0lDQWdJQ0FnZlR0Y2JpQWdJQ0I5WEc1Y2JseHVJQ0FnSUdGemVXNWpJR055WldGMFpWTnBaMjVsWkZKMWJrMWxjM05oWjJVb1hHNGdJQ0FnSUNBZ0lIQmhjbUZ0Y3pvZ1ZFOU9RMjl1ZEhKaFkzUkRjbVZoZEdWVGFXZHVaV1JTZFc1TlpYTnpZV2RsVUdGeVlXMXpMRnh1SUNBZ0lDazZJRkJ5YjIxcGMyVThWRTlPUTI5dWRISmhZM1JTZFc1TlpYTnpZV2RsUGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUcxbGMzTmhaMlVnUFNCaGQyRnBkQ0IwYUdsekxtTnlaV0YwWlZOcFoyNWxaRTFsYzNOaFoyVW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ1lXSnBPaUJ3WVhKaGJYTXVkVzV6YVdkdVpXUk5aWE56WVdkbExuTnBaMjVRWVhKaGJYTXVZV0pwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdkVzV6YVdkdVpXUkNlWFJsYzBKaGMyVTJORG9nY0dGeVlXMXpMblZ1YzJsbmJtVmtUV1Z6YzJGblpTNXphV2R1VUdGeVlXMXpMblZ1YzJsbmJtVmtRbmwwWlhOQ1lYTmxOalFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnphV2R1UW5sMFpYTkNZWE5sTmpRNklIQmhjbUZ0Y3k1emFXZHVRbmwwWlhOQ1lYTmxOalFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQndkV0pzYVdOTFpYbElaWGc2SUhCaGNtRnRjeTV3ZFdKc2FXTkxaWGxJWlhnc1hHNGdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lDQWdJQ0J0WlhOellXZGxMbVY0Y0dseVpTQTlJSEJoY21GdGN5NTFibk5wWjI1bFpFMWxjM05oWjJVdWMybG5ibEJoY21GdGN5NWxlSEJwY21VN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoWkdSeVpYTnpPaUJ3WVhKaGJYTXVkVzV6YVdkdVpXUk5aWE56WVdkbExtRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoWW1rNklIQmhjbUZ0Y3k1MWJuTnBaMjVsWkUxbGMzTmhaMlV1YzJsbmJsQmhjbUZ0Y3k1aFlta3NYRzRnSUNBZ0lDQWdJQ0FnSUNCbWRXNWpkR2x2Yms1aGJXVTZJSEJoY21GdGN5NTFibk5wWjI1bFpFMWxjM05oWjJVdVpuVnVZM1JwYjI1T1lXMWxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2JXVnpjMkZuWlN4Y2JpQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUJuWlhSRGIyUmxSbkp2YlVsdFlXZGxLRnh1SUNBZ0lDQWdJQ0J3WVhKaGJYTTZJRlJQVGtOdmJuUnlZV04wUjJWMFEyOWtaVVp5YjIxSmJXRm5aVkJoY21GdGN5eGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGUlBUa052Ym5SeVlXTjBSMlYwUTI5a1pVWnliMjFKYldGblpWSmxjM1ZzZEQ0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNnblkyOXVkSEpoWTNSekxtbHRZV2RsTG1OdlpHVW5MQ0J3WVhKaGJYTXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUdkbGRFUmxjR3h2ZVVSaGRHRW9YRzRnSUNBZ0lDQWdJSEJoY21GdGN6b2dWRTlPUTI5dWRISmhZM1JIWlhSRVpYQnNiM2xFWVhSaFVHRnlZVzF6TEZ4dUlDQWdJQ2s2SUZCeWIyMXBjMlU4VkU5T1EyOXVkSEpoWTNSSFpYUkVaWEJzYjNsRVlYUmhVbVZ6ZFd4MFBpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpiMjUwY21GamRITXVaR1Z3Ykc5NUxtUmhkR0VuTENCd1lYSmhiWE1wTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklHTnlaV0YwWlZKMWJrSnZaSGtvWEc0Z0lDQWdJQ0FnSUhCaGNtRnRjem9nVkU5T1EyOXVkSEpoWTNSRGNtVmhkR1ZTZFc1Q2IyUjVVR0Z5WVcxekxGeHVJQ0FnSUNrNklGQnliMjFwYzJVOFZFOU9RMjl1ZEhKaFkzUkRjbVZoZEdWU2RXNUNiMlI1VW1WemRXeDBQaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSmxjWFZsYzNSRGIzSmxLQ2RqYjI1MGNtRmpkSE11Y25WdUxtSnZaSGtuTENCd1lYSmhiWE1wTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklHZGxkRVoxYm1OMGFXOXVTV1FvWEc0Z0lDQWdJQ0FnSUhCaGNtRnRjem9nVkU5T1EyOXVkSEpoWTNSSFpYUkdkVzVqZEdsdmJrbGtVR0Z5WVcxekxGeHVJQ0FnSUNrNklGQnliMjFwYzJVOFZFOU9RMjl1ZEhKaFkzUkhaWFJHZFc1amRHbHZia2xrVW1WemRXeDBQaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSmxjWFZsYzNSRGIzSmxLQ2RqYjI1MGNtRmpkSE11Wm5WdVkzUnBiMjR1YVdRbkxDQndZWEpoYlhNcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJR2RsZEVKdlkwaGhjMmdvWEc0Z0lDQWdJQ0FnSUhCaGNtRnRjem9nVkU5T1EyOXVkSEpoWTNSQ2IyTXNYRzRnSUNBZ0tUb2dVSEp2YldselpUeFVUMDVEYjI1MGNtRmpkRWRsZEVKdlkwaGhjMmhTWlhOMWJIUStJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnhkV1Z6ZEVOdmNtVW9KMk52Ym5SeVlXTjBjeTVpYjJNdWFHRnphQ2NzSUhCaGNtRnRjeWs3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ2NHRnljMlZOWlhOellXZGxLRnh1SUNBZ0lDQWdJQ0J3WVhKaGJYTTZJRlJQVGtOdmJuUnlZV04wUW05akxGeHVJQ0FnSUNrNklGQnliMjFwYzJVOFVVMWxjM05oWjJVK0lIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WeGRXVnpkRU52Y21Vb0oyTnZiblJ5WVdOMGN5NXdZWEp6WlM1dFpYTnpZV2RsSnl3Z2NHRnlZVzF6S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCTlpYTnpZV2RsSUhCaGNuTnBibWRjYmx4dUlDQWdJR0Z6ZVc1aklHUmxZMjlrWlZKMWJrOTFkSEIxZENoY2JpQWdJQ0FnSUNBZ2NHRnlZVzF6T2lCVVQwNURiMjUwY21GamRFUmxZMjlrWlZKMWJrOTFkSEIxZEZCaGNtRnRjeXhjYmlBZ0lDQXBPaUJRY205dGFYTmxQRlJQVGtOdmJuUnlZV04wVW5WdVVtVnpkV3gwUGlCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsY1hWbGMzUkRiM0psS0NkamIyNTBjbUZqZEhNdWNuVnVMbTkxZEhCMWRDY3NJSEJoY21GdGN5azdYRzRnSUNBZ2ZWeHVYRzVjYmlBZ0lDQmhjM2x1WXlCa1pXTnZaR1ZKYm5CMWRFMWxjM05oWjJWQ2IyUjVLRnh1SUNBZ0lDQWdJQ0J3WVhKaGJYTTZJRlJQVGtOdmJuUnlZV04wUkdWamIyUmxUV1Z6YzJGblpVSnZaSGxRWVhKaGJYTXNYRzRnSUNBZ0tUb2dVSEp2YldselpUeFVUMDVEYjI1MGNtRmpkRVJsWTI5a1pVMWxjM05oWjJWQ2IyUjVVbVZ6ZFd4MFBpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpiMjUwY21GamRITXVjblZ1TG5WdWEyNXZkMjR1YVc1d2RYUW5MQ0J3WVhKaGJYTXBPMXh1SUNBZ0lIMWNibHh1WEc0Z0lDQWdZWE41Ym1NZ1pHVmpiMlJsVDNWMGNIVjBUV1Z6YzJGblpVSnZaSGtvWEc0Z0lDQWdJQ0FnSUhCaGNtRnRjem9nVkU5T1EyOXVkSEpoWTNSRVpXTnZaR1ZOWlhOellXZGxRbTlrZVZCaGNtRnRjeXhjYmlBZ0lDQXBPaUJRY205dGFYTmxQRlJQVGtOdmJuUnlZV04wUkdWamIyUmxUV1Z6YzJGblpVSnZaSGxTWlhOMWJIUStJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnhkV1Z6ZEVOdmNtVW9KMk52Ym5SeVlXTjBjeTV5ZFc0dWRXNXJibTkzYmk1dmRYUndkWFFuTENCd1lYSmhiWE1wTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUUxbGMzTmhaMlVnY0hKdlkyVnpjMmx1WjF4dVhHNGdJQ0FnWVhONWJtTWdaVzV6ZFhKbFRXVnpjMkZuWlVsa0tHMWxjM05oWjJVNklGUlBUa052Ym5SeVlXTjBUV1Z6YzJGblpTazZJRkJ5YjIxcGMyVThjM1J5YVc1blBpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnRaWE56WVdkbExtMWxjM05oWjJWSlpDQjhmQ0JoZDJGcGRDQW9ZWE41Ym1NZ0tDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2FXUWdQU0FvWVhkaGFYUWdkR2hwY3k1blpYUkNiMk5JWVhOb0tIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmliMk5DWVhObE5qUTZJRzFsYzNOaFoyVXViV1Z6YzJGblpVSnZaSGxDWVhObE5qUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCOUtTa3VhR0Z6YUR0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzFsYzNOaFoyVXViV1Z6YzJGblpVbGtJRDBnYVdRN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdhV1E3WEc0Z0lDQWdJQ0FnSUgwcEtDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nYzJWdVpFMWxjM05oWjJVb1hHNGdJQ0FnSUNBZ0lIQmhjbUZ0Y3pvZ1ZFOU9RMjl1ZEhKaFkzUk5aWE56WVdkbExGeHVJQ0FnSUNBZ0lDQndZWEpsYm5SVGNHRnVQem9nS0ZOd1lXNGdmQ0JUY0dGdVEyOXVkR1Y0ZENrc1hHNGdJQ0FnS1RvZ1VISnZiV2x6WlR4VVQwNU5aWE56WVdkbFVISnZZMlZ6YzJsdVoxTjBZWFJsUGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUdWNGNHbHlaU0E5SUhCaGNtRnRjeTVsZUhCcGNtVTdYRzRnSUNBZ0lDQWdJR2xtSUNobGVIQnBjbVVnSmlZZ0tFUmhkR1V1Ym05M0tDa2dQaUJsZUhCcGNtVWdLaUF4TURBd0tTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnVkU5T1EyeHBaVzUwUlhKeWIzSXVjMlZ1WkU1dlpHVlNaWEYxWlhOMFJtRnBiR1ZrS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNkTlpYTnpZV2RsSUdGc2NtVmhaSGtnWlhod2FYSmxaQ2NzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWVhkaGFYUWdkR2hwY3k1amIyMXdiR1YwWlVWeWNtOXlSR0YwWVNoN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0ZrWkhKbGMzTTZJSEJoY21GdGN5NWhaR1J5WlhOekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxYMmxrT2lCd1lYSmhiWE11YldWemMyRm5aVWxrTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwcExGeHVJQ0FnSUNBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCelpYSjJaWEpVYVcxbFJHVnNkR0VnUFNCTllYUm9MbUZpY3loaGQyRnBkQ0IwYUdsekxuRjFaWEpwWlhNdWMyVnlkbVZ5VkdsdFpVUmxiSFJoS0hCaGNtVnVkRk53WVc0cEtUdGNiaUFnSUNBZ0lDQWdhV1lnS0hObGNuWmxjbFJwYldWRVpXeDBZU0ErSUhSb2FYTXVZMjl1Wm1sbkxtOTFkRTltVTNsdVkxUm9jbVZ6YUc5c1pDZ3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG5GMVpYSnBaWE11WkhKdmNGTmxjblpsY2xScGJXVkVaV3gwWVNncE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dWRTlPUTJ4cFpXNTBSWEp5YjNJdVkyeHZZMnRQZFhSUFpsTjVibU1vWVhkaGFYUWdkR2hwY3k1amIyMXdiR1YwWlVWeWNtOXlSR0YwWVNncEtUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JqYjI1emRDQnNZWE4wUW14dlkydEpaQ0E5SUdGM1lXbDBJSFJvYVhNdVptbHVaRXhoYzNSVGFHRnlaRUpzYjJOcktIQmhjbUZ0Y3k1aFpHUnlaWE56S1R0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYVdRZ1BTQmhkMkZwZENCMGFHbHpMbVZ1YzNWeVpVMWxjM05oWjJWSlpDaHdZWEpoYlhNcE8xeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCcFpFSmhjMlUyTkNBOUlFSjFabVpsY2k1bWNtOXRLR2xrTENBbmFHVjRKeWt1ZEc5VGRISnBibWNvSjJKaGMyVTJOQ2NwTzF4dUlDQWdJQ0FnSUNCamIyNXpkQ0J0WlhOellXZGxVM0JoYmlBOUlIUm9hWE11WTI5dWRHVjRkQzV6ZEdGeWRGSnZiM1JUY0dGdUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdRdWMzVmljM1J5S0RBc0lERTJLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHbGtMbk4xWW5OMGNpZ3hOaXdnTVRZcExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSjIxbGMzTmhaMlZRY205alpYTnphVzVuSnl4Y2JpQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdiV1Z6YzJGblpWTndZVzR1WVdSa1ZHRm5jeWg3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnRaWE56WVdkbFNXUTZJR2xrTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdiV1Z6YzJGblpWTnBlbVU2SUUxaGRHZ3VZMlZwYkNod1lYSmhiWE11YldWemMyRm5aVUp2WkhsQ1lYTmxOalF1YkdWdVozUm9JQ29nTXlBdklEUXBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lXUmtjbVZ6Y3pvZ2NHRnlZVzF6TG1Ga1pISmxjM01zWEc0Z0lDQWdJQ0FnSUNBZ0lDQmxlSEJwY21VNklIQmhjbUZ0Y3k1bGVIQnBjbVVzWEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ0lDQmhkMkZwZENCMGFHbHpMbkYxWlhKcFpYTXVjRzl6ZEZKbGNYVmxjM1J6S0Z0Y2JpQWdJQ0FnSUNBZ0lDQWdJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWkRvZ2FXUkNZWE5sTmpRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1ltOWtlVG9nY0dGeVlXMXpMbTFsYzNOaFoyVkNiMlI1UW1GelpUWTBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTeGNiaUFnSUNBZ0lDQWdYU3dnY0dGeVpXNTBVM0JoYmlrN1hHNGdJQ0FnSUNBZ0lHMWxjM05oWjJWVGNHRnVMbVpwYm1semFDZ3BPMXh1SUNBZ0lDQWdJQ0IwYUdsekxtTnZibVpwWnk1c2IyY29KM05sYm1STlpYTnpZV2RsTGlCU1pYRjFaWE4wSUhCdmMzUmxaQ2NzSUdsa0tUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUd4aGMzUkNiRzlqYTBsa0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnYzJWdVpHbHVaMVJwYldVNklFMWhkR2d1Y205MWJtUW9SR0YwWlM1dWIzY29LU0F2SURFd01EQXBMRnh1SUNBZ0lDQWdJQ0I5TzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklIQnliMk5sYzNOTlpYTnpZV2RsS0Z4dUlDQWdJQ0FnSUNCdFpYTnpZV2RsT2lCVVQwNURiMjUwY21GamRFMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lISmxjM1ZzZEVacFpXeGtjem9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1UHpvZ0tGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDa3NYRzRnSUNBZ0lDQWdJSEpsZEhKNVNXNWtaWGcvT2lCdWRXMWlaWElzWEc0Z0lDQWdJQ0FnSUdGa1pISmxjM00vT2lCemRISnBibWNzWEc0Z0lDQWdJQ0FnSUdGaWFUODZJRlJQVGtOdmJuUnlZV04wUVVKSkxGeHVJQ0FnSUNBZ0lDQm1kVzVqZEdsdmJrNWhiV1UvT2lCemRISnBibWNzWEc0Z0lDQWdLVG9nVUhKdmJXbHpaVHhSVkhKaGJuTmhZM1JwYjI0K0lIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NISnZZMlZ6YzJsdVp5QTlJR0YzWVdsMElIUm9hWE11YzJWdVpFMWxjM05oWjJVb2JXVnpjMkZuWlN3Z2NHRnlaVzUwVTNCaGJpazdYRzRnSUNBZ0lDQWdJR052Ym5OMElIc2dkSEpoYm5OaFkzUnBiMjRnZlNBOUlHRjNZV2wwSUhSb2FYTXVkMkZwZEVadmNsUnlZVzV6WVdOMGFXOXVLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxVSEp2WTJWemMybHVaMU4wWVhSbE9pQndjbTlqWlhOemFXNW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NHRnlaVzUwVTNCaGJpeGNiaUFnSUNBZ0lDQWdJQ0FnSUdGaWFTeGNiaUFnSUNBZ0lDQWdJQ0FnSUdaMWJtTjBhVzl1VG1GdFpTeGNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwY21GdWMyRmpkR2x2Ymp0Y2JpQWdJQ0I5WEc1Y2JseHVJQ0FnSUdGemVXNWpJR1pwYm1STVlYTjBRbXh2WTJzb1kyaGhhVzQ2SUc1MWJXSmxjaXdnY21WemRXeDBPaUJ6ZEhKcGJtY3NJR0ZrWkdsMGFXOXVZV3hHYVd4MFpYSS9PaUJoYm5rcE9pQlFjbTl0YVhObFBEOWhibmsrSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWW14dlkydHpJRDBnWVhkaGFYUWdkR2hwY3k1eGRXVnlhV1Z6TG1Kc2IyTnJjeTV4ZFdWeWVTaDdYRzRnSUNBZ0lDQWdJQ0FnSUNCbWFXeDBaWEk2SUhzZ2QyOXlhMk5vWVdsdVgybGtPaUI3SUdWeE9pQmphR0ZwYmlCOUxDQXVMaTRvWVdSa2FYUnBiMjVoYkVacGJIUmxjaUI4ZkNCN2ZTa2dmU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZEN4Y2JpQWdJQ0FnSUNBZ0lDQWdJRzl5WkdWeVFuazZJRnRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIQmhkR2c2SUNkelpYRmZibThuTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmthWEpsWTNScGIyNDZJQ2RFUlZOREp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1hTeGNiaUFnSUNBZ0lDQWdJQ0FnSUd4cGJXbDBPaUF4TEZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHSnNiMk5yY3k1c1pXNW5kR2dnUGlBd0lEOGdZbXh2WTJ0eld6QmRJRG9nYm5Wc2JEdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUJtYVc1a1RXRjBZMmhwYm1kVGFHRnlaQ2h6YUdGeVpITTZJRkZUYUdGeVpFaGhjMmhiWFN3Z1lXUmtjbVZ6Y3pvZ2MzUnlhVzVuS1RvZ1VISnZiV2x6WlR3L1VWTm9ZWEprU0dGemFENGdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpYRjFaWE4wUTI5eVpTZ25ZMjl1ZEhKaFkzUnpMbVpwYm1RdWMyaGhjbVFuTENCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J6YUdGeVpITXNYRzRnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUJtYVc1a1RHRnpkRk5vWVhKa1FteHZZMnNvWVdSa2NtVnpjem9nYzNSeWFXNW5LVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZV1JrY21WemMxQmhjblJ6SUQwZ1lXUmtjbVZ6Y3k1emNHeHBkQ2duT2ljcE8xeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCM2IzSnJZMmhoYVc0Z1BTQmhaR1J5WlhOelVHRnlkSE11YkdWdVozUm9JRDRnTVNBL0lFNTFiV0psY2k1d1lYSnpaVWx1ZENoaFpHUnlaWE56VUdGeWRITmJNRjBzSURFd0tTQTZJREE3WEc1Y2JseHVJQ0FnSUNBZ0lDQXZMeUJwWmlCaFkyTnZkVzUwSUhKbGMybGtaWE1nYVc0Z2JXRnpkR1Z5SUdOb1lXbHVJSFJvWlc0Z2MzUmhjblJwYm1jZ2NHOXBiblFnYVhNZ2JHRnpkQ0J0WVhOMFpYSWdZMmhoYVc0Z1lteHZZMnRjYmlBZ0lDQWdJQ0FnTHk4Z1oyVnVaWEpoZEdWa0lHSmxabTl5WlNCdFpYTnpZV2RsSUhkaGN5QnpaVzUwWEc0Z0lDQWdJQ0FnSUdOdmJuTjBJRzFoYzNSbGNtTm9ZV2x1VEdGemRFSnNiMk5ySUQwZ1lYZGhhWFFnZEdocGN5NW1hVzVrVEdGemRFSnNiMk5yS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdUVUZUVkVWU1EwaEJTVTVmU1VRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FuYVdRZ2JXRnpkR1Z5SUhzZ2MyaGhjbVJmYUdGemFHVnpJSHNnZDI5eWEyTm9ZV2x1WDJsa0lITm9ZWEprSUdSbGMyTnlJSHNnY205dmRGOW9ZWE5vSUgwZ2ZTQjlKeXhjYmlBZ0lDQWdJQ0FnS1R0Y2JseHVJQ0FnSUNBZ0lDQXZMeUJwWmlCaFkyTnZkVzUwSUhKbGMybGtaWE1nYVc0Z2JXRnpkR1Z5WTJoaGFXNGdkR2hsYmlCemRHRnlkR2x1WnlCd2IybHVkQ0JwY3lCc1lYTjBJRzFoYzNSbGNtTm9ZV2x1SUdKc2IyTnJYRzRnSUNBZ0lDQWdJR2xtSUNoM2IzSnJZMmhoYVc0Z1BUMDlJRTFCVTFSRlVrTklRVWxPWDBsRUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9JVzFoYzNSbGNtTm9ZV2x1VEdGemRFSnNiMk5yS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnVkU5T1EyeHBaVzUwUlhKeWIzSXVibTlDYkc5amEzTW9UVUZUVkVWU1EwaEJTVTVmU1VRc0lHRjNZV2wwSUhSb2FYTXVZMjl0Y0d4bGRHVkZjbkp2Y2tSaGRHRW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwcEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnRZWE4wWlhKamFHRnBia3hoYzNSQ2JHOWpheTVwWkR0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQzh2SUdsbUlHRmpZMjkxYm5RZ2FYTWdabkp2YlNCdmRHaGxjaUJqYUdGcGJuTWdkR2hsYmlCemRHRnlkR2x1WnlCd2IybHVkQ0JwY3lCc1lYTjBJR0ZqWTI5MWJuUW5jeUJ6YUdGeVpDQmliRzlqYTF4dUlDQWdJQ0FnSUNBdkx5QlVieUJ2WW5SaGFXNGdhWFFnZDJVZ2RHRnJaU0J0WVhOMFpYSmphR0ZwYmlCaWJHOWpheUIwYnlCblpYUWdjMmhoY21SeklHTnZibVpwWjNWeVlYUnBiMjRnWVc1a0lITmxiR1ZqZEZ4dUlDQWdJQ0FnSUNBdkx5QnRZWFJqYUdsdVp5QnphR0Z5WkZ4dUlDQWdJQ0FnSUNCcFppQW9JVzFoYzNSbGNtTm9ZV2x1VEdGemRFSnNiMk5yS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCT2IyUmxJRk5GSUdOaGMyVWdMU0J1YnlCdFlYTjBaWEpqYUdGcGJpd2dibThnYzJoaGNtUnBibWN1SUVOb1pXTnJJSFJvWVhRZ2IyNXNlU0J2Ym1VZ2MyaGhjbVJjYmlBZ0lDQWdJQ0FnSUNBZ0lHeGxkQ0IzYjNKclkyaGhhVzVNWVhOMFFteHZZMnNnUFNCaGQyRnBkQ0IwYUdsekxtWnBibVJNWVhOMFFteHZZMnNvZDI5eWEyTm9ZV2x1TENBbllXWjBaWEpmYldWeVoyVWdjMmhoY21RbktUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDZ2hkMjl5YTJOb1lXbHVUR0Z6ZEVKc2IyTnJLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dWRTlPUTJ4cFpXNTBSWEp5YjNJdWJtOUNiRzlqYTNNb2QyOXlhMk5vWVdsdUxDQmhkMkZwZENCMGFHbHpMbU52YlhCc1pYUmxSWEp5YjNKRVlYUmhLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lXUmtjbVZ6Y3l4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUtTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklHbG1JSGR2Y210amFHRnBiaUJwY3lCemFHRnlaR1ZrSUhSb1pXNGdhWFFnYVhNZ2JtOTBJRTV2WkdVZ1UwVWdZVzVrSUcxaGMzUmxjbU5vWVdsdUlHSnNiMk5yY3lCdGFYTnphVzVuWEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJwY3lCbGNuSnZjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSGR2Y210amFHRnBia3hoYzNSQ2JHOWpheTVoWm5SbGNsOXRaWEpuWlNCOGZDQjNiM0pyWTJoaGFXNU1ZWE4wUW14dlkyc3VjMmhoY21RZ0lUMDlJQ2M0TURBd01EQXdNREF3TURBd01EQXdKeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRlJQVGtOc2FXVnVkRVZ5Y205eUxtNXZRbXh2WTJ0ektFMUJVMVJGVWtOSVFVbE9YMGxFTENCaGQyRnBkQ0IwYUdsekxtTnZiWEJzWlhSbFJYSnliM0pFWVhSaEtIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWVdSa2NtVnpjeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5S1NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUZSaGEyVWdiR0Z6ZENCaWJHOWpheUJpZVNCelpYRmZibTljYmlBZ0lDQWdJQ0FnSUNBZ0lIZHZjbXRqYUdGcGJreGhjM1JDYkc5amF5QTlJR0YzWVdsMElIUm9hWE11Wm1sdVpFeGhjM1JDYkc5amF5aDNiM0pyWTJoaGFXNHNJQ2RwWkNjc0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnphR0Z5WkRvZ2V5QmxjVG9nSnpnd01EQXdNREF3TURBd01EQXdNREFuSUgwc1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaGQyOXlhMk5vWVdsdVRHRnpkRUpzYjJOcktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1ZFOU9RMnhwWlc1MFJYSnliM0l1YVc1MllXeHBaRUpzYjJOclkyaGhhVzRvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDZE9ieUJ6ZEdGeWRHbHVaeUJPYjJSbElGTkZJR0pzYjJOcklHWnZkVzVrSnl4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWGRoYVhRZ2RHaHBjeTVqYjIxd2JHVjBaVVZ5Y205eVJHRjBZU2g3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JoWkdSeVpYTnpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSGR2Y210amFHRnBia3hoYzNSQ2JHOWpheTVwWkR0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJR052Ym5OMElITm9ZWEprY3pvZ1AxRlRhR0Z5WkVoaGMyaGJYU0E5SUcxaGMzUmxjbU5vWVdsdVRHRnpkRUpzYjJOclB5NXRZWE4wWlhJL0xuTm9ZWEprWDJoaGMyaGxjenRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRnphR0Z5WkhNZ2ZId2djMmhoY21SekxteGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1ZFOU9RMnhwWlc1MFJYSnliM0l1YVc1MllXeHBaRUpzYjJOclkyaGhhVzRvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSjA1dklHQnphR0Z5WkY5b1lYTm9aWE5nSUdacFpXeGtJR2x1SUcxaGMzUmxjbU5vWVdsdUlHSnNiMk5ySnl4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaGQyRnBkQ0IwYUdsekxtTnZiWEJzWlhSbFJYSnliM0pFWVhSaEtIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWVdSa2NtVnpjeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5S1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYzJoaGNtUkNiRzlqYXlBOUlHRjNZV2wwSUhSb2FYTXVabWx1WkUxaGRHTm9hVzVuVTJoaGNtUW9jMmhoY21SekxDQmhaR1J5WlhOektUdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NtOXZkRjlvWVhOb0lEMGdjMmhoY21SQ2JHOWphejh1WkdWelkzSS9Mbkp2YjNSZmFHRnphRHRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRnliMjkwWDJoaGMyZ3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9jbTkzSUZSUFRrTnNhV1Z1ZEVWeWNtOXlMbWx1ZG1Gc2FXUkNiRzlqYTJOb1lXbHVLRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ2RPYnlCZ2NtOXZkRjlvWVhOb1lDQm1hV1ZzWkNCcGJpQnphR0Z5WkNCa1pYTmpjaWNzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWVhkaGFYUWdkR2hwY3k1amIyMXdiR1YwWlVWeWNtOXlSR0YwWVNoN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0ZrWkhKbGMzTXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ5YjI5MFgyaGhjMmc3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ1kyaGxZMnRUYUdGeVpFMWhkR05vS0dKc2IyTnJPaUJSUW14dlkyc3NJR0ZrWkhKbGMzTTZJSE4wY21sdVp5azZJRkJ5YjIxcGMyVThZbTl2YkdWaGJqNGdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdJU0VvWVhkaGFYUWdkR2hwY3k1bWFXNWtUV0YwWTJocGJtZFRhR0Z5WkNoYlhHNGdJQ0FnSUNBZ0lDQWdJQ0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZDI5eWEyTm9ZV2x1WDJsa09pQmliRzlqYXk1M2IzSnJZMmhoYVc1ZmFXUWdmSHdnTUN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCemFHRnlaRG9nWW14dlkyc3VjMmhoY21RZ2ZId2dKeWNzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlMRnh1SUNBZ0lDQWdJQ0JkTENCaFpHUnlaWE56S1NrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdkMkZwZEU1bGVIUkNiRzlqYXloamRYSnlaVzUwT2lCemRISnBibWNzSUdGa1pISmxjM002SUhOMGNtbHVaeXdnZEdsdFpXOTFkRDg2SUc1MWJXSmxjaWs2SUZCeWIyMXBjMlU4VVVKc2IyTnJQaUI3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR0pzYjJOcklEMGdZWGRoYVhRZ2RHaHBjeTV4ZFdWeWFXVnpMbUpzYjJOcmN5NTNZV2wwUm05eUtIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdacGJIUmxjam9nZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhCeVpYWmZjbVZtT2lCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEp2YjNSZmFHRnphRG9nZXlCbGNUb2dZM1Z5Y21WdWRDQjlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnVDFJNklIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY0hKbGRsOWhiSFJmY21WbU9pQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnliMjkwWDJoaGMyZzZJSHNnWlhFNklHTjFjbkpsYm5RZ2ZTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2REb2dRa3hQUTB0ZlJrbEZURVJUTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdkR2x0Wlc5MWRDeGNiaUFnSUNBZ0lDQWdmU2s3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLR0pzYjJOclB5NWhablJsY2w5emNHeHBkQ0FtSmlBaEtHRjNZV2wwSUhSb2FYTXVZMmhsWTJ0VGFHRnlaRTFoZEdOb0tHSnNiMk5yTENCaFpHUnlaWE56S1NrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuRjFaWEpwWlhNdVlteHZZMnR6TG5kaGFYUkdiM0lvZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdacGJIUmxjam9nZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaRG9nZXlCdVpUb2dZbXh2WTJzdWFXUWdmU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NISmxkbDl5WldZNklIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISnZiM1JmYUdGemFEb2dleUJsY1RvZ1kzVnljbVZ1ZENCOUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NtVnpkV3gwT2lCQ1RFOURTMTlHU1VWTVJGTXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2x0Wlc5MWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmliRzlqYXp0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QjNZV2wwUm05eVZISmhibk5oWTNScGIyNG9jR0Z5WVcxek9pQlVUMDVYWVdsMFJtOXlWSEpoYm5OaFkzUnBiMjVRWVhKaGJYTXBPaUJRY205dGFYTmxQRlJQVGtOdmJuUnlZV04wVW5WdVVtVnpkV3gwUGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhSdmRHRnNVM1JoY25RZ1BTQkVZWFJsTG01dmR5Z3BPMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQmxlSEJwY21VZ1BTQndZWEpoYlhNdWJXVnpjMkZuWlM1bGVIQnBjbVVnZkh3Z01EdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2JXVnpjMkZuWlVsa0lEMGdZWGRoYVhRZ2RHaHBjeTVsYm5OMWNtVk5aWE56WVdkbFNXUW9jR0Z5WVcxekxtMWxjM05oWjJVcE8xeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCaFpHUnlaWE56SUQwZ2NHRnlZVzF6TG0xbGMzTmhaMlV1WVdSa2NtVnpjenRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdjSEp2WTJWemMybHVaeUE5SUhzZ0xpNHVjR0Z5WVcxekxtMWxjM05oWjJWUWNtOWpaWE56YVc1blUzUmhkR1VnZlR0Y2JpQWdJQ0FnSUNBZ2JHVjBJSFJ5WVc1ellXTjBhVzl1SUQwZ2JuVnNiRHRjYmlBZ0lDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJSFJwYldWU1pYQnZjblFnUFNCYlhUdGNibHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnYzNSdmNGUnBiV1VnUFNCbGVIQnBjbVZjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I4ZkNCTllYUm9Mbkp2ZFc1a0tDaEVZWFJsTG01dmR5Z3BJQ3NnZEdocGN5NWpiMjVtYVdjdWJXVnpjMkZuWlZCeWIyTmxjM05wYm1kVWFXMWxiM1YwS0NrcElDOGdNVEF3TUNrN1hHNWNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR2x1Wm1sdWFYUmxWMkZwZENBOUlIQmhjbUZ0Y3k1cGJtWnBibWwwWlZkaGFYUWdJVDA5SUdaaGJITmxPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWVdSa1ZHbHRaVzkxZENBOUlIUm9hWE11WTI5dVptbG5MbTFsYzNOaFoyVlFjbTlqWlhOemFXNW5WR2x0Wlc5MWRDZ3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2QyaHBiR1VnS0NGMGNtRnVjMkZqZEdsdmJpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHNXZkeUE5SUVSaGRHVXVibTkzS0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnZEdsdFpXOTFkQ0E5SUUxaGRHZ3ViV0Y0S0hOMGIzQlVhVzFsTENCdWIzY3BJQzBnYm05M0lDc2dZV1JrVkdsdFpXOTFkRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JzWlhRZ1lteHZZMnM2SUQ5UlFteHZZMnNnUFNCdWRXeHNPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElITjBZWEowSUQwZ1JHRjBaUzV1YjNjb0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWW14dlkyc2dQU0JoZDJGcGRDQjBhR2x6TG5kaGFYUk9aWGgwUW14dlkyc29jSEp2WTJWemMybHVaeTVzWVhOMFFteHZZMnRKWkN3Z1lXUmtjbVZ6Y3l3Z2RHbHRaVzkxZENrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHVnVaQ0E5SUVSaGRHVXVibTkzS0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJwYldWU1pYQnZjblF1Y0hWemFDaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHQkNiRzlqYXlCYkpIdGliRzlqYXk1cFpDQjhmQ0FuSjMxZElHQmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDc2dZR2hoY3lCaVpXVnVJSEpsWTJWcGRtVmtPaUFrZTJWdVpDQXRJSE4wWVhKMGZTQnRjeXdnWUZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS3lCZ1kyeHBaVzUwSUhScGJXVTZJQ1I3VFdGMGFDNXliM1Z1WkNobGJtUWdMeUF4TURBd0tYMHNJR0JjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ3NnWUdkbGJsOTFkR2x0WlRvZ0pIdGliRzlqYXk1blpXNWZkWFJwYldVZ2ZId2dNSDFnTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1Z5Y205eUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVZMjl1Wm1sbkxteHZaeWduUW14dlkyc2dkMkZwZEdsdVp5Qm1ZV2xzWldRNklDY3NJR1Z5Y205eUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tDRnBibVpwYm1sMFpWZGhhWFFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4bGRDQnlaWE52YkhabFpFVnljbTl5SUQwZ1pYSnliM0k3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1pYSnliM0l1WTI5a1pTQTlQVDBnVkU5T1JYSnliM0pEYjJSbExsZEJTVlJmUms5U1gxUkpUVVZQVlZRcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxaRVZ5Y205eUlEMGdWRTlPUTJ4cFpXNTBSWEp5YjNJdWJtVjBkMjl5YTFOcGJHVnVkQ2hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWGRoYVhRZ2RHaHBjeTVqYjIxd2JHVjBaVVZ5Y205eVJHRjBZU2g3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXVnpjMkZuWlY5cFpEb2diV1Z6YzJGblpVbGtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWW14dlkydGZhV1E2SUhCeWIyTmxjM05wYm1jdWJHRnpkRUpzYjJOclNXUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYVcxbGIzVjBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYldWemMyRm5aVjl3Y205alpYTnphVzVuWDNOMFlYUmxPaUJ3Y205alpYTnphVzVuTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1pYaHdhWEpsTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MyVnVaR2x1WjE5MGFXMWxPaUJ3Y205alpYTnphVzVuTG5ObGJtUnBibWRVYVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2djbVZ6YjJ4MlpXUkZjbkp2Y2p0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbU52Ym1acFp5NXNiMmNvSjFKbGRISjVJSGRoYVhScGJtY3VKeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR0pzYjJOcktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhCeWIyTmxjM05wYm1jdWJHRnpkRUpzYjJOclNXUWdQU0JpYkc5amF5NXBaQ0I4ZkNBbkp6dGNibHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JwYmsxelp5QTlJQ2hpYkc5amF5NXBibDl0YzJkZlpHVnpZM0lnZkh3Z1cxMHBMbVpwYm1Rb2VDQTlQaUI0TG0xeloxOXBaQ0E5UFQwZ2JXVnpjMkZuWlVsa0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHbHVUWE5uS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0IwY21GdWMyRmpkR2x2Ymtsa0lEMGdhVzVOYzJjdWRISmhibk5oWTNScGIyNWZhV1E3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb0lYUnlZVzV6WVdOMGFXOXVTV1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCVVQwNURiR2xsYm5SRmNuSnZjaTVwYm5aaGJHbGtRbXh2WTJ0amFHRnBiaWhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdKMDV2SUdacFpXeGtJR0IwY21GdWMyRmpkR2x2Ymw5cFpHQWdhVzRnWW14dlkyc25MRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhkMkZwZENCMGFHbHpMbU52YlhCc1pYUmxSWEp5YjNKRVlYUmhLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdGa1pISmxjM01zWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdFpYTnpZV2RsWDJsa09pQnRaWE56WVdkbFNXUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMHBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0IwY2xOMFlYSjBJRDBnUkdGMFpTNXViM2NvS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSeVlXNXpZV04wYVc5dUlEMGdZWGRoYVhRZ2RHaHBjeTV4ZFdWeWFXVnpMblJ5WVc1ellXTjBhVzl1Y3k1M1lXbDBSbTl5S0h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1hV3gwWlhJNklIc2dhV1E2SUhzZ1pYRTZJSFJ5WVc1ellXTjBhVzl1U1dRZ2ZTQjlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGMzVnNkRG9nVkZKQlRsTkJRMVJKVDA1ZlJrbEZURVJUWDA5U1JFbE9RVkpaTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUnBiV1Z2ZFhRNklFMUJXRjlVU1UxRlQxVlVMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwY21GalpVMWxjM05oWjJVb2RHaHBjeTVqYjI1bWFXY3VkSEpoWTJWeUxDQnRaWE56WVdkbFNXUXNJQ2QwY21GdWMyRmpkR2x2YmxKbFkyVnBkbVZrSnl3Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJ5WVc1ellXTjBhVzl1U1dRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUnBiV1ZTWlhCdmNuUXVjSFZ6YUNoZ1ZISmhibk5oWTNScGIyNGdXeVI3ZEhKaGJuTmhZM1JwYjI1SlpIMWRJR2hoY3lCaVpXVnVJSEpsWTJWcGRtVmtPaUFrZTBSaGRHVXVibTkzS0NrZ0xTQjBjbE4wWVhKMGZTQnRjMkFwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLQ2hpYkc5amF5NW5aVzVmZFhScGJXVWdmSHdnTUNrZ1BpQnpkRzl3VkdsdFpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0dWNGNHbHlaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUnlZV05sVFdWemMyRm5aU2gwYUdsekxtTnZibVpwWnk1MGNtRmpaWElzSUcxbGMzTmhaMlZKWkN3Z0oyMWxjM05oWjJWRmVIQnBjbVZrSnl3Z2UzMHBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRlJQVGtOc2FXVnVkRVZ5Y205eUxtMWxjM05oWjJWRmVIQnBjbVZrS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JoZDJGcGRDQjBhR2x6TG1OdmJYQnNaWFJsUlhKeWIzSkVZWFJoS0h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRaWE56WVdkbFgybGtPaUJ0WlhOellXZGxTV1FzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCelpXNWthVzVuWDNScGJXVTZJSEJ5YjJObGMzTnBibWN1YzJWdVpHbHVaMVJwYldVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxlSEJwY21VNklITjBiM0JVYVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbXh2WTJ0ZmRHbHRaVG9nWW14dlkyc3VaMlZ1WDNWMGFXMWxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWW14dlkydGZhV1E2SUhCeWIyTmxjM05wYm1jdWJHRnpkRUpzYjJOclNXUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMHBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFISnZkeUJVVDA1RGJHbGxiblJGY25KdmNpNTBjbUZ1YzJGamRHbHZibGRoYVhSVWFXMWxiM1YwS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRjNZV2wwSUhSb2FYTXVZMjl0Y0d4bGRHVkZjbkp2Y2tSaGRHRW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhaR1J5WlhOekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdFpYTnpZV2RsWDJsa09pQnRaWE56WVdkbFNXUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lITmxibVJwYm1kZmRHbHRaVG9nY0hKdlkyVnpjMmx1Wnk1elpXNWthVzVuVkdsdFpTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RHbHRaVzkxZEN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYldWemMyRm5aVjl3Y205alpYTnphVzVuWDNOMFlYUmxPaUJ3Y205alpYTnphVzVuTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMHBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQWdJQ0FnZEdsdFpWSmxjRzl5ZEM1emNHeHBZMlVvTUN3Z01Dd2dZRlJ5WVc1ellXTjBhVzl1SUhkaGFYUnBibWNnZEdsdFpUb2dKSHRFWVhSbExtNXZkeWdwSUMwZ2RHOTBZV3hUZEdGeWRIMGdiWE5nS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVkyOXVabWxuTG14dlp5aDBhVzFsVW1Wd2IzSjBMbXB2YVc0b0oxeGNiaWNwS1R0Y2JpQWdJQ0FnSUNBZ2ZTQmpZWFJqYUNBb1pYSnliM0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVkyOXVabWxuTG14dlp5Z25XM2RoYVhSR2IzSlVjbUZ1YzJGamRHbHZibDBuTENBblJrRkpURVZFSnl3Z1pYSnliM0lwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0dWeWNtOXlMbU52WkdVZ1BUMDlJRlJQVGtWeWNtOXlRMjlrWlM1TlJWTlRRVWRGWDBWWVVFbFNSVVJjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I4ZkNCbGNuSnZjaTVqYjJSbElEMDlQU0JVVDA1RmNuSnZja052WkdVdVZGSkJUbE5CUTFSSlQwNWZWMEZKVkY5VVNVMUZUMVZVS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnWVhkaGFYUWdkR2hwY3k1eVpYTnZiSFpsUkdWMFlXbHNaV1JGY25KdmNpaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWlhKeWIzSXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhCaGNtRnRjeTV0WlhOellXZGxMbTFsYzNOaFoyVkNiMlI1UW1GelpUWTBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2NtOWpaWE56YVc1bkxuTmxibVJwYm1kVWFXMWxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvY205M0lHVnljbTl5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjSEp2WTJWemMxUnlZVzV6WVdOMGFXOXVLRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lXUmtjbVZ6Y3l4Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJ5WVc1ellXTjBhVzl1TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjR0Z5WVcxekxtRmlhU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIQmhjbUZ0Y3k1bWRXNWpkR2x2Yms1aGJXVXNYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdmVnh1WEc1Y2JpQWdJQ0JoYzNsdVl5QndjbTlqWlhOelZISmhibk5oWTNScGIyNG9YRzRnSUNBZ0lDQWdJR0ZrWkhKbGMzTTZJSE4wY21sdVp5eGNiaUFnSUNBZ0lDQWdkSEpoYm5OaFkzUnBiMjQ2SUZGVWNtRnVjMkZqZEdsdmJpeGNiaUFnSUNBZ0lDQWdZV0pwT2lBL1ZFOU9RMjl1ZEhKaFkzUkJRa2tzWEc0Z0lDQWdJQ0FnSUdaMWJtTjBhVzl1VG1GdFpUb2dQM04wY21sdVp5eGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGUlBUa052Ym5SeVlXTjBVblZ1VW1WemRXeDBQaUI3WEc0Z0lDQWdJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0J5WlhOMWJIUWdQU0JoZDJGcGRDQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpiMjUwY21GamRITXVjSEp2WTJWemN5NTBjbUZ1YzJGamRHbHZiaWNzSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGNtRnVjMkZqZEdsdmJpeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhZbWtzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWm5WdVkzUnBiMjVPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkSEpoYm5OaFkzUnBiMjRzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTGk0dWNtVnpkV3gwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdmVHRjYmlBZ0lDQWdJQ0FnZlNCallYUmphQ0FvWlhKeWIzSXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdGalkyOTFiblJ6SUQwZ1lYZGhhWFFnZEdocGN5NXhkV1Z5YVdWekxtRmpZMjkxYm5SekxuRjFaWEo1S0h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbWFXeDBaWEk2SUhzZ2FXUTZJSHNnWlhFNklHRmtaSEpsYzNNZ2ZTQjlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2REb2dKMkZqWTE5MGVYQmxJR0poYkdGdVkyVW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJwYldWdmRYUTZJREV3TURBc1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoaFkyTnZkVzUwY3k1c1pXNW5kR2dnUFQwOUlEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUhKdmR5QlVUMDVEYkdsbGJuUkZjbkp2Y2k1aFkyTnZkVzUwVFdsemMybHVaeWhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lXUmtjbVZ6Y3l4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWGRoYVhRZ2RHaHBjeTVqYjIxd2JHVjBaVVZ5Y205eVJHRjBZU2g3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J2Y21sbmFXNWhiRjlsY25KdmNqb2daWEp5YjNJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWm5WdVkzUnBiMjVmYm1GdFpUb2dablZ1WTNScGIyNU9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnWlhKeWIzSTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCeVpYTnZiSFpsUkdWMFlXbHNaV1JGY25KdmNpaGNiaUFnSUNBZ0lDQWdaWEp5YjNJNklFVnljbTl5TEZ4dUlDQWdJQ0FnSUNCdFpYTnpZV2RsUW1GelpUWTBPaUJ6ZEhKcGJtY3NYRzRnSUNBZ0lDQWdJSFJwYldVNklHNTFiV0psY2l4Y2JpQWdJQ0FnSUNBZ1lXUmtjbVZ6Y3pvZ2MzUnlhVzVuTEZ4dUlDQWdJQ2tnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0JoWTJOdmRXNTBjeUE5SUdGM1lXbDBJSFJvYVhNdWNYVmxjbWxsY3k1aFkyTnZkVzUwY3k1eGRXVnllU2g3WEc0Z0lDQWdJQ0FnSUNBZ0lDQm1hV3gwWlhJNklIc2dhV1E2SUhzZ1pYRTZJR0ZrWkhKbGMzTWdmU0I5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ6ZFd4ME9pQW5hV1FnWVdOalgzUjVjR1VnWW1Gc1lXNWpaU0JpWVd4aGJtTmxYMjkwYUdWeUlIc2dZM1Z5Y21WdVkza2dkbUZzZFdVZ2ZTQmliMk1nWTI5a1pWOW9ZWE5vSUdSaGRHRmZhR0Z6YUNCc1lYTjBYM0JoYVdRbkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdsdFpXOTFkRG9nTVRBd01DeGNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0FnSUdsbUlDaGhZMk52ZFc1MGN5NXNaVzVuZEdnZ1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQlVUMDVEYkdsbGJuUkZjbkp2Y2k1aFkyTnZkVzUwVFdsemMybHVaeWhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JoWkdSeVpYTnpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0YzWVdsMElIUm9hWE11WTI5dGNHeGxkR1ZGY25KdmNrUmhkR0VvZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhaR1J5WlhOekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J2Y21sbmFXNWhiRjlsY25KdmNqb2daWEp5YjNJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTa3NYRzRnSUNBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJR052Ym5OMElHRmpZMjkxYm5RZ1BTQmhZMk52ZFc1MGMxc3dYVHRjYmlBZ0lDQWdJQ0FnY21WdGIzWmxWSGx3WlU1aGJXVW9ZV05qYjNWdWRDazdYRzRnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoZDJGcGRDQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpiMjUwY21GamRITXVjbVZ6YjJ4MlpTNWxjbkp2Y2ljc0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhaR1J5WlhOekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRmpZMjkxYm5Rc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXVnpjMkZuWlVKaGMyVTJOQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHMWhhVzVGY25KdmNqb2daWEp5YjNJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUNBZ2ZTQmpZWFJqYUNBb2NtVnpiMngyWldRcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJ5WlhOdmJIWmxaRHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWlhKeWIzSTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nYVhORVpYQnNiM2xsWkNoaFpHUnlaWE56T2lCemRISnBibWNzSUhCaGNtVnVkRk53WVc0L09pQW9VM0JoYmlCOElGTndZVzVEYjI1MFpYaDBLU2s2SUZCeWIyMXBjMlU4WW05dmJENGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQmhZMk52ZFc1MElEMGdZWGRoYVhRZ2RHaHBjeTV4ZFdWeWFXVnpMbUZqWTI5MWJuUnpMbkYxWlhKNUtIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdacGJIUmxjam9nZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsa09pQjdJR1Z4T2lCaFpHUnlaWE56SUgwc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lXTmpYM1I1Y0dVNklIc2daWEU2SUZGQlkyTnZkVzUwVkhsd1pTNWhZM1JwZG1VZ2ZTeGNiaUFnSUNBZ0lDQWdJQ0FnSUgwc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUTZJQ2RwWkNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1TEZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHRmpZMjkxYm5RdWJHVnVaM1JvSUQ0Z01EdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUJ3Y205alpYTnpSR1Z3Ykc5NVRXVnpjMkZuWlNoY2JpQWdJQ0FnSUNBZ2JXVnpjMkZuWlRvZ1ZFOU9RMjl1ZEhKaFkzUkVaWEJzYjNsTlpYTnpZV2RsTEZ4dUlDQWdJQ0FnSUNCd1lYSmxiblJUY0dGdVB6b2dLRk53WVc0Z2ZDQlRjR0Z1UTI5dWRHVjRkQ2tzWEc0Z0lDQWdJQ0FnSUhKbGRISjVTVzVrWlhnL09pQnVkVzFpWlhJc1hHNGdJQ0FnS1RvZ1VISnZiV2x6WlR4VVQwNURiMjUwY21GamRFUmxjR3h2ZVZKbGMzVnNkRDRnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbU52Ym1acFp5NXNiMmNvSjNCeWIyTmxjM05FWlhCc2IzbE5aWE56WVdkbEp5d2diV1Z6YzJGblpTazdYRzRnSUNBZ0lDQWdJR2xtSUNoaGQyRnBkQ0IwYUdsekxtbHpSR1Z3Ykc5NVpXUW9iV1Z6YzJGblpTNWhaR1J5WlhOekxDQndZWEpsYm5SVGNHRnVLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhaR1J5WlhOek9pQnRaWE56WVdkbExtRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lXeHlaV0ZrZVVSbGNHeHZlV1ZrT2lCMGNuVmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JqYjI1emRDQndjbTlqWlhOemFXNW5JRDBnWVhkaGFYUWdkR2hwY3k1elpXNWtUV1Z6YzJGblpTaHRaWE56WVdkbExtMWxjM05oWjJVc0lIQmhjbVZ1ZEZOd1lXNHBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1M1lXbDBSbTl5UkdWd2JHOTVWSEpoYm5OaFkzUnBiMjRvYldWemMyRm5aU3dnY0hKdlkyVnpjMmx1Wnl3Z2NHRnlaVzUwVTNCaGJpazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nZDJGcGRFWnZja1JsY0d4dmVWUnlZVzV6WVdOMGFXOXVLRnh1SUNBZ0lDQWdJQ0JrWlhCc2IzbE5aWE56WVdkbE9pQlVUMDVEYjI1MGNtRmpkRVJsY0d4dmVVMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lHMWxjM05oWjJWUWNtOWpaWE56YVc1blUzUmhkR1U2SUZSUFRrMWxjM05oWjJWUWNtOWpaWE56YVc1blUzUmhkR1VzWEc0Z0lDQWdJQ0FnSUhCaGNtVnVkRk53WVc0L09pQW9VM0JoYmlCOElGTndZVzVEYjI1MFpYaDBLU3hjYmlBZ0lDQWdJQ0FnYVc1bWFXNXBkR1ZYWVdsMFB6b2dZbTl2YkdWaGJpeGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGUlBUa052Ym5SeVlXTjBSR1Z3Ykc5NVVtVnpkV3gwUGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUcxbGMzTmhaMlVnUFNCa1pYQnNiM2xOWlhOellXZGxMbTFsYzNOaFoyVTdYRzRnSUNBZ0lDQWdJR052Ym5OMElISmxjM1ZzZENBOUlHRjNZV2wwSUhSb2FYTXVkMkZwZEVadmNsUnlZVzV6WVdOMGFXOXVLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxVSEp2WTJWemMybHVaMU4wWVhSbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnY0dGeVpXNTBVM0JoYml4Y2JpQWdJQ0FnSUNBZ0lDQWdJR2x1Wm1sdWFYUmxWMkZwZEN4Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBdUxpNXlaWE4xYkhRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoWkdSeVpYTnpPaUJ0WlhOellXZGxMbUZrWkhKbGMzTXNYRzRnSUNBZ0lDQWdJQ0FnSUNCaGJISmxZV1I1UkdWd2JHOTVaV1E2SUdaaGJITmxMRnh1SUNBZ0lDQWdJQ0I5TzF4dUlDQWdJSDFjYmx4dVhHNGdJQ0FnWVhONWJtTWdjSEp2WTJWemMxSjFiazFsYzNOaFoyVW9YRzRnSUNBZ0lDQWdJSEoxYmsxbGMzTmhaMlU2SUZSUFRrTnZiblJ5WVdOMFVuVnVUV1Z6YzJGblpTeGNiaUFnSUNBZ0lDQWdjR0Z5Wlc1MFUzQmhiajg2SUNoVGNHRnVJSHdnVTNCaGJrTnZiblJsZUhRcExGeHVJQ0FnSUNrNklGQnliMjFwYzJVOFZFOU9RMjl1ZEhKaFkzUlNkVzVTWlhOMWJIUStJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWpiMjVtYVdjdWJHOW5LQ2R3Y205alpYTnpVblZ1VFdWemMyRm5aU2NzSUhKMWJrMWxjM05oWjJVcE8xeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCd2NtOWpaWE56YVc1bklEMGdZWGRoYVhRZ2RHaHBjeTV6Wlc1a1RXVnpjMkZuWlNoeWRXNU5aWE56WVdkbExtMWxjM05oWjJVc0lIQmhjbVZ1ZEZOd1lXNHBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1M1lXbDBSbTl5VW5WdVZISmhibk5oWTNScGIyNG9jblZ1VFdWemMyRm5aU3dnY0hKdlkyVnpjMmx1Wnl3Z2NHRnlaVzUwVTNCaGJpazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nZDJGcGRFWnZjbEoxYmxSeVlXNXpZV04wYVc5dUtGeHVJQ0FnSUNBZ0lDQnlkVzVOWlhOellXZGxPaUJVVDA1RGIyNTBjbUZqZEZKMWJrMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lHMWxjM05oWjJWUWNtOWpaWE56YVc1blUzUmhkR1U2SUZSUFRrMWxjM05oWjJWUWNtOWpaWE56YVc1blUzUmhkR1VzWEc0Z0lDQWdJQ0FnSUhCaGNtVnVkRk53WVc0L09pQW9VM0JoYmlCOElGTndZVzVEYjI1MFpYaDBLU3hjYmlBZ0lDQWdJQ0FnYVc1bWFXNXBkR1ZYWVdsMFB6b2dZbTl2YkdWaGJpeGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGUlBUa052Ym5SeVlXTjBVblZ1VW1WemRXeDBQaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuZGhhWFJHYjNKVWNtRnVjMkZqZEdsdmJpaDdYRzRnSUNBZ0lDQWdJQ0FnSUNCdFpYTnpZV2RsT2lCeWRXNU5aWE56WVdkbExtMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxVSEp2WTJWemMybHVaMU4wWVhSbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnY0dGeVpXNTBVM0JoYml4Y2JpQWdJQ0FnSUNBZ0lDQWdJR2x1Wm1sdWFYUmxWMkZwZEN4Y2JpQWdJQ0FnSUNBZ0lDQWdJR0ZpYVRvZ2NuVnVUV1Z6YzJGblpTNWhZbWtzWEc0Z0lDQWdJQ0FnSUNBZ0lDQm1kVzVqZEdsdmJrNWhiV1U2SUhKMWJrMWxjM05oWjJVdVpuVnVZM1JwYjI1T1lXMWxMRnh1SUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2S2lwY2JpQWdJQ0FnS2lCRVpYQnlaV05oZEdWa0xpQlZjMlVnWUhKMWJrMWxjM05oWjJWTWIyTmhiR0FnYVc1emRHVmhaQzVjYmlBZ0lDQWdLaUJBY0dGeVlXMGdjR0Z5WVcxelhHNGdJQ0FnSUNvZ1FIQmhjbUZ0SUhkaGFYUlFZWEpoYlhOY2JpQWdJQ0FnS2lCQWNHRnlZVzBnY0dGeVpXNTBVM0JoYmx4dUlDQWdJQ0FxSUVCeVpYUjFjbTV6SUh0UWNtOXRhWE5sUEhWdWEyNXZkMjQrZlZ4dUlDQWdJQ0FxTDF4dUlDQWdJR0Z6ZVc1aklIQnliMk5sYzNOU2RXNU5aWE56WVdkbFRHOWpZV3dvWEc0Z0lDQWdJQ0FnSUhCaGNtRnRjem9nVkU5T1EyOXVkSEpoWTNSU2RXNU5aWE56WVdkbExGeHVJQ0FnSUNBZ0lDQjNZV2wwVUdGeVlXMXpQem9nVkU5T1EyOXVkSEpoWTNSQlkyTnZkVzUwVjJGcGRGQmhjbUZ0Y3l4Y2JpQWdJQ0FnSUNBZ2NHRnlaVzUwVTNCaGJqODZJQ2hUY0dGdUlId2dVM0JoYmtOdmJuUmxlSFFwTEZ4dUlDQWdJQ2s2SUZCeWIyMXBjMlU4VkU5T1EyOXVkSEpoWTNSU2RXNVNaWE4xYkhRK0lIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1amIyNW1hV2N1Ykc5bktDZHdjbTlqWlhOelVuVnVUV1Z6YzJGblpVeHZZMkZzSnl3Z2NHRnlZVzF6S1R0Y2JseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCaFkyTnZkVzUwSUQwZ1lYZGhhWFFnZEdocGN5NW5aWFJCWTJOdmRXNTBLSEJoY21GdGN5NWhaR1J5WlhOekxDQjBjblZsTENCM1lXbDBVR0Z5WVcxekxDQndZWEpsYm5SVGNHRnVLVHRjYmx4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaWEYxWlhOMFEyOXlaU2duWTI5dWRISmhZM1J6TG5KMWJpNXNiMk5oYkM1dGMyY25MQ0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhaR1J5WlhOek9pQndZWEpoYlhNdVlXUmtjbVZ6Y3l4Y2JpQWdJQ0FnSUNBZ0lDQWdJR0ZqWTI5MWJuUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCaFltazZJSEJoY21GdGN5NWhZbWtzWEc0Z0lDQWdJQ0FnSUNBZ0lDQm1kVzVqZEdsdmJrNWhiV1U2SUhCaGNtRnRjeTVtZFc1amRHbHZiazVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxRbUZ6WlRZME9pQndZWEpoYlhNdWJXVnpjMkZuWlM1dFpYTnpZV2RsUW05a2VVSmhjMlUyTkN4Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdSbVZsSUdOaGJHTjFiR0YwYVc5dVhHNWNiaUFnSUNCaWFXZENZV3hoYm1ObElEMGdKekI0TVRBd01EQXdNREF3TURBd01EQW5PMXh1WEc0Z0lDQWdZWE41Ym1NZ1kyRnNZMUoxYmtabFpYTW9YRzRnSUNBZ0lDQWdJSEJoY21GdGN6b2dWRTlPUTI5dWRISmhZM1JEWVd4alVuVnVSbVZsVUdGeVlXMXpMRnh1SUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1UHpvZ0tGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDa3NYRzRnSUNBZ0tUb2dVSEp2YldselpUeFVUMDVEYjI1MGNtRmpkRU5oYkdOR1pXVlNaWE4xYkhRK0lIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1amIyNW1hV2N1Ykc5bktDZGpZV3hqVW5WdVJtVmxjeWNzSUhCaGNtRnRjeWs3WEc1Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWVdOamIzVnVkQ0E5SUdGM1lXbDBJSFJvYVhNdVoyVjBRV05qYjNWdWRDaHdZWEpoYlhNdVlXUmtjbVZ6Y3l3Z2RISjFaU3dnY0dGeVlXMXpMbmRoYVhSUVlYSmhiWE1zSUhCaGNtVnVkRk53WVc0cE8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNod1lYSmhiWE11WlcxMWJHRjBaVUpoYkdGdVkyVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHRmpZMjkxYm5RdVltRnNZVzVqWlNBOUlIUm9hWE11WW1sblFtRnNZVzVqWlR0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpiMjUwY21GamRITXVjblZ1TG1abFpTY3NJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHRmtaSEpsYzNNNklIQmhjbUZ0Y3k1aFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZV05qYjNWdWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUdGaWFUb2djR0Z5WVcxekxtRmlhU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHWjFibU4wYVc5dVRtRnRaVG9nY0dGeVlXMXpMbVoxYm1OMGFXOXVUbUZ0WlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJR2x1Y0hWME9pQndZWEpoYlhNdWFXNXdkWFFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnJaWGxRWVdseU9pQndZWEpoYlhNdWEyVjVVR0ZwY2l4Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nWTJGc1kwUmxjR3h2ZVVabFpYTW9YRzRnSUNBZ0lDQWdJSEJoY21GdGN6b2dWRTlPUTI5dWRISmhZM1JEWVd4alJHVndiRzk1Um1WbFVHRnlZVzF6TEZ4dUlDQWdJQ0FnSUNCd1lYSmxiblJUY0dGdVB6b2dLRk53WVc0Z2ZDQlRjR0Z1UTI5dWRHVjRkQ2tzWEc0Z0lDQWdLVG9nVUhKdmJXbHpaVHhVVDA1RGIyNTBjbUZqZEVOaGJHTkdaV1ZTWlhOMWJIUStJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWpiMjVtYVdjdWJHOW5LQ2RqWVd4alJHVndiRzk1Um1WbGN5Y3NJSEJoY21GdGN5azdYRzVjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdiV1Z6YzJGblpTQTlJR0YzWVdsMElIUm9hWE11WTNKbFlYUmxSR1Z3Ykc5NVRXVnpjMkZuWlNod1lYSmhiWE1wTzF4dVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbU5oYkdOTmMyZFFjbTlqWlhOelJtVmxjeWg3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhaR1J5WlhOek9pQnRaWE56WVdkbExtRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxPaUJ0WlhOellXZGxMbTFsYzNOaFoyVXNYRzRnSUNBZ0lDQWdJQ0FnSUNCbGJYVnNZWFJsUW1Gc1lXNWpaVG9nY0dGeVlXMXpMbVZ0ZFd4aGRHVkNZV3hoYm1ObExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYm1WM1FXTmpiM1Z1ZERvZ2NHRnlZVzF6TG01bGQwRmpZMjkxYm5Rc1hHNGdJQ0FnSUNBZ0lIMHNJSEJoY21WdWRGTndZVzRwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklHTmhiR05OYzJkUWNtOWpaWE56Um1WbGN5aGNiaUFnSUNBZ0lDQWdjR0Z5WVcxek9pQlVUMDVEYjI1MGNtRmpkRU5oYkdOTmMyZFFjbTlqWlhOemFXNW5SbVZsYzFCaGNtRnRjeXhjYmlBZ0lDQWdJQ0FnY0dGeVpXNTBVM0JoYmo4NklDaFRjR0Z1SUh3Z1UzQmhia052Ym5SbGVIUXBMRnh1SUNBZ0lDazZJRkJ5YjIxcGMyVThWRTlPUTI5dWRISmhZM1JEWVd4alJtVmxVbVZ6ZFd4MFBpQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVkyOXVabWxuTG14dlp5Z25ZMkZzWTAxeloxQnliMk5sYzNOR1pXVnpKeXdnY0dGeVlXMXpLVHRjYmx4dUlDQWdJQ0FnSUNCc1pYUWdZV05qYjNWdWREb2dVVUZqWTI5MWJuUWdQU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmlZV3hoYm1ObE9pQjBhR2x6TG1KcFowSmhiR0Z1WTJVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwWkRvZ2NHRnlZVzF6TG1Ga1pISmxjM01zWEc0Z0lDQWdJQ0FnSUNBZ0lDQnNZWE4wWDNCaGFXUTZJRTFoZEdndVpteHZiM0lvUkdGMFpTNXViM2NvS1NBdklERXdNREFwTEZ4dUlDQWdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNnaGNHRnlZVzF6TG01bGQwRmpZMjkxYm5RcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdGalkyOTFiblFnUFNCaGQyRnBkQ0IwYUdsekxtZGxkRUZqWTI5MWJuUW9jR0Z5WVcxekxtRmtaSEpsYzNNc0lHWmhiSE5sTENCd1lYSmhiWE11ZDJGcGRGQmhjbUZ0Y3l3Z2NHRnlaVzUwVTNCaGJpazdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCcFppQW9jR0Z5WVcxekxtVnRkV3hoZEdWQ1lXeGhibU5sS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoWTJOdmRXNTBMbUpoYkdGdVkyVWdQU0IwYUdsekxtSnBaMEpoYkdGdVkyVTdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaWEYxWlhOMFEyOXlaU2duWTI5dWRISmhZM1J6TG5KMWJpNW1aV1V1YlhObkp5d2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1lXUmtjbVZ6Y3pvZ2NHRnlZVzF6TG1Ga1pISmxjM01zWEc0Z0lDQWdJQ0FnSUNBZ0lDQmhZMk52ZFc1MExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYldWemMyRm5aVUpoYzJVMk5Eb2djR0Z5WVcxekxtMWxjM05oWjJVdWJXVnpjMkZuWlVKdlpIbENZWE5sTmpRc1hHNGdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJRUZrWkhKbGMzTWdjSEp2WTJWemMybHVaMXh1WEc0Z0lDQWdZWE41Ym1NZ1kyOXVkbVZ5ZEVGa1pISmxjM01vWEc0Z0lDQWdJQ0FnSUhCaGNtRnRjem9nVkU5T1EyOXVkSEpoWTNSRGIyNTJaWEowUVdSa2NtVnpjMUJoY21GdGN5eGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGUlBUa052Ym5SeVlXTjBRMjl1ZG1WeWRFRmtaSEpsYzNOU1pYTjFiSFErSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZ4ZFdWemRFTnZjbVVvSjJOdmJuUnlZV04wY3k1aFpHUnlaWE56TG1OdmJuWmxjblFuTENCd1lYSmhiWE1wTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUVsdWRHVnlibUZzYzF4dVhHNGdJQ0FnWVhONWJtTWdhVzUwWlhKdVlXeEVaWEJzYjNsT1lYUnBkbVVvY0dGeVlXMXpPaUJVVDA1RGIyNTBjbUZqZEVSbGNHeHZlVkJoY21GdGN5azZJRkJ5YjIxcGMyVThWRTlPUTI5dWRISmhZM1JFWlhCc2IzbFNaWE4xYkhRK0lIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WeGRXVnpkRU52Y21Vb0oyTnZiblJ5WVdOMGN5NWtaWEJzYjNrbkxDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaFltazZJSEJoY21GdGN5NXdZV05yWVdkbExtRmlhU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wY25WamRHOXlTR1ZoWkdWeU9pQndZWEpoYlhNdVkyOXVjM1J5ZFdOMGIzSklaV0ZrWlhJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRISjFZM1J2Y2xCaGNtRnRjem9nY0dGeVlXMXpMbU52Ym5OMGNuVmpkRzl5VUdGeVlXMXpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2FXNXBkRkJoY21GdGN6b2djR0Z5WVcxekxtbHVhWFJRWVhKaGJYTXNYRzRnSUNBZ0lDQWdJQ0FnSUNCcGJXRm5aVUpoYzJVMk5Eb2djR0Z5WVcxekxuQmhZMnRoWjJVdWFXMWhaMlZDWVhObE5qUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCclpYbFFZV2x5T2lCd1lYSmhiWE11YTJWNVVHRnBjaXhjYmlBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnZlZ4dVhHNWNiaUFnSUNCaGMzbHVZeUJwYm5SbGNtNWhiRkoxYms1aGRHbDJaU2h3WVhKaGJYTTZJRlJQVGtOdmJuUnlZV04wVW5WdVVHRnlZVzF6S1RvZ1VISnZiV2x6WlR4VVQwNURiMjUwY21GamRGSjFibEpsYzNWc2RENGdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpYRjFaWE4wUTI5eVpTZ25ZMjl1ZEhKaFkzUnpMbkoxYmljc0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdGa1pISmxjM002SUhCaGNtRnRjeTVoWkdSeVpYTnpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lXSnBPaUJ3WVhKaGJYTXVZV0pwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdablZ1WTNScGIyNU9ZVzFsT2lCd1lYSmhiWE11Wm5WdVkzUnBiMjVPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYUdWaFpHVnlPaUJ3WVhKaGJYTXVhR1ZoWkdWeUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnYVc1d2RYUTZJSEJoY21GdGN5NXBibkIxZEN4Y2JpQWdJQ0FnSUNBZ0lDQWdJR3RsZVZCaGFYSTZJSEJoY21GdGN5NXJaWGxRWVdseUxGeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQjlYRzVjYmx4dUlDQWdJR0Z6ZVc1aklISmxkSEo1UTJGc2JDaGpZV3hzT2lBb2FXNWtaWGc2SUc1MWJXSmxjaWtnUFQ0Z1VISnZiV2x6WlR4aGJuaytLVG9nVUhKdmJXbHpaVHhoYm5rK0lIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NtVjBjbWxsYzBOdmRXNTBJRDBnZEdocGN5NWpiMjVtYVdjdWJXVnpjMkZuWlZKbGRISnBaWE5EYjNWdWRDZ3BPMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4UFNCeVpYUnlhV1Z6UTI5MWJuUTdJR2tnS3owZ01Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR2tnUGlBd0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1amIyNW1hV2N1Ykc5bktHQlNaWFJ5ZVNBakpIdHBmV0FwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZWGRoYVhRZ1kyRnNiQ2hwS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1Z5Y205eUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnY21WMGNua2dhV1lnYldWemMyRm5aU0JsZUhCcGNtVmtJRzl5SUdsbUlISmxjMjlzZG1sdVp5QnlaWFIxY201bFpDQjBhR0YwSUcxbGMzTmhaMlVnWlhod2FYSmxaQzl5WlhCc1lYbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJ3Y205MFpXTjBhVzl1SUdWeWNtOXlJRzl5SUdsbUlIUnlZVzV6WVdOMGFXOXVJSGRwZEdnZ2JXVnpjMkZuWlNCbGVIQnBjbVZrTDNKbGNHeGhlU0J3Y205MFpXTjBhVzl1SUdWeWNtOXlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnY21WMGRYSnVaV1JjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnBjMDl5YVdkcGJtRnNUM0pTWlhOdmJIWmxaQ0E5SUdWNGFYUkRiMlJsSUQwK0lDaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnVkU5T1EyeHBaVzUwUlhKeWIzSXVhWE5QY21sbmFXNWhiRU52Ym5SeVlXTjBSWEp5YjNJb1pYSnliM0lzSUdWNGFYUkRiMlJsS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjhmQ0JVVDA1RGJHbGxiblJGY25KdmNpNXBjMUpsYzI5c2RtVmtRMjl1ZEhKaFkzUkZjbkp2Y2tGbWRHVnlSWGh3YVhKbEtHVnljbTl5TENCbGVHbDBRMjlrWlNsY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhWelpWSmxkSEo1SUQwZ1pYSnliM0l1WTI5a1pTQTlQVDBnVkU5T1JYSnliM0pEYjJSbExrMUZVMU5CUjBWZlJWaFFTVkpGUkZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjhmQ0JwYzA5eWFXZHBibUZzVDNKU1pYTnZiSFpsWkNoVVQwNURiMjUwY21GamRFVjRhWFJEYjJSbExsSkZVRXhCV1Y5UVVrOVVSVU5VU1U5T0tWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I4ZkNCcGMwOXlhV2RwYm1Gc1QzSlNaWE52YkhabFpDaFVUMDVEYjI1MGNtRmpkRVY0YVhSRGIyUmxMazFGVTFOQlIwVmZSVmhRU1ZKRlJDazdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0NGMWMyVlNaWFJ5ZVNCOGZDQnBJRDA5UFNCeVpYUnlhV1Z6UTI5MWJuUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnWlhKeWIzSTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSFJvY205M0lGUlBUa05zYVdWdWRFVnljbTl5TG1sdWRHVnlibUZzUlhKeWIzSW9YRzRnSUNBZ0lDQWdJQ0FnSUNBblFXeHNJSEpsZEhKNUlHRjBkR1Z0Y0hSeklHWmhhV3hsWkNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoZDJGcGRDQjBhR2x6TG1OdmJYQnNaWFJsUlhKeWIzSkVZWFJoS0Nrc1hHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ2ZWeHVYRzVjYmlBZ0lDQmhjM2x1WXlCcGJuUmxjbTVoYkVSbGNHeHZlVXB6S0Z4dUlDQWdJQ0FnSUNCd1lYSmhiWE02SUZSUFRrTnZiblJ5WVdOMFJHVndiRzk1VUdGeVlXMXpMRnh1SUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1UHpvZ0tGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDa3NYRzRnSUNBZ0tUb2dVSEp2YldselpUeFVUMDVEYjI1MGNtRmpkRVJsY0d4dmVWSmxjM1ZzZEQ0Z2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG1OdmJtWnBaeTVzYjJjb0owUmxjR3h2ZVNCemRHRnlkQ2NwTzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaWFJ5ZVVOaGJHd29ZWE41Ym1NZ0tISmxkSEo1U1c1a1pYZ3BJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHUmxjR3h2ZVUxbGMzTmhaMlVnUFNCaGQyRnBkQ0IwYUdsekxtTnlaV0YwWlVSbGNHeHZlVTFsYzNOaFoyVW9jR0Z5WVcxekxDQnlaWFJ5ZVVsdVpHVjRLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hoZDJGcGRDQjBhR2x6TG1selJHVndiRzk1WldRb1pHVndiRzk1VFdWemMyRm5aUzVoWkdSeVpYTnpMQ0J3WVhKbGJuUlRjR0Z1S1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0ZrWkhKbGMzTTZJR1JsY0d4dmVVMWxjM05oWjJVdVlXUmtjbVZ6Y3l4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZV3h5WldGa2VVUmxjR3h2ZVdWa09pQjBjblZsTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCd2NtOWpaWE56YVc1bklEMGdZWGRoYVhRZ2RHaHBjeTV6Wlc1a1RXVnpjMkZuWlNoa1pYQnNiM2xOWlhOellXZGxMbTFsYzNOaFoyVXNJSEJoY21WdWRGTndZVzRwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11ZDJGcGRFWnZja1JsY0d4dmVWUnlZVzV6WVdOMGFXOXVLR1JsY0d4dmVVMWxjM05oWjJVc0lIQnliMk5sYzNOcGJtY3NJSEJoY21WdWRGTndZVzRwTzF4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNCOVhHNWNibHh1SUNBZ0lHRnplVzVqSUdsdWRHVnlibUZzVW5WdVNuTW9YRzRnSUNBZ0lDQWdJSEJoY21GdGN6b2dWRTlPUTI5dWRISmhZM1JTZFc1UVlYSmhiWE1zWEc0Z0lDQWdJQ0FnSUhCaGNtVnVkRk53WVc0L09pQW9VM0JoYmlCOElGTndZVzVEYjI1MFpYaDBLU3hjYmlBZ0lDQXBPaUJRY205dGFYTmxQRlJQVGtOdmJuUnlZV04wVW5WdVVtVnpkV3gwUGlCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WTI5dVptbG5MbXh2WnlnblVuVnVJSE4wWVhKMEp5azdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KbGRISjVRMkZzYkNoaGMzbHVZeUFvY21WMGNubEpibVJsZUNrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnY25WdVRXVnpjMkZuWlNBOUlHRjNZV2wwSUhSb2FYTXVZM0psWVhSbFVuVnVUV1Z6YzJGblpTaHdZWEpoYlhNc0lISmxkSEo1U1c1a1pYZ3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnY0hKdlkyVnpjMmx1WnlBOUlHRjNZV2wwSUhSb2FYTXVjMlZ1WkUxbGMzTmhaMlVvY25WdVRXVnpjMkZuWlM1dFpYTnpZV2RsTENCd1lYSmxiblJUY0dGdUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuZGhhWFJHYjNKU2RXNVVjbUZ1YzJGamRHbHZiaWh5ZFc1TlpYTnpZV2RsTENCd2NtOWpaWE56YVc1bkxDQndZWEpsYm5SVGNHRnVLVHRjYmlBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnZlZ4dVhHNWNiaUFnSUNCaGMzbHVZeUJuWlhSQlkyTnZkVzUwS0Z4dUlDQWdJQ0FnSUNCaFpHUnlaWE56T2lCemRISnBibWNzWEc0Z0lDQWdJQ0FnSUdGamRHbDJaVG9nWW05dmJHVmhiaXhjYmlBZ0lDQWdJQ0FnZDJGcGRGQmhjbUZ0Y3o4NklGUlBUa052Ym5SeVlXTjBRV05qYjNWdWRGZGhhWFJRWVhKaGJYTXNYRzRnSUNBZ0lDQWdJSEJoY21WdWRGTndZVzQvT2lBb1UzQmhiaUI4SUZOd1lXNURiMjUwWlhoMEtTeGNiaUFnSUNBcE9pQlFjbTl0YVhObFBGRkJZMk52ZFc1MFBpQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElHWnBiSFJsY2pvZ2V5QmJjM1J5YVc1blhUb2dZVzU1SUgwZ1BTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFpEb2dleUJsY1RvZ1lXUmtjbVZ6Y3lCOUxGeHVJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lDQWdJQ0JwWmlBb2QyRnBkRkJoY21GdGN5QW1KaUIzWVdsMFVHRnlZVzF6TG5SeVlXNXpZV04wYVc5dVRIUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHWnBiSFJsY2k1c1lYTjBYM1J5WVc1elgyeDBJRDBnZXlCblpUb2dkMkZwZEZCaGNtRnRjeTUwY21GdWMyRmpkR2x2Ymt4MElIMDdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnYVdZZ0tHRmpkR2wyWlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWm1sc2RHVnlMbUZqWTE5MGVYQmxJRDBnZXlCbGNUb2dVVUZqWTI5MWJuUlVlWEJsTG1GamRHbDJaU0I5TzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdkR2hwY3k1amIyNW1hV2N1Ykc5bktDZG5aWFJCWTJOdmRXNTBMaUJHYVd4MFpYSW5MQ0JtYVd4MFpYSXBPMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQmhZMk52ZFc1MGN5QTlJR0YzWVdsMElIUm9hWE11Y1hWbGNtbGxjeTVoWTJOdmRXNTBjeTV4ZFdWeWVTaDdYRzRnSUNBZ0lDQWdJQ0FnSUNCbWFXeDBaWElzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRNklDZHBaQ0JoWTJOZmRIbHdaU0JpYjJNZ1kyOWtaVjlvWVhOb0lHUmhkR0ZmYUdGemFDQmlZV3hoYm1ObElHSmhiR0Z1WTJWZmIzUm9aWElnZXlCamRYSnlaVzVqZVNCMllXeDFaU0I5SUd4aGMzUmZjR0ZwWkNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0F1TGk0b2QyRnBkRkJoY21GdGN5QW1KaUIzWVdsMFVHRnlZVzF6TG5ScGJXVnZkWFFnUHlCN0lIUnBiV1Z2ZFhRNklIZGhhWFJRWVhKaGJYTXVkR2x0Wlc5MWRDQjlJRG9nZTMwcExGeHVJQ0FnSUNBZ0lDQWdJQ0FnY0dGeVpXNTBVM0JoYml4Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQWdJR2xtSUNoaFkyTnZkVzUwY3k1c1pXNW5kR2dnUFQwOUlEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9jbTkzSUZSUFRrTnNhV1Z1ZEVWeWNtOXlMbUZqWTI5MWJuUk5hWE56YVc1bktGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lYZGhhWFFnZEdocGN5NWpiMjF3YkdWMFpVVnljbTl5UkdGMFlTaDdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdGa1pISmxjM01zWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlNrc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdGalkyOTFiblFnUFNCaFkyTnZkVzUwYzFzd1hUdGNiaUFnSUNBZ0lDQWdjbVZ0YjNabFZIbHdaVTVoYldVb1lXTmpiM1Z1ZENrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WTI5dVptbG5MbXh2WnlnbloyVjBRV05qYjNWdWRDNGdRV05qYjNWdWRDQnlaV05sYVhabFpDY3NJR0ZqWTI5MWJuUXBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZV05qYjNWdWREdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUJwYm5SbGNtNWhiRkoxYmt4dlkyRnNTbk1vWEc0Z0lDQWdJQ0FnSUhCaGNtRnRjem9nVkU5T1EyOXVkSEpoWTNSU2RXNU1iMk5oYkZCaGNtRnRjeXhjYmlBZ0lDQWdJQ0FnY0dGeVpXNTBVM0JoYmo4NklDaFRjR0Z1SUh3Z1UzQmhia052Ym5SbGVIUXBMRnh1SUNBZ0lDazZJRkJ5YjIxcGMyVThWRTlPUTI5dWRISmhZM1JTZFc1TWIyTmhiRkpsYzNWc2RENGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQmhaR1J5WlhOeklEMGdjR0Z5WVcxekxtRmtaSEpsYzNNN1hHNGdJQ0FnSUNBZ0lHbG1JQ2doWVdSa2NtVnpjeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdWRTlPUTJ4cFpXNTBSWEp5YjNJdVlXUmtjbVZ6YzFKbGNYVnBjbVZrUm05eVVuVnVURzlqWVd3b1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lYZGhhWFFnZEdocGN5NWpiMjF3YkdWMFpVVnljbTl5UkdGMFlTaDdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdGa1pISmxjM01zWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHWjFibU4wYVc5dVgyNWhiV1U2SUhCaGNtRnRjeTVtZFc1amRHbHZiazVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTa3NYRzRnSUNBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJR052Ym5OMElHRmpZMjkxYm5RZ1BTQndZWEpoYlhNdVlXTmpiM1Z1ZENCOGZDQW9ZWGRoYVhRZ2RHaHBjeTVuWlhSQlkyTnZkVzUwS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdZV1JrY21WemN5eGNiaUFnSUNBZ0lDQWdJQ0FnSUdaaGJITmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NHRnlZVzF6TG5kaGFYUlFZWEpoYlhNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1TEZ4dUlDQWdJQ0FnSUNBcEtUdGNiaUFnSUNBZ0lDQWdhV1lnS0NGaFkyTnZkVzUwTG1OdlpHVmZhR0Z6YUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dWRTlPUTJ4cFpXNTBSWEp5YjNJdVlXTmpiM1Z1ZEVOdlpHVk5hWE56YVc1bktGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRmtaSEpsYzNNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0tHRmpZMjkxYm5RNklHRnVlU2t1WW1Gc1lXNWpaU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JoZDJGcGRDQjBhR2x6TG1OdmJYQnNaWFJsUlhKeWIzSkVZWFJoS0h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZV1JrY21WemN5eGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWm5WdVkzUnBiMjVmYm1GdFpUb2djR0Z5WVcxekxtWjFibU4wYVc5dVRtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5S1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZ4ZFdWemRFTnZjbVVvSjJOdmJuUnlZV04wY3k1eWRXNHViRzlqWVd3bkxDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZV05qYjNWdWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUdGaWFUb2djR0Z5WVcxekxtRmlhU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHWjFibU4wYVc5dVRtRnRaVG9nY0dGeVlXMXpMbVoxYm1OMGFXOXVUbUZ0WlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJR2x1Y0hWME9pQndZWEpoYlhNdWFXNXdkWFFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnJaWGxRWVdseU9pQndZWEpoYlhNdWEyVjVVR0ZwY2l4Y2JpQWdJQ0FnSUNBZ0lDQWdJR1oxYkd4U2RXNDZJSEJoY21GdGN5NW1kV3hzVW5WdUxGeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCcGJuUmxjbTVoYkZKMWJrMWxjM05oWjJWTWIyTmhiRXB6S0Z4dUlDQWdJQ0FnSUNCd1lYSmhiWE02SUZSUFRrTnZiblJ5WVdOMFVuVnVUV1Z6YzJGblpVeHZZMkZzVUdGeVlXMXpMRnh1SUNBZ0lDQWdJQ0J3WVhKbGJuUlRjR0Z1UHpvZ0tGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDa3NYRzRnSUNBZ0tUb2dVSEp2YldselpUeFVUMDVEYjI1MGNtRmpkRkoxYmt4dlkyRnNVbVZ6ZFd4MFBpQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElHRmtaSEpsYzNNZ1BTQndZWEpoYlhNdVlXUmtjbVZ6Y3p0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0ZoWkdSeVpYTnpLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCVVQwNURiR2xsYm5SRmNuSnZjaTVoWkdSeVpYTnpVbVZ4ZFdseVpXUkdiM0pTZFc1TWIyTmhiQ2hoZDJGcGRDQjBhR2x6TG1OdmJYQnNaWFJsUlhKeWIzSkVZWFJoS0h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdaMWJtTjBhVzl1WDI1aGJXVTZJSEJoY21GdGN5NW1kVzVqZEdsdmJrNWhiV1VzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlLU2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWVdOamIzVnVkQ0E5SUhCaGNtRnRjeTVoWTJOdmRXNTBJSHg4SUNoaGQyRnBkQ0IwYUdsekxtZGxkRUZqWTI5MWJuUW9YRzRnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdabUZzYzJVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J3WVhKaGJYTXVkMkZwZEZCaGNtRnRjeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lIQmhjbVZ1ZEZOd1lXNHNYRzRnSUNBZ0lDQWdJQ2twTzF4dUlDQWdJQ0FnSUNCcFppQW9JV0ZqWTI5MWJuUXVZMjlrWlY5b1lYTm9LU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCVVQwNURiR2xsYm5SRmNuSnZjaTVoWTJOdmRXNTBRMjlrWlUxcGMzTnBibWNvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWVdSa2NtVnpjeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FvWVdOamIzVnVkRG9nWVc1NUtTNWlZV3hoYm1ObExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHRjNZV2wwSUhSb2FYTXVZMjl0Y0d4bGRHVkZjbkp2Y2tSaGRHRW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1kVzVqZEdsdmJsOXVZVzFsT2lCd1lYSmhiWE11Wm5WdVkzUnBiMjVPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMHBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpYRjFaWE4wUTI5eVpTZ25ZMjl1ZEhKaFkzUnpMbkoxYmk1c2IyTmhiQzV0YzJjbkxDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaFpHUnlaWE56TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZV05qYjNWdWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUdGaWFUb2djR0Z5WVcxekxtRmlhU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHWjFibU4wYVc5dVRtRnRaVG9nY0dGeVlXMXpMbVoxYm1OMGFXOXVUbUZ0WlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJRzFsYzNOaFoyVkNZWE5sTmpRNklIQmhjbUZ0Y3k1dFpYTnpZV2RsUW05a2VVSmhjMlUyTkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJR1oxYkd4U2RXNDZJSEJoY21GdGN5NW1kV3hzVW5WdUxGeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCcGJuUmxjbTVoYkZOcFoyNG9YRzRnSUNBZ0lDQWdJSFZ1YzJsbmJtVmtPaUJVVDA1RGIyNTBjbUZqZEZWdWMybG5ibVZrVFdWemMyRm5aU3hjYmlBZ0lDQWdJQ0FnYzI5MWNtTmxPaUJUYVdkdWFXNW5VMjkxY21ObExGeHVJQ0FnSUNrNklGQnliMjFwYzJVOFUybG5ibEpsYzNWc2RENGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQnRaWE56WVdkbElEMGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1ltRnpaVFkwT2lCMWJuTnBaMjVsWkM1aWVYUmxjMVJ2VTJsbmJrSmhjMlUyTkN4Y2JpQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1ltOTRJRDBnYzI5MWNtTmxMbUp2ZUR0Y2JpQWdJQ0FnSUNBZ2FXWWdLR0p2ZUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J6YVdkdVFubDBaWE5DWVhObE5qUTZJR0YzWVdsMElHSnZlQzV6YVdkdUtHMWxjM05oWjJVc0lGUlBUazkxZEhCMWRFVnVZMjlrYVc1bkxrSmhjMlUyTkNrc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NIVmliR2xqUzJWNVNHVjRPaUJoZDJGcGRDQmliM2d1WjJWMFVIVmliR2xqUzJWNUtDa3NYRzRnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJR052Ym5OMElHdGxlWE1nUFNCemIzVnlZMlV1YTJWNWN6dGNiaUFnSUNBZ0lDQWdhV1lnS0d0bGVYTXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhOcFoyNUxaWGx6SUQwZ1lYZGhhWFFnZEdocGN5NWpjbmx3ZEc4dWJtRmpiRk5wWjI1TFpYbHdZV2x5Um5KdmJWTmxZM0psZEV0bGVTaHJaWGx6TG5ObFkzSmxkQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lITnBaMjVDZVhSbGMwSmhjMlUyTkRvZ1lYZGhhWFFnZEdocGN5NWpjbmx3ZEc4dWJtRmpiRk5wWjI1RVpYUmhZMmhsWkNoY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiV1Z6YzJGblpTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJsbmJrdGxlWE11YzJWamNtVjBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCVVQwNVBkWFJ3ZFhSRmJtTnZaR2x1Wnk1Q1lYTmxOalFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2RXSnNhV05MWlhsSVpYZzZJSE5wWjI1TFpYbHpMbkIxWW14cFl5eGNiaUFnSUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdkR2h5YjNjZ1ZFOU9RMnhwWlc1MFJYSnliM0l1YzJsbmJtbHVaMU52ZFhKalpVbHpUbTkwVTNCbFkybG1hV1ZrS0NrN1hHNGdJQ0FnZlZ4dWZWeHVYRzVVVDA1RGIyNTBjbUZqZEhOTmIyUjFiR1V1Ylc5a2RXeGxUbUZ0WlNBOUlDZFVUMDVEYjI1MGNtRmpkSE5OYjJSMWJHVW5PMXh1WEc1amIyNXpkQ0JDVEU5RFMxOUdTVVZNUkZNZ1BTQmdYRzRnSUNBZ2FXUmNiaUFnSUNCblpXNWZkWFJwYldWY2JpQWdJQ0JoWm5SbGNsOXpjR3hwZEZ4dUlDQWdJSGR2Y210amFHRnBibDlwWkZ4dUlDQWdJSE5vWVhKa1hHNGdJQ0FnYVc1ZmJYTm5YMlJsYzJOeUlIdGNiaUFnSUNBZ0lDQWdiWE5uWDJsa1hHNGdJQ0FnSUNBZ0lIUnlZVzV6WVdOMGFXOXVYMmxrWEc0Z0lDQWdmVnh1WUR0Y2JseHVZMjl1YzNRZ1ZGSkJUbE5CUTFSSlQwNWZSa2xGVEVSVFgwOVNSRWxPUVZKWklEMGdZRnh1SUNBZ0lHbGtYRzRnSUNBZ1lXSnZjblJsWkZ4dUlDQWdJR052YlhCMWRHVWdlMXh1SUNBZ0lDQWdJQ0J6YTJsd2NHVmtYM0psWVhOdmJseHVJQ0FnSUNBZ0lDQmxlR2wwWDJOdlpHVmNiaUFnSUNBZ0lDQWdjM1ZqWTJWemMxeHVJQ0FnSUNBZ0lDQm5ZWE5mWm1WbGMxeHVJQ0FnSUgxY2JpQWdJQ0J6ZEc5eVlXZGxJSHRjYmlBZ0lDQWdJQ0J6ZEdGMGRYTmZZMmhoYm1kbFhHNGdJQ0FnSUNBZ2MzUnZjbUZuWlY5bVpXVnpYMk52Ykd4bFkzUmxaRnh1SUNBZ0lIMWNiaUFnSUNCaFkzUnBiMjRnZTF4dUlDQWdJQ0FnSUNCemRXTmpaWE56WEc0Z0lDQWdJQ0FnSUhaaGJHbGtYRzRnSUNBZ0lDQWdJRzV2WDJaMWJtUnpYRzRnSUNBZ0lDQWdJSEpsYzNWc2RGOWpiMlJsWEc0Z0lDQWdJQ0FnSUhSdmRHRnNYMlozWkY5bVpXVnpYRzRnSUNBZ0lDQWdJSFJ2ZEdGc1gyRmpkR2x2Ymw5bVpXVnpYRzRnSUNBZ2ZWeHVJQ0FnSUdsdVgyMXpaMXh1SUNBZ0lHNXZkMXh1SUNBZ0lHOTFkRjl0YzJkelhHNGdJQ0FnYjNWMFgyMWxjM05oWjJWeklIdGNiaUFnSUNBZ0lDQWdhV1JjYmlBZ0lDQWdJQ0FnWW05a2VWeHVJQ0FnSUNBZ0lDQnRjMmRmZEhsd1pWeHVJQ0FnSUNBZ0lDQjJZV3gxWlZ4dUlDQWdJSDFjYmlBZ0lDQnpkR0YwZFhOY2JpQWdJQ0IwYjNSaGJGOW1aV1Z6WEc1Z08xeHVJbDE5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMuVE9OTW5lbW9uaWNEaWN0aW9uYXJ5ID0gZXhwb3J0cy5UT05PdXRwdXRFbmNvZGluZyA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9UT05DbGllbnRFcnJvciA9IHJlcXVpcmUoXCIuLi9UT05DbGllbnRFcnJvclwiKTtcblxudmFyIF9UT05Nb2R1bGUyID0gcmVxdWlyZShcIi4uL1RPTk1vZHVsZVwiKTtcblxudmFyIF9jcnlwdG9Cb3ggPSByZXF1aXJlKFwiLi9jcnlwdG8tYm94XCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgVE9OT3V0cHV0RW5jb2RpbmcgPSB7XG4gIFRleHQ6ICdUZXh0JyxcbiAgSGV4OiAnSGV4JyxcbiAgSGV4VXBwZXJjYXNlOiAnSGV4VXBwZXJjYXNlJyxcbiAgQmFzZTY0OiAnQmFzZTY0J1xufTtcbmV4cG9ydHMuVE9OT3V0cHV0RW5jb2RpbmcgPSBUT05PdXRwdXRFbmNvZGluZztcbnZhciBUT05NbmVtb25pY0RpY3Rpb25hcnkgPSB7XG4gIFRPTjogMCxcbiAgRU5HTElTSDogMSxcbiAgQ0hJTkVTRV9TSU1QTElGSUVEOiAyLFxuICBDSElORVNFX1RSQURJVElPTkFMOiAzLFxuICBGUkVOQ0g6IDQsXG4gIElUQUxJQU46IDUsXG4gIEpBUEFORVNFOiA2LFxuICBLT1JFQU46IDcsXG4gIFNQQU5JU0g6IDhcbn07XG5leHBvcnRzLlRPTk1uZW1vbmljRGljdGlvbmFyeSA9IFRPTk1uZW1vbmljRGljdGlvbmFyeTtcblxuZnVuY3Rpb24gZml4SW5wdXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG1lc3NhZ2UudGV4dCA/IHtcbiAgICBiYXNlNjQ6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UudGV4dCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0JylcbiAgfSA6IG1lc3NhZ2U7XG59XG5cbnZhciBUT05DcnlwdG9Nb2R1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UT05Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKFRPTkNyeXB0b01vZHVsZSwgX1RPTk1vZHVsZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUT05DcnlwdG9Nb2R1bGUpO1xuXG4gIGZ1bmN0aW9uIFRPTkNyeXB0b01vZHVsZShjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRPTkNyeXB0b01vZHVsZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNyeXB0b0JveGVzXCIsIHZvaWQgMCk7XG5cbiAgICBfdGhpcy5jcnlwdG9Cb3hlcyA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVE9OQ3J5cHRvTW9kdWxlLCBbe1xuICAgIGtleTogXCJnZXRDcnlwdG9Cb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3J5cHRvQm94KHBhcmFtcykge1xuICAgICAgdmFyIGtleSA9IHBhcmFtcy5lbmNyeXB0ZWRTZWVkUGhyYXNlLnRleHQgfHwgcGFyYW1zLmVuY3J5cHRlZFNlZWRQaHJhc2UuYmFzZTY0IHx8IHBhcmFtcy5lbmNyeXB0ZWRTZWVkUGhyYXNlLmhleCB8fCAnJztcblxuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgdGhyb3cgX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yLmludmFsaWRDcnlwdG9Cb3hQYXJhbXMocGFyYW1zLmVuY3J5cHRlZFNlZWRQaHJhc2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3J5cHRvQm94ID0gdGhpcy5jcnlwdG9Cb3hlcy5nZXQoa2V5KTtcblxuICAgICAgaWYgKCFjcnlwdG9Cb3gpIHtcbiAgICAgICAgY3J5cHRvQm94ID0gbmV3IF9jcnlwdG9Cb3guQ29yZUNyeXB0b0JveCh0aGlzLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNyeXB0b0JveGVzLnNldChrZXksIGNyeXB0b0JveCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3J5cHRvQm94KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjdG9yaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmFjdG9yaXplID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjaGFsbGVuZ2VIZXgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5tYXRoLmZhY3Rvcml6ZScsIGNoYWxsZW5nZUhleCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZmFjdG9yaXplKF94KSB7XG4gICAgICAgIHJldHVybiBfZmFjdG9yaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWN0b3JpemU7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwibW9kdWxhclBvd2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbW9kdWxhclBvd2VyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYmFzZUhleCwgZXhwb25lbnRIZXgsIG1vZHVsdXNIZXgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm1hdGgubW9kdWxhclBvd2VyJywge1xuICAgICAgICAgICAgICAgICAgYmFzZTogYmFzZUhleCxcbiAgICAgICAgICAgICAgICAgIGV4cG9uZW50OiBleHBvbmVudEhleCxcbiAgICAgICAgICAgICAgICAgIG1vZHVsdXM6IG1vZHVsdXNIZXhcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG1vZHVsYXJQb3dlcihfeDIsIF94MywgX3g0KSB7XG4gICAgICAgIHJldHVybiBfbW9kdWxhclBvd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb2R1bGFyUG93ZXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZG9tR2VuZXJhdGVCeXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JhbmRvbUdlbmVyYXRlQnl0ZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhsZW5ndGgpIHtcbiAgICAgICAgdmFyIG91dHB1dEVuY29kaW5nLFxuICAgICAgICAgICAgX2FyZ3MzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZyA9IF9hcmdzMy5sZW5ndGggPiAxICYmIF9hcmdzM1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MzWzFdIDogVE9OT3V0cHV0RW5jb2RpbmcuSGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5yYW5kb20uZ2VuZXJhdGVCeXRlcycsIHtcbiAgICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0RW5jb2Rpbmc6IG91dHB1dEVuY29kaW5nXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByYW5kb21HZW5lcmF0ZUJ5dGVzKF94NSkge1xuICAgICAgICByZXR1cm4gX3JhbmRvbUdlbmVyYXRlQnl0ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmRvbUdlbmVyYXRlQnl0ZXM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZWQyNTUxOUtleXBhaXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9lZDI1NTE5S2V5cGFpciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8uZWQyNTUxOS5rZXlwYWlyJykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBlZDI1NTE5S2V5cGFpcigpIHtcbiAgICAgICAgcmV0dXJuIF9lZDI1NTE5S2V5cGFpci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWQyNTUxOUtleXBhaXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGljS2V5VG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wdWJsaWNLZXlUb1N0cmluZyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8udG9uX3B1YmxpY19rZXlfc3RyaW5nJywga2V5KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHB1YmxpY0tleVRvU3RyaW5nKF94Nikge1xuICAgICAgICByZXR1cm4gX3B1YmxpY0tleVRvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdWJsaWNLZXlUb1N0cmluZztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzaGE1MTJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zaGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBvdXRwdXRFbmNvZGluZyxcbiAgICAgICAgICAgIF9hcmdzNiA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3V0cHV0RW5jb2RpbmcgPSBfYXJnczYubGVuZ3RoID4gMSAmJiBfYXJnczZbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNlsxXSA6IFRPTk91dHB1dEVuY29kaW5nLkhleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8uc2hhNTEyJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZml4SW5wdXRNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0RW5jb2Rpbmc6IG91dHB1dEVuY29kaW5nXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzaGE1MTIoX3g3KSB7XG4gICAgICAgIHJldHVybiBfc2hhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaGE1MTI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2hhMjU2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2hhMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG91dHB1dEVuY29kaW5nLFxuICAgICAgICAgICAgX2FyZ3M3ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZyA9IF9hcmdzNy5sZW5ndGggPiAxICYmIF9hcmdzN1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M3WzFdIDogVE9OT3V0cHV0RW5jb2RpbmcuSGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5zaGEyNTYnLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBmaXhJbnB1dE1lc3NhZ2UobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZzogb3V0cHV0RW5jb2RpbmdcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNoYTI1NihfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9zaGEyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaGEyNTY7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2NyeXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2NyeXB0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgocGFyYW1zKSB7XG4gICAgICAgIHZhciBmaXhlZDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZml4ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGZpeGVkLnBhc3N3b3JkID0gZml4SW5wdXRNZXNzYWdlKHBhcmFtcy5wYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgZml4ZWQuc2FsdCA9IGZpeElucHV0TWVzc2FnZShwYXJhbXMuc2FsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLnNjcnlwdCcsIGZpeGVkKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNjcnlwdChfeDkpIHtcbiAgICAgICAgcmV0dXJuIF9zY3J5cHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjcnlwdDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJuYWNsQm94S2V5cGFpclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX25hY2xCb3hLZXlwYWlyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5uYWNsLmJveC5rZXlwYWlyJykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBuYWNsQm94S2V5cGFpcigpIHtcbiAgICAgICAgcmV0dXJuIF9uYWNsQm94S2V5cGFpci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFjbEJveEtleXBhaXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwibmFjbEJveEtleXBhaXJGcm9tU2VjcmV0S2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbmFjbEJveEtleXBhaXJGcm9tU2VjcmV0S2V5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHNlY3JldEtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5uYWNsLmJveC5rZXlwYWlyLmZyb21TZWNyZXRLZXknLCBzZWNyZXRLZXkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTAsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBuYWNsQm94S2V5cGFpckZyb21TZWNyZXRLZXkoX3gxMCkge1xuICAgICAgICByZXR1cm4gX25hY2xCb3hLZXlwYWlyRnJvbVNlY3JldEtleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFjbEJveEtleXBhaXJGcm9tU2VjcmV0S2V5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm5hY2xTaWduS2V5cGFpclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX25hY2xTaWduS2V5cGFpciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMSgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5zaWduLmtleXBhaXInKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTExLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbmFjbFNpZ25LZXlwYWlyKCkge1xuICAgICAgICByZXR1cm4gX25hY2xTaWduS2V5cGFpci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFjbFNpZ25LZXlwYWlyO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm5hY2xTaWduS2V5cGFpckZyb21TZWNyZXRLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9uYWNsU2lnbktleXBhaXJGcm9tU2VjcmV0S2V5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKHNlY3JldEtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5uYWNsLnNpZ24ua2V5cGFpci5mcm9tU2VjcmV0S2V5Jywgc2VjcmV0S2V5KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbmFjbFNpZ25LZXlwYWlyRnJvbVNlY3JldEtleShfeDExKSB7XG4gICAgICAgIHJldHVybiBfbmFjbFNpZ25LZXlwYWlyRnJvbVNlY3JldEtleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFjbFNpZ25LZXlwYWlyRnJvbVNlY3JldEtleTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJuYWNsQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbmFjbEJveCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIGZpeGVkO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZml4ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGZpeGVkLm1lc3NhZ2UgPSBmaXhJbnB1dE1lc3NhZ2UocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5ib3gnLCBmaXhlZCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG5hY2xCb3goX3gxMikge1xuICAgICAgICByZXR1cm4gX25hY2xCb3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hY2xCb3g7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwibmFjbEJveE9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9uYWNsQm94T3BlbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGZpeGVkO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZml4ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGZpeGVkLm1lc3NhZ2UgPSBmaXhJbnB1dE1lc3NhZ2UocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5ib3gub3BlbicsIGZpeGVkKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbmFjbEJveE9wZW4oX3gxMykge1xuICAgICAgICByZXR1cm4gX25hY2xCb3hPcGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYWNsQm94T3BlbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJuYWNsU2VjcmV0Qm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbmFjbFNlY3JldEJveCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNShwYXJhbXMpIHtcbiAgICAgICAgdmFyIGZpeGVkO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNSQoX2NvbnRleHQxNSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTUucHJldiA9IF9jb250ZXh0MTUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZml4ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGZpeGVkLm1lc3NhZ2UgPSBmaXhJbnB1dE1lc3NhZ2UocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5zZWNyZXQuYm94JywgZml4ZWQpKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBuYWNsU2VjcmV0Qm94KF94MTQpIHtcbiAgICAgICAgcmV0dXJuIF9uYWNsU2VjcmV0Qm94LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYWNsU2VjcmV0Qm94O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm5hY2xTZWNyZXRCb3hPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbmFjbFNlY3JldEJveE9wZW4gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYocGFyYW1zKSB7XG4gICAgICAgIHZhciBmaXhlZDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTYkKF9jb250ZXh0MTYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE2LnByZXYgPSBfY29udGV4dDE2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGZpeGVkID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBmaXhlZC5tZXNzYWdlID0gZml4SW5wdXRNZXNzYWdlKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm5hY2wuc2VjcmV0LmJveC5vcGVuJywgZml4ZWQpKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBuYWNsU2VjcmV0Qm94T3BlbihfeDE1KSB7XG4gICAgICAgIHJldHVybiBfbmFjbFNlY3JldEJveE9wZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hY2xTZWNyZXRCb3hPcGVuO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm5hY2xTaWduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbmFjbFNpZ24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTcobWVzc2FnZSwga2V5KSB7XG4gICAgICAgIHZhciBvdXRwdXRFbmNvZGluZyxcbiAgICAgICAgICAgIF9hcmdzMTcgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE3JChfY29udGV4dDE3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNy5wcmV2ID0gX2NvbnRleHQxNy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZyA9IF9hcmdzMTcubGVuZ3RoID4gMiAmJiBfYXJnczE3WzJdICE9PSB1bmRlZmluZWQgPyBfYXJnczE3WzJdIDogVE9OT3V0cHV0RW5jb2RpbmcuSGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5zaWduJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZml4SW5wdXRNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZzogb3V0cHV0RW5jb2RpbmdcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE3LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbmFjbFNpZ24oX3gxNiwgX3gxNykge1xuICAgICAgICByZXR1cm4gX25hY2xTaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYWNsU2lnbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJuYWNsU2lnbk9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9uYWNsU2lnbk9wZW4gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTgobWVzc2FnZSwga2V5KSB7XG4gICAgICAgIHZhciBvdXRwdXRFbmNvZGluZyxcbiAgICAgICAgICAgIF9hcmdzMTggPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE4JChfY29udGV4dDE4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxOC5wcmV2ID0gX2NvbnRleHQxOC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvdXRwdXRFbmNvZGluZyA9IF9hcmdzMTgubGVuZ3RoID4gMiAmJiBfYXJnczE4WzJdICE9PSB1bmRlZmluZWQgPyBfYXJnczE4WzJdIDogVE9OT3V0cHV0RW5jb2RpbmcuSGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubmFjbC5zaWduLm9wZW4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBmaXhJbnB1dE1lc3NhZ2UobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgIG91dHB1dEVuY29kaW5nOiBvdXRwdXRFbmNvZGluZ1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBuYWNsU2lnbk9wZW4oX3gxOCwgX3gxOSkge1xuICAgICAgICByZXR1cm4gX25hY2xTaWduT3Blbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFjbFNpZ25PcGVuO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm5hY2xTaWduRGV0YWNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9uYWNsU2lnbkRldGFjaGVkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE5KG1lc3NhZ2UsIGtleSkge1xuICAgICAgICB2YXIgb3V0cHV0RW5jb2RpbmcsXG4gICAgICAgICAgICBfYXJnczE5ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOSQoX2NvbnRleHQxOSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTkucHJldiA9IF9jb250ZXh0MTkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3V0cHV0RW5jb2RpbmcgPSBfYXJnczE5Lmxlbmd0aCA+IDIgJiYgX2FyZ3MxOVsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MxOVsyXSA6IFRPTk91dHB1dEVuY29kaW5nLkhleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLm5hY2wuc2lnbi5kZXRhY2hlZCcsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZpeElucHV0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0RW5jb2Rpbmc6IG91dHB1dEVuY29kaW5nXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG5hY2xTaWduRGV0YWNoZWQoX3gyMCwgX3gyMSkge1xuICAgICAgICByZXR1cm4gX25hY2xTaWduRGV0YWNoZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hY2xTaWduRGV0YWNoZWQ7XG4gICAgfSgpIC8vIE1uZW1vbmljXG5cbiAgfSwge1xuICAgIGtleTogXCJtbmVtb25pY1dvcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbW5lbW9uaWNXb3JkcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjAkKF9jb250ZXh0MjApIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIwLnByZXYgPSBfY29udGV4dDIwLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIwLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubW5lbW9uaWMud29yZHMnLCBwYXJhbXMgfHwge30pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjAsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBtbmVtb25pY1dvcmRzKF94MjIpIHtcbiAgICAgICAgcmV0dXJuIF9tbmVtb25pY1dvcmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtbmVtb25pY1dvcmRzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm1uZW1vbmljRnJvbVJhbmRvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX21uZW1vbmljRnJvbVJhbmRvbSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjEkKF9jb250ZXh0MjEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIxLnByZXYgPSBfY29udGV4dDIxLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubW5lbW9uaWMuZnJvbS5yYW5kb20nLCBwYXJhbXMgfHwge30pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBtbmVtb25pY0Zyb21SYW5kb20oX3gyMykge1xuICAgICAgICByZXR1cm4gX21uZW1vbmljRnJvbVJhbmRvbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW5lbW9uaWNGcm9tUmFuZG9tO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm1uZW1vbmljRnJvbUVudHJvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9tbmVtb25pY0Zyb21FbnRyb3B5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIyKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMiQoX2NvbnRleHQyMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjIucHJldiA9IF9jb250ZXh0MjIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjIuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5tbmVtb25pYy5mcm9tLmVudHJvcHknLCBwYXJhbXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBtbmVtb25pY0Zyb21FbnRyb3B5KF94MjQpIHtcbiAgICAgICAgcmV0dXJuIF9tbmVtb25pY0Zyb21FbnRyb3B5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtbmVtb25pY0Zyb21FbnRyb3B5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm1uZW1vbmljSXNWYWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX21uZW1vbmljSXNWYWxpZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjMkKF9jb250ZXh0MjMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIzLnByZXYgPSBfY29udGV4dDIzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIzLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubW5lbW9uaWMudmVyaWZ5JywgcGFyYW1zKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbW5lbW9uaWNJc1ZhbGlkKF94MjUpIHtcbiAgICAgICAgcmV0dXJuIF9tbmVtb25pY0lzVmFsaWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1uZW1vbmljSXNWYWxpZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJtbmVtb25pY0Rlcml2ZVNpZ25LZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbW5lbW9uaWNEZXJpdmVTaWduS2V5cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjQkKF9jb250ZXh0MjQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI0LnByZXYgPSBfY29udGV4dDI0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI0LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8ubW5lbW9uaWMuZGVyaXZlLnNpZ24ua2V5cycsIHBhcmFtcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG1uZW1vbmljRGVyaXZlU2lnbktleXMoX3gyNikge1xuICAgICAgICByZXR1cm4gX21uZW1vbmljRGVyaXZlU2lnbktleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1uZW1vbmljRGVyaXZlU2lnbktleXM7XG4gICAgfSgpIC8vIEhES2V5c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGRrZXlYUHJ2RnJvbU1uZW1vbmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaGRrZXlYUHJ2RnJvbU1uZW1vbmljID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI1KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNSQoX2NvbnRleHQyNSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjUucHJldiA9IF9jb250ZXh0MjUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5oZGtleS54cHJ2LmZyb20ubW5lbW9uaWMnLCBwYXJhbXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBoZGtleVhQcnZGcm9tTW5lbW9uaWMoX3gyNykge1xuICAgICAgICByZXR1cm4gX2hka2V5WFBydkZyb21NbmVtb25pYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGRrZXlYUHJ2RnJvbU1uZW1vbmljO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImhka2V5WFBydkRlcml2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2hka2V5WFBydkRlcml2ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNihzZXJpYWxpemVkLCBpbmRleCwgaGFyZGVuZWQsIGNvbXBsaWFudCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNiQoX2NvbnRleHQyNikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjYucHJldiA9IF9jb250ZXh0MjYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjYuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5oZGtleS54cHJ2LmRlcml2ZScsIHtcbiAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICBoYXJkZW5lZDogaGFyZGVuZWQsXG4gICAgICAgICAgICAgICAgICBjb21wbGlhbnQ6IGNvbXBsaWFudFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBoZGtleVhQcnZEZXJpdmUoX3gyOCwgX3gyOSwgX3gzMCwgX3gzMSkge1xuICAgICAgICByZXR1cm4gX2hka2V5WFBydkRlcml2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGRrZXlYUHJ2RGVyaXZlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImhka2V5WFBydkRlcml2ZVBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9oZGtleVhQcnZEZXJpdmVQYXRoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI3KHNlcmlhbGl6ZWQsIHBhdGgsIGNvbXBsaWFudCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNyQoX2NvbnRleHQyNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjcucHJldiA9IF9jb250ZXh0MjcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVxdWVzdENvcmUoJ2NyeXB0by5oZGtleS54cHJ2LmRlcml2ZS5wYXRoJywge1xuICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZDogc2VyaWFsaXplZCxcbiAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICBjb21wbGlhbnQ6IGNvbXBsaWFudFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBoZGtleVhQcnZEZXJpdmVQYXRoKF94MzIsIF94MzMsIF94MzQpIHtcbiAgICAgICAgcmV0dXJuIF9oZGtleVhQcnZEZXJpdmVQYXRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZGtleVhQcnZEZXJpdmVQYXRoO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImhka2V5WFBydlNlY3JldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2hka2V5WFBydlNlY3JldCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyOChzZXJpYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI4JChfY29udGV4dDI4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyOC5wcmV2ID0gX2NvbnRleHQyOC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLmhka2V5LnhwcnYuc2VjcmV0Jywge1xuICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZDogc2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBoZGtleVhQcnZTZWNyZXQoX3gzNSkge1xuICAgICAgICByZXR1cm4gX2hka2V5WFBydlNlY3JldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGRrZXlYUHJ2U2VjcmV0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImhka2V5WFBydlB1YmxpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2hka2V5WFBydlB1YmxpYyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyOShzZXJpYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI5JChfY29udGV4dDI5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyOS5wcmV2ID0gX2NvbnRleHQyOS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZXF1ZXN0Q29yZSgnY3J5cHRvLmhka2V5LnhwcnYucHVibGljJywge1xuICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZDogc2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjksIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBoZGtleVhQcnZQdWJsaWMoX3gzNikge1xuICAgICAgICByZXR1cm4gX2hka2V5WFBydlB1YmxpYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGRrZXlYUHJ2UHVibGljO1xuICAgIH0oKSAvLyBFbmNyeXB0aW9uXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGFjaGEyMFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFjaGEyMChwYXJhbXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RDb3JlKCdjcnlwdG8uY2hhY2hhMjAnLCBwYXJhbXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUT05DcnlwdG9Nb2R1bGU7XG59KF9UT05Nb2R1bGUyLlRPTk1vZHVsZSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVE9OQ3J5cHRvTW9kdWxlO1xuVE9OQ3J5cHRvTW9kdWxlLm1vZHVsZU5hbWUgPSAnVE9OQ3J5cHRvTW9kdWxlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXRiMlIxYkdWekwxUlBUa055ZVhCMGIwMXZaSFZzWlM1cWN5SmRMQ0p1WVcxbGN5STZXeUpVVDA1UGRYUndkWFJGYm1OdlpHbHVaeUlzSWxSbGVIUWlMQ0pJWlhnaUxDSklaWGhWY0hCbGNtTmhjMlVpTENKQ1lYTmxOalFpTENKVVQwNU5ibVZ0YjI1cFkwUnBZM1JwYjI1aGNua2lMQ0pVVDA0aUxDSkZUa2RNU1ZOSUlpd2lRMGhKVGtWVFJWOVRTVTFRVEVsR1NVVkVJaXdpUTBoSlRrVlRSVjlVVWtGRVNWUkpUMDVCVENJc0lrWlNSVTVEU0NJc0lrbFVRVXhKUVU0aUxDSktRVkJCVGtWVFJTSXNJa3RQVWtWQlRpSXNJbE5RUVU1SlUwZ2lMQ0ptYVhoSmJuQjFkRTFsYzNOaFoyVWlMQ0p0WlhOellXZGxJaXdpZEdWNGRDSXNJbUpoYzJVMk5DSXNJa0oxWm1abGNpSXNJbVp5YjIwaUxDSjBiMU4wY21sdVp5SXNJbFJQVGtOeWVYQjBiMDF2WkhWc1pTSXNJbU52Ym5SbGVIUWlMQ0pqY25sd2RHOUNiM2hsY3lJc0lrMWhjQ0lzSW5CaGNtRnRjeUlzSW10bGVTSXNJbVZ1WTNKNWNIUmxaRk5sWldSUWFISmhjMlVpTENKb1pYZ2lMQ0pVVDA1RGJHbGxiblJGY25KdmNpSXNJbWx1ZG1Gc2FXUkRjbmx3ZEc5Q2IzaFFZWEpoYlhNaUxDSmpjbmx3ZEc5Q2IzZ2lMQ0puWlhRaUxDSkRiM0psUTNKNWNIUnZRbTk0SWl3aWMyVjBJaXdpVUhKdmJXbHpaU0lzSW5KbGMyOXNkbVVpTENKamFHRnNiR1Z1WjJWSVpYZ2lMQ0p5WlhGMVpYTjBRMjl5WlNJc0ltSmhjMlZJWlhnaUxDSmxlSEJ2Ym1WdWRFaGxlQ0lzSW0xdlpIVnNkWE5JWlhnaUxDSmlZWE5sSWl3aVpYaHdiMjVsYm5RaUxDSnRiMlIxYkhWeklpd2liR1Z1WjNSb0lpd2liM1YwY0hWMFJXNWpiMlJwYm1jaUxDSm1hWGhsWkNJc0lrOWlhbVZqZENJc0ltRnpjMmxuYmlJc0luQmhjM04zYjNKa0lpd2ljMkZzZENJc0luTmxZM0psZEV0bGVTSXNJbk5sY21saGJHbDZaV1FpTENKcGJtUmxlQ0lzSW1oaGNtUmxibVZrSWl3aVkyOXRjR3hwWVc1MElpd2ljR0YwYUNJc0lsUlBUazF2WkhWc1pTSXNJbTF2WkhWc1pVNWhiV1VpWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096dEJRWGxDUVRzN1FVRkZRVHM3UVVGRFFUczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGRlR5eEpRVUZOUVN4cFFrRkJhVUlzUjBGQlJ6dEJRVU0zUWtNc1JVRkJRVUVzU1VGQlNTeEZRVUZGTEUxQlJIVkNPMEZCUlRkQ1F5eEZRVUZCUVN4SFFVRkhMRVZCUVVVc1MwRkdkMEk3UVVGSE4wSkRMRVZCUVVGQkxGbEJRVmtzUlVGQlJTeGpRVWhsTzBGQlNUZENReXhGUVVGQlFTeE5RVUZOTEVWQlFVVTdRVUZLY1VJc1EwRkJNVUk3TzBGQlVVRXNTVUZCVFVNc2NVSkJRWEZDTEVkQlFVYzdRVUZEYWtORExFVkJRVUZCTEVkQlFVY3NSVUZCUlN4RFFVUTBRanRCUVVWcVEwTXNSVUZCUVVFc1QwRkJUeXhGUVVGRkxFTkJSbmRDTzBGQlIycERReXhGUVVGQlFTeHJRa0ZCYTBJc1JVRkJSU3hEUVVoaE8wRkJTV3BEUXl4RlFVRkJRU3h0UWtGQmJVSXNSVUZCUlN4RFFVcFpPMEZCUzJwRFF5eEZRVUZCUVN4TlFVRk5MRVZCUVVVc1EwRk1lVUk3UVVGTmFrTkRMRVZCUVVGQkxFOUJRVThzUlVGQlJTeERRVTUzUWp0QlFVOXFRME1zUlVGQlFVRXNVVUZCVVN4RlFVRkZMRU5CVUhWQ08wRkJVV3BEUXl4RlFVRkJRU3hOUVVGTkxFVkJRVVVzUTBGU2VVSTdRVUZUYWtORExFVkJRVUZCTEU5QlFVOHNSVUZCUlR0QlFWUjNRaXhEUVVFNVFqczdPMEZCWVZBc1UwRkJVME1zWlVGQlZDeERRVUY1UWtNc1QwRkJla0lzUlVGQmIwVTdRVUZEYUVVc1UwRkJUMEVzVDBGQlR5eERRVUZEUXl4SlFVRlNMRWRCUTBRN1FVRkRSVU1zU1VGQlFVRXNUVUZCVFN4RlFVRkZReXhOUVVGTkxFTkJRVU5ETEVsQlFWQXNRMEZCV1Vvc1QwRkJUeXhEUVVGRFF5eEpRVUZ3UWl4RlFVRXdRaXhOUVVFeFFpeEZRVU5JU1N4UlFVUkhMRU5CUTAwc1VVRkVUanRCUVVSV0xFZEJSRU1zUjBGTFJFd3NUMEZNVGp0QlFVMUlPenRKUVVWdlFrMHNaVHM3T3pzN1FVRkhha0lzTWtKQlFWbERMRTlCUVZvc1JVRkJkVU03UVVGQlFUczdRVUZCUVRzN1FVRkRia01zT0VKQlFVMUJMRTlCUVU0N08wRkJSRzFET3p0QlFVVnVReXhWUVVGTFF5eFhRVUZNTEVkQlFXMUNMRWxCUVVsRExFZEJRVW9zUlVGQmJrSTdRVUZHYlVNN1FVRkhkRU03T3pzN2FVTkJSVmxETEUwc1JVRkJiVVE3UVVGRE5VUXNWVUZCVFVNc1IwRkJSeXhIUVVGSFJDeE5RVUZOTEVOQlFVTkZMRzFDUVVGUUxFTkJRVEpDV0N4SlFVRXpRaXhKUVVOTVV5eE5RVUZOTEVOQlFVTkZMRzFDUVVGUUxFTkJRVEpDVml4TlFVUjBRaXhKUVVWTVVTeE5RVUZOTEVOQlFVTkZMRzFDUVVGUUxFTkJRVEpDUXl4SFFVWjBRaXhKUVVkTUxFVkJTRkE3TzBGQlNVRXNWVUZCU1N4RFFVRkRSaXhIUVVGTUxFVkJRVlU3UVVGRFRpeGpRVUZOUnl3clFrRkJaVU1zYzBKQlFXWXNRMEZCYzBOTUxFMUJRVTBzUTBGQlEwVXNiVUpCUVRkRExFTkJRVTQ3UVVGRFNEczdRVUZEUkN4VlFVRkpTU3hUUVVGVExFZEJRVWNzUzBGQlMxSXNWMEZCVEN4RFFVRnBRbE1zUjBGQmFrSXNRMEZCY1VKT0xFZEJRWEpDTEVOQlFXaENPenRCUVVOQkxGVkJRVWtzUTBGQlEwc3NVMEZCVEN4RlFVRm5RanRCUVVOYVFTeFJRVUZCUVN4VFFVRlRMRWRCUVVjc1NVRkJTVVVzZDBKQlFVb3NRMEZCYTBJc1NVRkJiRUlzUlVGQmQwSlNMRTFCUVhoQ0xFTkJRVm83UVVGRFFTeGhRVUZMUml4WFFVRk1MRU5CUVdsQ1Z5eEhRVUZxUWl4RFFVRnhRbElzUjBGQmNrSXNSVUZCTUVKTExGTkJRVEZDTzBGQlEwZzdPMEZCUTBRc1lVRkJUMGtzVDBGQlR5eERRVUZEUXl4UFFVRlNMRU5CUVdkQ1RDeFRRVUZvUWl4RFFVRlFPMEZCUTBnN096czdjVWRCUldWTkxGazdPenM3TzJsRVFVTk1MRXRCUVV0RExGZEJRVXdzUTBGQmFVSXNkVUpCUVdwQ0xFVkJRVEJEUkN4WlFVRXhReXhET3pzN096czdPenM3T3pzN096czdPenM3TzNsSFFVbFFSU3hQTEVWQlEwRkRMRmNzUlVGRFFVTXNWVHM3T3pzN2EwUkJSVThzUzBGQlMwZ3NWMEZCVEN4RFFVRnBRaXd3UWtGQmFrSXNSVUZCTmtNN1FVRkRhRVJKTEd0Q1FVRkJRU3hKUVVGSkxFVkJRVVZJTEU5QlJEQkRPMEZCUldoRVNTeHJRa0ZCUVVFc1VVRkJVU3hGUVVGRlNDeFhRVVp6UXp0QlFVZG9SRWtzYTBKQlFVRkJMRTlCUVU4c1JVRkJSVWc3UVVGSWRVTXNhVUpCUVRkRExFTTdPenM3T3pzN096czdPenM3T3pzN096czdaMGhCVVZCSkxFMDdPenM3T3pzN1FVRkRRVU1zWjBKQlFVRkJMR01zT0VSQlFYZERMME1zYVVKQlFXbENMRU5CUVVORkxFYzdhMFJCUlc1RUxFdEJRVXR4UXl4WFFVRk1MRU5CUVdsQ0xEWkNRVUZxUWl4RlFVRm5SRHRCUVVOdVJFOHNhMEpCUVVGQkxFMUJRVTBzUlVGQlRrRXNUVUZFYlVRN1FVRkZia1JETEd0Q1FVRkJRU3hqUVVGakxFVkJRV1JCTzBGQlJtMUVMR2xDUVVGb1JDeERPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN2EwUkJVVUVzUzBGQlMxSXNWMEZCVEN4RFFVRnBRaXgzUWtGQmFrSXNRenM3T3pzN096czdPenM3T3pzN096czdPenM0UjBGSFlWb3NSenM3T3pzN2EwUkJRMklzUzBGQlMxa3NWMEZCVEN4RFFVRnBRaXc0UWtGQmFrSXNSVUZCYVVSYUxFZEJRV3BFTEVNN096czdPenM3T3pzN096czdPenM3T3pzN1owZEJTVkJZTEU4N096czdPenM3UVVGRFFTdENMR2RDUVVGQlFTeGpMRGhFUVVGM1F5OURMR2xDUVVGcFFpeERRVUZEUlN4SE8ydEVRVVZ1UkN4TFFVRkxjVU1zVjBGQlRDeERRVU5JTEdWQlJFY3NSVUZGU0R0QlFVTkpka0lzYTBKQlFVRkJMRTlCUVU4c1JVRkJSVVFzWlVGQlpTeERRVUZEUXl4UFFVRkVMRU5CUkRWQ08wRkJSVWtyUWl4clFrRkJRVUVzWTBGQll5eEZRVUZrUVR0QlFVWktMR2xDUVVaSExFTTdPenM3T3pzN096czdPenM3T3pzN096czdhVWRCVlZBdlFpeFBPenM3T3pzN08wRkJRMEVyUWl4blFrRkJRVUVzWXl3NFJFRkJkME12UXl4cFFrRkJhVUlzUTBGQlEwVXNSenRyUkVGRmJrUXNTMEZCUzNGRExGZEJRVXdzUTBGRFNDeGxRVVJITEVWQlJVZzdRVUZEU1haQ0xHdENRVUZCUVN4UFFVRlBMRVZCUVVWRUxHVkJRV1VzUTBGQlEwTXNUMEZCUkN4RFFVUTFRanRCUVVWSkswSXNhMEpCUVVGQkxHTkJRV01zUlVGQlpFRTdRVUZHU2l4cFFrRkdSeXhET3pzN096czdPenM3T3pzN096czdPenM3TzIxSFFWTkZja0lzVFRzN096czdPMEZCUTBoelFpeG5Ra0ZCUVVFc1N5eEhRVUV3UWtNc1RVRkJUU3hEUVVGRFF5eE5RVUZRTEVOQlFXTXNSVUZCWkN4RlFVRnJRbmhDTEUxQlFXeENMRU03UVVGRGFFTnpRaXhuUWtGQlFVRXNTMEZCU3l4RFFVRkRSeXhSUVVGT0xFZEJRV2xDY0VNc1pVRkJaU3hEUVVGRFZ5eE5RVUZOTEVOQlFVTjVRaXhSUVVGU0xFTkJRV2hETzBGQlEwRklMR2RDUVVGQlFTeExRVUZMTEVOQlFVTkpMRWxCUVU0c1IwRkJZWEpETEdWQlFXVXNRMEZCUTFjc1RVRkJUU3hEUVVGRE1FSXNTVUZCVWl4RFFVRTFRanRyUkVGRFR5eExRVUZMWWl4WFFVRk1MRU5CUVdsQ0xHVkJRV3BDTEVWQlFXdERVeXhMUVVGc1F5eERPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN2EwUkJTVUVzUzBGQlMxUXNWMEZCVEN4RFFVRnBRaXg1UWtGQmFrSXNRenM3T3pzN096czdPenM3T3pzN096czdPenQ1U0VGSGRVSmpMRk03T3pzN08yMUVRVU4yUWl4TFFVRkxaQ3hYUVVGTUxFTkJRV2xDTEhWRFFVRnFRaXhGUVVFd1JHTXNVMEZCTVVRc1F6czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzIxRVFVbEJMRXRCUVV0a0xGZEJRVXdzUTBGQmFVSXNNRUpCUVdwQ0xFTTdPenM3T3pzN096czdPenM3T3pzN096czdNRWhCUjNkQ1l5eFRPenM3T3p0dFJFRkRlRUlzUzBGQlMyUXNWMEZCVEN4RFFVRnBRaXgzUTBGQmFrSXNSVUZCTWtSakxGTkJRVE5FTEVNN096czdPenM3T3pzN096czdPenM3T3pzN2NVZEJSMGN6UWl4Tk96czdPenM3UVVGRFNuTkNMR2RDUVVGQlFTeExMRWRCUVRKQ1F5eE5RVUZOTEVOQlFVTkRMRTFCUVZBc1EwRkJZeXhGUVVGa0xFVkJRV3RDZUVJc1RVRkJiRUlzUXp0QlFVTnFRM05DTEdkQ1FVRkJRU3hMUVVGTExFTkJRVU5vUXl4UFFVRk9MRWRCUVdkQ1JDeGxRVUZsTEVOQlFVTlhMRTFCUVUwc1EwRkJRMVlzVDBGQlVpeERRVUV2UWp0dFJFRkRUeXhMUVVGTGRVSXNWMEZCVEN4RFFVRnBRaXhwUWtGQmFrSXNSVUZCYjBOVExFdEJRWEJETEVNN096czdPenM3T3pzN096czdPenM3T3pzN2VVZEJSMDkwUWl4Tk96czdPenM3UVVGRFVuTkNMR2RDUVVGQlFTeExMRWRCUVRKQ1F5eE5RVUZOTEVOQlFVTkRMRTFCUVZBc1EwRkJZeXhGUVVGa0xFVkJRV3RDZUVJc1RVRkJiRUlzUXp0QlFVTnFRM05DTEdkQ1FVRkJRU3hMUVVGTExFTkJRVU5vUXl4UFFVRk9MRWRCUVdkQ1JDeGxRVUZsTEVOQlFVTlhMRTFCUVUwc1EwRkJRMVlzVDBGQlVpeERRVUV2UWp0dFJFRkRUeXhMUVVGTGRVSXNWMEZCVEN4RFFVRnBRaXh6UWtGQmFrSXNSVUZCZVVOVExFdEJRWHBETEVNN096czdPenM3T3pzN096czdPenM3T3pzN01rZEJSMU4wUWl4Tk96czdPenM3UVVGRFZuTkNMR2RDUVVGQlFTeExMRWRCUVRKQ1F5eE5RVUZOTEVOQlFVTkRMRTFCUVZBc1EwRkJZeXhGUVVGa0xFVkJRV3RDZUVJc1RVRkJiRUlzUXp0QlFVTnFRM05DTEdkQ1FVRkJRU3hMUVVGTExFTkJRVU5vUXl4UFFVRk9MRWRCUVdkQ1JDeGxRVUZsTEVOQlFVTlhMRTFCUVUwc1EwRkJRMVlzVDBGQlVpeERRVUV2UWp0dFJFRkRUeXhMUVVGTGRVSXNWMEZCVEN4RFFVRnBRaXgzUWtGQmFrSXNSVUZCTWtOVExFdEJRVE5ETEVNN096czdPenM3T3pzN096czdPenM3T3pzN0swZEJSMkYwUWl4Tk96czdPenM3UVVGRFpITkNMR2RDUVVGQlFTeExMRWRCUVRKQ1F5eE5RVUZOTEVOQlFVTkRMRTFCUVZBc1EwRkJZeXhGUVVGa0xFVkJRV3RDZUVJc1RVRkJiRUlzUXp0QlFVTnFRM05DTEdkQ1FVRkJRU3hMUVVGTExFTkJRVU5vUXl4UFFVRk9MRWRCUVdkQ1JDeGxRVUZsTEVOQlFVTlhMRTFCUVUwc1EwRkJRMVlzVDBGQlVpeERRVUV2UWp0dFJFRkRUeXhMUVVGTGRVSXNWMEZCVEN4RFFVRnBRaXcyUWtGQmFrSXNSVUZCWjBSVExFdEJRV2hFTEVNN096czdPenM3T3pzN096czdPenM3T3pzN2MwZEJTVkJvUXl4UExFVkJRMEZYTEVjN096czdPenM3UVVGRFFXOUNMR2RDUVVGQlFTeGpMR2xGUVVGM1F5OURMR2xDUVVGcFFpeERRVUZEUlN4SE8yMUVRVVZ1UkN4TFFVRkxjVU1zVjBGQlRDeERRVUZwUWl4clFrRkJha0lzUlVGQmNVTTdRVUZEZUVOMlFpeHJRa0ZCUVVFc1QwRkJUeXhGUVVGRlJDeGxRVUZsTEVOQlFVTkRMRTlCUVVRc1EwRkVaMEk3UVVGRmVFTlhMR3RDUVVGQlFTeEhRVUZITEVWQlFVaEJMRWRCUm5kRE8wRkJSM2hEYjBJc2EwSkJRVUZCTEdOQlFXTXNSVUZCWkVFN1FVRklkME1zYVVKQlFYSkRMRU03T3pzN096czdPenM3T3pzN096czdPenM3TUVkQlVWQXZRaXhQTEVWQlEwRlhMRWM3T3pzN096czdRVUZEUVc5Q0xHZENRVUZCUVN4akxHbEZRVUYzUXk5RExHbENRVUZwUWl4RFFVRkRSU3hITzIxRVFVVnVSQ3hMUVVGTGNVTXNWMEZCVEN4RFFVRnBRaXgxUWtGQmFrSXNSVUZCTUVNN1FVRkROME4yUWl4clFrRkJRVUVzVDBGQlR5eEZRVUZGUkN4bFFVRmxMRU5CUVVORExFOUJRVVFzUTBGRWNVSTdRVUZGTjBOWExHdENRVUZCUVN4SFFVRkhMRVZCUVVoQkxFZEJSalpETzBGQlJ6ZERiMElzYTBKQlFVRkJMR05CUVdNc1JVRkJaRUU3UVVGSU5rTXNhVUpCUVRGRExFTTdPenM3T3pzN096czdPenM3T3pzN096czdPRWRCVVZBdlFpeFBMRVZCUTBGWExFYzdPenM3T3pzN1FVRkRRVzlDTEdkQ1FVRkJRU3hqTEdsRlFVRjNReTlETEdsQ1FVRnBRaXhEUVVGRFJTeEhPMjFFUVVWdVJDeExRVUZMY1VNc1YwRkJUQ3hEUVVGcFFpd3lRa0ZCYWtJc1JVRkJPRU03UVVGRGFrUjJRaXhyUWtGQlFVRXNUMEZCVHl4RlFVRkZSQ3hsUVVGbExFTkJRVU5ETEU5QlFVUXNRMEZFZVVJN1FVRkZha1JYTEd0Q1FVRkJRU3hIUVVGSExFVkJRVWhCTEVkQlJtbEVPMEZCUjJwRWIwSXNhMEpCUVVGQkxHTkJRV01zUlVGQlpFRTdRVUZJYVVRc2FVSkJRVGxETEVNN096czdPenM3T3pzN096czdPenRSUVU5WU96czdPenN5UjBGRmIwSnlRaXhOT3pzN096dHRSRUZEVkN4TFFVRkxZU3hYUVVGTUxFTkJRV2xDTEhWQ1FVRnFRaXhGUVVFd1EySXNUVUZCVFN4SlFVRkpMRVZCUVhCRUxFTTdPenM3T3pzN096czdPenM3T3pzN096czdaMGhCUjJOQkxFMDdPenM3TzIxRVFVTmtMRXRCUVV0aExGZEJRVXdzUTBGQmFVSXNOa0pCUVdwQ0xFVkJRV2RFWWl4TlFVRk5MRWxCUVVrc1JVRkJNVVFzUXpzN096czdPenM3T3pzN096czdPenM3T3p0cFNFRkhaVUVzVFRzN096czdiVVJCUTJZc1MwRkJTMkVzVjBGQlRDeERRVU5JTERoQ1FVUkhMRVZCUlVoaUxFMUJSa2NzUXpzN096czdPenM3T3pzN096czdPenM3T3pzMlIwRk5WMEVzVFRzN096czdiVVJCUTFnc1MwRkJTMkVzVjBGQlRDeERRVUZwUWl4M1FrRkJha0lzUlVGQk1rTmlMRTFCUVRORExFTTdPenM3T3pzN096czdPenM3T3pzN096czdiMGhCUjJ0Q1FTeE5PenM3T3p0dFJFRkRiRUlzUzBGQlMyRXNWMEZCVEN4RFFVRnBRaXhyUTBGQmFrSXNSVUZCY1VSaUxFMUJRWEpFTEVNN096czdPenM3T3pzN096czdPenRSUVVkWU96czdPenR0U0VGRk5FSkJMRTA3T3pzN08yMUVRVU5xUWl4TFFVRkxZU3hYUVVGTUxFTkJRV2xDTEdsRFFVRnFRaXhGUVVGdlJHSXNUVUZCY0VRc1F6czdPenM3T3pzN096czdPenM3T3pzN096czJSMEZKVURSQ0xGVXNSVUZEUVVNc1N5eEZRVU5CUXl4UkxFVkJRMEZETEZNN096czdPMjFFUVVWUExFdEJRVXRzUWl4WFFVRk1MRU5CUTBnc01FSkJSRWNzUlVGRlNEdEJRVU5KWlN4clFrRkJRVUVzVlVGQlZTeEZRVUZXUVN4VlFVUktPMEZCUlVsRExHdENRVUZCUVN4TFFVRkxMRVZCUVV4QkxFdEJSa283UVVGSFNVTXNhMEpCUVVGQkxGRkJRVkVzUlVGQlVrRXNVVUZJU2p0QlFVbEpReXhyUWtGQlFVRXNVMEZCVXl4RlFVRlVRVHRCUVVwS0xHbENRVVpITEVNN096czdPenM3T3pzN096czdPenM3T3pzN2FVaEJXVkJJTEZVc1JVRkRRVWtzU1N4RlFVTkJSQ3hUT3pzN096dHRSRUZGVHl4TFFVRkxiRUlzVjBGQlRDeERRVU5JTEN0Q1FVUkhMRVZCUlVnN1FVRkRTV1VzYTBKQlFVRkJMRlZCUVZVc1JVRkJWa0VzVlVGRVNqdEJRVVZKU1N4clFrRkJRVUVzU1VGQlNTeEZRVUZLUVN4SlFVWktPMEZCUjBsRUxHdENRVUZCUVN4VFFVRlRMRVZCUVZSQk8wRkJTRW9zYVVKQlJrY3NRenM3T3pzN096czdPenM3T3pzN096czdPenMyUjBGVlYwZ3NWVHM3T3pzN2JVUkJRMWdzUzBGQlMyWXNWMEZCVEN4RFFVRnBRaXd3UWtGQmFrSXNSVUZCTmtNN1FVRkJSV1VzYTBKQlFVRkJMRlZCUVZVc1JVRkJWa0U3UVVGQlJpeHBRa0ZCTjBNc1F6czdPenM3T3pzN096czdPenM3T3pzN096czJSMEZIVjBFc1ZUczdPenM3YlVSQlExZ3NTMEZCUzJZc1YwRkJUQ3hEUVVGcFFpd3dRa0ZCYWtJc1JVRkJOa003UVVGQlJXVXNhMEpCUVVGQkxGVkJRVlVzUlVGQlZrRTdRVUZCUml4cFFrRkJOME1zUXpzN096czdPenM3T3pzN096czdPMUZCUjFnN096czdOa0pCUlZNMVFpeE5MRVZCUVcxRk8wRkJRM2hGTEdGQlFVOHNTMEZCUzJFc1YwRkJUQ3hEUVVGcFFpeHBRa0ZCYWtJc1JVRkJiME5pTEUxQlFYQkRMRU5CUVZBN1FVRkRTRHM3T3p0RlFXNVFkME5wUXl4eFFqczdPMEZCYzFBM1EzSkRMR1ZCUVdVc1EwRkJRM05ETEZWQlFXaENMRWRCUVRaQ0xHbENRVUUzUWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFYRzRnS2lCRGIzQjVjbWxuYUhRZ01qQXhPQzB5TURJd0lGUlBUaUJFUlZZZ1UwOU1WVlJKVDA1VElFeFVSQzVjYmlBcUwxeHVYRzR2THlCQVpteHZkMXh1THlvZ1pYTnNhVzUwTFdScGMyRmliR1VnWTJ4aGMzTXRiV1YwYUc5a2N5MTFjMlV0ZEdocGN5eHdjbVZtWlhJdGIySnFaV04wTFhOd2NtVmhaQ0FxTDF4dVhHNXBiWEJ2Y25RZ2RIbHdaU0I3WEc0Z0lDQWdWRTlPUm1GamRHOXlhWHBsVW1WemRXeDBMRnh1SUNBZ0lGUlBUa2x1Y0hWMFRXVnpjMkZuWlN4Y2JpQWdJQ0JVVDA1TFpYbFFZV2x5UkdGMFlTeGNiaUFnSUNCVVQwNVBkWFJ3ZFhSRmJtTnZaR2x1WjFSNWNHVXNYRzRnSUNBZ1ZFOU9VMk55ZVhCMFVHRnlZVzF6TEZ4dUlDQWdJRlJQVGs1aFkyeENiM2hRWVhKaGJYTXNYRzRnSUNBZ1ZFOU9UbUZqYkZObFkzSmxkRUp2ZUZCaGNtRnRjeXhjYmlBZ0lDQlVUMDVOYm1WdGIyNXBZMWR2Y21SelVHRnlZVzF6TEZ4dUlDQWdJRlJQVGsxdVpXMXZibWxqUm5KdmJWSmhibVJ2YlZCaGNtRnRjeXhjYmlBZ0lDQlVUMDVOYm1WdGIyNXBZMFp5YjIxRmJuUnliM0I1VUdGeVlXMXpMRnh1SUNBZ0lGUlBUazF1WlcxdmJtbGpTWE5XWVd4cFpGQmhjbUZ0Y3l4Y2JpQWdJQ0JVVDA1TmJtVnRiMjVwWTBSbGNtbDJaVk5wWjI1TFpYbHpVR0Z5WVcxekxGeHVJQ0FnSUZSUFRrTnllWEIwYnl4Y2JpQWdJQ0JVVDA1SVJFdGxlVVp5YjIxTmJtVnRiMjVwWTFCaGNtRnRjeXhjYmlBZ0lDQlVUMDVEY25sd2RHOUNiM2hRWVhKaGJYTXNYRzRnSUNBZ1ZFOU9RM0o1Y0hSdlFtOTRMQ0JVVDA1RGNubHdkRzlEYUdGRGFHRXlNRkJoY21GdGN5d2dWRTlPUTNKNWNIUnZRMmhoUTJoaE1qQlNaWE4xYkhRc1hHNTlJR1p5YjIwZ0p5NHVMeTR1TDNSNWNHVnpKenRjYm1sdGNHOXlkQ0I3SUZSUFRrTnNhV1Z1ZEVWeWNtOXlJSDBnWm5KdmJTQW5MaTR2VkU5T1EyeHBaVzUwUlhKeWIzSW5PMXh1YVcxd2IzSjBJSFI1Y0dVZ2V5QlVUMDVOYjJSMWJHVkRiMjUwWlhoMElIMGdabkp2YlNBbkxpNHZWRTlPVFc5a2RXeGxKenRjYm1sdGNHOXlkQ0I3SUZSUFRrMXZaSFZzWlNCOUlHWnliMjBnSnk0dUwxUlBUazF2WkhWc1pTYzdYRzVwYlhCdmNuUWdleUJEYjNKbFEzSjVjSFJ2UW05NElIMGdabkp2YlNBbkxpOWpjbmx3ZEc4dFltOTRKenRjYmx4dVpYaHdiM0owSUdOdmJuTjBJRlJQVGs5MWRIQjFkRVZ1WTI5a2FXNW5JRDBnZTF4dUlDQWdJRlJsZUhRNklDZFVaWGgwSnl4Y2JpQWdJQ0JJWlhnNklDZElaWGduTEZ4dUlDQWdJRWhsZUZWd2NHVnlZMkZ6WlRvZ0owaGxlRlZ3Y0dWeVkyRnpaU2NzWEc0Z0lDQWdRbUZ6WlRZME9pQW5RbUZ6WlRZMEp5eGNibjA3WEc1Y2JseHVaWGh3YjNKMElHTnZibk4wSUZSUFRrMXVaVzF2Ym1salJHbGpkR2x2Ym1GeWVTQTlJSHRjYmlBZ0lDQlVUMDQ2SURBc1hHNGdJQ0FnUlU1SFRFbFRTRG9nTVN4Y2JpQWdJQ0JEU0VsT1JWTkZYMU5KVFZCTVNVWkpSVVE2SURJc1hHNGdJQ0FnUTBoSlRrVlRSVjlVVWtGRVNWUkpUMDVCVERvZ015eGNiaUFnSUNCR1VrVk9RMGc2SURRc1hHNGdJQ0FnU1ZSQlRFbEJUam9nTlN4Y2JpQWdJQ0JLUVZCQlRrVlRSVG9nTml4Y2JpQWdJQ0JMVDFKRlFVNDZJRGNzWEc0Z0lDQWdVMUJCVGtsVFNEb2dPQ3hjYm4wN1hHNWNibHh1Wm5WdVkzUnBiMjRnWm1sNFNXNXdkWFJOWlhOellXZGxLRzFsYzNOaFoyVTZJRlJQVGtsdWNIVjBUV1Z6YzJGblpTazZJRlJQVGtsdWNIVjBUV1Z6YzJGblpTQjdYRzRnSUNBZ2NtVjBkWEp1SUcxbGMzTmhaMlV1ZEdWNGRGeHVJQ0FnSUNBZ0lDQS9JSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHSmhjMlUyTkRvZ1FuVm1abVZ5TG1aeWIyMG9iV1Z6YzJGblpTNTBaWGgwTENBbmRYUm1PQ2NwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTG5SdlUzUnlhVzVuS0NkaVlYTmxOalFuS1N4Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQTZJRzFsYzNOaFoyVTdYRzU5WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRlJQVGtOeWVYQjBiMDF2WkhWc1pTQmxlSFJsYm1SeklGUlBUazF2WkhWc1pTQnBiWEJzWlcxbGJuUnpJRlJQVGtOeWVYQjBieUI3WEc0Z0lDQWdZM0o1Y0hSdlFtOTRaWE02SUUxaGNEeHpkSEpwYm1jc0lFTnZjbVZEY25sd2RHOUNiM2crTzF4dVhHNGdJQ0FnWTI5dWMzUnlkV04wYjNJb1kyOXVkR1Y0ZERvZ1ZFOU9UVzlrZFd4bFEyOXVkR1Y0ZENrZ2UxeHVJQ0FnSUNBZ0lDQnpkWEJsY2loamIyNTBaWGgwS1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVqY25sd2RHOUNiM2hsY3lBOUlHNWxkeUJOWVhBb0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNCblpYUkRjbmx3ZEc5Q2IzZ29jR0Z5WVcxek9pQlVUMDVEY25sd2RHOUNiM2hRWVhKaGJYTXBPaUJRY205dGFYTmxQRlJQVGtOeWVYQjBiMEp2ZUQ0Z2UxeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCclpYa2dQU0J3WVhKaGJYTXVaVzVqY25sd2RHVmtVMlZsWkZCb2NtRnpaUzUwWlhoMFhHNGdJQ0FnSUNBZ0lDQWdJQ0I4ZkNCd1lYSmhiWE11Wlc1amNubHdkR1ZrVTJWbFpGQm9jbUZ6WlM1aVlYTmxOalJjYmlBZ0lDQWdJQ0FnSUNBZ0lIeDhJSEJoY21GdGN5NWxibU55ZVhCMFpXUlRaV1ZrVUdoeVlYTmxMbWhsZUZ4dUlDQWdJQ0FnSUNBZ0lDQWdmSHdnSnljN1hHNGdJQ0FnSUNBZ0lHbG1JQ2doYTJWNUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFISnZkeUJVVDA1RGJHbGxiblJGY25KdmNpNXBiblpoYkdsa1EzSjVjSFJ2UW05NFVHRnlZVzF6S0hCaGNtRnRjeTVsYm1OeWVYQjBaV1JUWldWa1VHaHlZWE5sS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnNaWFFnWTNKNWNIUnZRbTk0SUQwZ2RHaHBjeTVqY25sd2RHOUNiM2hsY3k1blpYUW9hMlY1S1R0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0ZqY25sd2RHOUNiM2dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR055ZVhCMGIwSnZlQ0E5SUc1bGR5QkRiM0psUTNKNWNIUnZRbTk0S0hSb2FYTXNJSEJoY21GdGN5azdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbU55ZVhCMGIwSnZlR1Z6TG5ObGRDaHJaWGtzSUdOeWVYQjBiMEp2ZUNrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlGQnliMjFwYzJVdWNtVnpiMngyWlNoamNubHdkRzlDYjNncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJR1poWTNSdmNtbDZaU2hqYUdGc2JHVnVaMlZJWlhnNklITjBjbWx1WnlrNklGQnliMjFwYzJVOFZFOU9SbUZqZEc5eWFYcGxVbVZ6ZFd4MFBpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KbGNYVmxjM1JEYjNKbEtDZGpjbmx3ZEc4dWJXRjBhQzVtWVdOMGIzSnBlbVVuTENCamFHRnNiR1Z1WjJWSVpYZ3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUcxdlpIVnNZWEpRYjNkbGNpaGNiaUFnSUNBZ0lDQWdZbUZ6WlVobGVEb2djM1J5YVc1bkxGeHVJQ0FnSUNBZ0lDQmxlSEJ2Ym1WdWRFaGxlRG9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0J0YjJSMWJIVnpTR1Y0T2lCemRISnBibWNzWEc0Z0lDQWdLVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnhkV1Z6ZEVOdmNtVW9KMk55ZVhCMGJ5NXRZWFJvTG0xdlpIVnNZWEpRYjNkbGNpY3NJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHSmhjMlU2SUdKaGMyVklaWGdzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmxlSEJ2Ym1WdWREb2daWGh3YjI1bGJuUklaWGdzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnRiMlIxYkhWek9pQnRiMlIxYkhWelNHVjRMRnh1SUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QnlZVzVrYjIxSFpXNWxjbUYwWlVKNWRHVnpLRnh1SUNBZ0lDQWdJQ0JzWlc1bmRHZzZJRzUxYldKbGNpeGNiaUFnSUNBZ0lDQWdiM1YwY0hWMFJXNWpiMlJwYm1jNklGUlBUazkxZEhCMWRFVnVZMjlrYVc1blZIbHdaU0E5SUZSUFRrOTFkSEIxZEVWdVkyOWthVzVuTGtobGVDeGNiaUFnSUNBcE9pQlFjbTl0YVhObFBITjBjbWx1Wno0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNnblkzSjVjSFJ2TG5KaGJtUnZiUzVuWlc1bGNtRjBaVUo1ZEdWekp5d2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JHVnVaM1JvTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdiM1YwY0hWMFJXNWpiMlJwYm1jc1hHNGdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lIMWNibHh1WEc0Z0lDQWdZWE41Ym1NZ1pXUXlOVFV4T1V0bGVYQmhhWElvS1RvZ1VISnZiV2x6WlR4VVQwNUxaWGxRWVdseVJHRjBZVDRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaWEYxWlhOMFEyOXlaU2duWTNKNWNIUnZMbVZrTWpVMU1Ua3VhMlY1Y0dGcGNpY3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUhCMVlteHBZMHRsZVZSdlUzUnlhVzVuS0d0bGVUb2djM1J5YVc1bktUb2dVSEp2YldselpUeHpkSEpwYm1jK0lIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WeGRXVnpkRU52Y21Vb0oyTnllWEIwYnk1MGIyNWZjSFZpYkdsalgydGxlVjl6ZEhKcGJtY25MQ0JyWlhrcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJSE5vWVRVeE1paGNiaUFnSUNBZ0lDQWdiV1Z6YzJGblpUb2dWRTlPU1c1d2RYUk5aWE56WVdkbExGeHVJQ0FnSUNBZ0lDQnZkWFJ3ZFhSRmJtTnZaR2x1WnpvZ1ZFOU9UM1YwY0hWMFJXNWpiMlJwYm1kVWVYQmxJRDBnVkU5T1QzVjBjSFYwUlc1amIyUnBibWN1U0dWNExGeHVJQ0FnSUNrNklGQnliMjFwYzJVOGMzUnlhVzVuUGlCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsY1hWbGMzUkRiM0psS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdKMk55ZVhCMGJ5NXphR0UxTVRJbkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUcxbGMzTmhaMlU2SUdacGVFbHVjSFYwVFdWemMyRm5aU2h0WlhOellXZGxLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J2ZFhSd2RYUkZibU52WkdsdVp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUgwc1hHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nYzJoaE1qVTJLRnh1SUNBZ0lDQWdJQ0J0WlhOellXZGxPaUJVVDA1SmJuQjFkRTFsYzNOaFoyVXNYRzRnSUNBZ0lDQWdJRzkxZEhCMWRFVnVZMjlrYVc1bk9pQlVUMDVQZFhSd2RYUkZibU52WkdsdVoxUjVjR1VnUFNCVVQwNVBkWFJ3ZFhSRmJtTnZaR2x1Wnk1SVpYZ3NYRzRnSUNBZ0tUb2dVSEp2YldselpUeHpkSEpwYm1jK0lIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WeGRXVnpkRU52Y21Vb1hHNGdJQ0FnSUNBZ0lDQWdJQ0FuWTNKNWNIUnZMbk5vWVRJMU5pY3NYRzRnSUNBZ0lDQWdJQ0FnSUNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXVnpjMkZuWlRvZ1ptbDRTVzV3ZFhSTlpYTnpZV2RsS0cxbGMzTmhaMlVwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUc5MWRIQjFkRVZ1WTI5a2FXNW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTeGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCelkzSjVjSFFvY0dGeVlXMXpPaUJVVDA1VFkzSjVjSFJRWVhKaGJYTXBPaUJRY205dGFYTmxQSE4wY21sdVp6NGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQm1hWGhsWkRvZ1ZFOU9VMk55ZVhCMFVHRnlZVzF6SUQwZ0tFOWlhbVZqZEM1aGMzTnBaMjRvZTMwc0lIQmhjbUZ0Y3lrNklHRnVlU2s3WEc0Z0lDQWdJQ0FnSUdacGVHVmtMbkJoYzNOM2IzSmtJRDBnWm1sNFNXNXdkWFJOWlhOellXZGxLSEJoY21GdGN5NXdZWE56ZDI5eVpDazdYRzRnSUNBZ0lDQWdJR1pwZUdWa0xuTmhiSFFnUFNCbWFYaEpibkIxZEUxbGMzTmhaMlVvY0dGeVlXMXpMbk5oYkhRcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNnblkzSjVjSFJ2TG5OamNubHdkQ2NzSUdacGVHVmtLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCdVlXTnNRbTk0UzJWNWNHRnBjaWdwT2lCUWNtOXRhWE5sUEZSUFRrdGxlVkJoYVhKRVlYUmhQaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSmxjWFZsYzNSRGIzSmxLQ2RqY25sd2RHOHVibUZqYkM1aWIzZ3VhMlY1Y0dGcGNpY3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUc1aFkyeENiM2hMWlhsd1lXbHlSbkp2YlZObFkzSmxkRXRsZVNoelpXTnlaWFJMWlhrNklITjBjbWx1WnlrNklGQnliMjFwYzJVOFZFOU9TMlY1VUdGcGNrUmhkR0UrSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZ4ZFdWemRFTnZjbVVvSjJOeWVYQjBieTV1WVdOc0xtSnZlQzVyWlhsd1lXbHlMbVp5YjIxVFpXTnlaWFJMWlhrbkxDQnpaV055WlhSTFpYa3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUc1aFkyeFRhV2R1UzJWNWNHRnBjaWdwT2lCUWNtOXRhWE5sUEZSUFRrdGxlVkJoYVhKRVlYUmhQaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSmxjWFZsYzNSRGIzSmxLQ2RqY25sd2RHOHVibUZqYkM1emFXZHVMbXRsZVhCaGFYSW5LVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCdVlXTnNVMmxuYmt0bGVYQmhhWEpHY205dFUyVmpjbVYwUzJWNUtITmxZM0psZEV0bGVUb2djM1J5YVc1bktUb2dVSEp2YldselpUeFVUMDVMWlhsUVlXbHlSR0YwWVQ0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNnblkzSjVjSFJ2TG01aFkyd3VjMmxuYmk1clpYbHdZV2x5TG1aeWIyMVRaV055WlhSTFpYa25MQ0J6WldOeVpYUkxaWGtwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklHNWhZMnhDYjNnb2NHRnlZVzF6T2lCVVQwNU9ZV05zUW05NFVHRnlZVzF6S1RvZ1VISnZiV2x6WlR4emRISnBibWMrSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWm1sNFpXUTZJRlJQVGs1aFkyeENiM2hRWVhKaGJYTWdQU0FvVDJKcVpXTjBMbUZ6YzJsbmJpaDdmU3dnY0dGeVlXMXpLVG9nWVc1NUtUdGNiaUFnSUNBZ0lDQWdabWw0WldRdWJXVnpjMkZuWlNBOUlHWnBlRWx1Y0hWMFRXVnpjMkZuWlNod1lYSmhiWE11YldWemMyRm5aU2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSmxjWFZsYzNSRGIzSmxLQ2RqY25sd2RHOHVibUZqYkM1aWIzZ25MQ0JtYVhobFpDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nYm1GamJFSnZlRTl3Wlc0b2NHRnlZVzF6T2lCVVQwNU9ZV05zUW05NFVHRnlZVzF6S1RvZ1VISnZiV2x6WlR4emRISnBibWMrSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWm1sNFpXUTZJRlJQVGs1aFkyeENiM2hRWVhKaGJYTWdQU0FvVDJKcVpXTjBMbUZ6YzJsbmJpaDdmU3dnY0dGeVlXMXpLVG9nWVc1NUtUdGNiaUFnSUNBZ0lDQWdabWw0WldRdWJXVnpjMkZuWlNBOUlHWnBlRWx1Y0hWMFRXVnpjMkZuWlNod1lYSmhiWE11YldWemMyRm5aU2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSmxjWFZsYzNSRGIzSmxLQ2RqY25sd2RHOHVibUZqYkM1aWIzZ3ViM0JsYmljc0lHWnBlR1ZrS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QnVZV05zVTJWamNtVjBRbTk0S0hCaGNtRnRjem9nVkU5T1RtRmpiRk5sWTNKbGRFSnZlRkJoY21GdGN5azZJRkJ5YjIxcGMyVThjM1J5YVc1blBpQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElHWnBlR1ZrT2lCVVQwNU9ZV05zUW05NFVHRnlZVzF6SUQwZ0tFOWlhbVZqZEM1aGMzTnBaMjRvZTMwc0lIQmhjbUZ0Y3lrNklHRnVlU2s3WEc0Z0lDQWdJQ0FnSUdacGVHVmtMbTFsYzNOaFoyVWdQU0JtYVhoSmJuQjFkRTFsYzNOaFoyVW9jR0Z5WVcxekxtMWxjM05oWjJVcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNnblkzSjVjSFJ2TG01aFkyd3VjMlZqY21WMExtSnZlQ2NzSUdacGVHVmtLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCdVlXTnNVMlZqY21WMFFtOTRUM0JsYmlod1lYSmhiWE02SUZSUFRrNWhZMnhUWldOeVpYUkNiM2hRWVhKaGJYTXBPaUJRY205dGFYTmxQSE4wY21sdVp6NGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQm1hWGhsWkRvZ1ZFOU9UbUZqYkVKdmVGQmhjbUZ0Y3lBOUlDaFBZbXBsWTNRdVlYTnphV2R1S0h0OUxDQndZWEpoYlhNcE9pQmhibmtwTzF4dUlDQWdJQ0FnSUNCbWFYaGxaQzV0WlhOellXZGxJRDBnWm1sNFNXNXdkWFJOWlhOellXZGxLSEJoY21GdGN5NXRaWE56WVdkbEtUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WeGRXVnpkRU52Y21Vb0oyTnllWEIwYnk1dVlXTnNMbk5sWTNKbGRDNWliM2d1YjNCbGJpY3NJR1pwZUdWa0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUJ1WVdOc1UybG5iaWhjYmlBZ0lDQWdJQ0FnYldWemMyRm5aVG9nVkU5T1NXNXdkWFJOWlhOellXZGxMRnh1SUNBZ0lDQWdJQ0JyWlhrNklITjBjbWx1Wnl4Y2JpQWdJQ0FnSUNBZ2IzVjBjSFYwUlc1amIyUnBibWM2SUZSUFRrOTFkSEIxZEVWdVkyOWthVzVuVkhsd1pTQTlJRlJQVGs5MWRIQjFkRVZ1WTI5a2FXNW5Ma2hsZUN4Y2JpQWdJQ0FwT2lCUWNtOXRhWE5sUEhOMGNtbHVaejRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaWEYxWlhOMFEyOXlaU2duWTNKNWNIUnZMbTVoWTJ3dWMybG5iaWNzSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzFsYzNOaFoyVTZJR1pwZUVsdWNIVjBUV1Z6YzJGblpTaHRaWE56WVdkbEtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUd0bGVTeGNiaUFnSUNBZ0lDQWdJQ0FnSUc5MWRIQjFkRVZ1WTI5a2FXNW5MRnh1SUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QnVZV05zVTJsbmJrOXdaVzRvWEc0Z0lDQWdJQ0FnSUcxbGMzTmhaMlU2SUZSUFRrbHVjSFYwVFdWemMyRm5aU3hjYmlBZ0lDQWdJQ0FnYTJWNU9pQnpkSEpwYm1jc1hHNGdJQ0FnSUNBZ0lHOTFkSEIxZEVWdVkyOWthVzVuT2lCVVQwNVBkWFJ3ZFhSRmJtTnZaR2x1WjFSNWNHVWdQU0JVVDA1UGRYUndkWFJGYm1OdlpHbHVaeTVJWlhnc1hHNGdJQ0FnS1RvZ1VISnZiV2x6WlR4emRISnBibWMrSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZ4ZFdWemRFTnZjbVVvSjJOeWVYQjBieTV1WVdOc0xuTnBaMjR1YjNCbGJpY3NJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJVNklHWnBlRWx1Y0hWMFRXVnpjMkZuWlNodFpYTnpZV2RsS1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJR3RsZVN4Y2JpQWdJQ0FnSUNBZ0lDQWdJRzkxZEhCMWRFVnVZMjlrYVc1bkxGeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCdVlXTnNVMmxuYmtSbGRHRmphR1ZrS0Z4dUlDQWdJQ0FnSUNCdFpYTnpZV2RsT2lCVVQwNUpibkIxZEUxbGMzTmhaMlVzWEc0Z0lDQWdJQ0FnSUd0bGVUb2djM1J5YVc1bkxGeHVJQ0FnSUNBZ0lDQnZkWFJ3ZFhSRmJtTnZaR2x1WnpvZ1ZFOU9UM1YwY0hWMFJXNWpiMlJwYm1kVWVYQmxJRDBnVkU5T1QzVjBjSFYwUlc1amIyUnBibWN1U0dWNExGeHVJQ0FnSUNrNklGQnliMjFwYzJVOGMzUnlhVzVuUGlCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsY1hWbGMzUkRiM0psS0NkamNubHdkRzh1Ym1GamJDNXphV2R1TG1SbGRHRmphR1ZrSnl3Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYldWemMyRm5aVG9nWm1sNFNXNXdkWFJOWlhOellXZGxLRzFsYzNOaFoyVXBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2EyVjVMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2IzVjBjSFYwUlc1amIyUnBibWNzWEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklFMXVaVzF2Ym1salhHNWNiaUFnSUNCaGMzbHVZeUJ0Ym1WdGIyNXBZMWR2Y21SektIQmhjbUZ0Y3o4NklGUlBUazF1WlcxdmJtbGpWMjl5WkhOUVlYSmhiWE1wT2lCUWNtOXRhWE5sUEhOMGNtbHVaejRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaWEYxWlhOMFEyOXlaU2duWTNKNWNIUnZMbTF1WlcxdmJtbGpMbmR2Y21Sekp5d2djR0Z5WVcxeklIeDhJSHQ5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QnRibVZ0YjI1cFkwWnliMjFTWVc1a2IyMG9jR0Z5WVcxelB6b2dWRTlPVFc1bGJXOXVhV05HY205dFVtRnVaRzl0VUdGeVlXMXpLVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnhkV1Z6ZEVOdmNtVW9KMk55ZVhCMGJ5NXRibVZ0YjI1cFl5NW1jbTl0TG5KaGJtUnZiU2NzSUhCaGNtRnRjeUI4ZkNCN2ZTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nYlc1bGJXOXVhV05HY205dFJXNTBjbTl3ZVNod1lYSmhiWE02SUZSUFRrMXVaVzF2Ym1salJuSnZiVVZ1ZEhKdmNIbFFZWEpoYlhNcE9pQlFjbTl0YVhObFBITjBjbWx1Wno0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNoY2JpQWdJQ0FnSUNBZ0lDQWdJQ2RqY25sd2RHOHViVzVsYlc5dWFXTXVabkp2YlM1bGJuUnliM0I1Snl4Y2JpQWdJQ0FnSUNBZ0lDQWdJSEJoY21GdGN5eGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCdGJtVnRiMjVwWTBselZtRnNhV1FvY0dGeVlXMXpPaUJVVDA1TmJtVnRiMjVwWTBselZtRnNhV1JRWVhKaGJYTXBPaUJRY205dGFYTmxQR0p2YjJ4bFlXNCtJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnhkV1Z6ZEVOdmNtVW9KMk55ZVhCMGJ5NXRibVZ0YjI1cFl5NTJaWEpwWm5rbkxDQndZWEpoYlhNcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJRzF1WlcxdmJtbGpSR1Z5YVhabFUybG5ia3RsZVhNb2NHRnlZVzF6T2lCVVQwNU5ibVZ0YjI1cFkwUmxjbWwyWlZOcFoyNUxaWGx6VUdGeVlXMXpLVG9nVUhKdmJXbHpaVHhVVDA1TFpYbFFZV2x5UkdGMFlUNGdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpYRjFaWE4wUTI5eVpTZ25ZM0o1Y0hSdkxtMXVaVzF2Ym1sakxtUmxjbWwyWlM1emFXZHVMbXRsZVhNbkxDQndZWEpoYlhNcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklFaEVTMlY1YzF4dVhHNGdJQ0FnWVhONWJtTWdhR1JyWlhsWVVISjJSbkp2YlUxdVpXMXZibWxqS0hCaGNtRnRjem9nVkU5T1NFUkxaWGxHY205dFRXNWxiVzl1YVdOUVlYSmhiWE1wT2lCUWNtOXRhWE5sUEhOMGNtbHVaejRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaWEYxWlhOMFEyOXlaU2duWTNKNWNIUnZMbWhrYTJWNUxuaHdjbll1Wm5KdmJTNXRibVZ0YjI1cFl5Y3NJSEJoY21GdGN5azdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1lYTjVibU1nYUdSclpYbFlVSEoyUkdWeWFYWmxLRnh1SUNBZ0lDQWdJQ0J6WlhKcFlXeHBlbVZrT2lCemRISnBibWNzWEc0Z0lDQWdJQ0FnSUdsdVpHVjRPaUJ1ZFcxaVpYSXNYRzRnSUNBZ0lDQWdJR2hoY21SbGJtVmtPaUJpYjI5c1pXRnVMRnh1SUNBZ0lDQWdJQ0JqYjIxd2JHbGhiblE2SUdKdmIyeGxZVzRzWEc0Z0lDQWdLVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnhkV1Z6ZEVOdmNtVW9YRzRnSUNBZ0lDQWdJQ0FnSUNBblkzSjVjSFJ2TG1oa2EyVjVMbmh3Y25ZdVpHVnlhWFpsSnl4Y2JpQWdJQ0FnSUNBZ0lDQWdJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J6WlhKcFlXeHBlbVZrTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsdVpHVjRMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2hoY21SbGJtVmtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052YlhCc2FXRnVkQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIMHNYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ2FHUnJaWGxZVUhKMlJHVnlhWFpsVUdGMGFDaGNiaUFnSUNBZ0lDQWdjMlZ5YVdGc2FYcGxaRG9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0J3WVhSb09pQnpkSEpwYm1jc1hHNGdJQ0FnSUNBZ0lHTnZiWEJzYVdGdWREb2dZbTl2YkdWaGJpeGNiaUFnSUNBcE9pQlFjbTl0YVhObFBITjBjbWx1Wno0Z2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBRMjl5WlNoY2JpQWdJQ0FnSUNBZ0lDQWdJQ2RqY25sd2RHOHVhR1JyWlhrdWVIQnlkaTVrWlhKcGRtVXVjR0YwYUNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWeWFXRnNhWHBsWkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd1lYUm9MRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052YlhCc2FXRnVkQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIMHNYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ2FHUnJaWGxZVUhKMlUyVmpjbVYwS0hObGNtbGhiR2w2WldRNklITjBjbWx1WnlrNklGQnliMjFwYzJVOGMzUnlhVzVuUGlCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsY1hWbGMzUkRiM0psS0NkamNubHdkRzh1YUdSclpYa3VlSEJ5ZGk1elpXTnlaWFFuTENCN0lITmxjbWxoYkdsNlpXUWdmU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ2FHUnJaWGxZVUhKMlVIVmliR2xqS0hObGNtbGhiR2w2WldRNklITjBjbWx1WnlrNklGQnliMjFwYzJVOGMzUnlhVzVuUGlCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsY1hWbGMzUkRiM0psS0NkamNubHdkRzh1YUdSclpYa3VlSEJ5ZGk1d2RXSnNhV01uTENCN0lITmxjbWxoYkdsNlpXUWdmU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnUlc1amNubHdkR2x2Ymx4dVhHNGdJQ0FnWTJoaFkyaGhNakFvY0dGeVlXMXpPaUJVVDA1RGNubHdkRzlEYUdGRGFHRXlNRkJoY21GdGN5azZJRkJ5YjIxcGMyVThWRTlPUTNKNWNIUnZRMmhoUTJoaE1qQlNaWE4xYkhRK0lIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WeGRXVnpkRU52Y21Vb0oyTnllWEIwYnk1amFHRmphR0V5TUNjc0lIQmhjbUZ0Y3lrN1hHNGdJQ0FnZlZ4dWZWeHVYRzVVVDA1RGNubHdkRzlOYjJSMWJHVXViVzlrZFd4bFRtRnRaU0E5SUNkVVQwNURjbmx3ZEc5TmIyUjFiR1VuTzF4dUlsMTkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5NQVhfVElNRU9VVCA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hcG9sbG9DYWNoZUlubWVtb3J5ID0gcmVxdWlyZShcImFwb2xsby1jYWNoZS1pbm1lbW9yeVwiKTtcblxudmFyIF9hcG9sbG9DbGllbnQgPSByZXF1aXJlKFwiYXBvbGxvLWNsaWVudFwiKTtcblxudmFyIF9hcG9sbG9MaW5rID0gcmVxdWlyZShcImFwb2xsby1saW5rXCIpO1xuXG52YXIgX2Fwb2xsb0xpbmtIdHRwID0gcmVxdWlyZShcImFwb2xsby1saW5rLWh0dHBcIik7XG5cbnZhciBfYXBvbGxvTGlua1dzID0gcmVxdWlyZShcImFwb2xsby1saW5rLXdzXCIpO1xuXG52YXIgX2Fwb2xsb1V0aWxpdGllcyA9IHJlcXVpcmUoXCJhcG9sbG8tdXRpbGl0aWVzXCIpO1xuXG52YXIgX2dyYXBocWxUYWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJncmFwaHFsLXRhZ1wiKSk7XG5cbnZhciBfc3Vic2NyaXB0aW9uc1RyYW5zcG9ydFdzID0gcmVxdWlyZShcInN1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzXCIpO1xuXG52YXIgX2Fwb2xsb0xpbmtDb250ZXh0ID0gcmVxdWlyZShcImFwb2xsby1saW5rLWNvbnRleHRcIik7XG5cbnZhciBfb3BlbnRyYWNpbmcgPSByZXF1aXJlKFwib3BlbnRyYWNpbmdcIik7XG5cbnZhciBfVE9OQ2xpZW50ID0gcmVxdWlyZShcIi4uL1RPTkNsaWVudFwiKTtcblxudmFyIF9UT05DbGllbnRFcnJvciA9IHJlcXVpcmUoXCIuLi9UT05DbGllbnRFcnJvclwiKTtcblxudmFyIF9UT05Nb2R1bGUyID0gcmVxdWlyZShcIi4uL1RPTk1vZHVsZVwiKTtcblxudmFyIF9UT05Db25maWdNb2R1bGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9UT05Db25maWdNb2R1bGVcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gS2VlcC1hbGl2ZSB0aW1lb3V0IHVzZWQgdG8gc3VwcG9ydCBrZWVwLWFsaXZlIGNvbm5lY3Rpb24gY2hlY2tpbmc6XG4vLyAtIEV2ZXJ5IDEgbWludXRlIHNlcnZlciBzZW5kcyBHUUxfQ09OTkVDVElPTl9LRUVQX0FMSVZFIG1lc3NhZ2UuXG4vLyAtIEV2ZXJ5IDIgbWludXRlcyBjbGllbnQgY2hlY2tzIHRoYXQgR1FMX0NPTk5FQ1RJT05fS0VFUF9BTElWRSBtZXNzYWdlIHdhcyByZWNlaXZlZFxuLy8gICB3aXRoaW4gbGFzdCAyIG1pbnV0ZXMuXG4vLyAtIElmIGNsaWVudCBoYWRuJ3QgcmVjZWl2ZWQga2VlcCBhbGl2ZSBtZXNzYWdlIGR1cmluZyBsYXN0IDIgbWludXRlc1xuLy8gICBpdCBjbG9zZXMgY29ubmVjdGlvbiBhbmQgZ29lcyB0byByZWNvbm5lY3QuXG52YXIgS0VFUF9BTElWRV9USU1FT1VUID0gMiAqIDYwMDAwO1xudmFyIE1BWF9USU1FT1VUID0gMjE0NzQ4MzY0NztcbmV4cG9ydHMuTUFYX1RJTUVPVVQgPSBNQVhfVElNRU9VVDtcblxuZnVuY3Rpb24gcmVzb2x2ZVBhcmFtcyhhcmdzLCByZXF1aXJlZFBhcmFtTmFtZSwgcmVzb2x2ZUFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MubGVuZ3RoID09PSAxICYmIHJlcXVpcmVkUGFyYW1OYW1lIGluIGFyZ3NbMF0gPyBhcmdzWzBdIDogcmVzb2x2ZUFyZ3MoKTtcbn1cblxudmFyIE11bHRpY2FzdFByb21pc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNdWx0aWNhc3RQcm9taXNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdWx0aWNhc3RQcm9taXNlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxpc3RlbmVyc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25Db21wbGV0ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE11bHRpY2FzdFByb21pc2UsIFt7XG4gICAga2V5OiBcImxpc3RlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSB7XG4gICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7fSxcbiAgICAgICAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QoKSB7fVxuICAgICAgfTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGlzdGVuZXIucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGxpc3RlbmVyLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5yZXNvbHZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVqZWN0KGVycm9yKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIucmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZShjb21wbGV0ZUxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE11bHRpY2FzdFByb21pc2U7XG59KCk7XG5cbmZ1bmN0aW9uIHZlcnNpb25Ub051bWJlcihzKSB7XG4gIHZhciBwYXJ0cyA9IFwiXCIuY29uY2F0KHMgfHwgJycpLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE51bWJlcih4KTtcbiAgfSkuc2xpY2UoMCwgMyk7XG5cbiAgd2hpbGUgKHBhcnRzLmxlbmd0aCA8IDMpIHtcbiAgICBwYXJ0cy5wdXNoKDApO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzWzBdICogMTAwMDAwMCArIHBhcnRzWzFdICogMTAwMCArIHBhcnRzWzJdO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2VydmVySW5mbyh2ZXJzaW9uU3RyaW5nKSB7XG4gIHZhciB2ZXJzaW9uID0gdmVyc2lvblRvTnVtYmVyKHZlcnNpb25TdHJpbmcgfHwgJzAuMjQuNCcpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgc3VwcG9ydHNPcGVyYXRpb25JZDogdmVyc2lvbiA+IDI0MDA0LFxuICAgIHN1cHBvcnRzQWdncmVnYXRpb25zOiB2ZXJzaW9uID49IDI1MDAwLFxuICAgIHN1cHBvcnRzVGltZTogdmVyc2lvbiA+PSAyNjAwMyxcbiAgICB0aW1lRGVsdGE6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2goZmV0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcXVlcnlUaW1lb3V0ID0gb3B0aW9ucy5xdWVyeVRpbWVvdXQ7XG4gICAgICB2YXIgZmV0Y2hPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgaWYgKHF1ZXJ5VGltZW91dCkge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IGdsb2JhbC5BYm9ydENvbnRyb2xsZXIgPyBuZXcgZ2xvYmFsLkFib3J0Q29udHJvbGxlcigpIDogbnVsbDtcblxuICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgIGZldGNoT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yLnF1ZXJ5Rm9yY2libHlBYm9ydGVkKF9UT05DbGllbnRFcnJvci5lbXB0eVRPTkVycm9yRGF0YSkpO1xuXG4gICAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHF1ZXJ5VGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIGZldGNoKGlucHV0LCBmZXRjaE9wdGlvbnMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIFRPTlF1ZXJpZXNNb2R1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UT05Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKFRPTlF1ZXJpZXNNb2R1bGUsIF9UT05Nb2R1bGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVE9OUXVlcmllc01vZHVsZSk7XG5cbiAgZnVuY3Rpb24gVE9OUXVlcmllc01vZHVsZShjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRPTlF1ZXJpZXNNb2R1bGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0cmFuc2FjdGlvbnNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJtZXNzYWdlc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImJsb2Nrc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFjY291bnRzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiYmxvY2tzX3NpZ25hdHVyZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjb25maWdcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJncmFwaHFsQ2xpZW50Q3JlYXRpb25cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJncmFwaHFsQ2xpZW50XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZ3JhcGhxbENsaWVudENvbmZpZ1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIndzTGlua1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImh0dHBMaW5rXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib3ZlcnJpZGVXc1VybFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9wZXJhdGlvbklkUHJlZml4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib3BlcmF0aW9uSWRTdWZmaXhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZXJ2ZXJJbmZvXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiYWN0aXZlUXVlcmllc1JlamVjdHNcIiwgdm9pZCAwKTtcblxuICAgIF90aGlzLmdyYXBocWxDbGllbnQgPSBudWxsO1xuICAgIF90aGlzLmdyYXBocWxDbGllbnRDcmVhdGlvbiA9IG51bGw7XG4gICAgX3RoaXMuZ3JhcGhxbENsaWVudENvbmZpZyA9IG51bGw7XG4gICAgX3RoaXMud3NMaW5rID0gbnVsbDtcbiAgICBfdGhpcy5odHRwTGluayA9IG51bGw7XG4gICAgX3RoaXMub3ZlcnJpZGVXc1VybCA9IG51bGw7XG4gICAgX3RoaXMub3BlcmF0aW9uSWRQcmVmaXggPSAoRGF0ZS5ub3coKSAlIDYwMDAwKS50b1N0cmluZygxNik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpICs9IDEpIHtcbiAgICAgIHZhciByYW5kb21QYXJ0ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XG4gICAgICBfdGhpcy5vcGVyYXRpb25JZFByZWZpeCA9IFwiXCIuY29uY2F0KF90aGlzLm9wZXJhdGlvbklkUHJlZml4KS5jb25jYXQocmFuZG9tUGFydCk7XG4gICAgfVxuXG4gICAgX3RoaXMub3BlcmF0aW9uSWRTdWZmaXggPSAxO1xuICAgIF90aGlzLnNlcnZlckluZm8gPSByZXNvbHZlU2VydmVySW5mbygpO1xuICAgIF90aGlzLmFjdGl2ZVF1ZXJpZXNSZWplY3RzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRPTlF1ZXJpZXNNb2R1bGUsIFt7XG4gICAga2V5OiBcInJlZ2lzdGVyUXVlcnlSZWplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJRdWVyeVJlamVjdChyZWplY3QpIHtcbiAgICAgIHRoaXMuYWN0aXZlUXVlcmllc1JlamVjdHMucHVzaChyZWplY3QpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnJlZ2lzdGVyUXVlcnlSZWplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3RlclF1ZXJ5UmVqZWN0KHJlamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5hY3RpdmVRdWVyaWVzUmVqZWN0cy5pbmRleE9mKHJlamVjdCk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUXVlcmllc1JlamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVqZWN0QWN0aXZlUXVlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWplY3RBY3RpdmVRdWVyaWVzKCkge1xuICAgICAgdmFyIHJlamVjdHMgPSB0aGlzLmFjdGl2ZVF1ZXJpZXNSZWplY3RzO1xuICAgICAgdGhpcy5hY3RpdmVRdWVyaWVzUmVqZWN0cyA9IFtdO1xuXG4gICAgICB2YXIgZXJyID0gX1RPTkNsaWVudEVycm9yLlRPTkNsaWVudEVycm9yLnF1ZXJ5Rm9yY2libHlBYm9ydGVkKHt9KTtcblxuICAgICAgcmVqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldHVwID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuY29udGV4dC5nZXRNb2R1bGUoX1RPTkNvbmZpZ01vZHVsZVtcImRlZmF1bHRcIl0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gbmV3IFRPTlF1ZXJpZXNNb2R1bGVDb2xsZWN0aW9uKHRoaXMsICd0cmFuc2FjdGlvbnMnLCAnVHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbmV3IFRPTlF1ZXJpZXNNb2R1bGVDb2xsZWN0aW9uKHRoaXMsICdtZXNzYWdlcycsICdNZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja3MgPSBuZXcgVE9OUXVlcmllc01vZHVsZUNvbGxlY3Rpb24odGhpcywgJ2Jsb2NrcycsICdCbG9jaycpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWNjb3VudHMgPSBuZXcgVE9OUXVlcmllc01vZHVsZUNvbGxlY3Rpb24odGhpcywgJ2FjY291bnRzJywgJ0FjY291bnQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2Nrc19zaWduYXR1cmVzID0gbmV3IFRPTlF1ZXJpZXNNb2R1bGVDb2xsZWN0aW9uKHRoaXMsICdibG9ja3Nfc2lnbmF0dXJlcycsICdCbG9ja1NpZ25hdHVyZXMnKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICByZXR1cm4gX3NldHVwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXR1cDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRRdWVyeVVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRRdWVyeVVybCgpIHtcbiAgICAgIHZhciBfdGhpcyRncmFwaHFsQ2xpZW50Q287XG5cbiAgICAgIHJldHVybiAoKF90aGlzJGdyYXBocWxDbGllbnRDbyA9IHRoaXMuZ3JhcGhxbENsaWVudENvbmZpZykgPT09IG51bGwgfHwgX3RoaXMkZ3JhcGhxbENsaWVudENvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRncmFwaHFsQ2xpZW50Q28uaHR0cFVybCkgfHwgJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVjdFJlZGlyZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGV0ZWN0UmVkaXJlY3QgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihmZXRjaCwgc291cmNlVXJsKSB7XG4gICAgICAgIHZhciByZXNwb25zZSwgcmVzcG9uc2VUZXh0LCByZXNwb25zZUpzb24sIHNvdXJjZUxvY2F0aW9uLCByZXNwb25zZUxvY2F0aW9uO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoKHNvdXJjZVVybCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICByZXNwb25zZUpzb24gPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJJbmZvID0gcmVzb2x2ZVNlcnZlckluZm8ocmVzcG9uc2VKc29uLmRhdGEuaW5mby52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgzKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlLnJlZGlyZWN0ZWQgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UudXJsKTtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlLnJlZGlyZWN0ZWQgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICcnKTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIHNvdXJjZUxvY2F0aW9uID0gX1RPTkNvbmZpZ01vZHVsZS5VUkxQYXJ0cy5wYXJzZShzb3VyY2VVcmwpLmZpeFF1ZXJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9KS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VMb2NhdGlvbiA9IF9UT05Db25maWdNb2R1bGUuVVJMUGFydHMucGFyc2UocmVzcG9uc2UudXJsKS5maXhRdWVyeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfSkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlTG9jYXRpb24gIT09IHNvdXJjZUxvY2F0aW9uID8gcmVzcG9uc2UudXJsIDogJycpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzMsIDExXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBkZXRlY3RSZWRpcmVjdChfeCwgX3gyKSB7XG4gICAgICAgIHJldHVybiBfZGV0ZWN0UmVkaXJlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGVjdFJlZGlyZWN0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldENsaWVudENvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldENsaWVudENvbmZpZyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICB2YXIgY29uZmlnLCBjbGllbnRQbGF0Zm9ybSwgZmV0Y2gsIGdldENvbmZpZ0ZvclNlcnZlciwgX2l0ZXJhdG9yLCBfc3RlcCwgc2VydmVyLCBjbGllbnRDb25maWcsIHJlZGlyZWN0ZWQsIGh0dHBQYXJ0cztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBnZXRDb25maWdGb3JTZXJ2ZXIgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnRm9yU2VydmVyKHNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgdmFyIGh0dHBQYXJ0cyA9IF9UT05Db25maWdNb2R1bGUuVVJMUGFydHMucGFyc2Uoc2VydmVyKS5maXhQcm90b2NvbChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA9PT0gJ2h0dHA6Ly8nID8geCA6ICdodHRwczovLyc7XG4gICAgICAgICAgICAgICAgICB9KS5maXhQYXRoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh4LCBcIi9ncmFwaHFsXCIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBodHRwID0gaHR0cFBhcnRzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgd3MgPSBodHRwUGFydHMuZml4UHJvdG9jb2woZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPT09ICdodHRwOi8vJyA/ICd3czovLycgOiAnd3NzOi8vJztcbiAgICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBodHRwVXJsOiBodHRwLFxuICAgICAgICAgICAgICAgICAgICB3c1VybDogd3MsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoOiBjbGllbnRQbGF0Zm9ybS5mZXRjaCxcbiAgICAgICAgICAgICAgICAgICAgV2ViU29ja2V0OiBjbGllbnRQbGF0Zm9ybS5XZWJTb2NrZXRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgICAgIGNsaWVudFBsYXRmb3JtID0gX1RPTkNsaWVudC5UT05DbGllbnQuY2xpZW50UGxhdGZvcm07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50UGxhdGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUT04gQ2xpZW50IGRvZXMgbm90IGNvbmZpZ3VyZWQnKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgZmV0Y2ggPSBjbGllbnRQbGF0Zm9ybS5mZXRjaDtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb25maWcuZGF0YS5zZXJ2ZXJzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDc7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlcnZlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZyA9IGdldENvbmZpZ0ZvclNlcnZlcihzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3RSZWRpcmVjdChmZXRjaCwgXCJcIi5jb25jYXQoY2xpZW50Q29uZmlnLmh0dHBVcmwsIFwiP3F1ZXJ5PSU3QmluZm8lN0J2ZXJzaW9uJTdEJTdEXCIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIHJlZGlyZWN0ZWQgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdGVkICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgaHR0cFBhcnRzID0gX1RPTkNvbmZpZ01vZHVsZS5VUkxQYXJ0cy5wYXJzZShyZWRpcmVjdGVkKS5maXhRdWVyeShmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZy5odHRwVXJsID0gaHR0cFBhcnRzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBjbGllbnRDb25maWcud3NVcmwgPSBodHRwUGFydHMuZml4UHJvdG9jb2woZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPT09ICdodHRwOi8vJyA/ICd3czovLycgOiAnd3NzOi8vJztcbiAgICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgY2xpZW50Q29uZmlnKTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMTIpO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuX2VyckxvZ1ZlcmJvc2UpIGNvbnNvbGUubG9nKFwiW2dldENsaWVudENvbmZpZ10gZm9yIHNlcnZlciBcXFwiXCIuY29uY2F0KHNlcnZlciwgXCJcXFwiIGZhaWxlZFwiKSwge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogX2NvbnRleHQzLnQwLm1lc3NhZ2UgfHwgX2NvbnRleHQzLnQwLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGh0dHBfdXJsOiBjbGllbnRDb25maWcuaHR0cFVybCxcbiAgICAgICAgICAgICAgICAgICAgd3NfdXJsOiBjbGllbnRDb25maWcud3NVcmxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI3O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MSA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDcpO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoX2NvbnRleHQzLnQxKTtcblxuICAgICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMzA7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMzApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgZ2V0Q29uZmlnRm9yU2VydmVyKGNvbmZpZy5kYXRhLnNlcnZlcnNbMF0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1s3LCAyNywgMzAsIDMzXSwgWzEyLCAyMF1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4gX2dldENsaWVudENvbmZpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0Q2xpZW50Q29uZmlnO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcnZlckluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTZXJ2ZXJJbmZvID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoc3Bhbikge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGhxbENsaWVudFJlcXVpcmVkKHNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLnNlcnZlckluZm8pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJJbmZvKF94Mykge1xuICAgICAgICByZXR1cm4gX2dldFNlcnZlckluZm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFNlcnZlckluZm87XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2VydmVyVGltZURlbHRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2VydmVyVGltZURlbHRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoc3Bhbikge1xuICAgICAgICB2YXIgc2VydmVySW5mbywgY2xpZW50Q29uZmlnLCBzdGFydCwgcmVzcG9uc2UsIGVuZCwgcmVzcG9uc2VEYXRhLCBzZXJ2ZXJUaW1lO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VydmVySW5mbyhzcGFuKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc2VydmVySW5mbyA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZyA9IHRoaXMuZ3JhcGhxbENsaWVudENvbmZpZztcblxuICAgICAgICAgICAgICAgIGlmICghKGNsaWVudENvbmZpZyAmJiBzZXJ2ZXJJbmZvLnN1cHBvcnRzVGltZSAmJiBzZXJ2ZXJJbmZvLnRpbWVEZWx0YSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDU7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBEYXRlLm5vdygpOyAvLyBub2luc3BlY3Rpb24gU3BlbGxDaGVja2luZ0luc3BlY3Rpb25cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnLmZldGNoKFwiXCIuY29uY2F0KGNsaWVudENvbmZpZy5odHRwVXJsLCBcIj9xdWVyeT0lN0JpbmZvJTdCdGltZSU3RCU3RFwiKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICByZXNwb25zZURhdGEgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUaW1lID0gcmVzcG9uc2VEYXRhLmRhdGEuaW5mby50aW1lO1xuICAgICAgICAgICAgICAgIHNlcnZlckluZm8udGltZURlbHRhID0gTWF0aC5yb3VuZChzZXJ2ZXJUaW1lIC0gKHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAvIDIpKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxODtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSg1KTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLl9lcnJMb2dWZXJib3NlKSBjb25zb2xlLmxvZygnPj4+JywgX2NvbnRleHQ1LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHNlcnZlckluZm8udGltZURlbHRhIHx8IDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzUsIDE4XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXJ2ZXJUaW1lRGVsdGEoX3g0KSB7XG4gICAgICAgIHJldHVybiBfc2VydmVyVGltZURlbHRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJ2ZXJUaW1lRGVsdGE7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2VydmVyTm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2VydmVyTm93ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoc3Bhbikge1xuICAgICAgICB2YXIgdGltZURlbHRhO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyVGltZURlbHRhKHNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aW1lRGVsdGEgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBEYXRlLm5vdygpICsgdGltZURlbHRhKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2VydmVyTm93KF94NSkge1xuICAgICAgICByZXR1cm4gX3NlcnZlck5vdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VydmVyTm93O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImRyb3BTZXJ2ZXJUaW1lRGVsdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJvcFNlcnZlclRpbWVEZWx0YSgpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZlckluZm8pIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJJbmZvLnRpbWVEZWx0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlT3BlcmF0aW9uSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVPcGVyYXRpb25JZCgpIHtcbiAgICAgIHRoaXMub3BlcmF0aW9uSWRTdWZmaXggKz0gMTtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm9wZXJhdGlvbklkUHJlZml4KS5jb25jYXQodGhpcy5vcGVyYXRpb25JZFN1ZmZpeC50b1N0cmluZygxNikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5pc2hPcGVyYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmluaXNoT3BlcmF0aW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KG9wZXJhdGlvbklkcykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShvcGVyYXRpb25JZHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2ZXJJbmZvKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDcuc2VudC5zdXBwb3J0c09wZXJhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBocWxNdXRhdGlvbihcIm11dGF0aW9uIGZpbmlzaE9wZXJhdGlvbnMoJG9wZXJhdGlvbklkczogW1N0cmluZ10pIHtcXG4gICAgICAgICAgICAgICAgZmluaXNoT3BlcmF0aW9ucyhvcGVyYXRpb25JZHM6ICRvcGVyYXRpb25JZHMpXFxuICAgICAgICAgICAgfVwiLCB7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZHM6IG9wZXJhdGlvbklkc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBmaW5pc2hPcGVyYXRpb25zKF94Nikge1xuICAgICAgICByZXR1cm4gX2ZpbmlzaE9wZXJhdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmlzaE9wZXJhdGlvbnM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWNjb3VudHNDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEFjY291bnRzQ291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOChwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeSgncXVlcnl7Z2V0QWNjb3VudHNDb3VudH0nLCB1bmRlZmluZWQsIHBhcmVudFNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCByZXN1bHQuZGF0YS5nZXRBY2NvdW50c0NvdW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0QWNjb3VudHNDb3VudChfeDcpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRBY2NvdW50c0NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRBY2NvdW50c0NvdW50O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldFRyYW5zYWN0aW9uc0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0VHJhbnNhY3Rpb25zQ291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOShwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeSgncXVlcnl7Z2V0VHJhbnNhY3Rpb25zQ291bnR9JywgdW5kZWZpbmVkLCBwYXJlbnRTcGFuKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LmRhdGEuZ2V0VHJhbnNhY3Rpb25zQ291bnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbnNDb3VudChfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRUcmFuc2FjdGlvbnNDb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0VHJhbnNhY3Rpb25zQ291bnQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWNjb3VudHNUb3RhbEJhbGFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRBY2NvdW50c1RvdGFsQmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMChwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KCdxdWVyeXtnZXRBY2NvdW50c1RvdGFsQmFsYW5jZX0nLCB1bmRlZmluZWQsIHBhcmVudFNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDEwLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdC5kYXRhLmdldEFjY291bnRzVG90YWxCYWxhbmNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTAsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRBY2NvdW50c1RvdGFsQmFsYW5jZShfeDkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRBY2NvdW50c1RvdGFsQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0QWNjb3VudHNUb3RhbEJhbGFuY2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdFJlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcG9zdFJlcXVlc3RzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKHJlcXVlc3RzLCBwYXJlbnRTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEyJChfY29udGV4dDEyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5jb250ZXh0LnRyYWNlKCdxdWVyaWVzLnBvc3RSZXF1ZXN0cycsIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMShzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgX3RoaXMyLmdyYXBocWxNdXRhdGlvbihcIm11dGF0aW9uIHBvc3RSZXF1ZXN0cygkcmVxdWVzdHM6IFtSZXF1ZXN0XSkge1xcbiAgICAgICAgICAgICAgICBwb3N0UmVxdWVzdHMocmVxdWVzdHM6ICRyZXF1ZXN0cylcXG4gICAgICAgICAgICB9XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzOiByZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNwYW4pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTEpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpLCBwYXJlbnRTcGFuKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcG9zdFJlcXVlc3RzKF94MTAsIF94MTEpIHtcbiAgICAgICAgcmV0dXJuIF9wb3N0UmVxdWVzdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc3RSZXF1ZXN0cztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJtdXRhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX211dGF0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE0KHFsKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB2YXJpYWJsZXMsXG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICAgICAgX2FyZ3MxNCA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTQkKF9jb250ZXh0MTQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE0LnByZXYgPSBfY29udGV4dDE0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IF9hcmdzMTQubGVuZ3RoID4gMSAmJiBfYXJnczE0WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczE0WzFdIDoge307XG4gICAgICAgICAgICAgICAgcGFyZW50U3BhbiA9IF9hcmdzMTQubGVuZ3RoID4gMiA/IF9hcmdzMTRbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuY29udGV4dC50cmFjZSgncXVlcmllcy5tdXRhdGlvbicsIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMoc3Bhbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRUYWcoJ3BhcmFtcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiBxbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIsIF90aGlzMy5ncmFwaHFsTXV0YXRpb24ocWwsIHZhcmlhYmxlcywgc3BhbikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxMyk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpLCBwYXJlbnRTcGFuKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbXV0YXRpb24oX3gxMykge1xuICAgICAgICByZXR1cm4gX211dGF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtdXRhdGlvbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJxdWVyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3F1ZXJ5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE2KHFsKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciB2YXJpYWJsZXMsXG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIF9hcmdzMTYgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE2JChfY29udGV4dDE2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNi5wcmV2ID0gX2NvbnRleHQxNi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSBfYXJnczE2Lmxlbmd0aCA+IDEgJiYgX2FyZ3MxNlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MxNlsxXSA6IHt9O1xuICAgICAgICAgICAgICAgIHBhcmVudFNwYW4gPSBfYXJnczE2Lmxlbmd0aCA+IDIgPyBfYXJnczE2WzJdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBfYXJnczE2Lmxlbmd0aCA+IDMgPyBfYXJnczE2WzNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LmFicnVwdChcInJldHVyblwiLCB0aGlzLmNvbnRleHQudHJhY2UoJ3F1ZXJpZXMucXVlcnknLCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE1KHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTUkKF9jb250ZXh0MTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE1LnByZXYgPSBfY29udGV4dDE1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0VGFnKCdwYXJhbXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LmFicnVwdChcInJldHVyblwiLCBfdGhpczQuZ3JhcGhxbFF1ZXJ5KHFsLCB2YXJpYWJsZXMsIHNwYW4sIHRpbWVvdXQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTUpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSwgcGFyZW50U3BhbikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHF1ZXJ5KF94MTUpIHtcbiAgICAgICAgcmV0dXJuIF9xdWVyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JhcGhxbE11dGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ3JhcGhxbE11dGF0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE3KHFsKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZXMsXG4gICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgbXV0YXRpb24sXG4gICAgICAgICAgICBfYXJnczE3ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNyQoX2NvbnRleHQxNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzID0gX2FyZ3MxNy5sZW5ndGggPiAxICYmIF9hcmdzMTdbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMTdbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICBzcGFuID0gX2FyZ3MxNy5sZW5ndGggPiAyID8gX2FyZ3MxN1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbiA9ICgwLCBfZ3JhcGhxbFRhZ1tcImRlZmF1bHRcIl0pKFtxbF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCB0aGlzLmdyYXBoUWwoZnVuY3Rpb24gKGNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbjogbXV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2VTcGFuOiBzcGFuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBncmFwaHFsTXV0YXRpb24oX3gxNykge1xuICAgICAgICByZXR1cm4gX2dyYXBocWxNdXRhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhcGhxbE11dGF0aW9uO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdyYXBocWxRdWVyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dyYXBocWxRdWVyeSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMShxbCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB2YXIgdmFyaWFibGVzLFxuICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIG5leHRUaW1lb3V0LFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgZm9yY2VUZXJtaW5hdGVFeHRyYVRpbWVvdXQsXG4gICAgICAgICAgICBmb3JjZVRlcm1pbmF0ZVRpbWVvdXQsXG4gICAgICAgICAgICBfcmV0LFxuICAgICAgICAgICAgcmVzb2x2ZWRFcnJvcixcbiAgICAgICAgICAgIF9hcmdzMjEgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjEkKF9jb250ZXh0MjEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIxLnByZXYgPSBfY29udGV4dDIxLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IF9hcmdzMjEubGVuZ3RoID4gMSAmJiBfYXJnczIxWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczIxWzFdIDoge307XG4gICAgICAgICAgICAgICAgc3BhbiA9IF9hcmdzMjEubGVuZ3RoID4gMiA/IF9hcmdzMjFbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IF9hcmdzMjEubGVuZ3RoID4gMyA/IF9hcmdzMjFbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSAoMCwgX2dyYXBocWxUYWdbXCJkZWZhdWx0XCJdKShbcWxdKTtcbiAgICAgICAgICAgICAgICBuZXh0VGltZW91dCA9IDEwMDtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGZvcmNlVGVybWluYXRlRXh0cmFUaW1lb3V0ID0gNTAwMDtcbiAgICAgICAgICAgICAgICBmb3JjZVRlcm1pbmF0ZVRpbWVvdXQgPSB0aW1lb3V0IHx8IHRoaXMuY29uZmlnLndhaXRGb3JUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyMS5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIxLnByZXYgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLmRlbGVnYXRlWWllbGQoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE5KCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudCwgY29udGV4dDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE5JChfY29udGV4dDE5KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE5LnByZXYgPSBfY29udGV4dDE5Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5ncmFwaHFsQ2xpZW50UmVxdWlyZWQoc3Bhbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50ID0gX2NvbnRleHQxOS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlU3Bhbjogc3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VGltZW91dDogTWF0aC5taW4oZm9yY2VUZXJtaW5hdGVUaW1lb3V0ICsgZm9yY2VUZXJtaW5hdGVFeHRyYVRpbWVvdXQsIE1BWF9USU1FT1VUKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTgoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNBY3R1YWwsIGRvUmVzb2x2ZSwgZG9SZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOCQoX2NvbnRleHQxOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxOC5wcmV2ID0gX2NvbnRleHQxOC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0dWFsID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1Jlc29sdmUgPSBmdW5jdGlvbiBkb1Jlc29sdmUocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FjdHVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1JlamVjdCA9IGZ1bmN0aW9uIGRvUmVqZWN0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FjdHVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM1LnJlZ2lzdGVyUXVlcnlSZWplY3QoZG9SZWplY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgucHJldiA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgudDAgPSBkb1Jlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgudDEgPSBfY29udGV4dDE4LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfY29udGV4dDE4LnQwKShfY29udGV4dDE4LnQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE4LnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOC50MiA9IF9jb250ZXh0MThbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9SZWplY3QoX2NvbnRleHQxOC50Mik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgucHJldiA9IDE1O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNS51bnJlZ2lzdGVyUXVlcnlSZWplY3QoZG9SZWplY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LmZpbmlzaCgxNSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxOCwgbnVsbCwgW1s0LCAxMiwgMTUsIDE4XV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE5LnQwID0gX2NvbnRleHQxOS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY6IF9jb250ZXh0MTkudDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTE5KTtcbiAgICAgICAgICAgICAgICB9KSgpLCBcInQwXCIsIDExKTtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9yZXQgPSBfY29udGV4dDIxLnQwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoX3R5cGVvZihfcmV0KSA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjEubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjEuYWJydXB0KFwicmV0dXJuXCIsIF9yZXQudik7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIxLm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjEucHJldiA9IDE2O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjEudDEgPSBfY29udGV4dDIxW1wiY2F0Y2hcIl0oOSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMS5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZUdyYXBoUUxFcnJvcihfY29udGV4dDIxLnQxKTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIHJlc29sdmVkRXJyb3IgPSBfY29udGV4dDIxLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShUT05RdWVyaWVzTW9kdWxlLmlzTmV0d29ya0Vycm9yKHJlc29sdmVkRXJyb3IpICYmICF0aGlzLmNvbmZpZy5pc05ldHdvcmtUaW1lb3V0RXhwaXJlZFNpbmNlKHN0YXJ0VGltZSkpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIxLm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLmRlbGVnYXRlWWllbGQoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIwKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJldHJ5RGVsYXlUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjAkKF9jb250ZXh0MjApIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjAucHJldiA9IF9jb250ZXh0MjAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczUuY29uZmlnLmxvZyhyZXNvbHZlZEVycm9yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeURlbGF5VGltZW91dCA9IG5leHRUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIwLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGltZW91dCA8IDMyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0VGltZW91dCAqPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlVGVybWluYXRlRXh0cmFUaW1lb3V0IDwgX3RoaXM1LmNvbmZpZy53YWl0Rm9yVGltZW91dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VUZXJtaW5hdGVFeHRyYVRpbWVvdXQgKz0gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIwLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyMCk7XG4gICAgICAgICAgICAgICAgfSkoKSwgXCJ0MlwiLCAyMyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIxLm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgIHRocm93IHJlc29sdmVkRXJyb3I7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIxLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjEsIHRoaXMsIFtbOSwgMTZdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdyYXBocWxRdWVyeShfeDE4KSB7XG4gICAgICAgIHJldHVybiBfZ3JhcGhxbFF1ZXJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFwaHFsUXVlcnk7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZUdyYXBoUUxFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Jlc29sdmVHcmFwaFFMRXJyb3IgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjIoZXJyb3IpIHtcbiAgICAgICAgdmFyIGdxbEVyciwgY2xpZW50RXJyLCBncWxFeGMsIGVycm9ycztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjIkKF9jb250ZXh0MjIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIyLnByZXYgPSBfY29udGV4dDIyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGdxbEVyciA9IGVycm9yLmdyYXBoUUxFcnJvcnMgJiYgZXJyb3IuZ3JhcGhRTEVycm9yc1swXTtcblxuICAgICAgICAgICAgICAgIGlmICghZ3FsRXJyKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xpZW50RXJyID0gbmV3IEVycm9yKGdxbEVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBncWxFeGMgPSBncWxFcnIuZXh0ZW5zaW9ucyAmJiBncWxFcnIuZXh0ZW5zaW9ucy5leGNlcHRpb24gfHwge307XG4gICAgICAgICAgICAgICAgY2xpZW50RXJyLm51bWJlciA9IGdxbEV4Yy5jb2RlIHx8IDA7XG4gICAgICAgICAgICAgICAgY2xpZW50RXJyLmNvZGUgPSBncWxFeGMuY29kZSB8fCAwO1xuICAgICAgICAgICAgICAgIGNsaWVudEVyci5zb3VyY2UgPSBncWxFeGMuc291cmNlIHx8ICdjbGllbnQnO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIyLmFicnVwdChcInJldHVyblwiLCBjbGllbnRFcnIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvciAmJiBlcnJvci5uZXR3b3JrRXJyb3IgJiYgZXJyb3IubmV0d29ya0Vycm9yLnJlc3VsdCAmJiBlcnJvci5uZXR3b3JrRXJyb3IucmVzdWx0LmVycm9ycztcblxuICAgICAgICAgICAgICAgIGlmICghZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjIudDAgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMi50MSA9IGVycm9ycztcbiAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUVycm9yRGF0YSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMi50MiA9IF9jb250ZXh0MjIuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyMi50MC5xdWVyeUZhaWxlZC5jYWxsKF9jb250ZXh0MjIudDAsIF9jb250ZXh0MjIudDEsIF9jb250ZXh0MjIudDIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIyLmFicnVwdChcInJldHVyblwiLCBlcnJvcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVHcmFwaFFMRXJyb3IoX3gxOSkge1xuICAgICAgICByZXR1cm4gX3Jlc29sdmVHcmFwaFFMRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc29sdmVHcmFwaFFMRXJyb3I7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JhcGhRbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dyYXBoUWwgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjMocmVxdWVzdCwgc3Bhbikge1xuICAgICAgICB2YXIgY2xpZW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMyQoX2NvbnRleHQyMykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjMucHJldiA9IF9jb250ZXh0MjMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaHFsQ2xpZW50UmVxdWlyZWQoc3Bhbik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNsaWVudCA9IF9jb250ZXh0MjMuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIzLnByZXYgPSAzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QoY2xpZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0MjMuc2VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjMucHJldiA9IDk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMy50MCA9IF9jb250ZXh0MjNbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIzLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlR3JhcGhRTEVycm9yKF9jb250ZXh0MjMudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyMy5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjMsIHRoaXMsIFtbMywgOV1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ3JhcGhRbChfeDIwLCBfeDIxKSB7XG4gICAgICAgIHJldHVybiBfZ3JhcGhRbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhcGhRbDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJncmFwaHFsQ2xpZW50UmVxdWlyZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9ncmFwaHFsQ2xpZW50UmVxdWlyZWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjQocGFyZW50U3Bhbikge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgY3JlYXRpb247XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI0JChfY29udGV4dDI0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNC5wcmV2ID0gX2NvbnRleHQyNC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ3JhcGhxbENsaWVudCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI0LmFicnVwdChcInJldHVyblwiLCB0aGlzLmdyYXBocWxDbGllbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ3JhcGhxbENsaWVudENyZWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaHFsQ2xpZW50Q3JlYXRpb24ubGlzdGVuKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjcmVhdGlvbiA9IG5ldyBNdWx0aWNhc3RQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaHFsQ2xpZW50Q3JlYXRpb24gPSBjcmVhdGlvbjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDI0LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudHJhY2UoJ3NldHVwIGNsaWVudCcsIGZ1bmN0aW9uIChzcGFuKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2LmNyZWF0ZUdyYXBocWxDbGllbnQoc3Bhbik7XG4gICAgICAgICAgICAgICAgfSwgcGFyZW50U3Bhbik7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocWxDbGllbnRDcmVhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3JlYXRpb24ucmVzb2x2ZSh0aGlzLmdyYXBocWxDbGllbnQpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5wcmV2ID0gMTY7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC50MCA9IF9jb250ZXh0MjRbXCJjYXRjaFwiXSg5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocWxDbGllbnRDcmVhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3JlYXRpb24ucmVqZWN0KF9jb250ZXh0MjQudDApO1xuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MjQudDA7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5ncmFwaHFsQ2xpZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI0LCB0aGlzLCBbWzksIDE2XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBncmFwaHFsQ2xpZW50UmVxdWlyZWQoX3gyMikge1xuICAgICAgICByZXR1cm4gX2dyYXBocWxDbGllbnRSZXF1aXJlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhcGhxbENsaWVudFJlcXVpcmVkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUdyYXBocWxDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jcmVhdGVHcmFwaHFsQ2xpZW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI2KHNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHVzZUh0dHAsIGNsaWVudENvbmZpZywgc3Vic09wdGlvbnMsIHN1YnNjcmlwdGlvbkNsaWVudCwgZ3VhcmQsIHRyYWNlckxpbmssIHdyYXBMaW5rLCBpc1N1YnNjcmlwdGlvbiwgbGluaztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjYkKF9jb250ZXh0MjYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI2LnByZXYgPSBfY29udGV4dDI2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZUh0dHAgPSAhdGhpcy5jb25maWcuZGF0YS51c2VXZWJTb2NrZXRGb3JRdWVyaWVzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2xpZW50Q29uZmlnKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZyA9IF9jb250ZXh0MjYuc2VudDtcbiAgICAgICAgICAgICAgICBzdWJzT3B0aW9ucyA9IHRoaXMuY29uZmlnLnRyYWNlci5pbmplY3Qoc3BhbiwgX29wZW50cmFjaW5nLkZPUk1BVF9URVhUX01BUCwge30pO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkNsaWVudCA9IG5ldyBfc3Vic2NyaXB0aW9uc1RyYW5zcG9ydFdzLlN1YnNjcmlwdGlvbkNsaWVudChjbGllbnRDb25maWcud3NVcmwsIHtcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IEtFRVBfQUxJVkVfVElNRU9VVCxcbiAgICAgICAgICAgICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25QYXJhbXM6IGZ1bmN0aW9uIGNvbm5lY3Rpb25QYXJhbXMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWNjZXNzS2V5OiBfdGhpczcuY29uZmlnLmRhdGEgJiYgX3RoaXM3LmNvbmZpZy5kYXRhLmFjY2Vzc0tleSxcbiAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzdWJzT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNsaWVudENvbmZpZy5XZWJTb2NrZXQpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkNsaWVudC5vblJlY29ubmVjdGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczcuY29uZmlnLl9lcnJMb2dWZXJib3NlKSBjb25zb2xlLmxvZygnW1RPTkNsaWVudC5xdWVyaWVzXScsICdXZWJTb2NrZXQgUmVjb25uZWN0ZWQnKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXM3LnJlamVjdEFjdGl2ZVF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBndWFyZCA9IHtcbiAgICAgICAgICAgICAgICAgIGRldGVjdGluZ1JlZGlyZWN0aW9uOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uQ2xpZW50Lm9uRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzNy5jb25maWcuX2VyckxvZ1ZlcmJvc2UpIGNvbnNvbGUubG9nKCdbVE9OQ2xpZW50LnF1ZXJpZXNdJywgJ1dlYlNvY2tldCBGYWlsZWQnKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGd1YXJkLmRldGVjdGluZ1JlZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI1KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29uZmlnLCBjb25maWdJc0NoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI1JChfY29udGV4dDI1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNS5wcmV2ID0gX2NvbnRleHQyNS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZC5kZXRlY3RpbmdSZWRpcmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5wcmV2ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczcuZ2V0Q2xpZW50Q29uZmlnKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZyA9IF9jb250ZXh0MjUuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdJc0NoYW5nZWQgPSBuZXdDb25maWcuaHR0cFVybCAhPT0gY2xpZW50Q29uZmlnLmh0dHBVcmwgfHwgbmV3Q29uZmlnLndzVXJsICE9PSBjbGllbnRDb25maWcud3NVcmw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnSXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM3LmNvbmZpZy5fbG9nVmVyYm9zZSkgY29uc29sZS5sb2coJ1tUT05DbGllbnQucXVlcmllc10nLCAnQ2xpZW50IGNvbmZpZyBjaGFuZ2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRDb25maWcgPSBuZXdDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczcuZ3JhcGhxbENsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkNsaWVudC51cmwgPSBuZXdDb25maWcud3NVcmw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczcud3NMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNy53c0xpbmsudXJsID0gbmV3Q29uZmlnLndzVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM3Lmh0dHBMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNy5odHRwTGluay51cmkgPSBuZXdDb25maWcuaHR0cFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI1LnQwID0gX2NvbnRleHQyNVtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczcuY29uZmlnLl9lcnJMb2dWZXJib3NlKSBjb25zb2xlLmxvZygnW1RPTkNsaWVudC5xdWVyaWVzXSByZWRpcmVjdGlvbiBkZXRlY3RvciBmYWlsZWQnLCBfY29udGV4dDI1LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkLmRldGVjdGluZ1JlZGlyZWN0aW9uID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI1LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyNSwgbnVsbCwgW1sxLCA5XV0pO1xuICAgICAgICAgICAgICAgICAgfSkpKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25DbGllbnQubWF4Q29ubmVjdFRpbWVHZW5lcmF0b3IuZHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uQ2xpZW50Lm1heENvbm5lY3RUaW1lR2VuZXJhdG9yLm1heDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXBvbGxvTGlua0NvbnRleHQuc2V0Q29udGV4dCkoZnVuY3Rpb24gKF8sIHJlcSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkU3BhbiA9IHJlcSAmJiByZXEudHJhY2VTcGFuIHx8IHNwYW47XG4gICAgICAgICAgICAgICAgICByZXEuaGVhZGVycyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczcuY29uZmlnLnRyYWNlci5pbmplY3QocmVzb2x2ZWRTcGFuLCBfb3BlbnRyYWNpbmcuRk9STUFUX1RFWFRfTUFQLCByZXEuaGVhZGVycyk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBhY2Nlc3NLZXkgPSBfdGhpczcuY29uZmlnLmRhdGEgJiYgX3RoaXM3LmNvbmZpZy5kYXRhLmFjY2Vzc0tleTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGFjY2Vzc0tleSkge1xuICAgICAgICAgICAgICAgICAgICByZXEuaGVhZGVycy5hY2Nlc3NLZXkgPSBhY2Nlc3NLZXk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgdHJhY2VyTGluayA9IF9jb250ZXh0MjYuc2VudDtcblxuICAgICAgICAgICAgICAgIHdyYXBMaW5rID0gZnVuY3Rpb24gd3JhcExpbmsobGluaykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlckxpbmsuY29uY2F0KGxpbmspO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpc1N1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGlzU3Vic2NyaXB0aW9uKF9yZWY2KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBfcmVmNi5xdWVyeTtcbiAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gKDAsIF9hcG9sbG9VdGlsaXRpZXMuZ2V0TWFpbkRlZmluaXRpb24pKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJyAmJiBkZWZpbml0aW9uLm9wZXJhdGlvbiA9PT0gJ3N1YnNjcmlwdGlvbic7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMud3NMaW5rID0gbmV3IF9hcG9sbG9MaW5rV3MuV2ViU29ja2V0TGluayhzdWJzY3JpcHRpb25DbGllbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHR0cExpbmsgPSB1c2VIdHRwID8gbmV3IF9hcG9sbG9MaW5rSHR0cC5IdHRwTGluayh7XG4gICAgICAgICAgICAgICAgICB1cmk6IGNsaWVudENvbmZpZy5odHRwVXJsLFxuICAgICAgICAgICAgICAgICAgZmV0Y2g6IGFib3J0YWJsZUZldGNoKGNsaWVudENvbmZpZy5mZXRjaClcbiAgICAgICAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGluayA9IHRoaXMuaHR0cExpbmsgPyAoMCwgX2Fwb2xsb0xpbmsuc3BsaXQpKGlzU3Vic2NyaXB0aW9uLCB3cmFwTGluayh0aGlzLndzTGluayksIHdyYXBMaW5rKHRoaXMuaHR0cExpbmspKSA6IHdyYXBMaW5rKHRoaXMud3NMaW5rKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocWxDbGllbnRDb25maWcgPSBjbGllbnRDb25maWc7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaHFsQ2xpZW50ID0gbmV3IF9hcG9sbG9DbGllbnQuQXBvbGxvQ2xpZW50KHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBuZXcgX2Fwb2xsb0NhY2hlSW5tZW1vcnkuSW5NZW1vcnlDYWNoZSh7fSksXG4gICAgICAgICAgICAgICAgICBsaW5rOiBsaW5rLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hRdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiAnbm8tY2FjaGUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3k6ICduby1jYWNoZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVHcmFwaHFsQ2xpZW50KF94MjMpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVHcmFwaHFsQ2xpZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVHcmFwaHFsQ2xpZW50O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2xvc2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjcoKSB7XG4gICAgICAgIHZhciBjbGllbnQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI3JChfY29udGV4dDI3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNy5wcmV2ID0gX2NvbnRleHQyNy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ3JhcGhxbENsaWVudCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNy5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsaWVudCA9IHRoaXMuZ3JhcGhxbENsaWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocWxDbGllbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNsaWVudC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNy5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LmNsZWFyU3RvcmUoKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF9jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2U7XG4gICAgfSgpXG4gIH1dLCBbe1xuICAgIGtleTogXCJpc05ldHdvcmtFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc05ldHdvcmtFcnJvcihlcnJvcikge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IF9UT05DbGllbnRFcnJvci5UT05FcnJvckNvZGUuUVVFUllfRk9SQ0lCTFlfQUJPUlRFRCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ldHdvcmtFcnJvciA9IGVycm9yLm5ldHdvcmtFcnJvcjtcblxuICAgICAgaWYgKCFuZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2Vycm5vJyBpbiBuZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhKCdyZXNwb25zZScgaW4gbmV0d29ya0Vycm9yIHx8ICdyZXN1bHQnIGluIG5ldHdvcmtFcnJvcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRPTlF1ZXJpZXNNb2R1bGU7XG59KF9UT05Nb2R1bGUyLlRPTk1vZHVsZSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVE9OUXVlcmllc01vZHVsZTtcblxudmFyIFRPTlF1ZXJpZXNNb2R1bGVDb2xsZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVE9OUXVlcmllc01vZHVsZUNvbGxlY3Rpb24obW9kdWxlLCBjb2xsZWN0aW9uTmFtZSwgdHlwZU5hbWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVE9OUXVlcmllc01vZHVsZUNvbGxlY3Rpb24pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kdWxlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2xsZWN0aW9uTmFtZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHlwZU5hbWVcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBjb2xsZWN0aW9uTmFtZTtcbiAgICB0aGlzLnR5cGVOYW1lID0gdHlwZU5hbWU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVE9OUXVlcmllc01vZHVsZUNvbGxlY3Rpb24sIFt7XG4gICAga2V5OiBcInF1ZXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcXVlcnkyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI5KCkge1xuICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICB2YXIgX2xlbixcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBfa2V5LFxuICAgICAgICAgICAgX3Jlc29sdmVQYXJhbXMsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBvcmRlckJ5LFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgb3BlcmF0aW9uSWQsXG4gICAgICAgICAgICBwYXJlbnRTcGFuLFxuICAgICAgICAgICAgX2FyZ3MyOSA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyOSQoX2NvbnRleHQyOSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjkucHJldiA9IF9jb250ZXh0MjkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZm9yIChfbGVuID0gX2FyZ3MyOS5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gX2FyZ3MyOVtfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfcmVzb2x2ZVBhcmFtcyA9IHJlc29sdmVQYXJhbXMoYXJncywgJ2ZpbHRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhcmdzWzFdLFxuICAgICAgICAgICAgICAgICAgICBvcmRlckJ5OiBhcmdzWzJdLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogYXJnc1szXSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogYXJnc1s0XSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U3BhbjogYXJnc1s1XVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSwgZmlsdGVyID0gX3Jlc29sdmVQYXJhbXMuZmlsdGVyLCByZXN1bHQgPSBfcmVzb2x2ZVBhcmFtcy5yZXN1bHQsIG9yZGVyQnkgPSBfcmVzb2x2ZVBhcmFtcy5vcmRlckJ5LCBsaW1pdCA9IF9yZXNvbHZlUGFyYW1zLmxpbWl0LCB0aW1lb3V0ID0gX3Jlc29sdmVQYXJhbXMudGltZW91dCwgb3BlcmF0aW9uSWQgPSBfcmVzb2x2ZVBhcmFtcy5vcGVyYXRpb25JZCwgcGFyZW50U3BhbiA9IF9yZXNvbHZlUGFyYW1zLnBhcmVudFNwYW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjkuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMubW9kdWxlLmNvbnRleHQudHJhY2UoXCJcIi5jb25jYXQodGhpcy5jb2xsZWN0aW9uTmFtZSwgXCIucXVlcnlcIiksIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjcgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjgoc3Bhbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlT3BlcmF0aW9uSWQsIGMsIHQsIHFsLCB2YXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI4JChfY29udGV4dDI4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyOC5wcmV2ID0gX2NvbnRleHQyOC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldFRhZygncGFyYW1zJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyQnk6IG9yZGVyQnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IG9wZXJhdGlvbklkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOC50MCA9IG9wZXJhdGlvbklkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dDI4LnQwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI4Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4Lm1vZHVsZS5nZXRTZXJ2ZXJJbmZvKHNwYW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI4LnQwID0gX2NvbnRleHQyOC5zZW50LnN1cHBvcnRzT3BlcmF0aW9uSWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZU9wZXJhdGlvbklkID0gX2NvbnRleHQyOC50MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gX3RoaXM4LmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfdGhpczgudHlwZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcWwgPSBcIlxcbiAgICAgICAgICAgIHF1ZXJ5IFwiLmNvbmNhdChjLCBcIihcXG4gICAgICAgICAgICAgICAgJGZpbHRlcjogXCIpLmNvbmNhdCh0LCBcIkZpbHRlcixcXG4gICAgICAgICAgICAgICAgJG9yZGVyQnk6IFtRdWVyeU9yZGVyQnldLCBcXG4gICAgICAgICAgICAgICAgJGxpbWl0OiBJbnQsIFxcbiAgICAgICAgICAgICAgICAkdGltZW91dDogRmxvYXRcXG4gICAgICAgICAgICAgICAgXCIpLmNvbmNhdCh1c2VPcGVyYXRpb25JZCA/ICcsICRvcGVyYXRpb25JZDogU3RyaW5nJyA6ICcnLCBcIlxcbiAgICAgICAgICAgICApIHtcXG4gICAgICAgICAgICAgICAgXCIpLmNvbmNhdChjLCBcIihcXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogJGZpbHRlciwgXFxuICAgICAgICAgICAgICAgICAgICBvcmRlckJ5OiAkb3JkZXJCeSwgXFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogJGxpbWl0LCBcXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6ICR0aW1lb3V0XFxuICAgICAgICAgICAgICAgICAgICBcIikuY29uY2F0KHVzZU9wZXJhdGlvbklkID8gJywgb3BlcmF0aW9uSWQ6ICRvcGVyYXRpb25JZCcgOiAnJywgXCJcXG4gICAgICAgICAgICAgICAgKSB7IFwiKS5jb25jYXQocmVzdWx0LCBcIiB9XFxuICAgICAgICAgICAgfVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyQnk6IG9yZGVyQnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZU9wZXJhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMub3BlcmF0aW9uSWQgPSBvcGVyYXRpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLnRpbWVvdXQgPSBNYXRoLm1pbihNQVhfVElNRU9VVCwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOC5tb2R1bGUuZ3JhcGhxbFF1ZXJ5KHFsLCB2YXJpYWJsZXMsIHNwYW4sIHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOC50MSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjguYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mjguc2VudC5kYXRhW19jb250ZXh0MjgudDFdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjguc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTI4KTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDI0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCksIHBhcmVudFNwYW4pKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjksIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIF9xdWVyeTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImFnZ3JlZ2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FnZ3JlZ2F0ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMzEkKF9jb250ZXh0MzEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMxLnByZXYgPSBfY29udGV4dDMxLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMxLmFicnVwdChcInJldHVyblwiLCB0aGlzLm1vZHVsZS5jb250ZXh0LnRyYWNlKFwiXCIuY29uY2F0KHRoaXMuY29sbGVjdGlvbk5hbWUsIFwiLmFnZ3JlZ2F0ZVwiKSwgLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmOCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMChzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0LCBxLCBxbCwgdmFyaWFibGVzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMCQoX2NvbnRleHQzMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzAucHJldiA9IF9jb250ZXh0MzAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRUYWcoJ3BhcmFtcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogcGFyYW1zLmZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogcGFyYW1zLmZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOS5tb2R1bGUuZ2V0U2VydmVySW5mbyhzcGFuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0MzAuc2VudC5zdXBwb3J0c0FnZ3JlZ2F0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzAudDAgPSBfVE9OQ2xpZW50RXJyb3IuVE9OQ2xpZW50RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5Lm1vZHVsZS5jb21wbGV0ZUVycm9yRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMwLnQxID0gX2NvbnRleHQzMC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MzAudDAuc2VydmVyRG9lc250U3VwcG9ydEFnZ3JlZ2F0aW9ucy5jYWxsKF9jb250ZXh0MzAudDAsIF9jb250ZXh0MzAudDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gX3RoaXM5LnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBfdGhpczkudHlwZU5hbWUuZW5kc1dpdGgoJ3MnKSA/IFwiYWdncmVnYXRlXCIuY29uY2F0KHQpIDogXCJhZ2dyZWdhdGVcIi5jb25jYXQodCwgXCJzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFsID0gXCJcXG4gICAgICAgICAgICBxdWVyeSBcIi5jb25jYXQocSwgXCIoXFxuICAgICAgICAgICAgICAgICRmaWx0ZXI6IFwiKS5jb25jYXQodCwgXCJGaWx0ZXIsXFxuICAgICAgICAgICAgICAgICRmaWVsZHM6IFtGaWVsZEFnZ3JlZ2F0aW9uXSBcXG4gICAgICAgICAgICAgKSB7XFxuICAgICAgICAgICAgICAgIFwiKS5jb25jYXQocSwgXCIoXFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6ICRmaWx0ZXIsIFxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzOiAkZmllbGRzIFxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgfVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHBhcmFtcy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHBhcmFtcy5maWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzAubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczkubW9kdWxlLmdyYXBocWxRdWVyeShxbCwgdmFyaWFibGVzLCBzcGFuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzAudDIgPSBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMwLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMwLnNlbnQuZGF0YVtfY29udGV4dDMwLnQyXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMwLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzMCk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gyNikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpLCBwYXJhbXMucGFyZW50U3BhbikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMxLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZShfeDI1KSB7XG4gICAgICAgIHJldHVybiBfYWdncmVnYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZ2dyZWdhdGU7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZSgpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9yZXNvbHZlUGFyYW1zMiA9IHJlc29sdmVQYXJhbXMoYXJncywgJ2ZpbHRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWx0ZXI6IGFyZ3NbMF0sXG4gICAgICAgICAgcmVzdWx0OiBhcmdzWzFdLFxuICAgICAgICAgIG9uRG9jRXZlbnQ6IGFyZ3NbMl0sXG4gICAgICAgICAgb25FcnJvcjogYXJnc1szXVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICAgICAgZmlsdGVyID0gX3Jlc29sdmVQYXJhbXMyLmZpbHRlcixcbiAgICAgICAgICByZXN1bHQgPSBfcmVzb2x2ZVBhcmFtczIucmVzdWx0LFxuICAgICAgICAgIG9uRG9jRXZlbnQgPSBfcmVzb2x2ZVBhcmFtczIub25Eb2NFdmVudCxcbiAgICAgICAgICBvbkVycm9yID0gX3Jlc29sdmVQYXJhbXMyLm9uRXJyb3I7XG5cbiAgICAgIHZhciBzcGFuID0gdGhpcy5tb2R1bGUuY29uZmlnLnRyYWNlci5zdGFydFNwYW4oJ1RPTlF1ZXJpZXNNb2R1bGUuanM6c3Vic2NyaWJlICcpO1xuICAgICAgc3Bhbi5zZXRUYWcoX29wZW50cmFjaW5nLlRhZ3MuU1BBTl9LSU5ELCAnY2xpZW50Jyk7XG4gICAgICB2YXIgdGV4dCA9IFwic3Vic2NyaXB0aW9uIFwiLmNvbmNhdCh0aGlzLmNvbGxlY3Rpb25OYW1lLCBcIigkZmlsdGVyOiBcIikuY29uY2F0KHRoaXMudHlwZU5hbWUsIFwiRmlsdGVyKSB7XFxuICAgICAgICAgICAgXCIpLmNvbmNhdCh0aGlzLmNvbGxlY3Rpb25OYW1lLCBcIihmaWx0ZXI6ICRmaWx0ZXIpIHsgXCIpLmNvbmNhdChyZXN1bHQsIFwiIH1cXG4gICAgICAgIH1cIik7XG4gICAgICB2YXIgcXVlcnkgPSAoMCwgX2dyYXBocWxUYWdbXCJkZWZhdWx0XCJdKShbdGV4dF0pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICAgIF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMigpIHtcbiAgICAgICAgdmFyIGNsaWVudCwgb2JzZXJ2YWJsZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMzIkKF9jb250ZXh0MzIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMyLnByZXYgPSBfY29udGV4dDMyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMC5tb2R1bGUuZ3JhcGhxbENsaWVudFJlcXVpcmVkKHNwYW4pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBfY29udGV4dDMyLnNlbnQ7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IGNsaWVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgIG9uRG9jRXZlbnQoJ2luc2VydC91cGRhdGUnLCBtZXNzYWdlLmRhdGFbX3RoaXMxMC5jb2xsZWN0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMyLnByZXYgPSA4O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIudDAgPSBfY29udGV4dDMyW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgICAgc3Bhbi5sb2coe1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdmYWlsZWQnLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZDogX2NvbnRleHQzMi50MFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIG9uRXJyb3IoX2NvbnRleHQzMi50MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuX2VyckxvZ1ZlcmJvc2UpIGNvbnNvbGUubG9nKCdUT04gQ2xpZW50IHN1YnNjcmlwdGlvbiBlcnJvcicsIF9jb250ZXh0MzIudDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMyLCBudWxsLCBbWzAsIDhdXSk7XG4gICAgICB9KSkoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgc3Bhbi5maW5pc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhaXRGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF93YWl0Rm9yID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMzKCkge1xuICAgICAgICB2YXIgX2xlbjMsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgX2tleTMsXG4gICAgICAgICAgICBfcmVzb2x2ZVBhcmFtczMsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBwYXJhbXNUaW1lb3V0LFxuICAgICAgICAgICAgcGFyZW50U3BhbixcbiAgICAgICAgICAgIG9wZXJhdGlvbklkLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIGRvY3MsXG4gICAgICAgICAgICBfYXJnczMzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMzJChfY29udGV4dDMzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzMy5wcmV2ID0gX2NvbnRleHQzMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBmb3IgKF9sZW4zID0gX2FyZ3MzMy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTNdID0gX2FyZ3MzM1tfa2V5M107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3Jlc29sdmVQYXJhbXMzID0gcmVzb2x2ZVBhcmFtcyhhcmdzLCAnZmlsdGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IGFyZ3NbMl0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFNwYW46IGFyZ3NbM11cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksIGZpbHRlciA9IF9yZXNvbHZlUGFyYW1zMy5maWx0ZXIsIHJlc3VsdCA9IF9yZXNvbHZlUGFyYW1zMy5yZXN1bHQsIHBhcmFtc1RpbWVvdXQgPSBfcmVzb2x2ZVBhcmFtczMudGltZW91dCwgcGFyZW50U3BhbiA9IF9yZXNvbHZlUGFyYW1zMy5wYXJlbnRTcGFuLCBvcGVyYXRpb25JZCA9IF9yZXNvbHZlUGFyYW1zMy5vcGVyYXRpb25JZDtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gcGFyYW1zVGltZW91dCB8fCB0aGlzLm1vZHVsZS5jb25maWcud2FpdEZvclRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMzLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgcGFyZW50U3BhbjogcGFyZW50U3BhbixcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBvcGVyYXRpb25JZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBkb2NzID0gX2NvbnRleHQzMy5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoZG9jcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMy5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMzLmFicnVwdChcInJldHVyblwiLCBkb2NzWzBdKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMy50MCA9IF9UT05DbGllbnRFcnJvci5UT05DbGllbnRFcnJvcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMzLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGUuY29tcGxldGVFcnJvckRhdGEoe1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogdGhpcy5jb2xsZWN0aW9uTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMy50MSA9IF9jb250ZXh0MzMuc2VudDtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDMzLnQwLndhaXRGb3JUaW1lb3V0LmNhbGwoX2NvbnRleHQzMy50MCwgX2NvbnRleHQzMy50MSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHdhaXRGb3IoKSB7XG4gICAgICAgIHJldHVybiBfd2FpdEZvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2FpdEZvcjtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBUT05RdWVyaWVzTW9kdWxlQ29sbGVjdGlvbjtcbn0oKTtcblxuVE9OUXVlcmllc01vZHVsZS5tb2R1bGVOYW1lID0gJ1RPTlF1ZXJpZXNNb2R1bGUnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5dGIyUjFiR1Z6TDFSUFRsRjFaWEpwWlhOTmIyUjFiR1V1YW5NaVhTd2libUZ0WlhNaU9sc2lTMFZGVUY5QlRFbFdSVjlVU1UxRlQxVlVJaXdpVFVGWVgxUkpUVVZQVlZRaUxDSnlaWE52YkhabFVHRnlZVzF6SWl3aVlYSm5jeUlzSW5KbGNYVnBjbVZrVUdGeVlXMU9ZVzFsSWl3aWNtVnpiMngyWlVGeVozTWlMQ0pzWlc1bmRHZ2lMQ0pOZFd4MGFXTmhjM1JRY205dGFYTmxJaXdpYkdsemRHVnVaWEp6SWl3aWIyNURiMjF3YkdWMFpTSXNJbXhwYzNSbGJtVnlJaXdpY21WemIyeDJaU0lzSW5KbGFtVmpkQ0lzSW5CMWMyZ2lMQ0pRY205dGFYTmxJaXdpZG1Gc2RXVWlMQ0pqYjIxd2JHVjBaU0lzSW1WeWNtOXlJaXdpWTI5dGNHeGxkR1ZNYVhOMFpXNWxjaUlzSW1admNrVmhZMmdpTENKMlpYSnphVzl1Vkc5T2RXMWlaWElpTENKeklpd2ljR0Z5ZEhNaUxDSnpjR3hwZENJc0ltMWhjQ0lzSW5naUxDSk9kVzFpWlhJaUxDSnpiR2xqWlNJc0luSmxjMjlzZG1WVFpYSjJaWEpKYm1adklpd2lkbVZ5YzJsdmJsTjBjbWx1WnlJc0luWmxjbk5wYjI0aUxDSnpkWEJ3YjNKMGMwOXdaWEpoZEdsdmJrbGtJaXdpYzNWd2NHOXlkSE5CWjJkeVpXZGhkR2x2Ym5NaUxDSnpkWEJ3YjNKMGMxUnBiV1VpTENKMGFXMWxSR1ZzZEdFaUxDSmhZbTl5ZEdGaWJHVkdaWFJqYUNJc0ltWmxkR05vSWl3aWFXNXdkWFFpTENKdmNIUnBiMjV6SWl3aWNYVmxjbmxVYVcxbGIzVjBJaXdpWm1WMFkyaFBjSFJwYjI1eklpd2lZMjl1ZEhKdmJHeGxjaUlzSW1kc2IySmhiQ0lzSWtGaWIzSjBRMjl1ZEhKdmJHeGxjaUlzSW5OcFoyNWhiQ0lzSW5ObGRGUnBiV1Z2ZFhRaUxDSlVUMDVEYkdsbGJuUkZjbkp2Y2lJc0luRjFaWEo1Um05eVkybGliSGxCWW05eWRHVmtJaXdpWlcxd2RIbFVUMDVGY25KdmNrUmhkR0VpTENKaFltOXlkQ0lzSW5Sb1pXNGlMQ0pVVDA1UmRXVnlhV1Z6VFc5a2RXeGxJaXdpWTI5dWRHVjRkQ0lzSW1keVlYQm9jV3hEYkdsbGJuUWlMQ0puY21Gd2FIRnNRMnhwWlc1MFEzSmxZWFJwYjI0aUxDSm5jbUZ3YUhGc1EyeHBaVzUwUTI5dVptbG5JaXdpZDNOTWFXNXJJaXdpYUhSMGNFeHBibXNpTENKdmRtVnljbWxrWlZkelZYSnNJaXdpYjNCbGNtRjBhVzl1U1dSUWNtVm1hWGdpTENKRVlYUmxJaXdpYm05M0lpd2lkRzlUZEhKcGJtY2lMQ0pwSWl3aWNtRnVaRzl0VUdGeWRDSXNJazFoZEdnaUxDSnliM1Z1WkNJc0luSmhibVJ2YlNJc0ltOXdaWEpoZEdsdmJrbGtVM1ZtWm1sNElpd2ljMlZ5ZG1WeVNXNW1ieUlzSW1GamRHbDJaVkYxWlhKcFpYTlNaV3BsWTNSeklpd2lhVzVrWlhnaUxDSnBibVJsZUU5bUlpd2ljM0JzYVdObElpd2ljbVZxWldOMGN5SXNJbVZ5Y2lJc0ltTnZibVpwWnlJc0ltZGxkRTF2WkhWc1pTSXNJbFJQVGtOdmJtWnBaMDF2WkhWc1pTSXNJblJ5WVc1ellXTjBhVzl1Y3lJc0lsUlBUbEYxWlhKcFpYTk5iMlIxYkdWRGIyeHNaV04wYVc5dUlpd2liV1Z6YzJGblpYTWlMQ0ppYkc5amEzTWlMQ0poWTJOdmRXNTBjeUlzSW1Kc2IyTnJjMTl6YVdkdVlYUjFjbVZ6SWl3aWFIUjBjRlZ5YkNJc0luTnZkWEpqWlZWeWJDSXNJbkpsYzNCdmJuTmxJaXdpZEdWNGRDSXNJbkpsYzNCdmJuTmxWR1Y0ZENJc0luSmxjM0J2Ym5ObFNuTnZiaUlzSWtwVFQwNGlMQ0p3WVhKelpTSXNJbVJoZEdFaUxDSnBibVp2SWl3aWNtVmthWEpsWTNSbFpDSXNJblZ5YkNJc0luTnZkWEpqWlV4dlkyRjBhVzl1SWl3aVZWSk1VR0Z5ZEhNaUxDSm1hWGhSZFdWeWVTSXNJblJ2VEc5M1pYSkRZWE5sSWl3aWNtVnpjRzl1YzJWTWIyTmhkR2x2YmlJc0ltZGxkRU52Ym1acFowWnZjbE5sY25abGNpSXNJbk5sY25abGNpSXNJbWgwZEhCUVlYSjBjeUlzSW1acGVGQnliM1J2WTI5c0lpd2labWw0VUdGMGFDSXNJbWgwZEhBaUxDSjNjeUlzSW5kelZYSnNJaXdpWTJ4cFpXNTBVR3hoZEdadmNtMGlMQ0pYWldKVGIyTnJaWFFpTENKVVQwNURiR2xsYm5RaUxDSkZjbkp2Y2lJc0luTmxjblpsY25NaUxDSmpiR2xsYm5SRGIyNW1hV2NpTENKa1pYUmxZM1JTWldScGNtVmpkQ0lzSWw4aUxDSmZaWEp5VEc5blZtVnlZbTl6WlNJc0ltTnZibk52YkdVaUxDSnNiMmNpTENKdFpYTnpZV2RsSWl3aWFIUjBjRjkxY213aUxDSjNjMTkxY213aUxDSnpjR0Z1SWl3aVozSmhjR2h4YkVOc2FXVnVkRkpsY1hWcGNtVmtJaXdpWjJWMFUyVnlkbVZ5U1c1bWJ5SXNJbk4wWVhKMElpd2laVzVrSWl3aWFuTnZiaUlzSW5KbGMzQnZibk5sUkdGMFlTSXNJbk5sY25abGNsUnBiV1VpTENKMGFXMWxJaXdpYzJWeWRtVnlWR2x0WlVSbGJIUmhJaXdpYjNCbGNtRjBhVzl1U1dSeklpd2laM0poY0doeGJFMTFkR0YwYVc5dUlpd2ljR0Z5Wlc1MFUzQmhiaUlzSW5GMVpYSjVJaXdpZFc1a1pXWnBibVZrSWl3aWNtVnpkV3gwSWl3aVoyVjBRV05qYjNWdWRITkRiM1Z1ZENJc0ltZGxkRlJ5WVc1ellXTjBhVzl1YzBOdmRXNTBJaXdpWjJWMFFXTmpiM1Z1ZEhOVWIzUmhiRUpoYkdGdVkyVWlMQ0p5WlhGMVpYTjBjeUlzSW5SeVlXTmxJaXdpY1d3aUxDSjJZWEpwWVdKc1pYTWlMQ0p6WlhSVVlXY2lMQ0p0ZFhSaGRHbHZiaUlzSW5ScGJXVnZkWFFpTENKbmNtRndhSEZzVVhWbGNua2lMQ0puY21Gd2FGRnNJaXdpWTJ4cFpXNTBJaXdpYlhWMFlYUmxJaXdpZEhKaFkyVlRjR0Z1SWl3aWJtVjRkRlJwYldWdmRYUWlMQ0p6ZEdGeWRGUnBiV1VpTENKbWIzSmpaVlJsY20xcGJtRjBaVVY0ZEhKaFZHbHRaVzkxZENJc0ltWnZjbU5sVkdWeWJXbHVZWFJsVkdsdFpXOTFkQ0lzSW5kaGFYUkdiM0pVYVcxbGIzVjBJaXdpYldsdUlpd2lhWE5CWTNSMVlXd2lMQ0prYjFKbGMyOXNkbVVpTENKa2IxSmxhbVZqZENJc0luSmxaMmx6ZEdWeVVYVmxjbmxTWldwbFkzUWlMQ0oxYm5KbFoybHpkR1Z5VVhWbGNubFNaV3BsWTNRaUxDSnlaWE52YkhabFIzSmhjR2hSVEVWeWNtOXlJaXdpY21WemIyeDJaV1JGY25KdmNpSXNJbWx6VG1WMGQyOXlhMFZ5Y205eUlpd2lhWE5PWlhSM2IzSnJWR2x0Wlc5MWRFVjRjR2x5WldSVGFXNWpaU0lzSW5KbGRISjVSR1ZzWVhsVWFXMWxiM1YwSWl3aVozRnNSWEp5SWl3aVozSmhjR2hSVEVWeWNtOXljeUlzSW1Oc2FXVnVkRVZ5Y2lJc0ltZHhiRVY0WXlJc0ltVjRkR1Z1YzJsdmJuTWlMQ0psZUdObGNIUnBiMjRpTENKdWRXMWlaWElpTENKamIyUmxJaXdpYzI5MWNtTmxJaXdpWlhKeWIzSnpJaXdpYm1WMGQyOXlhMFZ5Y205eUlpd2lZMjl0Y0d4bGRHVkZjbkp2Y2tSaGRHRWlMQ0p4ZFdWeWVVWmhhV3hsWkNJc0luSmxjWFZsYzNRaUxDSnNhWE4wWlc0aUxDSmpjbVZoZEdsdmJpSXNJbU55WldGMFpVZHlZWEJvY1d4RGJHbGxiblFpTENKMWMyVklkSFJ3SWl3aWRYTmxWMlZpVTI5amEyVjBSbTl5VVhWbGNtbGxjeUlzSW1kbGRFTnNhV1Z1ZEVOdmJtWnBaeUlzSW5OMVluTlBjSFJwYjI1eklpd2lkSEpoWTJWeUlpd2lhVzVxWldOMElpd2lSazlTVFVGVVgxUkZXRlJmVFVGUUlpd2ljM1ZpYzJOeWFYQjBhVzl1UTJ4cFpXNTBJaXdpVTNWaWMyTnlhWEIwYVc5dVEyeHBaVzUwSWl3aWNtVmpiMjV1WldOMElpd2lZMjl1Ym1WamRHbHZibEJoY21GdGN5SXNJbUZqWTJWemMwdGxlU0lzSW1obFlXUmxjbk1pTENKdmJsSmxZMjl1Ym1WamRHVmtJaXdpY21WcVpXTjBRV04wYVhabFVYVmxjbWxsY3lJc0ltZDFZWEprSWl3aVpHVjBaV04wYVc1blVtVmthWEpsWTNScGIyNGlMQ0p2YmtWeWNtOXlJaXdpYm1WM1EyOXVabWxuSWl3aVkyOXVabWxuU1hORGFHRnVaMlZrSWl3aVgyeHZaMVpsY21KdmMyVWlMQ0oxY21raUxDSnRZWGhEYjI1dVpXTjBWR2x0WlVkbGJtVnlZWFJ2Y2lJc0ltUjFjbUYwYVc5dUlpd2liV0Y0SWl3aWNtVnhJaXdpY21WemIyeDJaV1JUY0dGdUlpd2lkSEpoWTJWeVRHbHVheUlzSW5keVlYQk1hVzVySWl3aWJHbHVheUlzSW1OdmJtTmhkQ0lzSW1selUzVmljMk55YVhCMGFXOXVJaXdpWkdWbWFXNXBkR2x2YmlJc0ltdHBibVFpTENKdmNHVnlZWFJwYjI0aUxDSlhaV0pUYjJOclpYUk1hVzVySWl3aVNIUjBjRXhwYm1zaUxDSkJjRzlzYkc5RGJHbGxiblFpTENKallXTm9aU0lzSWtsdVRXVnRiM0o1UTJGamFHVWlMQ0prWldaaGRXeDBUM0IwYVc5dWN5SXNJbmRoZEdOb1VYVmxjbmtpTENKbVpYUmphRkJ2YkdsamVTSXNJbk4wYjNBaUxDSmpiR1ZoY2xOMGIzSmxJaXdpVkU5T1JYSnliM0pEYjJSbElpd2lVVlZGVWxsZlJrOVNRMGxDVEZsZlFVSlBVbFJGUkNJc0lsUlBUazF2WkhWc1pTSXNJbTF2WkhWc1pTSXNJbU52Ykd4bFkzUnBiMjVPWVcxbElpd2lkSGx3WlU1aGJXVWlMQ0ptYVd4MFpYSWlMQ0p2Y21SbGNrSjVJaXdpYkdsdGFYUWlMQ0p2Y0dWeVlYUnBiMjVKWkNJc0luVnpaVTl3WlhKaGRHbHZia2xrSWl3aVl5SXNJblFpTENKd1lYSmhiWE1pTENKbWFXVnNaSE1pTENKelpYSjJaWEpFYjJWemJuUlRkWEJ3YjNKMFFXZG5jbVZuWVhScGIyNXpJaXdpY1NJc0ltVnVaSE5YYVhSb0lpd2liMjVFYjJORmRtVnVkQ0lzSW5OMFlYSjBVM0JoYmlJc0lsUmhaM01pTENKVFVFRk9YMHRKVGtRaUxDSnpkV0p6WTNKcGNIUnBiMjRpTENKdlluTmxjblpoWW14bElpd2ljM1ZpYzJOeWFXSmxJaXdpWlhabGJuUWlMQ0p3WVhsc2IyRmtJaXdpZFc1emRXSnpZM0pwWW1VaUxDSm1hVzVwYzJnaUxDSndZWEpoYlhOVWFXMWxiM1YwSWl3aVpHOWpjeUlzSW1OdmJHeGxZM1JwYjI0aUxDSnRiMlIxYkdWT1lXMWxJbDBzSW0xaGNIQnBibWR6SWpvaU96czdPenM3T3pzN1FVRk5RVHM3UVVGRFFUczdRVUZEUVRzN1FVRkRRVHM3UVVGRFFUczdRVUZEUVRzN1FVRkRRVHM3UVVGRFFUczdRVUZEUVRzN1FVRkRRVHM3UVVGWlFUczdRVUZEUVRzN1FVRkZRVHM3UVVGRFFUczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096dEJRWGRDUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEpRVUZOUVN4clFrRkJhMElzUjBGQlJ5eEpRVUZKTEV0QlFTOUNPMEZCUlU4c1NVRkJUVU1zVjBGQlZ5eEhRVUZITEZWQlFYQkNPenM3UVVGRlVDeFRRVUZUUXl4aFFVRlVMRU5CUVRCQ1F5eEpRVUV4UWl4RlFVRjFRME1zYVVKQlFYWkRMRVZCUVd0RlF5eFhRVUZzUlN4RlFVRXlSanRCUVVOMlJpeFRRVUZSUml4SlFVRkpMRU5CUVVOSExFMUJRVXdzUzBGQlowSXNRMEZCYWtJc1NVRkJkMEpHTEdsQ1FVRnBRaXhKUVVGSlJDeEpRVUZKTEVOQlFVTXNRMEZCUkN4RFFVRnFSQ3hIUVVGM1JFRXNTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkJOVVFzUjBGQmEwVkZMRmRCUVZjc1JVRkJjRVk3UVVGRFNEczdTVUZQUzBVc1owSTdRVUZKUml3NFFrRkJZenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVOV0xGTkJRVXRETEZOQlFVd3NSMEZCYVVJc1JVRkJha0k3UVVGRFFTeFRRVUZMUXl4VlFVRk1MRWRCUVd0Q0xFbEJRV3hDTzBGQlEwZzdPenM3TmtKQlJYZENPMEZCUTNKQ0xGVkJRVTFETEZGQlFXdERMRWRCUVVjN1FVRkRka05ETEZGQlFVRkJMRTlCUVU4c1JVRkJSU3h0UWtGQlRTeERRVU5rTEVOQlJuTkRPMEZCUjNaRFF5eFJRVUZCUVN4TlFVRk5MRVZCUVVVc2EwSkJRVTBzUTBGRFlqdEJRVXB6UXl4UFFVRXpRenRCUVUxQkxGZEJRVXRLTEZOQlFVd3NRMEZCWlVzc1NVRkJaaXhEUVVGdlFrZ3NVVUZCY0VJN1FVRkRRU3hoUVVGUExFbEJRVWxKTEU5QlFVb3NRMEZCV1N4VlFVRkRTQ3hQUVVGRUxFVkJRVlZETEUxQlFWWXNSVUZCY1VJN1FVRkRjRU5HTEZGQlFVRkJMRkZCUVZFc1EwRkJRME1zVDBGQlZDeEhRVUZ0UWtFc1QwRkJia0k3UVVGRFFVUXNVVUZCUVVFc1VVRkJVU3hEUVVGRFJTeE5RVUZVTEVkQlFXdENRU3hOUVVGc1FqdEJRVU5JTEU5QlNFMHNRMEZCVUR0QlFVbElPenM3TkVKQlJVOUhMRXNzUlVGQll6dEJRVU5zUWl4WFFVRkxReXhSUVVGTUxFTkJRV01zVlVGQlFVNHNVVUZCVVR0QlFVRkJMR1ZCUVVsQkxGRkJRVkVzUTBGQlEwTXNUMEZCVkN4RFFVRnBRa2tzUzBGQmFrSXNRMEZCU2p0QlFVRkJMRTlCUVhSQ08wRkJRMGc3T3pzeVFrRkZUVVVzU3l4RlFVRmpPMEZCUTJwQ0xGZEJRVXRFTEZGQlFVd3NRMEZCWXl4VlFVRkJUaXhSUVVGUk8wRkJRVUVzWlVGQlNVRXNVVUZCVVN4RFFVRkRSU3hOUVVGVUxFTkJRV2RDU3l4TFFVRm9RaXhEUVVGS08wRkJRVUVzVDBGQmRFSTdRVUZEU0RzN096WkNRVVZSUXl4blFpeEZRVUZuUlR0QlFVRkJMRlZCUXpkRVZpeFRRVVEyUkN4SFFVTXZReXhKUVVRclF5eERRVU0zUkVFc1UwRkVOa1E3UVVGRmNrVXNWMEZCUzBFc1UwRkJUQ3hIUVVGcFFpeEZRVUZxUWpzN1FVRkRRU3hWUVVGSkxFdEJRVXRETEZWQlFWUXNSVUZCY1VJN1FVRkRha0lzWVVGQlMwRXNWVUZCVER0QlFVTklPenRCUVVORVJDeE5RVUZCUVN4VFFVRlRMRU5CUVVOWExFOUJRVllzUTBGQmEwSXNWVUZCUVZRc1VVRkJVVHRCUVVGQkxHVkJRVWxSTEdkQ1FVRm5RaXhEUVVGRFVpeFJRVUZFTEVOQlFYQkNPMEZCUVVFc1QwRkJNVUk3UVVGRFNEczdPenM3TzBGQlIwd3NVMEZCVTFVc1pVRkJWQ3hEUVVGNVFrTXNRMEZCZWtJc1JVRkJORU03UVVGRGVFTXNUVUZCVFVNc1MwRkJTeXhIUVVGSExGVkJRVWRFTEVOQlFVTXNTVUZCU1N4RlFVRlNMRVZCUVdGRkxFdEJRV0lzUTBGQmJVSXNSMEZCYmtJc1JVRkRWRU1zUjBGRVV5eERRVU5NTEZWQlFVRkRMRU5CUVVNN1FVRkJRU3hYUVVGSlF5eE5RVUZOTEVOQlFVTkVMRU5CUVVRc1EwRkJWanRCUVVGQkxFZEJSRWtzUlVGRlZFVXNTMEZHVXl4RFFVVklMRU5CUmtjc1JVRkZRU3hEUVVaQkxFTkJRV1E3TzBGQlIwRXNVMEZCVDB3c1MwRkJTeXhEUVVGRGFFSXNUVUZCVGl4SFFVRmxMRU5CUVhSQ0xFVkJRWGxDTzBGQlEzSkNaMElzU1VGQlFVRXNTMEZCU3l4RFFVRkRWQ3hKUVVGT0xFTkJRVmNzUTBGQldEdEJRVU5JT3p0QlFVTkVMRk5CUVU5VExFdEJRVXNzUTBGQlF5eERRVUZFTEVOQlFVd3NSMEZCVnl4UFFVRllMRWRCUVhGQ1FTeExRVUZMTEVOQlFVTXNRMEZCUkN4RFFVRk1MRWRCUVZjc1NVRkJhRU1zUjBGQmRVTkJMRXRCUVVzc1EwRkJReXhEUVVGRUxFTkJRVzVFTzBGQlEwZzdPMEZCUlVRc1UwRkJVMDBzYVVKQlFWUXNRMEZCTWtKRExHRkJRVE5DTEVWQlFYZEdPMEZCUTNCR0xFMUJRVTFETEU5QlFVOHNSMEZCUjFZc1pVRkJaU3hEUVVGRFV5eGhRVUZoTEVsQlFVa3NVVUZCYkVJc1EwRkJMMEk3UVVGRFFTeFRRVUZQTzBGQlEwaERMRWxCUVVGQkxFOUJRVThzUlVGQlVFRXNUMEZFUnp0QlFVVklReXhKUVVGQlFTeHRRa0ZCYlVJc1JVRkJSVVFzVDBGQlR5eEhRVUZITEV0QlJqVkNPMEZCUjBoRkxFbEJRVUZCTEc5Q1FVRnZRaXhGUVVGRlJpeFBRVUZQTEVsQlFVa3NTMEZJT1VJN1FVRkpTRWNzU1VGQlFVRXNXVUZCV1N4RlFVRkZTQ3hQUVVGUExFbEJRVWtzUzBGS2RFSTdRVUZMU0Vrc1NVRkJRVUVzVTBGQlV5eEZRVUZGTzBGQlRGSXNSMEZCVUR0QlFVOUlPenRCUVVWRUxGTkJRVk5ETEdOQlFWUXNRMEZCZDBKRExFdEJRWGhDTEVWQlFTdENPMEZCUXpOQ0xGTkJRVThzVlVGQlEwTXNTMEZCUkN4RlFVRlJReXhQUVVGU0xFVkJRVzlDTzBGQlEzWkNMRmRCUVU4c1NVRkJTWGhDTEU5QlFVb3NRMEZCV1N4VlFVRkRTQ3hQUVVGRUxFVkJRVlZETEUxQlFWWXNSVUZCY1VJN1FVRkRjRU1zVlVGQlRUSkNMRmxCUVhWRExFZEJRVWRFTEU5QlFVOHNRMEZCUTBNc1dVRkJlRVE3UVVGRFFTeFZRVUZKUXl4WlFVRlpMRWRCUVVkR0xFOUJRVzVDT3p0QlFVTkJMRlZCUVVsRExGbEJRVW9zUlVGQmEwSTdRVUZEWkN4WlFVRk5SU3hWUVVGVkxFZEJRVWRETEUxQlFVMHNRMEZCUTBNc1pVRkJVQ3hIUVVGNVFpeEpRVUZKUkN4TlFVRk5MRU5CUVVORExHVkJRVmdzUlVGQmVrSXNSMEZCZDBRc1NVRkJNMFU3TzBGQlEwRXNXVUZCU1VZc1ZVRkJTaXhGUVVGblFqdEJRVU5hUkN4VlFVRkJRU3haUVVGWkxHMURRVU5NUml4UFFVUkxPMEZCUlZKTkxGbEJRVUZCTEUxQlFVMHNSVUZCUlVnc1ZVRkJWU3hEUVVGRFJ6dEJRVVpZTEZsQlFWbzdRVUZKU0RzN1FVRkRSRU1zVVVGQlFVRXNWVUZCVlN4RFFVRkRMRmxCUVUwN1FVRkRZbXBETEZWQlFVRkJMRTFCUVUwc1EwRkJRMnRETEN0Q1FVRmxReXh2UWtGQlppeERRVUZ2UTBNc2FVTkJRWEJETEVOQlFVUXNRMEZCVGpzN1FVRkRRU3hqUVVGSlVDeFZRVUZLTEVWQlFXZENPMEZCUTFwQkxGbEJRVUZCTEZWQlFWVXNRMEZCUTFFc1MwRkJXRHRCUVVOSU8wRkJRMG9zVTBGTVV5eEZRVXRRVml4WlFVeFBMRU5CUVZZN1FVRk5TRHM3UVVGRFJFZ3NUVUZCUVVFc1MwRkJTeXhEUVVGRFF5eExRVUZFTEVWQlFWRkhMRmxCUVZJc1EwRkJUQ3hEUVVFeVFsVXNTVUZCTTBJc1EwRkJaME4yUXl4UFFVRm9ReXhGUVVGNVEwTXNUVUZCZWtNN1FVRkRTQ3hMUVc1Q1RTeERRVUZRTzBGQmIwSklMRWRCY2tKRU8wRkJjMEpJT3p0SlFVZHZRblZETEdkQ096czdPenRCUVhGQ2FrSXNORUpCUVZsRExFOUJRVm9zUlVGQmRVTTdRVUZCUVRzN1FVRkJRVHM3UVVGRGJrTXNPRUpCUVUxQkxFOUJRVTQ3TzBGQlJHMURPenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVWdVF5eFZRVUZMUXl4aFFVRk1MRWRCUVhGQ0xFbEJRWEpDTzBGQlEwRXNWVUZCUzBNc2NVSkJRVXdzUjBGQk5rSXNTVUZCTjBJN1FVRkRRU3hWUVVGTFF5eHRRa0ZCVEN4SFFVRXlRaXhKUVVFelFqdEJRVU5CTEZWQlFVdERMRTFCUVV3c1IwRkJZeXhKUVVGa08wRkJRMEVzVlVGQlMwTXNVVUZCVEN4SFFVRm5RaXhKUVVGb1FqdEJRVU5CTEZWQlFVdERMR0ZCUVV3c1IwRkJjVUlzU1VGQmNrSTdRVUZEUVN4VlFVRkxReXhwUWtGQlRDeEhRVUY1UWl4RFFVRkRReXhKUVVGSkxFTkJRVU5ETEVkQlFVd3NTMEZCWVN4TFFVRmtMRVZCUVhGQ1F5eFJRVUZ5UWl4RFFVRTRRaXhGUVVFNVFpeERRVUY2UWpzN1FVRkRRU3hUUVVGTExFbEJRVWxETEVOQlFVTXNSMEZCUnl4RFFVRmlMRVZCUVdkQ1FTeERRVUZETEVkQlFVY3NSVUZCY0VJc1JVRkJkMEpCTEVOQlFVTXNTVUZCU1N4RFFVRTNRaXhGUVVGblF6dEJRVU0xUWl4VlFVRk5ReXhWUVVGVkxFZEJRVWRETEVsQlFVa3NRMEZCUTBNc1MwRkJUQ3hEUVVGWFJDeEpRVUZKTEVOQlFVTkZMRTFCUVV3c1MwRkJaMElzUjBGQk0wSXNSVUZCWjBOTUxGRkJRV2hETEVOQlFYbERMRVZCUVhwRExFTkJRVzVDTzBGQlEwRXNXVUZCUzBnc2FVSkJRVXdzWVVGQk5FSXNUVUZCUzBFc2FVSkJRV3BETEZOQlFYRkVTeXhWUVVGeVJEdEJRVU5JT3p0QlFVTkVMRlZCUVV0SkxHbENRVUZNTEVkQlFYbENMRU5CUVhwQ08wRkJRMEVzVlVGQlMwTXNWVUZCVEN4SFFVRnJRbnBETEdsQ1FVRnBRaXhGUVVGdVF6dEJRVU5CTEZWQlFVc3dReXh2UWtGQlRDeEhRVUUwUWl4RlFVRTFRanRCUVdadFF6dEJRV2RDZEVNN096czdkME5CUlcxQ01VUXNUU3hGUVVGMVFqdEJRVU4yUXl4WFFVRkxNRVFzYjBKQlFVd3NRMEZCTUVKNlJDeEpRVUV4UWl4RFFVRXJRa1FzVFVGQkwwSTdRVUZEU0RzN096QkRRVVZ4UWtFc1RTeEZRVUYxUWp0QlFVTjZReXhWUVVGTk1rUXNTMEZCU3l4SFFVRkhMRXRCUVV0RUxHOUNRVUZNTEVOQlFUQkNSU3hQUVVFeFFpeERRVUZyUXpWRUxFMUJRV3hETEVOQlFXUTdPMEZCUTBFc1ZVRkJTVEpFTEV0QlFVc3NTVUZCU1N4RFFVRmlMRVZCUVdkQ08wRkJRMW9zWVVGQlMwUXNiMEpCUVV3c1EwRkJNRUpITEUxQlFURkNMRU5CUVdsRFJpeExRVUZxUXl4RlFVRjNReXhEUVVGNFF6dEJRVU5JTzBGQlEwbzdPenN3UTBGRmNVSTdRVUZEYkVJc1ZVRkJUVWNzVDBGQlR5eEhRVUZITEV0QlFVdEtMRzlDUVVGeVFqdEJRVU5CTEZkQlFVdEJMRzlDUVVGTUxFZEJRVFJDTEVWQlFUVkNPenRCUVVOQkxGVkJRVTFMTEVkQlFVY3NSMEZCUnpkQ0xDdENRVUZsUXl4dlFrRkJaaXhEUVVGdlF5eEZRVUZ3UXl4RFFVRmFPenRCUVVOQk1rSXNUVUZCUVVFc1QwRkJUeXhEUVVGRGRrUXNUMEZCVWl4RFFVRm5RaXhWUVVGRFVDeE5RVUZFTEVWQlFWazdRVUZEZUVJc1dVRkJTVHRCUVVOQlFTeFZRVUZCUVN4TlFVRk5MRU5CUVVNclJDeEhRVUZFTEVOQlFVNDdRVUZEU0N4VFFVWkVMRU5CUlVVc1owSkJRVTBzUTBGRFVEdEJRVU5LTEU5QlRFUTdRVUZOU0RzN096czdPenM3TzBGQlIwY3NjVUpCUVV0RExFMUJRVXdzUjBGQll5eExRVUZMZUVJc1QwRkJUQ3hEUVVGaGVVSXNVMEZCWWl4RFFVRjFRa01zTWtKQlFYWkNMRU5CUVdRN1FVRkRRU3h4UWtGQlMwTXNXVUZCVEN4SFFVRnZRaXhKUVVGSlF5d3dRa0ZCU2l4RFFVRXJRaXhKUVVFdlFpeEZRVUZ4UXl4alFVRnlReXhGUVVGeFJDeGhRVUZ5UkN4RFFVRndRanRCUVVOQkxIRkNRVUZMUXl4UlFVRk1MRWRCUVdkQ0xFbEJRVWxFTERCQ1FVRktMRU5CUVN0Q0xFbEJRUzlDTEVWQlFYRkRMRlZCUVhKRExFVkJRV2xFTEZOQlFXcEVMRU5CUVdoQ08wRkJRMEVzY1VKQlFVdEZMRTFCUVV3c1IwRkJZeXhKUVVGSlJpd3dRa0ZCU2l4RFFVRXJRaXhKUVVFdlFpeEZRVUZ4UXl4UlFVRnlReXhGUVVFclF5eFBRVUV2UXl4RFFVRmtPMEZCUTBFc2NVSkJRVXRITEZGQlFVd3NSMEZCWjBJc1NVRkJTVWdzTUVKQlFVb3NRMEZCSzBJc1NVRkJMMElzUlVGQmNVTXNWVUZCY2tNc1JVRkJhVVFzVTBGQmFrUXNRMEZCYUVJN1FVRkRRU3h4UWtGQlMwa3NhVUpCUVV3c1IwRkRTU3hKUVVGSlNpd3dRa0ZCU2l4RFFVRXJRaXhKUVVFdlFpeEZRVUZ4UXl4dFFrRkJja01zUlVGQk1FUXNhVUpCUVRGRUxFTkJSRW83T3pzN096czdPenM3T3pzN096czdPenRyUTBGSmEwSTdRVUZCUVRzN1FVRkRiRUlzWVVGQlR5d3JRa0ZCUzNwQ0xHMUNRVUZNTEdkR1FVRXdRamhDTEU5QlFURkNMRXRCUVhGRExFVkJRVFZETzBGQlEwZzdPenM3TWtkQlJXOUNha1FzU3l4RlFVRlphMFFzVXpzN096czdPenQxUWtGRFRteEVMRXRCUVVzc1EwRkJRMnRFTEZOQlFVUXNRenM3TzBGQlFYUkNReXhuUWtGQlFVRXNVVHM3TzNWQ1FVVjVRa0VzVVVGQlVTeERRVUZEUXl4SlFVRlVMRVU3T3p0QlFVRnlRa01zWjBKQlFVRkJMRms3UVVGRFFVTXNaMEpCUVVGQkxGa3NSMEZCWlVNc1NVRkJTU3hEUVVGRFF5eExRVUZNTEVOQlFWZElMRmxCUVZnc1F6dEJRVU55UWl4eFFrRkJTM0JDTEZWQlFVd3NSMEZCYTBKNlF5eHBRa0ZCYVVJc1EwRkJRemhFTEZsQlFWa3NRMEZCUTBjc1NVRkJZaXhEUVVGclFrTXNTVUZCYkVJc1EwRkJkVUpvUlN4UFFVRjRRaXhEUVVGdVF6czdPenM3T3pzN08zTkNRVWRCZVVRc1VVRkJVU3hEUVVGRFVTeFZRVUZVTEV0QlFYZENMRWs3T3pzN08ydEVRVU5xUWxJc1VVRkJVU3hEUVVGRFV5eEhPenM3YzBKQlJXaENWQ3hSUVVGUkxFTkJRVU5STEZWQlFWUXNTMEZCZDBJc1N6czdPenM3YTBSQlEycENMRVU3T3p0QlFVVk1SU3huUWtGQlFVRXNZeXhIUVVGcFFrTXNNRUpCUVZOT0xFdEJRVlFzUTBGQlpVNHNVMEZCWml4RlFVTnNRbUVzVVVGRWEwSXNRMEZEVkR0QlFVRkJMSGxDUVVGTkxFVkJRVTQ3UVVGQlFTeHBRa0ZFVXl4RlFVVnNRbkpETEZGQlJtdENMRWRCUjJ4Q2MwTXNWMEZJYTBJc1JUdEJRVWxxUWtNc1owSkJRVUZCTEdkQ0xFZEJRVzFDU0N3d1FrRkJVMDRzUzBGQlZDeERRVUZsVEN4UlFVRlJMRU5CUVVOVExFZEJRWGhDTEVWQlEzQkNSeXhSUVVSdlFpeERRVU5ZTzBGQlFVRXNlVUpCUVUwc1JVRkJUanRCUVVGQkxHbENRVVJYTEVWQlJYQkNja01zVVVGR2IwSXNSMEZIY0VKelF5eFhRVWh2UWl4Rk8ydEVRVWxzUWtNc1owSkJRV2RDTEV0QlFVdEtMR05CUVhKQ0xFZEJRWE5EVml4UlFVRlJMRU5CUVVOVExFZEJRUzlETEVkQlFYRkVMRVU3T3pzN096czdPenM3T3pzN096czdPenM3T3pKRFFWZHVSRTBzYTBJN096czdPenRCUVVGQlFTeG5Ra0ZCUVVFc2EwSXNaME5CUVcxQ1F5eE5MRVZCUVhGRE8wRkJRemRFTEhOQ1FVRk5ReXhUUVVGVExFZEJRVWRPTERCQ1FVRlRUaXhMUVVGVUxFTkJRV1ZYTEUxQlFXWXNSVUZEWWtVc1YwRkVZU3hEUVVORUxGVkJRVUZvUml4RFFVRkRPMEZCUVVFc01rSkJRVXRCTEVOQlFVTXNTMEZCU3l4VFFVRk9MRWRCUVd0Q1FTeERRVUZzUWl4SFFVRnpRaXhWUVVFelFqdEJRVUZCTEcxQ1FVUkJMRVZCUldKcFJpeFBRVVpoTEVOQlJVd3NWVUZCUVdwR0xFTkJRVU03UVVGQlFTeHhRMEZCVDBFc1EwRkJVRHRCUVVGQkxHMUNRVVpKTEVOQlFXeENPenRCUVVkQkxITkNRVUZOYTBZc1NVRkJTU3hIUVVGSFNDeFRRVUZUTEVOQlFVTXhReXhSUVVGV0xFVkJRV0k3UVVGRFFTeHpRa0ZCVFRoRExFVkJRVVVzUjBGQlIwb3NVMEZCVXl4RFFVTm1ReXhYUVVSTkxFTkJRMDBzVlVGQlFXaEdMRU5CUVVNN1FVRkJRU3d5UWtGQlMwRXNRMEZCUXl4TFFVRkxMRk5CUVU0c1IwRkJhMElzVDBGQmJFSXNSMEZCTkVJc1VVRkJha003UVVGQlFTeHRRa0ZFVUN4RlFVVk9jVU1zVVVGR1RTeEZRVUZZTzBGQlIwRXNlVUpCUVU4N1FVRkRTSFZDTEc5Q1FVRkJRU3hQUVVGUExFVkJRVVZ6UWl4SlFVUk9PMEZCUlVoRkxHOUNRVUZCUVN4TFFVRkxMRVZCUVVWRUxFVkJSa283UVVGSFNIaEZMRzlDUVVGQlFTeExRVUZMTEVWQlFVVXdSU3hqUVVGakxFTkJRVU14UlN4TFFVaHVRanRCUVVsSU1rVXNiMEpCUVVGQkxGTkJRVk1zUlVGQlJVUXNZMEZCWXl4RFFVRkRRenRCUVVwMlFpeHRRa0ZCVUR0QlFVMUlMR2xDT3p0QlFYSkNTMjVETEdkQ1FVRkJRU3hOTEVkQlFWTXNTMEZCUzBFc1RUdEJRVU5rYTBNc1owSkJRVUZCTEdNc1IwRkJhVUpGTEhGQ1FVRlZSaXhqT3p0dlFrRkROVUpCTEdNN096czdPM05DUVVOTFJ5eExRVUZMTEVOQlFVTXNaME5CUVVRc1F6czdPMEZCUlZRM1JTeG5Ra0ZCUVVFc1N5eEhRVUZSTUVVc1kwRkJZeXhEUVVGRE1VVXNTenQxUkVGclFsSjNReXhOUVVGTkxFTkJRVU5wUWl4SlFVRlFMRU5CUVZseFFpeFBPenM3T3pzN096czdPenRCUVVGMFFsZ3NaMEpCUVVGQkxFMDdRVUZEUkZrc1owSkJRVUZCTEZrc1IwRkJaV0lzYTBKQlFXdENMRU5CUVVORExFMUJRVVFzUXpzN08zVkNRVWxXTEV0QlFVdGhMR05CUVV3c1EwRkRja0pvUml4TFFVUnhRaXhaUVVWc1FpdEZMRmxCUVZrc1EwRkJRemxDTEU5QlJrc3NiME03T3p0QlFVRnVRbFVzWjBKQlFVRkJMRlU3TzBGQlNVNHNiMEpCUVVsQkxGVkJRVlVzUzBGQlN5eEZRVUZ1UWl4RlFVRjFRanRCUVVOaVV5eHJRa0ZCUVVFc1UwRkVZU3hIUVVORVRpd3dRa0ZCVTA0c1MwRkJWQ3hEUVVGbFJ5eFZRVUZtTEVWQlEySkpMRkZCUkdFc1EwRkRTaXhWUVVGQmEwSXNRMEZCUXp0QlFVRkJMREpDUVVGSkxFVkJRVW83UVVGQlFTeHRRa0ZFUnl4RFFVUkRPMEZCUjI1Q1JpeHJRa0ZCUVVFc1dVRkJXU3hEUVVGRE9VSXNUMEZCWWl4SFFVRjFRbTFDTEZOQlFWTXNRMEZCUXpGRExGRkJRVllzUlVGQmRrSTdRVUZEUVhGRUxHdENRVUZCUVN4WlFVRlpMRU5CUVVOT0xFdEJRV0lzUjBGQmNVSk1MRk5CUVZNc1EwRkRla0pETEZkQlJHZENMRU5CUTBvc1ZVRkJRV2hHTEVOQlFVTTdRVUZCUVN3eVFrRkJTMEVzUTBGQlF5eExRVUZMTEZOQlFVNHNSMEZCYTBJc1QwRkJiRUlzUjBGQk5FSXNVVUZCYWtNN1FVRkJRU3h0UWtGRVJ5eEZRVVZvUW5GRExGRkJSbWRDTEVWQlFYSkNPMEZCUjBnN08ydEVRVU5OY1VRc1dUczdPenM3UVVGRlVDeHZRa0ZCUjNaRExFMUJRVTBzUTBGQlF6QkRMR05CUVZZc1JVRkJNRUpETEU5QlFVOHNRMEZCUTBNc1IwRkJVaXd3UTBGQk5rTnFRaXhOUVVFM1F5eG5Ra0ZCSzBRN1FVRkRja1pyUWl4clFrRkJRVUVzVDBGQlR5eEZRVUZGTEdGQlFVMUJMRTlCUVU0c1NVRkJhVUlzWVVGQlRUTkVMRkZCUVU0c1JVRkVNa1E3UVVGRmNrWXJRaXhyUWtGQlFVRXNTVUZCU1N4RlFVRkZPMEZCUTBZMlFpeHZRa0ZCUVVFc1VVRkJVU3hGUVVGRlVDeFpRVUZaTEVOQlFVTTVRaXhQUVVSeVFqdEJRVVZHYzBNc2IwSkJRVUZCTEUxQlFVMHNSVUZCUlZJc1dVRkJXU3hEUVVGRFRqdEJRVVp1UWp0QlFVWXJSU3hwUWtGQkwwUTdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3p0clJFRlRNMEpRTEd0Q1FVRnJRaXhEUVVGRE1VSXNUVUZCVFN4RFFVRkRhVUlzU1VGQlVDeERRVUZaY1VJc1QwRkJXaXhEUVVGdlFpeERRVUZ3UWl4RFFVRkVMRU03T3pzN096czdPenM3T3pzN096czdPenM3TUVkQlIxUlZMRWs3T3pzN096dDFRa0ZEVml4TFFVRkxReXh4UWtGQlRDeERRVUV5UWtRc1NVRkJNMElzUXpzN08ydEVRVU5ETEV0QlFVdDJSQ3hWT3pzN096czdPenM3T3pzN096czdPenM3T3pSSFFVZE5kVVFzU1RzN096czdPenQxUWtGRFR5eExRVUZMUlN4aFFVRk1MRU5CUVcxQ1JpeEpRVUZ1UWl4RE96czdRVUZCYmtKMlJDeG5Ra0ZCUVVFc1ZUdEJRVU5CT0VNc1owSkJRVUZCTEZrc1IwRkJaU3hMUVVGTE5VUXNiVUk3TzNOQ1FVTjBRalJFTEZsQlFWa3NTVUZCU1RsRExGVkJRVlVzUTBGQlEzQkRMRmxCUVROQ0xFbEJRVEpEYjBNc1ZVRkJWU3hEUVVGRGJrTXNVMEZCV0N4TFFVRjVRaXhKT3pzN096czdRVUZGTVVRMlJpeG5Ra0ZCUVVFc1N5eEhRVUZSYmtVc1NVRkJTU3hEUVVGRFF5eEhRVUZNTEVVc1JVRkRaRHM3TzNWQ1FVTjFRbk5FTEZsQlFWa3NRMEZCUXk5RkxFdEJRV0lzVjBGQmMwSXJSU3haUVVGWkxFTkJRVU01UWl4UFFVRnVReXhwUXpzN08wRkJRV3BDUlN4blFrRkJRVUVzVVR0QlFVTkJlVU1zWjBKQlFVRkJMRWNzUjBGQlRYQkZMRWxCUVVrc1EwRkJRME1zUjBGQlRDeEZPenQxUWtGRFpUQkNMRkZCUVZFc1EwRkJRekJETEVsQlFWUXNSVHM3TzBGQlFYSkNReXhuUWtGQlFVRXNXVHRCUVVOQlF5eG5Ra0ZCUVVFc1ZTeEhRVUZoUkN4WlFVRlpMRU5CUVVOeVF5eEpRVUZpTEVOQlFXdENReXhKUVVGc1FpeERRVUYxUW5ORExFazdRVUZETVVNdlJDeG5Ra0ZCUVVFc1ZVRkJWU3hEUVVGRGJrTXNVMEZCV0N4SFFVRjFRaXRDTEVsQlFVa3NRMEZCUTBNc1MwRkJUQ3hEUVVGWGFVVXNWVUZCVlN4SlFVRkpTaXhMUVVGTExFZEJRVWNzUTBGQlEwTXNSMEZCUnl4SFFVRkhSQ3hMUVVGUUxFbEJRV2RDTEVOQlFUVkNMRU5CUVhKQ0xFTkJRWFpDT3pzN096czdPMEZCUlVFc2IwSkJRVWR1UkN4TlFVRk5MRU5CUVVNd1F5eGpRVUZXTEVWQlFUQkNReXhQUVVGUExFTkJRVU5ETEVkQlFWSXNRMEZCV1N4TFFVRmFPenM3YTBSQlJ6TkNia1FzVlVGQlZTeERRVUZEYmtNc1UwRkJXQ3hKUVVGM1FpeERPenM3T3pzN096czdPenM3T3pzN096czdPM05IUVVkdVFqQkdMRWs3T3pzN096czdkVUpCUTFrc1MwRkJTMU1zWlVGQlRDeERRVUZ4UWxRc1NVRkJja0lzUXpzN08wRkJRV3hDTVVZc1owSkJRVUZCTEZNN2EwUkJRME13UWl4SlFVRkpMRU5CUVVORExFZEJRVXdzUzBGQllUTkNMRk03T3pzN096czdPenM3T3pzN096czdPenN3UTBGSFJqdEJRVU5zUWl4VlFVRkpMRXRCUVV0dFF5eFZRVUZVTEVWQlFYRkNPMEZCUTJwQ0xHRkJRVXRCTEZWQlFVd3NRMEZCWjBKdVF5eFRRVUZvUWl4SFFVRTBRaXhKUVVFMVFqdEJRVU5JTzBGQlEwbzdPenN3UTBGRk5rSTdRVUZETVVJc1YwRkJTMnRETEdsQ1FVRk1MRWxCUVRCQ0xFTkJRVEZDTzBGQlEwRXNkVUpCUVZVc1MwRkJTMVFzYVVKQlFXWXNVMEZCYlVNc1MwRkJTMU1zYVVKQlFVd3NRMEZCZFVKT0xGRkJRWFpDTEVOQlFXZERMRVZCUVdoRExFTkJRVzVETzBGQlEwZzdPenM3TmtkQlJYTkNkMFVzV1RzN096czdjMEpCUTJaQkxGbEJRVmtzUTBGQlEyaEpMRTFCUVdJc1MwRkJkMElzUXpzN096czdPenM3TzNWQ1FVZG9RaXhMUVVGTGQwZ3NZVUZCVEN4Rk96czdiVU5CUVhOQ0wwWXNiVUk3T3pzN096czdPenQxUWtGSE5VSXNTMEZCUzNkSExHVkJRVXdzZFVsQlJVVTdRVUZEU2tRc2EwSkJRVUZCTEZsQlFWa3NSVUZCV2tFN1FVRkVTU3hwUWtGR1JpeERPenM3T3pzN096czdPenM3T3pzN096czdPelpIUVU5aFJTeFZPenM3T3pzN08zVkNRVU5GTEV0QlFVdERMRXRCUVV3c1EwRkJWeXg1UWtGQldDeEZRVUZ6UTBNc1UwRkJkRU1zUlVGQmFVUkdMRlZCUVdwRUxFTTdPenRCUVVGbVJ5eG5Ra0ZCUVVFc1RUdHJSRUZEUTBFc1RVRkJUU3hEUVVGRE9VTXNTVUZCVUN4RFFVRlpLME1zWjBJN096czdPenM3T3pzN096czdPenM3T3pzN2FVaEJSMGxLTEZVN096czdPenM3ZFVKQlEwWXNTMEZCUzBNc1MwRkJUQ3hEUVVGWExEWkNRVUZZTEVWQlFUQkRReXhUUVVFeFF5eEZRVUZ4UkVZc1ZVRkJja1FzUXpzN08wRkJRV1pITEdkQ1FVRkJRU3hOTzJ0RVFVTkRRU3hOUVVGTkxFTkJRVU01UXl4SlFVRlFMRU5CUVZsblJDeHZRanM3T3pzN096czdPenM3T3pzN096czdPenR4U0VGSFQwd3NWVHM3T3pzN096dDFRa0ZEVEN4TFFVRkxReXhMUVVGTUxFTkJRVmNzWjBOQlFWZ3NSVUZCTmtORExGTkJRVGRETEVWQlFYZEVSaXhWUVVGNFJDeERPenM3UVVGQlprY3NaMEpCUVVGQkxFMDdiVVJCUTBOQkxFMUJRVTBzUTBGQlF6bERMRWxCUVZBc1EwRkJXV2xFTEhWQ096czdPenM3T3pzN096czdPenM3T3pzN096QkhRVWRLUXl4UkxFVkJRWEZDVUN4Vk96czdPenM3TzIxRVFVTTNRaXhMUVVGTGNFWXNUMEZCVEN4RFFVRmhORVlzUzBGQllpeERRVUZ0UWl4elFrRkJia0k3UVVGQlFTd3dSa0ZCTWtNc2JVSkJRVTl3UWl4SlFVRlFPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFTd3JSRUZEZGtNc1RVRkJTU3hEUVVGRFZ5eGxRVUZNTEc5SVFVVklPMEZCUTBGUkxEaENRVUZCUVN4UlFVRlJMRVZCUVZKQk8wRkJSRUVzTmtKQlJrY3NSVUZKU201Q0xFbEJTa2tzUTBGRWRVTTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNiVUpCUVRORE96dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMSEZDUVUxS1dTeFZRVTVKTEVNN096czdPenM3T3pzN096czdPenM3T3pzN2MwZEJWVkJUTEVVN096czdPenM3T3pzN1FVRkRRVU1zWjBKQlFVRkJMRk1zYVVWQlFTdENMRVU3UVVGREwwSldMR2RDUVVGQlFTeFZPMjFFUVVWUExFdEJRVXR3Uml4UFFVRk1MRU5CUVdFMFJpeExRVUZpTEVOQlFXMUNMR3RDUVVGdVFqdEJRVUZCTERKR1FVRjFReXh0UWtGQlQzQkNMRWxCUVZBN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU14UTBFc05FSkJRVUZCTEVsQlFVa3NRMEZCUTNWQ0xFMUJRVXdzUTBGQldTeFJRVUZhTEVWQlFYTkNPMEZCUTJ4Q1F5dzRRa0ZCUVVFc1VVRkJVU3hGUVVGRlNDeEZRVVJSTzBGQlJXeENReXc0UWtGQlFVRXNVMEZCVXl4RlFVRlVRVHRCUVVaclFpdzJRa0ZCZEVJN1FVRkVNRU1zSzBSQlMyNURMRTFCUVVrc1EwRkJRMWdzWlVGQlRDeERRVUZ4UWxVc1JVRkJja0lzUlVGQmVVSkRMRk5CUVhwQ0xFVkJRVzlEZEVJc1NVRkJjRU1zUTBGTWJVTTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNiVUpCUVhaRE96dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMSEZDUVUxS1dTeFZRVTVKTEVNN096czdPenM3T3pzN096czdPenM3T3pzN2JVZEJWVkJUTEVVN096czdPenM3T3pzN08wRkJRMEZETEdkQ1FVRkJRU3hUTEdsRlFVRXJRaXhGTzBGQlF5OUNWaXhuUWtGQlFVRXNWVHRCUVVOQllTeG5Ra0ZCUVVFc1R6dHRSRUZGVHl4TFFVRkxha2NzVDBGQlRDeERRVUZoTkVZc1MwRkJZaXhEUVVGdFFpeGxRVUZ1UWp0QlFVRkJMREpHUVVGdlF5eHRRa0ZCVDNCQ0xFbEJRVkE3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTjJRMEVzTkVKQlFVRkJMRWxCUVVrc1EwRkJRM1ZDTEUxQlFVd3NRMEZCV1N4UlFVRmFMRVZCUVhOQ08wRkJRMnhDVml3NFFrRkJRVUVzUzBGQlN5eEZRVUZGVVN4RlFVUlhPMEZCUld4Q1F5dzRRa0ZCUVVFc1UwRkJVeXhGUVVGVVFUdEJRVVpyUWl3MlFrRkJkRUk3UVVGRWRVTXNLMFJCUzJoRExFMUJRVWtzUTBGQlEwa3NXVUZCVEN4RFFVRnJRa3dzUlVGQmJFSXNSVUZCYzBKRExGTkJRWFJDTEVWQlFXbERkRUlzU1VGQmFrTXNSVUZCZFVONVFpeFBRVUYyUXl4RFFVeG5RenM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3h0UWtGQmNFTTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzY1VKQlRVcGlMRlZCVGtrc1F6czdPenM3T3pzN096czdPenM3T3pzN096czJSMEZUVjFNc1JUczdPenM3T3pzN08wRkJRVmxETEdkQ1FVRkJRU3hUTEdsRlFVRXJRaXhGTzBGQlFVbDBRaXhuUWtGQlFVRXNTVHRCUVVNelJIZENMR2RDUVVGQlFTeFJMRWRCUVZjc05FSkJRVWtzUTBGQlEwZ3NSVUZCUkN4RFFVRktMRU03YlVSQlExWXNTMEZCUzAwc1QwRkJUQ3hEUVVGaExGVkJRVU5ETEUxQlFVUTdRVUZCUVN4NVFrRkJXVUVzVFVGQlRTeERRVUZEUXl4TlFVRlFMRU5CUVdNN1FVRkRNVU5NTEc5Q1FVRkJRU3hSUVVGUkxFVkJRVkpCTEZGQlJEQkRPMEZCUlRGRFJpeHZRa0ZCUVVFc1UwRkJVeXhGUVVGVVFTeFRRVVl3UXp0QlFVY3hRemxHTEc5Q1FVRkJRU3hQUVVGUExFVkJRVVU3UVVGRFRITkhMSE5DUVVGQlFTeFRRVUZUTEVWQlFVVTVRanRCUVVST08wRkJTR2xETEcxQ1FVRmtMRU5CUVZvN1FVRkJRU3hwUWtGQllpeERPenM3T3pzN096czdPenM3T3pzN096czdPekJIUVhkQ1VIRkNMRVU3T3pzN096czdPenM3T3pzN096czdPenM3UVVGRFFVTXNaMEpCUVVGQkxGTXNhVVZCUVN0Q0xFVTdRVUZETDBKMFFpeG5Ra0ZCUVVFc1NUdEJRVU5CZVVJc1owSkJRVUZCTEU4N1FVRkZUVm9zWjBKQlFVRkJMRXNzUjBGQlVTdzBRa0ZCU1N4RFFVRkRVU3hGUVVGRUxFTkJRVW9zUXp0QlFVTldWU3huUWtGQlFVRXNWeXhIUVVGakxFYzdRVUZEV2tNc1owSkJRVUZCTEZNc1IwRkJXV2hITEVsQlFVa3NRMEZCUTBNc1IwRkJUQ3hGTzBGQlEyUm5SeXhuUWtGQlFVRXNNRUlzUjBGQk5rSXNTVHRCUVVNelFrTXNaMEpCUVVGQkxIRkNMRWRCUVhkQ1ZDeFBRVUZQTEVsQlFVa3NTMEZCUzNwRkxFMUJRVXdzUTBGQldXMUdMR05CUVZvc1JUczdPM0ZDUVVOc1F5eEpPenM3T3pzN096czdPenM3TzJsRFFVVnpRaXhOUVVGSkxFTkJRVU5zUXl4eFFrRkJUQ3hEUVVFeVFrUXNTVUZCTTBJc1F6czdPMEZCUVdZMFFpd3dRa0ZCUVVFc1RUdEJRVU5CY0Vjc01FSkJRVUZCTEU4c1IwRkJaVHRCUVVOcVFuTkhMRFJDUVVGQlFTeFRRVUZUTEVWQlFVVTVRaXhKUVVSTk8wRkJSV3BDY0VZc05FSkJRVUZCTEZsQlFWa3NSVUZCUlR0QlFVTldSQ3c0UWtGQlFVRXNXVUZCV1N4RlFVRkZNRUlzU1VGQlNTeERRVUZESzBZc1IwRkJUQ3hEUVVOV1JpeHhRa0ZCY1VJc1IwRkJSMFFzTUVKQlJHUXNSVUZGVmpWS0xGZEJSbFU3UVVGRVNqdEJRVVpITERKQ096dHBRMEZUVWl4SlFVRkpZU3hQUVVGS0xFTkJRVmtzVlVGQlEwZ3NUMEZCUkN4RlFVRlZReXhOUVVGV0xFVkJRWEZDTzBGQlF6RkRMSGxHUVVGRE8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTlBjVW9zYzBOQlFVRkJMRkZCUkZBc1IwRkRhMElzU1VGRWJFSTdPMEZCUlZORExITkRRVUZCUVN4VFFVWlVMRWRCUlhGQ0xGTkJRVnBCTEZOQlFWa3NRMEZCUTNaQ0xFMUJRVVFzUlVGQldUdEJRVU14UWl3MFEwRkJTWE5DTEZGQlFVb3NSVUZCWXp0QlFVTldRU3d3UTBGQlFVRXNVVUZCVVN4SFFVRkhMRXRCUVZnN1FVRkRRWFJLTERCRFFVRkJRU3hQUVVGUExFTkJRVU5uU1N4TlFVRkVMRU5CUVZBN1FVRkRTRHRCUVVOS0xIVkRRVkJLT3p0QlFWRlRkMElzYzBOQlFVRkJMRkZCVWxRc1IwRlJiMElzVTBGQldFRXNVVUZCVnl4RFFVRkRiRW9zUzBGQlJDeEZRVUZYTzBGQlEzaENMRFJEUVVGSlowb3NVVUZCU2l4RlFVRmpPMEZCUTFaQkxEQkRRVUZCUVN4UlFVRlJMRWRCUVVjc1MwRkJXRHRCUVVOQmNrb3NNRU5CUVVGQkxFMUJRVTBzUTBGQlEwc3NTMEZCUkN4RFFVRk9PMEZCUTBnN1FVRkRTaXgxUTBGaVNqczdRVUZqUnl4elEwRkJRU3hOUVVGSkxFTkJRVU50U2l4dFFrRkJUQ3hEUVVGNVFrUXNVVUZCZWtJN08wRkJaRWc3UVVGQlFTeHpSRUZuUWs5RUxGTkJhRUpRTzBGQlFVRTdRVUZCUVN3MlEwRm5RblZDVml4TlFVRk5MRU5CUVVObUxFdEJRVkFzUTBGQllUdEJRVU42UWtFc2QwTkJRVUZCTEV0QlFVc3NSVUZCVEVFc1MwRkVlVUk3UVVGRmVrSlRMSGREUVVGQlFTeFRRVUZUTEVWQlFWUkJMRk5CUm5sQ08wRkJSM3BDT1VZc2QwTkJRVUZCTEU5QlFVOHNSVUZCVUVFN1FVRkllVUlzZFVOQlFXSXNRMEZvUW5aQ096dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQmMwSlBLMGNzYzBOQlFVRkJMRkZCUVZFc1pVRkJVanM3UVVGMFFsQTdRVUZCUVRzN1FVRjNRazhzYzBOQlFVRXNUVUZCU1N4RFFVRkRSU3h4UWtGQlRDeERRVUV5UWtZc1VVRkJNMEk3TzBGQmVFSlFPenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMRFpDUVVGRU8wRkJNa0pJTERKQ1FUVkNXU3hET3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPM1ZDUVRoQ1pTeExRVUZMUnl4dFFrRkJUQ3hsT3pzN1FVRkJkRUpETEdkQ1FVRkJRU3hoT3p0elFrRkRSbkJJTEdkQ1FVRm5RaXhEUVVGRGNVZ3NZMEZCYWtJc1EwRkJaME5FTEdGQlFXaERMRXRCUTBjc1EwRkJReXhMUVVGTE0wWXNUVUZCVEN4RFFVRlpOa1lzTkVKQlFWb3NRMEZCZVVOaUxGTkJRWHBETEVNN096czdPenM3T3pzN08wRkJRMG9zTUVKQlFVRXNUVUZCU1N4RFFVRkRhRVlzVFVGQlRDeERRVUZaTkVNc1IwRkJXaXhEUVVGblFpdERMR0ZCUVdoQ096dEJRVU5OUnl3d1FrRkJRVUVzYVVJc1IwRkJiMEptTEZjN08ybERRVU53UWl4SlFVRkpOMGtzVDBGQlNpeERRVUZaTEZWQlFVRklMRTlCUVU4N1FVRkJRU3h0UTBGQlNXdERMRlZCUVZVc1EwRkJRMnhETEU5QlFVUXNSVUZCVlN0S0xHbENRVUZXTEVOQlFXUTdRVUZCUVN3eVFrRkJia0lzUXpzN08wRkJRMDRzT0VKQlFVbG1MRmRCUVZjc1IwRkJSeXhKUVVGc1FpeEZRVUYzUWp0QlFVTndRa0VzTkVKQlFVRkJMRmRCUVZjc1NVRkJTU3hEUVVGbU8wRkJRMGc3TzBGQlEwUXNPRUpCUVVsRkxEQkNRVUV3UWl4SFFVRkhMRTFCUVVrc1EwRkJRMnBHTEUxQlFVd3NRMEZCV1cxR0xHTkJRVm9zUlVGQmFrTXNSVUZCSzBRN1FVRkRNMFJHTERSQ1FVRkJRU3d3UWtGQk1FSXNTVUZCU1N4SlFVRTVRanRCUVVOSU96czdPenM3T3pzN096czdPenM3YzBKQlJVdFZMR0U3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN08ybElRVTFKZEVvc1N6czdPenM3TzBGQlEyaENNRW9zWjBKQlFVRkJMRTBzUjBGQlV6RktMRXRCUVVzc1EwRkJRekpLTEdGQlFVNHNTVUZCZFVJelNpeExRVUZMTEVOQlFVTXlTaXhoUVVGT0xFTkJRVzlDTEVOQlFYQkNMRU03TzNGQ1FVTnNRMFFzVFRzN096czdRVUZEVFVVc1owSkJRVUZCTEZNc1IwRkJXU3hKUVVGSk5VUXNTMEZCU2l4RFFVRlZNRVFzVFVGQlRTeERRVUZEYkVRc1QwRkJha0lzUXp0QlFVTmFjVVFzWjBKQlFVRkJMRTBzUjBGQlZVZ3NUVUZCVFN4RFFVRkRTU3hWUVVGUUxFbEJRWEZDU2l4TlFVRk5MRU5CUVVOSkxGVkJRVkFzUTBGQmEwSkRMRk5CUVhoRExFbEJRWE5FTEVVN1FVRkRjRVZJTEdkQ1FVRkJRU3hUUVVGRUxFTkJRV2xDU1N4TlFVRnFRaXhIUVVFd1FrZ3NUVUZCVFN4RFFVRkRTU3hKUVVGUUxFbEJRV1VzUTBGQmVrTTdRVUZEUTB3c1owSkJRVUZCTEZOQlFVUXNRMEZCYVVKTExFbEJRV3BDTEVkQlFYZENTaXhOUVVGTkxFTkJRVU5KTEVsQlFWQXNTVUZCWlN4RFFVRjJRenRCUVVORFRDeG5Ra0ZCUVVFc1UwRkJSQ3hEUVVGcFFrMHNUVUZCYWtJc1IwRkJNRUpNTEUxQlFVMHNRMEZCUTBzc1RVRkJVQ3hKUVVGcFFpeFJRVUV6UXp0dFJFRkRUMDRzVXpzN08wRkJSVXhQTEdkQ1FVRkJRU3hOTEVkQlFWTnVTeXhMUVVGTExFbEJRMkpCTEV0QlFVc3NRMEZCUTI5TExGbEJSRVVzU1VGRlVuQkxMRXRCUVVzc1EwRkJRMjlMTEZsQlFVNHNRMEZCYlVJeFF5eE5RVVpZTEVsQlIxSXhTQ3hMUVVGTExFTkJRVU52U3l4WlFVRk9MRU5CUVcxQ01VTXNUVUZCYmtJc1EwRkJNRUo1UXl4Tk96dHhRa0ZETjBKQkxFMDdPenM3TzJkRFFVTlBkRWtzT0VJN1owTkJRVEpDYzBrc1RUczdkVUpCUVdNc1MwRkJTMFVzYVVKQlFVd3NSVHM3T3p0cFJVRkJNVUpETEZjN096dHRSRUZGYmtKMFN5eExPenM3T3pzN096czdPenM3T3pzN096czdPM0ZIUVVkSGRVc3NUeXhGUVVGcFJEVkVMRWs3T3pzN096czdkVUpCUTNSRExFdEJRVXRETEhGQ1FVRk1MRU5CUVRKQ1JDeEpRVUV6UWl4RE96czdRVUZCWmpSQ0xHZENRVUZCUVN4Tk96czdkVUpCUlZkblF5eFBRVUZQTEVOQlFVTm9ReXhOUVVGRUxFTTdPenM3T3pzN096dDFRa0ZGVWl4TFFVRkxZeXh0UWtGQlRDeGxPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzIxSVFVbFJPVUlzVlRzN096czdPenM3Y1VKQlEzQkNMRXRCUVV0dVJpeGhPenM3T3p0dFJFRkRSU3hMUVVGTFFTeGhPenM3Y1VKQlJWb3NTMEZCUzBNc2NVSTdPenM3T3p0MVFrRkRReXhMUVVGTFFTeHhRa0ZCVEN4RFFVRXlRbTFKTEUxQlFUTkNMRVU3T3pzN096czdRVUZGUVVNc1owSkJRVUZCTEZFc1IwRkJWeXhKUVVGSmJrd3NaMEpCUVVvc1JUdEJRVU5xUWl4eFFrRkJTeXRETEhGQ1FVRk1MRWRCUVRaQ2Iwa3NVVUZCTjBJN096dDFRa0ZGVlN4TFFVRkxkRWtzVDBGQlRDeERRVUZoTkVZc1MwRkJZaXhEUVVGdFFpeGpRVUZ1UWl4RlFVRnRReXhWUVVGRGNFSXNTVUZCUkN4RlFVRlZPMEZCUXk5RExIbENRVUZQTEUxQlFVa3NRMEZCUXl0RUxHMUNRVUZNTEVOQlFYbENMMFFzU1VGQmVrSXNRMEZCVUR0QlFVTklMR2xDUVVaTExFVkJSVWhaTEZWQlJrY3NRenM3TzBGQlIwNHNjVUpCUVV0c1JpeHhRa0ZCVEN4SFFVRTJRaXhKUVVFM1FqdEJRVU5CYjBrc1owSkJRVUZCTEZGQlFWRXNRMEZCUXk5TExFOUJRVlFzUTBGQmFVSXNTMEZCU3pCRExHRkJRWFJDT3pzN096czdPMEZCUlVFc2NVSkJRVXRETEhGQ1FVRk1MRWRCUVRaQ0xFbEJRVGRDTzBGQlEwRnZTU3huUWtGQlFVRXNVVUZCVVN4RFFVRkRPVXNzVFVGQlZEczdPenR0UkVGSlJDeExRVUZMZVVNc1lUczdPenM3T3pzN096czdPenM3T3pzN096dHBTRUZIVlhWRkxFazdPenM3T3pzN08wRkJRMmhDWjBVc1owSkJRVUZCTEU4c1IwRkJWU3hEUVVGRExFdEJRVXRvU0N4TlFVRk1MRU5CUVZscFFpeEpRVUZhTEVOQlFXbENaMGNzYzBJN08zVkNRVU5VTEV0QlFVdERMR1ZCUVV3c1JUczdPMEZCUVhKQ00wVXNaMEpCUVVGQkxGazdRVUZGUlRSRkxHZENRVUZCUVN4WExFZEJRV01zUzBGQlMyNUlMRTFCUVV3c1EwRkJXVzlJTEUxQlFWb3NRMEZCYlVKRExFMUJRVzVDTEVOQlFUQkNja1VzU1VGQk1VSXNSVUZCWjBOelJTdzBRa0ZCYUVNc1JVRkJhVVFzUlVGQmFrUXNRenRCUVVOa1F5eG5Ra0ZCUVVFc2EwSXNSMEZCTWtRc1NVRkJTVU1zTkVOQlFVb3NRMEZETjBScVJpeFpRVUZaTEVOQlFVTk9MRXRCUkdkRUxFVkJSVGRFTzBGQlEwbDNReXhyUWtGQlFVRXNUMEZCVHl4RlFVRkZja29zYTBKQlJHSTdRVUZGU1hGTkxHdENRVUZCUVN4VFFVRlRMRVZCUVVVc1NVRkdaanRCUVVkSlF5eHJRa0ZCUVVFc1owSkJRV2RDTEVWQlFVVTdRVUZCUVN3eVFrRkJUenRCUVVOeVFrTXNjMEpCUVVGQkxGTkJRVk1zUlVGQlJTeE5RVUZKTEVOQlFVTXpTQ3hOUVVGTUxFTkJRVmxwUWl4SlFVRmFMRWxCUVc5Q0xFMUJRVWtzUTBGQlEycENMRTFCUVV3c1EwRkJXV2xDTEVsQlFWb3NRMEZCYVVJd1J5eFRRVVF6UWp0QlFVVnlRa01zYzBKQlFVRkJMRTlCUVU4c1JVRkJSVlE3UVVGR1dTeHhRa0ZCVUR0QlFVRkJPMEZCU0hSQ0xHbENRVVkyUkN4RlFWVTNSRFZGTEZsQlFWa3NRMEZCUTBvc1UwRldaMFFzUXp0QlFWbHFSVzlHTEdkQ1FVRkJRU3hyUWtGQmEwSXNRMEZCUTAwc1lVRkJia0lzUTBGQmFVTXNXVUZCVFR0QlFVTnVReXh6UWtGQlJ5eE5RVUZKTEVOQlFVTTNTQ3hOUVVGTUxFTkJRVmt3UXl4alFVRm1MRVZCUVN0Q1F5eFBRVUZQTEVOQlFVTkRMRWRCUVZJc1EwRkJXU3h4UWtGQldpeEZRVUZ0UXl4MVFrRkJia003TzBGQlF5OUNMR3RDUVVGQkxFMUJRVWtzUTBGQlEydEdMRzFDUVVGTU8wRkJRMGdzYVVKQlNFUTdRVUZKVFVNc1owSkJRVUZCTEVzc1IwRkJVVHRCUVVOV1F5eHJRa0ZCUVVFc2IwSkJRVzlDTEVWQlFVVTdRVUZFV2l4cFFqdEJRVWRrVkN4blFrRkJRVUVzYTBKQlFXdENMRU5CUVVOVkxFOUJRVzVDTEVOQlFUSkNMRmxCUVUwN1FVRkROMElzYzBKQlFVY3NUVUZCU1N4RFFVRkRha2tzVFVGQlRDeERRVUZaTUVNc1kwRkJaaXhGUVVFclFrTXNUMEZCVHl4RFFVRkRReXhIUVVGU0xFTkJRVmtzY1VKQlFWb3NSVUZCYlVNc2EwSkJRVzVET3p0QlFVTXZRaXh6UWtGQlNXMUdMRXRCUVVzc1EwRkJRME1zYjBKQlFWWXNSVUZCWjBNN1FVRkROVUk3UVVGRFNEczdRVUZEUkN3clJVRkJRenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUjBRc05FSkJRVUZCTEV0QlFVc3NRMEZCUTBNc2IwSkJRVTRzUjBGQk5rSXNTVUZCTjBJN1FVRkVTRHRCUVVGQk8wRkJRVUVzYlVOQlJ5dENMRTFCUVVrc1EwRkJRMlFzWlVGQlRDeEZRVWd2UWpzN1FVRkJRVHRCUVVkaFowSXNORUpCUVVGQkxGTkJTR0k3UVVGSllVTXNORUpCUVVGQkxHVkJTbUlzUjBGSkswSkVMRk5CUVZNc1EwRkJRM3BJTEU5QlFWWXNTMEZCYzBJNFFpeFpRVUZaTEVOQlFVTTVRaXhQUVVGdVF5eEpRVU5xUW5sSUxGTkJRVk1zUTBGQlEycEhMRXRCUVZZc1MwRkJiMEpOTEZsQlFWa3NRMEZCUTA0c1MwRk1MME03TzBGQlRVOHNaME5CUVVsclJ5eGxRVUZLTEVWQlFYRkNPMEZCUTJwQ0xHdERRVUZITEUxQlFVa3NRMEZCUTI1SkxFMUJRVXdzUTBGQldXOUpMRmRCUVdZc1JVRkJORUo2Uml4UFFVRlBMRU5CUVVORExFZEJRVklzUTBGQldTeHhRa0ZCV2l4RlFVRnRReXgxUWtGQmJrTTdRVUZETlVKTUxEaENRVUZCUVN4WlFVRlpMRWRCUVVjeVJpeFRRVUZtTzBGQlEwRXNPRUpCUVVFc1RVRkJTU3hEUVVGRGRrb3NiVUpCUVV3c1IwRkJNa0kwUkN4WlFVRXpRanRCUVVOQlowWXNPRUpCUVVGQkxHdENRVUZyUWl4RFFVRkRia2NzUjBGQmJrSXNSMEZCZVVJNFJ5eFRRVUZUTEVOQlFVTnFSeXhMUVVGdVF6czdRVUZEUVN4clEwRkJTU3hOUVVGSkxFTkJRVU55UkN4TlFVRlVMRVZCUVdsQ08wRkJRMklzWjBOQlFVRXNUVUZCU1N4RFFVRkRRU3hOUVVGTUxFTkJRVmwzUXl4SFFVRmFMRWRCUVd0Q09FY3NVMEZCVXl4RFFVRkRha2NzUzBGQk5VSTdRVUZEU0RzN1FVRkRSQ3hyUTBGQlNTeE5RVUZKTEVOQlFVTndSQ3hSUVVGVUxFVkJRVzFDTzBGQlEyWXNaME5CUVVFc1RVRkJTU3hEUVVGRFFTeFJRVUZNTEVOQlFXTjNTaXhIUVVGa0xFZEJRVzlDU0N4VFFVRlRMRU5CUVVONlNDeFBRVUU1UWp0QlFVTklPMEZCUTBvN08wRkJha0pTTzBGQlFVRTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJiVUpQTEdkRFFVRkhMRTFCUVVrc1EwRkJRMVFzVFVGQlRDeERRVUZaTUVNc1kwRkJaaXhGUVVFclFrTXNUMEZCVHl4RFFVRkRReXhIUVVGU0xFTkJRVmtzYVVSQlFWbzdPMEZCYmtKMFF6dEJRWEZDUjIxR0xEUkNRVUZCUVN4TFFVRkxMRU5CUVVORExHOUNRVUZPTEVkQlFUWkNMRXRCUVRkQ096dEJRWEpDU0R0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFTeHRRa0ZCUkR0QlFYVkNTQ3hwUWtFMVFrUTdPMEZCTmtKQlZDeG5Ra0ZCUVVFc2EwSkJRV3RDTEVOQlFVTmxMSFZDUVVGdVFpeERRVUV5UTBNc1VVRkJNME1zUjBGQmMwUXNXVUZCVFR0QlFVTjRSQ3g1UWtGQlQyaENMR3RDUVVGclFpeERRVUZEWlN4MVFrRkJia0lzUTBGQk1rTkZMRWRCUVd4RU8wRkJRMGdzYVVKQlJrUTdPenQxUWtGSmVVSXNiVU5CUVZjc1ZVRkJReTlHTEVOQlFVUXNSVUZCU1dkSExFZEJRVW9zUlVGQldUdEJRVU0xUXl4elFrRkJUVU1zV1VGQldTeEhRVUZKUkN4SFFVRkhMRWxCUVVsQkxFZEJRVWNzUTBGQlF6TkVMRk5CUVZvc1NVRkJNRUk1UWl4SlFVRXZRenRCUVVOQmVVWXNhMEpCUVVGQkxFZEJRVWNzUTBGQlEySXNUMEZCU2l4SFFVRmpMRVZCUVdRN08wRkJRMEVzYTBKQlFVRXNUVUZCU1N4RFFVRkROVWdzVFVGQlRDeERRVUZaYjBnc1RVRkJXaXhEUVVGdFFrTXNUVUZCYmtJc1EwRkJNRUp4UWl4WlFVRXhRaXhGUVVGM1EzQkNMRFJDUVVGNFF5eEZRVUY1UkcxQ0xFZEJRVWNzUTBGQlEySXNUMEZCTjBRN08wRkJRMEVzYzBKQlFVMUVMRk5CUVZNc1IwRkJSeXhOUVVGSkxFTkJRVU16U0N4TlFVRk1MRU5CUVZscFFpeEpRVUZhTEVsQlFXOUNMRTFCUVVrc1EwRkJRMnBDTEUxQlFVd3NRMEZCV1dsQ0xFbEJRVm9zUTBGQmFVSXdSeXhUUVVGMlJEczdRVUZEUVN4elFrRkJTVUVzVTBGQlNpeEZRVUZsTzBGQlExaGpMRzlDUVVGQlFTeEhRVUZITEVOQlFVTmlMRTlCUVVvc1EwRkJXVVFzVTBGQldpeEhRVUYzUWtFc1UwRkJlRUk3UVVGRFNEczdRVUZEUkN4NVFrRkJUenRCUVVOSVF5eHZRa0ZCUVVFc1QwRkJUeXhGUVVGRllTeEhRVUZITEVOQlFVTmlPMEZCUkZZc2JVSkJRVkE3UVVGSFNDeHBRa0ZZZDBJc1F6czdPMEZCUVc1Q1pTeG5Ra0ZCUVVFc1ZUczdRVUZaUVVNc1owSkJRVUZCTEZFc1IwRkJWeXhUUVVGWVFTeFJRVUZYTEVOQlFVTkRMRWxCUVVRN1FVRkJRU3g1UWtGQmEwTkdMRlZCUVZVc1EwRkJRMGNzVFVGQldDeERRVUZyUWtRc1NVRkJiRUlzUTBGQmJFTTdRVUZCUVN4cFFqczdRVUZEV0VVc1owSkJRVUZCTEdNc1IwRkJhVUlzVTBGQmFrSkJMR05CUVdsQ0xGRkJRV1U3UVVGQlFTeHpRa0ZCV214R0xFdEJRVmtzVTBGQldrRXNTMEZCV1R0QlFVTnNReXh6UWtGQlRXMUdMRlZCUVZVc1IwRkJSeXgzUTBGQmEwSnVSaXhMUVVGc1FpeERRVUZ1UWp0QlFVTkJMSGxDUVVOSmJVWXNWVUZCVlN4RFFVRkRReXhKUVVGWUxFdEJRVzlDTEhGQ1FVRndRaXhKUVVOSFJDeFZRVUZWTEVOQlFVTkZMRk5CUVZnc1MwRkJlVUlzWTBGR2FFTTdRVUZKU0N4cFFqczdRVUZGUkN4eFFrRkJTM1JMTEUxQlFVd3NSMEZCWXl4SlFVRkpkVXNzTWtKQlFVb3NRMEZCYTBJMVFpeHJRa0ZCYkVJc1EwRkJaRHRCUVVOQkxIRkNRVUZMTVVrc1VVRkJUQ3hIUVVGblFtMUpMRTlCUVU4c1IwRkRha0lzU1VGQlNXOURMSGRDUVVGS0xFTkJRV0U3UVVGRFdHWXNhMEpCUVVGQkxFZEJRVWNzUlVGQlJUbEdMRmxCUVZrc1EwRkJRemxDTEU5QlJGQTdRVUZGV0dwRUxHdENRVUZCUVN4TFFVRkxMRVZCUVVWRUxHTkJRV01zUTBGQlEyZEdMRmxCUVZrc1EwRkJReTlGTEV0QlFXUTdRVUZHVml4cFFrRkJZaXhEUVVScFFpeEhRVXRxUWl4SlFVeE9PMEZCVFUxeFRDeG5Ra0ZCUVVFc1NTeEhRVUZQTEV0QlFVdG9TeXhSUVVGTUxFZEJRMUFzZFVKQlFVMXJTeXhqUVVGT0xFVkJRWE5DU0N4UlFVRlJMRU5CUVVNc1MwRkJTMmhMTEUxQlFVNHNRMEZCT1VJc1JVRkJOa05uU3l4UlFVRlJMRU5CUVVNc1MwRkJTeTlLTEZGQlFVNHNRMEZCY2tRc1EwRkVUeXhIUVVWUUswb3NVVUZCVVN4RFFVRkRMRXRCUVV0b1N5eE5RVUZPTEVNN1FVRkRaQ3h4UWtGQlMwUXNiVUpCUVV3c1IwRkJNa0kwUkN4WlFVRXpRanRCUVVOQkxIRkNRVUZMT1VRc1lVRkJUQ3hIUVVGeFFpeEpRVUZKTkVzc01FSkJRVW9zUTBGQmFVSTdRVUZEYkVORExHdENRVUZCUVN4TFFVRkxMRVZCUVVVc1NVRkJTVU1zYTBOQlFVb3NRMEZCYTBJc1JVRkJiRUlzUTBGRU1rSTdRVUZGYkVOV0xHdENRVUZCUVN4SlFVRkpMRVZCUVVwQkxFbEJSbXRETzBGQlIyeERWeXhyUWtGQlFVRXNZMEZCWXl4RlFVRkZPMEZCUTFwRExHOUNRVUZCUVN4VlFVRlZMRVZCUVVVN1FVRkRVa01zYzBKQlFVRkJMRmRCUVZjc1JVRkJSVHRCUVVSTUxIRkNRVVJCTzBGQlNWbzNSaXh2UWtGQlFVRXNTMEZCU3l4RlFVRkZPMEZCUTBnMlJpeHpRa0ZCUVVFc1YwRkJWeXhGUVVGRk8wRkJSRlk3UVVGS1N6dEJRVWhyUWl4cFFrRkJha0lzUTBGQmNrSTdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN2NVSkJaVWtzUzBGQlMycE1MR0U3T3pzN08wRkJRME50Unl4blFrRkJRVUVzVFN4SFFVRlRMRXRCUVV0dVJ5eGhPMEZCUTNCQ0xIRkNRVUZMUVN4aFFVRk1MRWRCUVhGQ0xFbEJRWEpDTzBGQlEwRnRSeXhuUWtGQlFVRXNUVUZCVFN4RFFVRkRLMFVzU1VGQlVEczdkVUpCUTAwdlJTeE5RVUZOTEVOQlFVTm5SaXhWUVVGUUxFVTdPenM3T3pzN096czdPenM3T3pzN096dHRRMEYyVUZGMlRpeExMRVZCUVhGQ08wRkJRM1pETEZWQlFVbEJMRXRCUVVzc1EwRkJRMmxMTEVsQlFVNHNTMEZCWlhWRUxEWkNRVUZoUXl4elFrRkJhRU1zUlVGQmQwUTdRVUZEY0VRc1pVRkJUeXhKUVVGUU8wRkJRMGc3TzBGQlEwUXNWVUZCVFhKRUxGbEJRVmtzUjBGQlIzQkxMRXRCUVVzc1EwRkJRMjlMTEZsQlFUTkNPenRCUVVOQkxGVkJRVWtzUTBGQlEwRXNXVUZCVEN4RlFVRnRRanRCUVVObUxHVkJRVThzUzBGQlVEdEJRVU5JT3p0QlFVTkVMRlZCUVVrc1YwRkJWMEVzV1VGQlppeEZRVUUyUWp0QlFVTjZRaXhsUVVGUExFbEJRVkE3UVVGRFNEczdRVUZEUkN4aFFVRlBMRVZCUVVVc1kwRkJZMEVzV1VGQlpDeEpRVUU0UWl4WlFVRlpRU3haUVVFMVF5eERRVUZRTzBGQlEwZzdPenM3UlVFdlVubERjMFFzY1VJN096czdTVUZuYUVKNFF6TktMREJDTzBGQlQwWXNjME5CUTBrMFNpeE5RVVJLTEVWQlJVbERMR05CUmtvc1JVRkhTVU1zVVVGSVNpeEZRVWxGTzBGQlFVRTdPMEZCUVVFN08wRkJRVUU3TzBGQlFVRTdPMEZCUTBVc1UwRkJTMFlzVFVGQlRDeEhRVUZqUVN4TlFVRmtPMEZCUTBFc1UwRkJTME1zWTBGQlRDeEhRVUZ6UWtFc1kwRkJkRUk3UVVGRFFTeFRRVUZMUXl4UlFVRk1MRWRCUVdkQ1FTeFJRVUZvUWp0QlFVTklPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096UkRRVWROTTA4c1NUdEJRVUZCUVN4clFrRkJRVUVzU1RzN08ybERRV3RDUTBRc1lVRkJZU3hEUVVGcFFrTXNTVUZCYWtJc1JVRkJkVUlzVVVGQmRrSXNSVUZCYVVNN1FVRkJRU3g1UWtGQlR6dEJRVU55UkRSUExHOUNRVUZCUVN4TlFVRk5MRVZCUVVVMVR5eEpRVUZKTEVOQlFVTXNRMEZCUkN4RFFVUjVRenRCUVVWeVJIZEpMRzlDUVVGQlFTeE5RVUZOTEVWQlFVZDRTU3hKUVVGSkxFTkJRVU1zUTBGQlJDeERRVVozUXp0QlFVZHlSRFpQTEc5Q1FVRkJRU3hQUVVGUExFVkJRVWMzVHl4SlFVRkpMRU5CUVVNc1EwRkJSQ3hEUVVoMVF6dEJRVWx5UkRoUExHOUNRVUZCUVN4TFFVRkxMRVZCUVVjNVR5eEpRVUZKTEVOQlFVTXNRMEZCUkN4RFFVcDVRenRCUVV0eVJHdEtMRzlDUVVGQlFTeFBRVUZQTEVWQlFVZHNTaXhKUVVGSkxFTkJRVU1zUTBGQlJDeERRVXgxUXp0QlFVMXlSSEZKTEc5Q1FVRkJRU3hWUVVGVkxFVkJRVVZ5U1N4SlFVRkpMRU5CUVVNc1EwRkJSRHRCUVU1eFF5eHRRa0ZCVUR0QlFVRkJMR2xDUVVGcVF5eERMRVZCVUdJMFR5eE5MR3RDUVVGQlFTeE5MRVZCUTBGd1J5eE5MR3RDUVVGQlFTeE5MRVZCUTBGeFJ5eFBMR3RDUVVGQlFTeFBMRVZCUTBGRExFc3NhMEpCUVVGQkxFc3NSVUZEUVRWR0xFOHNhMEpCUVVGQkxFOHNSVUZEUVRaR0xGY3NhMEpCUVVGQkxGY3NSVUZEUVRGSExGVXNhMEpCUVVGQkxGVTdiVVJCVTBjc1MwRkJTMjlITEUxQlFVd3NRMEZCV1hoTUxFOUJRVm9zUTBGQmIwSTBSaXhMUVVGd1FpeFhRVUUyUWl4TFFVRkxOa1lzWTBGQmJFTTdRVUZCUVN3eVJrRkJNRVFzYlVKQlFVOXFTQ3hKUVVGUU8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTTNSRUVzTkVKQlFVRkJMRWxCUVVrc1EwRkJRM1ZDTEUxQlFVd3NRMEZCV1N4UlFVRmFMRVZCUVhOQ08wRkJRMnhDTkVZc09FSkJRVUZCTEUxQlFVMHNSVUZCVGtFc1RVRkVhMEk3UVVGRmJFSndSeXc0UWtGQlFVRXNUVUZCVFN4RlFVRk9RU3hOUVVaclFqdEJRVWRzUW5GSExEaENRVUZCUVN4UFFVRlBMRVZCUVZCQkxFOUJTR3RDTzBGQlNXeENReXc0UWtGQlFVRXNTMEZCU3l4RlFVRk1RU3hMUVVwclFqdEJRVXRzUWpWR0xEaENRVUZCUVN4UFFVRlBMRVZCUVZCQkxFOUJUR3RDTzBGQlRXeENOa1lzT0VKQlFVRkJMRmRCUVZjc1JVRkJXRUU3UVVGT2EwSXNOa0pCUVhSQ08wRkJSRFpFTERSRFFWTjBRMEVzVjBGVWMwTTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlFVRTdRVUZCUVN4dFEwRlZMME1zVFVGQlNTeERRVUZEVGl4TlFVRk1MRU5CUVZrNVJ5eGhRVUZhTEVOQlFUQkNSaXhKUVVFeFFpeERRVllyUXpzN1FVRkJRVHRCUVVGQkxEUkVRVlZrTjBZc2JVSkJWbU03TzBGQlFVRTdRVUZUZGtSdlRpdzBRa0ZCUVVFc1kwRlVkVVE3UVVGWGRrUkRMRFJDUVVGQlFTeERRVmgxUkN4SFFWZHVSQ3hOUVVGSkxFTkJRVU5RTEdOQldEaERPMEZCV1haRVVTdzBRa0ZCUVVFc1EwRmFkVVFzUjBGWmJrUXNUVUZCU1N4RFFVRkRVQ3hSUVZvNFF6dEJRV0YyUkRkR0xEUkNRVUZCUVN4RlFXSjFSQ3hwUTBGamNrUnRSeXhEUVdSeFJDeDVRMEZsT1VORExFTkJaamhETEd0S1FXMUNka1JHTEdOQlFXTXNSMEZCUnl4M1FrRkJTQ3hIUVVFNFFpeEZRVzVDVnl4cFJFRnhRblpFUXl4RFFYSkNkVVFzWjAxQk1FSnVSRVFzWTBGQll5eEhRVUZITERaQ1FVRklMRWRCUVcxRExFVkJNVUpGTEcxRFFUSkNia1I0Unl4TlFUTkNiVVE3UVVFMlFuWkVUeXcwUWtGQlFVRXNVMEUzUW5WRUxFZEJOa0o0UWp0QlFVTnFRelpHTERoQ1FVRkJRU3hOUVVGTkxFVkJRVTVCTEUxQlJHbERPMEZCUldwRFF5dzRRa0ZCUVVFc1QwRkJUeXhGUVVGUVFTeFBRVVpwUXp0QlFVZHFRME1zT0VKQlFVRkJMRXRCUVVzc1JVRkJURUU3UVVGSWFVTXNOa0pCTjBKM1FqczdRVUZyUXpkRUxHZERRVUZKUlN4alFVRktMRVZCUVc5Q08wRkJRMmhDYWtjc09FSkJRVUZCTEZOQlFWTXNRMEZCUTJkSExGZEJRVllzUjBGQmQwSkJMRmRCUVhoQ08wRkJRMGc3TzBGQlEwUXNaME5CUVVrM1JpeFBRVUZLTEVWQlFXRTdRVUZEVkVnc09FSkJRVUZCTEZOQlFWTXNRMEZCUTBjc1QwRkJWaXhIUVVGdlFuQkdMRWxCUVVrc1EwRkJReXRHTEVkQlFVd3NRMEZCVXk5S0xGZEJRVlFzUlVGQmMwSnZTaXhQUVVGMFFpeERRVUZ3UWp0QlFVTklPenRCUVhaRE5FUTdRVUZCUVN4dFEwRjNReTlETEUxQlFVa3NRMEZCUTNWR0xFMUJRVXdzUTBGQldYUkdMRmxCUVZvc1EwRkJlVUpNTEVWQlFYcENMRVZCUVRaQ1F5eFRRVUUzUWl4RlFVRjNRM1JDTEVsQlFYaERMRVZCUVRoRGVVSXNUMEZCT1VNc1EwRjRReXRET3p0QlFVRkJPMEZCUVVFc05FTkJkME5qSzBZc1EwRjRRMlE3UVVGQlFTd3JSVUYzUTFOMlNpeEpRWGhEVkRzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVN4dFFrRkJNVVE3TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc2NVSkJlVU5LTWtNc1ZVRjZRMGtzUXpzN096czdPenM3T3pzN096czdPenM3T3p0MVIwRTJRMUE0Unl4Tk96czdPenM3TzIxRVFVVlBMRXRCUVV0V0xFMUJRVXdzUTBGQldYaE1MRTlCUVZvc1EwRkJiMEkwUml4TFFVRndRaXhYUVVFMlFpeExRVUZMTmtZc1kwRkJiRU03UVVGQlFTd3lSa0ZCT0VRc2JVSkJRVTlxU0N4SlFVRlFPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU5xUlVFc05FSkJRVUZCTEVsQlFVa3NRMEZCUTNWQ0xFMUJRVXdzUTBGQldTeFJRVUZhTEVWQlFYTkNPMEZCUTJ4Q05FWXNPRUpCUVVGQkxFMUJRVTBzUlVGQlJVOHNUVUZCVFN4RFFVRkRVQ3hOUVVSSE8wRkJSV3hDVVN3NFFrRkJRVUVzVFVGQlRTeEZRVUZGUkN4TlFVRk5MRU5CUVVORE8wRkJSa2NzTmtKQlFYUkNPMEZCUkdsRk8wRkJRVUVzYlVOQlMzSkVMRTFCUVVrc1EwRkJRMWdzVFVGQlRDeERRVUZaT1Vjc1lVRkJXaXhEUVVFd1FrWXNTVUZCTVVJc1EwRk1jVVE3TzBGQlFVRTdRVUZCUVN4blJFRkxjRUkxUml4dlFrRk1iMEk3UVVGQlFUdEJRVUZCTzBGQlFVRTdPMEZCUVVFc05FTkJUWFpFWXl3NFFrRk9kVVE3UVVGQlFUdEJRVUZCTEcxRFFVOXVSQ3hOUVVGSkxFTkJRVU00VEN4TlFVRk1MRU5CUVZsMFJDeHBRa0ZCV2l4RlFWQnRSRHM3UVVGQlFUdEJRVUZCTzBGQlFVRXNaMFJCVFhoRGEwVXNLMEpCVG5kRE96dEJRVUZCTzBGQlZUTkVTQ3cwUWtGQlFVRXNRMEZXTWtRc1IwRlZka1FzVFVGQlNTeERRVUZEVUN4UlFWWnJSRHRCUVZjelJGY3NORUpCUVVGQkxFTkJXREpFTEVkQlYzWkVMRTFCUVVrc1EwRkJRMWdzVVVGQlRDeERRVUZqV1N4UlFVRmtMRU5CUVhWQ0xFZEJRWFpDTEhWQ1FVRXdRMHdzUTBGQk1VTXNkVUpCUVRSRVFTeERRVUUxUkN4TlFWaDFSRHRCUVZrelJIQkhMRFJDUVVGQlFTeEZRVm95UkN4cFEwRmhla1IzUnl4RFFXSjVSQ3g1UTBGamJFUktMRU5CWkd0RUxITkhRV2xDTTBSSkxFTkJha0l5UkR0QlFYTkNNMFIyUnl3MFFrRkJRVUVzVTBGMFFqSkVMRWRCYzBJMVFqdEJRVU5xUXpaR0xEaENRVUZCUVN4TlFVRk5MRVZCUVVWUExFMUJRVTBzUTBGQlExQXNUVUZFYTBJN1FVRkZha05STERoQ1FVRkJRU3hOUVVGTkxFVkJRVVZFTEUxQlFVMHNRMEZCUTBNN1FVRkdhMElzTmtKQmRFSTBRanRCUVVGQk8wRkJRVUVzYlVOQk1FSnVSQ3hOUVVGSkxFTkJRVU5ZTEUxQlFVd3NRMEZCV1hSR0xGbEJRVm9zUTBGQmVVSk1MRVZCUVhwQ0xFVkJRVFpDUXl4VFFVRTNRaXhGUVVGM1EzUkNMRWxCUVhoRExFTkJNVUp0UkRzN1FVRkJRVHRCUVVGQkxEUkRRVEJDUXpaSUxFTkJNVUpFTzBGQlFVRXNLMFZCTUVKS05Vb3NTVUV4UWtrN08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc2JVSkJRVGxFT3p0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQkxIRkNRVEpDU25sS0xFMUJRVTBzUTBGQlF6bEhMRlZCTTBKSUxFTTdPenM3T3pzN096czdPenM3T3pzN096dG5RMEZ6UTBzN1FVRkJRVHM3UVVGQlFTeDVRMEZRVkhKSkxFbEJUMU03UVVGUVZFRXNVVUZCUVVFc1NVRlBVenRCUVVGQk96dEJRVUZCTERSQ1FVMVNSQ3hoUVVGaExFTkJRWEZDUXl4SlFVRnlRaXhGUVVFeVFpeFJRVUV6UWl4RlFVRnhRenRCUVVGQkxHVkJRVTg3UVVGRGVrUTBUeXhWUVVGQlFTeE5RVUZOTEVWQlFVVTFUeXhKUVVGSkxFTkJRVU1zUTBGQlJDeERRVVEyUXp0QlFVVjZSSGRKTEZWQlFVRkJMRTFCUVUwc1JVRkJSM2hKTEVsQlFVa3NRMEZCUXl4RFFVRkVMRU5CUmpSRE8wRkJSM3BFZDFBc1ZVRkJRVUVzVlVGQlZTeEZRVUZIZUZBc1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGSWQwTTdRVUZKZWtRd1RTeFZRVUZCUVN4UFFVRlBMRVZCUVVjeFRTeEpRVUZKTEVOQlFVTXNRMEZCUkR0QlFVb3lReXhUUVVGUU8wRkJRVUVzVDBGQmNrTXNRMEZPVER0QlFVRkJMRlZCUlZJMFR5eE5RVVpSTEcxQ1FVVlNRU3hOUVVaUk8wRkJRVUVzVlVGSFVuQkhMRTFCU0ZFc2JVSkJSMUpCTEUxQlNGRTdRVUZCUVN4VlFVbFNaMGdzVlVGS1VTeHRRa0ZKVWtFc1ZVRktVVHRCUVVGQkxGVkJTMUk1UXl4UFFVeFJMRzFDUVV0U1FTeFBRVXhST3p0QlFWbGFMRlZCUVUxcVJpeEpRVUZKTEVkQlFVY3NTMEZCUzJkSUxFMUJRVXdzUTBGQldXaExMRTFCUVZvc1EwRkJiVUp2U0N4TlFVRnVRaXhEUVVFd1FqUkVMRk5CUVRGQ0xFTkJRVzlETEdkRFFVRndReXhEUVVGaU8wRkJRMEZvU1N4TlFVRkJRU3hKUVVGSkxFTkJRVU4xUWl4TlFVRk1MRU5CUVZrd1J5eHJRa0ZCUzBNc1UwRkJha0lzUlVGQk5FSXNVVUZCTlVJN1FVRkRRU3hWUVVGTmRFc3NTVUZCU1N3d1FrRkJiVUlzUzBGQlMzRktMR05CUVhoQ0xIVkNRVUZ0UkN4TFFVRkxReXhSUVVGNFJDeHZRMEZEU2l4TFFVRkxSQ3hqUVVSRUxHbERRVU56UTJ4SExFMUJSSFJETEd0Q1FVRldPMEZCUjBFc1ZVRkJUVVlzUzBGQlN5eEhRVUZITERSQ1FVRkpMRU5CUVVOcVJDeEpRVUZFTEVOQlFVb3NRMEZCWkR0QlFVTkJMRlZCUVVsMVN5eFpRVUZaTEVkQlFVY3NTVUZCYmtJN08wRkJRMEVzYlVWQlFVTTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEhWQ1FVVTBRaXhQUVVGSkxFTkJRVU51UWl4TlFVRk1MRU5CUVZrdlJ5eHhRa0ZCV2l4RFFVRnJRMFFzU1VGQmJFTXNRMEZHTlVJN08wRkJRVUU3UVVGRllUUkNMR2RDUVVGQlFTeE5RVVppTzBGQlIyRjNSeXhuUWtGQlFVRXNWVUZJWWl4SFFVY3dRbmhITEUxQlFVMHNRMEZCUTNsSExGTkJRVkFzUTBGQmFVSTdRVUZEYUVONFNDeHJRa0ZCUVVFc1MwRkJTeXhGUVVGTVFTeExRVVJuUXp0QlFVVm9RMU1zYTBKQlFVRkJMRk5CUVZNc1JVRkJSVHRCUVVOUU5rWXNiMEpCUVVGQkxFMUJRVTBzUlVGQlRrRTdRVUZFVHp0QlFVWnhRaXhwUWtGQmFrSXNRMEZJTVVJN1FVRlRUMmRDTEdkQ1FVRkJRU3haUVVGWkxFZEJRVWRETEZWQlFWVXNRMEZCUTBNc1UwRkJXQ3hEUVVGeFFpeFZRVUZEZUVrc1QwRkJSQ3hGUVVGaE8wRkJRemREYTBrc2EwSkJRVUZCTEZWQlFWVXNRMEZCUXl4bFFVRkVMRVZCUVd0Q2JFa3NUMEZCVHl4RFFVRkROVUlzU1VGQlVpeERRVUZoTEU5QlFVa3NRMEZCUTJkS0xHTkJRV3hDTEVOQlFXeENMRU5CUVZZN1FVRkRTQ3hwUWtGR1l5eERRVUZtTzBGQlZGQTdRVUZCUVRzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGaFQycElMR2RDUVVGQlFTeEpRVUZKTEVOQlFVTktMRWRCUVV3c1EwRkJVenRCUVVOTU1Fa3NhMEpCUVVGQkxFdEJRVXNzUlVGQlJTeFJRVVJHTzBGQlJVeERMR3RDUVVGQlFTeFBRVUZQTzBGQlJrWXNhVUpCUVZRN08wRkJTVUVzYjBKQlFVbDBSQ3hQUVVGS0xFVkJRV0U3UVVGRFZFRXNhMEpCUVVGQkxFOUJRVThzWlVGQlVEdEJRVU5JTEdsQ1FVWkVMRTFCUlU4N1FVRkRTQ3h6UWtGQlIycEpMRTFCUVUwc1EwRkJRekJETEdOQlFWWXNSVUZCTUVKRExFOUJRVThzUTBGQlEwTXNSMEZCVWl4RFFVRlpMQ3RDUVVGYU8wRkJRemRDT3p0QlFYSkNVanRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVN4UFFVRkVPenRCUVhkQ1FTeGhRVUZQTzBGQlEwZzBTU3hSUVVGQlFTeFhRVUZYTEVWQlFVVXNkVUpCUVUwN1FVRkRaaXhqUVVGSlRDeFpRVUZLTEVWQlFXdENPMEZCUTJSQkxGbEJRVUZCTEZsQlFWa3NRMEZCUTBzc1YwRkJZanRCUVVOQmVFa3NXVUZCUVVFc1NVRkJTU3hEUVVGRGVVa3NUVUZCVER0QlFVTklPMEZCUTBvN1FVRk9SU3hQUVVGUU8wRkJVVWc3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN05rTkJSMDFzVVN4Sk8wRkJRVUZCTEd0Q1FVRkJRU3hKT3pzN2EwTkJZME5FTEdGQlFXRXNRMEZCYlVKRExFbEJRVzVDTEVWQlFYbENMRkZCUVhwQ0xFVkJRVzFETzBGQlFVRXNlVUpCUVU4N1FVRkRka1EwVHl4dlFrRkJRVUVzVFVGQlRTeEZRVUZGTlU4c1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGRU1rTTdRVUZGZGtSM1NTeHZRa0ZCUVVFc1RVRkJUU3hGUVVGSGVFa3NTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkdNRU03UVVGSGRrUnJTaXh2UWtGQlFVRXNUMEZCVHl4RlFVRkhiRW9zU1VGQlNTeERRVUZETEVOQlFVUXNRMEZJZVVNN1FVRkpka1J4U1N4dlFrRkJRVUVzVlVGQlZTeEZRVUZGY2trc1NVRkJTU3hEUVVGRExFTkJRVVE3UVVGS2RVTXNiVUpCUVZBN1FVRkJRU3hwUWtGQmJrTXNReXhGUVV4aU5FOHNUU3h0UWtGQlFVRXNUU3hGUVVOQmNFY3NUU3h0UWtGQlFVRXNUU3hGUVVOVE1rZ3NZU3h0UWtGQlZHcElMRThzUlVGRFFXSXNWU3h0UWtGQlFVRXNWU3hGUVVOQk1FY3NWeXh0UWtGQlFVRXNWenRCUVU5Rk4wWXNaMEpCUVVGQkxFOHNSMEZCVldsSUxHRkJRV0VzU1VGQlNTeExRVUZMTVVJc1RVRkJUQ3hEUVVGWmFFc3NUVUZCV2l4RFFVRnRRbTFHTEdOQlFXNUNMRVU3TzNWQ1FVTmtMRXRCUVV0MFFpeExRVUZNTEVOQlFWYzdRVUZETVVKelJ5eHJRa0ZCUVVFc1RVRkJUU3hGUVVGT1FTeE5RVVF3UWp0QlFVVXhRbkJITEd0Q1FVRkJRU3hOUVVGTkxFVkJRVTVCTEUxQlJqQkNPMEZCUnpGQ1ZTeHJRa0ZCUVVFc1QwRkJUeXhGUVVGUVFTeFBRVWd3UWp0QlFVa3hRbUlzYTBKQlFVRkJMRlZCUVZVc1JVRkJWa0VzVlVGS01FSTdRVUZMTVVJd1J5eHJRa0ZCUVVFc1YwRkJWeXhGUVVGWVFUdEJRVXd3UWl4cFFrRkJXQ3hET3pzN1FVRkJZbkZDTEdkQ1FVRkJRU3hKT3p0elFrRlBSa0VzU1VGQlNTeERRVUZEYWxFc1RVRkJUQ3hIUVVGakxFTTdPenM3TzIxRVFVTlFhVkVzU1VGQlNTeERRVUZETEVOQlFVUXNRenM3TzJkRFFVVlVlazRzT0VJN08zVkNRVUZ2UXl4TFFVRkxPRXdzVFVGQlRDeERRVUZaZEVRc2FVSkJRVm9zUTBGQk9FSTdRVUZEY0VWclJpeHJRa0ZCUVVFc1ZVRkJWU3hGUVVGRkxFdEJRVXN6UWp0QlFVUnRSQ3hwUWtGQk9VSXNRenM3T3p0dlEwRkJja0k1UlN4ak96czdPenM3T3pzN096czdPenM3T3pzN096czdRVUZOTjBJMVJ5eG5Ra0ZCWjBJc1EwRkJRM05PTEZWQlFXcENMRWRCUVRoQ0xHdENRVUU1UWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFYRzRnS2lCRGIzQjVjbWxuYUhRZ01qQXhPQzB5TURJd0lGUlBUaUJFUlZZZ1UwOU1WVlJKVDA1VElFeFVSQzVjYmlBcUwxeHVYRzR2THlCQVpteHZkMXh1WEc1cGJYQnZjblFnZXlCSmJrMWxiVzl5ZVVOaFkyaGxJSDBnWm5KdmJTQW5ZWEJ2Ykd4dkxXTmhZMmhsTFdsdWJXVnRiM0o1Snp0Y2JtbHRjRzl5ZENCN0lFRndiMnhzYjBOc2FXVnVkQ0I5SUdaeWIyMGdKMkZ3YjJ4c2J5MWpiR2xsYm5Rbk8xeHVhVzF3YjNKMElIc2dRWEJ2Ykd4dlRHbHVheXdnYzNCc2FYUWdmU0JtY205dElDZGhjRzlzYkc4dGJHbHVheWM3WEc1cGJYQnZjblFnZXlCSWRIUndUR2x1YXlCOUlHWnliMjBnSjJGd2IyeHNieTFzYVc1ckxXaDBkSEFuTzF4dWFXMXdiM0owSUhzZ1YyVmlVMjlqYTJWMFRHbHVheUI5SUdaeWIyMGdKMkZ3YjJ4c2J5MXNhVzVyTFhkekp6dGNibWx0Y0c5eWRDQjdJR2RsZEUxaGFXNUVaV1pwYm1sMGFXOXVJSDBnWm5KdmJTQW5ZWEJ2Ykd4dkxYVjBhV3hwZEdsbGN5YzdYRzVwYlhCdmNuUWdaM0ZzSUdaeWIyMGdKMmR5WVhCb2NXd3RkR0ZuSnp0Y2JtbHRjRzl5ZENCN0lGTjFZbk5qY21sd2RHbHZia05zYVdWdWRDQjlJR1p5YjIwZ0ozTjFZbk5qY21sd2RHbHZibk10ZEhKaGJuTndiM0owTFhkekp6dGNibWx0Y0c5eWRDQjdJSE5sZEVOdmJuUmxlSFFnZlNCbWNtOXRJQ2RoY0c5c2JHOHRiR2x1YXkxamIyNTBaWGgwSnp0Y2JtbHRjRzl5ZENCN1hHNGdJQ0FnUms5U1RVRlVYMVJGV0ZSZlRVRlFMQ0JVWVdkekxDQlRjR0Z1TENCVGNHRnVRMjl1ZEdWNGRDeGNibjBnWm5KdmJTQW5iM0JsYm5SeVlXTnBibWNuTzF4dWFXMXdiM0owSUhSNWNHVWdlMXh1SUNBZ0lGUlBUbEYxWlhKcFpYTXNYRzRnSUNBZ1ZFOU9VVU52Ykd4bFkzUnBiMjRzWEc0Z0lDQWdVM1ZpYzJOeWFYQjBhVzl1TEZ4dUlDQWdJRlJQVGxGMVpYSjVVR0Z5WVcxekxGeHVJQ0FnSUZSUFRsTjFZbk5qY21saVpWQmhjbUZ0Y3l4Y2JpQWdJQ0JVVDA1WFlXbDBSbTl5VUdGeVlXMXpMRnh1SUNBZ0lGUlBUbEYxWlhKNVFXZG5jbVZuWVhSbFVHRnlZVzF6TEZ4dWZTQm1jbTl0SUNjdUxpOHVMaTkwZVhCbGN5YzdYRzVwYlhCdmNuUWdleUJVVDA1RGJHbGxiblFnZlNCbWNtOXRJQ2N1TGk5VVQwNURiR2xsYm5Rbk8xeHVhVzF3YjNKMElIc2daVzF3ZEhsVVQwNUZjbkp2Y2tSaGRHRXNJRlJQVGtOc2FXVnVkRVZ5Y205eUxDQlVUMDVGY25KdmNrTnZaR1VnZlNCbWNtOXRJQ2N1TGk5VVQwNURiR2xsYm5SRmNuSnZjaWM3WEc1cGJYQnZjblFnZEhsd1pTQjdJRlJQVGsxdlpIVnNaVU52Ym5SbGVIUWdmU0JtY205dElDY3VMaTlVVDA1TmIyUjFiR1VuTzF4dWFXMXdiM0owSUhzZ1ZFOU9UVzlrZFd4bElIMGdabkp2YlNBbkxpNHZWRTlPVFc5a2RXeGxKenRjYm1sdGNHOXlkQ0JVVDA1RGIyNW1hV2ROYjJSMWJHVXNJSHNnVlZKTVVHRnlkSE1nZlNCbWNtOXRJQ2N1TDFSUFRrTnZibVpwWjAxdlpIVnNaU2M3WEc1Y2JseHVaWGh3YjNKMElIUjVjR1VnVW1WeGRXVnpkQ0E5SUh0Y2JpQWdJQ0JwWkRvZ2MzUnlhVzVuTEZ4dUlDQWdJR0p2WkhrNklITjBjbWx1Wnl4Y2JuMWNibHh1Wlhod2IzSjBJSFI1Y0dVZ1UyVnlkbVZ5U1c1bWJ5QTlJSHRjYmlBZ0lDQjJaWEp6YVc5dU9pQnVkVzFpWlhJc1hHNGdJQ0FnYzNWd2NHOXlkSE5QY0dWeVlYUnBiMjVKWkRvZ1ltOXZiR1ZoYml4Y2JpQWdJQ0J6ZFhCd2IzSjBjMEZuWjNKbFoyRjBhVzl1Y3pvZ1ltOXZiR1ZoYml4Y2JpQWdJQ0J6ZFhCd2IzSjBjMVJwYldVNklHSnZiMnhsWVc0c1hHNGdJQ0FnZEdsdFpVUmxiSFJoT2lBL2JuVnRZbVZ5TEZ4dWZUdGNibHh1WEc1MGVYQmxJRWR5WVhCb1VVeERiR2xsYm5SRGIyNW1hV2NnUFNCN1hHNGdJQ0FnYUhSMGNGVnliRG9nYzNSeWFXNW5MRnh1SUNBZ0lIZHpWWEpzT2lCemRISnBibWNzWEc0Z0lDQWdabVYwWTJnNklHRnVlU3hjYmlBZ0lDQlhaV0pUYjJOclpYUTZJR0Z1ZVN4Y2JuMDdYRzVjYmk4dklFdGxaWEF0WVd4cGRtVWdkR2x0Wlc5MWRDQjFjMlZrSUhSdklITjFjSEJ2Y25RZ2EyVmxjQzFoYkdsMlpTQmpiMjV1WldOMGFXOXVJR05vWldOcmFXNW5PbHh1THk4Z0xTQkZkbVZ5ZVNBeElHMXBiblYwWlNCelpYSjJaWElnYzJWdVpITWdSMUZNWDBOUFRrNUZRMVJKVDA1ZlMwVkZVRjlCVEVsV1JTQnRaWE56WVdkbExseHVMeThnTFNCRmRtVnllU0F5SUcxcGJuVjBaWE1nWTJ4cFpXNTBJR05vWldOcmN5QjBhR0YwSUVkUlRGOURUMDVPUlVOVVNVOU9YMHRGUlZCZlFVeEpWa1VnYldWemMyRm5aU0IzWVhNZ2NtVmpaV2wyWldSY2JpOHZJQ0FnZDJsMGFHbHVJR3hoYzNRZ01pQnRhVzUxZEdWekxseHVMeThnTFNCSlppQmpiR2xsYm5RZ2FHRmtiaWQwSUhKbFkyVnBkbVZrSUd0bFpYQWdZV3hwZG1VZ2JXVnpjMkZuWlNCa2RYSnBibWNnYkdGemRDQXlJRzFwYm5WMFpYTmNiaTh2SUNBZ2FYUWdZMnh2YzJWeklHTnZibTVsWTNScGIyNGdZVzVrSUdkdlpYTWdkRzhnY21WamIyNXVaV04wTGx4dVkyOXVjM1FnUzBWRlVGOUJURWxXUlY5VVNVMUZUMVZVSUQwZ01pQXFJRFl3TURBd08xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1RVRllYMVJKVFVWUFZWUWdQU0F5TVRRM05EZ3pOalEzTzF4dVhHNW1kVzVqZEdsdmJpQnlaWE52YkhabFVHRnlZVzF6UEZRK0tHRnlaM002SUdGdWVWdGRMQ0J5WlhGMWFYSmxaRkJoY21GdFRtRnRaVG9nYzNSeWFXNW5MQ0J5WlhOdmJIWmxRWEpuY3pvZ0tDa2dQVDRnVkNrNklGUWdlMXh1SUNBZ0lISmxkSFZ5YmlBb1lYSm5jeTVzWlc1bmRHZ2dQVDA5SURFcElDWW1JQ2h5WlhGMWFYSmxaRkJoY21GdFRtRnRaU0JwYmlCaGNtZHpXekJkS1NBL0lHRnlaM05iTUYwZ09pQnlaWE52YkhabFFYSm5jeWdwTzF4dWZWeHVYRzUwZVhCbElFMTFiSFJwWTJGemRFeHBjM1JsYm1WeVBGWmhiSFZsUGlBOUlIdGNiaUFnSUNCeVpYTnZiSFpsT2lBb2RtRnNkV1U2SUZaaGJIVmxLU0E5UGlCMmIybGtPMXh1SUNBZ0lISmxhbVZqZERvZ0tHVnljbTl5T2lCRmNuSnZjaWtnUFQ0Z2RtOXBaRHRjYm4wN1hHNWNibU5zWVhOeklFMTFiSFJwWTJGemRGQnliMjFwYzJVOFZtRnNkV1UrSUh0Y2JpQWdJQ0JzYVhOMFpXNWxjbk02SUUxMWJIUnBZMkZ6ZEV4cGMzUmxibVZ5UEZaaGJIVmxQbHRkTzF4dUlDQWdJRzl1UTI5dGNHeGxkR1U2SUQ4b0tDa2dQVDRnZG05cFpDazdYRzVjYmlBZ0lDQmpiMjV6ZEhKMVkzUnZjaWdwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVzYVhOMFpXNWxjbk1nUFNCYlhUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1dmJrTnZiWEJzWlhSbElEMGdiblZzYkR0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzYVhOMFpXNG9LVG9nVUhKdmJXbHpaVHhXWVd4MVpUNGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQnNhWE4wWlc1bGNqb2dUWFZzZEdsallYTjBUR2x6ZEdWdVpYSThWbUZzZFdVK0lEMGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVnpiMngyWlRvZ0tDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxhbVZqZERvZ0tDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnZlR0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVzYVhOMFpXNWxjbk11Y0hWemFDaHNhWE4wWlc1bGNpazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnVaWGNnVUhKdmJXbHpaU2dvY21WemIyeDJaU3dnY21WcVpXTjBLU0E5UGlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JzYVhOMFpXNWxjaTV5WlhOdmJIWmxJRDBnY21WemIyeDJaVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHeHBjM1JsYm1WeUxuSmxhbVZqZENBOUlISmxhbVZqZER0Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVnpiMngyWlNoMllXeDFaVG9nVm1Gc2RXVXBJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWpiMjF3YkdWMFpTaHNhWE4wWlc1bGNpQTlQaUJzYVhOMFpXNWxjaTV5WlhOdmJIWmxLSFpoYkhWbEtTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVnFaV04wS0dWeWNtOXlPaUJGY25KdmNpa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtTnZiWEJzWlhSbEtHeHBjM1JsYm1WeUlEMCtJR3hwYzNSbGJtVnlMbkpsYW1WamRDaGxjbkp2Y2lrcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdOdmJYQnNaWFJsS0dOdmJYQnNaWFJsVEdsemRHVnVaWEk2SUNoc2FYTjBaVzVsY2pvZ1RYVnNkR2xqWVhOMFRHbHpkR1Z1WlhJOFZtRnNkV1UrS1NBOVBpQjJiMmxrS1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhzZ2JHbHpkR1Z1WlhKeklIMGdQU0IwYUdsek8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG14cGMzUmxibVZ5Y3lBOUlGdGRPMXh1SUNBZ0lDQWdJQ0JwWmlBb2RHaHBjeTV2YmtOdmJYQnNaWFJsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxtOXVRMjl0Y0d4bGRHVW9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCc2FYTjBaVzVsY25NdVptOXlSV0ZqYUNoc2FYTjBaVzVsY2lBOVBpQmpiMjF3YkdWMFpVeHBjM1JsYm1WeUtHeHBjM1JsYm1WeUtTazdYRzRnSUNBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCMlpYSnphVzl1Vkc5T2RXMWlaWElvY3pvZ2MzUnlhVzVuS1RvZ2JuVnRZbVZ5SUh0Y2JpQWdJQ0JqYjI1emRDQndZWEowY3lBOUlHQWtlM01nZkh3Z0p5ZDlZQzV6Y0d4cGRDZ25MaWNwWEc0Z0lDQWdJQ0FnSUM1dFlYQW9lQ0E5UGlCT2RXMWlaWElvZUNrcFhHNGdJQ0FnSUNBZ0lDNXpiR2xqWlNnd0xDQXpLVHRjYmlBZ0lDQjNhR2xzWlNBb2NHRnlkSE11YkdWdVozUm9JRHdnTXlrZ2UxeHVJQ0FnSUNBZ0lDQndZWEowY3k1d2RYTm9LREFwTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z2NHRnlkSE5iTUYwZ0tpQXhNREF3TURBd0lDc2djR0Z5ZEhOYk1WMGdLaUF4TURBd0lDc2djR0Z5ZEhOYk1sMDdYRzU5WEc1Y2JtWjFibU4wYVc5dUlISmxjMjlzZG1WVFpYSjJaWEpKYm1adktIWmxjbk5wYjI1VGRISnBibWM2SUhOMGNtbHVaeUI4SUc1MWJHd2dmQ0IwZVhCbGIyWWdkVzVrWldacGJtVmtLVG9nVTJWeWRtVnlTVzVtYnlCN1hHNGdJQ0FnWTI5dWMzUWdkbVZ5YzJsdmJpQTlJSFpsY25OcGIyNVViMDUxYldKbGNpaDJaWEp6YVc5dVUzUnlhVzVuSUh4OElDY3dMakkwTGpRbktUdGNiaUFnSUNCeVpYUjFjbTRnZTF4dUlDQWdJQ0FnSUNCMlpYSnphVzl1TEZ4dUlDQWdJQ0FnSUNCemRYQndiM0owYzA5d1pYSmhkR2x2Ymtsa09pQjJaWEp6YVc5dUlENGdNalF3TURRc1hHNGdJQ0FnSUNBZ0lITjFjSEJ2Y25SelFXZG5jbVZuWVhScGIyNXpPaUIyWlhKemFXOXVJRDQ5SURJMU1EQXdMRnh1SUNBZ0lDQWdJQ0J6ZFhCd2IzSjBjMVJwYldVNklIWmxjbk5wYjI0Z1BqMGdNall3TURNc1hHNGdJQ0FnSUNBZ0lIUnBiV1ZFWld4MFlUb2diblZzYkN4Y2JpQWdJQ0I5TzF4dWZWeHVYRzVtZFc1amRHbHZiaUJoWW05eWRHRmliR1ZHWlhSamFDaG1aWFJqYUNrZ2UxeHVJQ0FnSUhKbGRIVnliaUFvYVc1d2RYUXNJRzl3ZEdsdmJuTXBJRDArSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUc1bGR5QlFjbTl0YVhObEtDaHlaWE52YkhabExDQnlaV3BsWTNRcElEMCtJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhGMVpYSjVWR2x0Wlc5MWREb2diblZ0WW1WeUlId2dkSGx3Wlc5bUlIVnVaR1ZtYVc1bFpDQTlJRzl3ZEdsdmJuTXVjWFZsY25sVWFXMWxiM1YwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdiR1YwSUdabGRHTm9UM0IwYVc5dWN5QTlJRzl3ZEdsdmJuTTdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9jWFZsY25sVWFXMWxiM1YwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWTI5dWRISnZiR3hsY2lBOUlHZHNiMkpoYkM1QlltOXlkRU52Ym5SeWIyeHNaWElnUHlCdVpYY2daMnh2WW1Gc0xrRmliM0owUTI5dWRISnZiR3hsY2lncElEb2diblZzYkR0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCcFppQW9ZMjl1ZEhKdmJHeGxjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1aWFJqYUU5d2RHbHZibk1nUFNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdUxpNXZjSFJwYjI1ekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MybG5ibUZzT2lCamIyNTBjbTlzYkdWeUxuTnBaMjVoYkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWMFZHbHRaVzkxZENnb0tTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxhbVZqZENoVVQwNURiR2xsYm5SRmNuSnZjaTV4ZFdWeWVVWnZjbU5wWW14NVFXSnZjblJsWkNobGJYQjBlVlJQVGtWeWNtOXlSR0YwWVNrcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1kyOXVkSEp2Ykd4bGNpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1ZEhKdmJHeGxjaTVoWW05eWRDZ3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTd2djWFZsY25sVWFXMWxiM1YwS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lHWmxkR05vS0dsdWNIVjBMQ0JtWlhSamFFOXdkR2x2Ym5NcExuUm9aVzRvY21WemIyeDJaU3dnY21WcVpXTjBLVHRjYmlBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnZlR0Y2JuMWNibHh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlVUMDVSZFdWeWFXVnpUVzlrZFd4bElHVjRkR1Z1WkhNZ1ZFOU9UVzlrZFd4bElHbHRjR3hsYldWdWRITWdWRTlPVVhWbGNtbGxjeUI3WEc0Z0lDQWdkSEpoYm5OaFkzUnBiMjV6T2lCVVQwNVJRMjlzYkdWamRHbHZianRjYmlBZ0lDQnRaWE56WVdkbGN6b2dWRTlPVVVOdmJHeGxZM1JwYjI0N1hHNGdJQ0FnWW14dlkydHpPaUJVVDA1UlEyOXNiR1ZqZEdsdmJqdGNiaUFnSUNCaFkyTnZkVzUwY3pvZ1ZFOU9VVU52Ykd4bFkzUnBiMjQ3WEc0Z0lDQWdZbXh2WTJ0elgzTnBaMjVoZEhWeVpYTTZJRlJQVGxGRGIyeHNaV04wYVc5dU8xeHVYRzRnSUNBZ1kyOXVabWxuT2lCVVQwNURiMjVtYVdkTmIyUjFiR1U3WEc1Y2JpQWdJQ0JuY21Gd2FIRnNRMnhwWlc1MFEzSmxZWFJwYjI0NklEOU5kV3gwYVdOaGMzUlFjbTl0YVhObFBFRndiMnhzYjBOc2FXVnVkRDQ3WEc0Z0lDQWdaM0poY0doeGJFTnNhV1Z1ZERvZ1AwRndiMnhzYjBOc2FXVnVkRHRjYmlBZ0lDQm5jbUZ3YUhGc1EyeHBaVzUwUTI5dVptbG5PaUEvUjNKaGNHaFJURU5zYVdWdWRFTnZibVpwWnp0Y2JpQWdJQ0IzYzB4cGJtczZJRDlYWldKVGIyTnJaWFJNYVc1ck8xeHVJQ0FnSUdoMGRIQk1hVzVyT2lBL1NIUjBjRXhwYm1zN1hHNWNiaUFnSUNCdmRtVnljbWxrWlZkelZYSnNPaUEvYzNSeWFXNW5PMXh1SUNBZ0lHOXdaWEpoZEdsdmJrbGtVSEpsWm1sNE9pQnpkSEpwYm1jN1hHNGdJQ0FnYjNCbGNtRjBhVzl1U1dSVGRXWm1hWGc2SUc1MWJXSmxjanRjYmlBZ0lDQnpaWEoyWlhKSmJtWnZPaUJUWlhKMlpYSkpibVp2TzF4dUlDQWdJR0ZqZEdsMlpWRjFaWEpwWlhOU1pXcGxZM1J6T2lBb0tHRnVlU2tnUFQ0Z2RtOXBaQ2xiWFR0Y2JseHVJQ0FnSUdOdmJuTjBjblZqZEc5eUtHTnZiblJsZUhRNklGUlBUazF2WkhWc1pVTnZiblJsZUhRcElIdGNiaUFnSUNBZ0lDQWdjM1Z3WlhJb1kyOXVkR1Y0ZENrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WjNKaGNHaHhiRU5zYVdWdWRDQTlJRzUxYkd3N1hHNGdJQ0FnSUNBZ0lIUm9hWE11WjNKaGNHaHhiRU5zYVdWdWRFTnlaV0YwYVc5dUlEMGdiblZzYkR0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVuY21Gd2FIRnNRMnhwWlc1MFEyOXVabWxuSUQwZ2JuVnNiRHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjMHhwYm1zZ1BTQnVkV3hzTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbWgwZEhCTWFXNXJJRDBnYm5Wc2JEdGNiaUFnSUNBZ0lDQWdkR2hwY3k1dmRtVnljbWxrWlZkelZYSnNJRDBnYm5Wc2JEdGNiaUFnSUNBZ0lDQWdkR2hwY3k1dmNHVnlZWFJwYjI1SlpGQnlaV1pwZUNBOUlDaEVZWFJsTG01dmR5Z3BJQ1VnTmpBd01EQXBMblJ2VTNSeWFXNW5LREUyS1R0Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQXhNRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCeVlXNWtiMjFRWVhKMElEMGdUV0YwYUM1eWIzVnVaQ2hOWVhSb0xuSmhibVJ2YlNncElDb2dNalUyS1M1MGIxTjBjbWx1WnlneE5pazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbTl3WlhKaGRHbHZia2xrVUhKbFptbDRJRDBnWUNSN2RHaHBjeTV2Y0dWeVlYUnBiMjVKWkZCeVpXWnBlSDBrZTNKaGJtUnZiVkJoY25SOVlEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0IwYUdsekxtOXdaWEpoZEdsdmJrbGtVM1ZtWm1sNElEMGdNVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXpaWEoyWlhKSmJtWnZJRDBnY21WemIyeDJaVk5sY25abGNrbHVabThvS1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVoWTNScGRtVlJkV1Z5YVdWelVtVnFaV04wY3lBOUlGdGRPMXh1SUNBZ0lIMWNibHh1SUNBZ0lISmxaMmx6ZEdWeVVYVmxjbmxTWldwbFkzUW9jbVZxWldOME9pQW9ZVzU1S1NBOVBpQjJiMmxrS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WVdOMGFYWmxVWFZsY21sbGMxSmxhbVZqZEhNdWNIVnphQ2h5WldwbFkzUXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIVnVjbVZuYVhOMFpYSlJkV1Z5ZVZKbGFtVmpkQ2h5WldwbFkzUTZJQ2hoYm5rcElEMCtJSFp2YVdRcElIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2FXNWtaWGdnUFNCMGFHbHpMbUZqZEdsMlpWRjFaWEpwWlhOU1pXcGxZM1J6TG1sdVpHVjRUMllvY21WcVpXTjBLVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHbHVaR1Y0SUQ0OUlEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WVdOMGFYWmxVWFZsY21sbGMxSmxhbVZqZEhNdWMzQnNhV05sS0dsdVpHVjRMQ0F4S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGFtVmpkRUZqZEdsMlpWRjFaWEpwWlhNb0tTQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElISmxhbVZqZEhNZ1BTQjBhR2x6TG1GamRHbDJaVkYxWlhKcFpYTlNaV3BsWTNSek8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1GamRHbDJaVkYxWlhKcFpYTlNaV3BsWTNSeklEMGdXMTA3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1Z5Y2lBOUlGUlBUa05zYVdWdWRFVnljbTl5TG5GMVpYSjVSbTl5WTJsaWJIbEJZbTl5ZEdWa0tIdDlLVHRjYmlBZ0lDQWdJQ0FnY21WcVpXTjBjeTVtYjNKRllXTm9LQ2h5WldwbFkzUXBJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NtVnFaV04wS0dWeWNpazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOUlHTmhkR05vSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlNsY2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QnpaWFIxY0NncElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1amIyNW1hV2NnUFNCMGFHbHpMbU52Ym5SbGVIUXVaMlYwVFc5a2RXeGxLRlJQVGtOdmJtWnBaMDF2WkhWc1pTazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWRISmhibk5oWTNScGIyNXpJRDBnYm1WM0lGUlBUbEYxWlhKcFpYTk5iMlIxYkdWRGIyeHNaV04wYVc5dUtIUm9hWE1zSUNkMGNtRnVjMkZqZEdsdmJuTW5MQ0FuVkhKaGJuTmhZM1JwYjI0bktUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1dFpYTnpZV2RsY3lBOUlHNWxkeUJVVDA1UmRXVnlhV1Z6VFc5a2RXeGxRMjlzYkdWamRHbHZiaWgwYUdsekxDQW5iV1Z6YzJGblpYTW5MQ0FuVFdWemMyRm5aU2NwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbUpzYjJOcmN5QTlJRzVsZHlCVVQwNVJkV1Z5YVdWelRXOWtkV3hsUTI5c2JHVmpkR2x2YmloMGFHbHpMQ0FuWW14dlkydHpKeXdnSjBKc2IyTnJKeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVZV05qYjNWdWRITWdQU0J1WlhjZ1ZFOU9VWFZsY21sbGMwMXZaSFZzWlVOdmJHeGxZM1JwYjI0b2RHaHBjeXdnSjJGalkyOTFiblJ6Snl3Z0owRmpZMjkxYm5RbktUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1aWJHOWphM05mYzJsbmJtRjBkWEpsY3lBOVhHNGdJQ0FnSUNBZ0lDQWdJQ0J1WlhjZ1ZFOU9VWFZsY21sbGMwMXZaSFZzWlVOdmJHeGxZM1JwYjI0b2RHaHBjeXdnSjJKc2IyTnJjMTl6YVdkdVlYUjFjbVZ6Snl3Z0owSnNiMk5yVTJsbmJtRjBkWEpsY3ljcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdkbGRGRjFaWEo1VlhKc0tDazZJSE4wY21sdVp5QjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1keVlYQm9jV3hEYkdsbGJuUkRiMjVtYVdjL0xtaDBkSEJWY213Z2ZId2dKeWM3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ1pHVjBaV04wVW1Wa2FYSmxZM1FvWm1WMFkyZzZJR0Z1ZVN3Z2MyOTFjbU5sVlhKc09pQnpkSEpwYm1jcE9pQlFjbTl0YVhObFBITjBjbWx1Wno0Z2UxeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCeVpYTndiMjV6WlNBOUlHRjNZV2wwSUdabGRHTm9LSE52ZFhKalpWVnliQ2s3WEc0Z0lDQWdJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0J5WlhOd2IyNXpaVlJsZUhRZ1BTQmhkMkZwZENCeVpYTndiMjV6WlM1MFpYaDBLQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCeVpYTndiMjV6WlVwemIyNGdQU0JLVTA5T0xuQmhjbk5sS0hKbGMzQnZibk5sVkdWNGRDazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbk5sY25abGNrbHVabThnUFNCeVpYTnZiSFpsVTJWeWRtVnlTVzVtYnloeVpYTndiMjV6WlVwemIyNHVaR0YwWVM1cGJtWnZMblpsY25OcGIyNHBPMXh1SUNBZ0lDQWdJQ0I5SUdOaGRHTm9JSHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCcFppQW9jbVZ6Y0c5dWMyVXVjbVZrYVhKbFkzUmxaQ0E5UFQwZ2RISjFaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlISmxjM0J2Ym5ObExuVnliRHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCcFppQW9jbVZ6Y0c5dWMyVXVjbVZrYVhKbFkzUmxaQ0E5UFQwZ1ptRnNjMlVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQW5KenRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCamIyNXpkQ0J6YjNWeVkyVk1iMk5oZEdsdmJpQTlJRlZTVEZCaGNuUnpMbkJoY25ObEtITnZkWEpqWlZWeWJDbGNiaUFnSUNBZ0lDQWdJQ0FnSUM1bWFYaFJkV1Z5ZVNnb0tTQTlQaUFuSnlsY2JpQWdJQ0FnSUNBZ0lDQWdJQzUwYjFOMGNtbHVaeWdwWEc0Z0lDQWdJQ0FnSUNBZ0lDQXVkRzlNYjNkbGNrTmhjMlVvS1R0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY21WemNHOXVjMlZNYjJOaGRHbHZiaUE5SUZWU1RGQmhjblJ6TG5CaGNuTmxLSEpsYzNCdmJuTmxMblZ5YkNsY2JpQWdJQ0FnSUNBZ0lDQWdJQzVtYVhoUmRXVnllU2dvS1NBOVBpQW5KeWxjYmlBZ0lDQWdJQ0FnSUNBZ0lDNTBiMU4wY21sdVp5Z3BYRzRnSUNBZ0lDQWdJQ0FnSUNBdWRHOU1iM2RsY2tOaGMyVW9LVHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSEpsYzNCdmJuTmxURzlqWVhScGIyNGdJVDA5SUhOdmRYSmpaVXh2WTJGMGFXOXVJRDhnY21WemNHOXVjMlV1ZFhKc0lEb2dKeWM3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ1oyVjBRMnhwWlc1MFEyOXVabWxuS0NrNklGQnliMjFwYzJVOFIzSmhjR2hSVEVOc2FXVnVkRU52Ym1acFp6NGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQmpiMjVtYVdjZ1BTQjBhR2x6TG1OdmJtWnBaenRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZMnhwWlc1MFVHeGhkR1p2Y20wZ1BTQlVUMDVEYkdsbGJuUXVZMnhwWlc1MFVHeGhkR1p2Y20wN1hHNGdJQ0FnSUNBZ0lHbG1JQ2doWTJ4cFpXNTBVR3hoZEdadmNtMHBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9jbTkzSUVWeWNtOXlLQ2RVVDA0Z1EyeHBaVzUwSUdSdlpYTWdibTkwSUdOdmJtWnBaM1Z5WldRbktUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JqYjI1emRDQm1aWFJqYUNBOUlHTnNhV1Z1ZEZCc1lYUm1iM0p0TG1abGRHTm9PMXh1WEc0Z0lDQWdJQ0FnSUdaMWJtTjBhVzl1SUdkbGRFTnZibVpwWjBadmNsTmxjblpsY2loelpYSjJaWEk2SUhOMGNtbHVaeWs2SUVkeVlYQm9VVXhEYkdsbGJuUkRiMjVtYVdjZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdhSFIwY0ZCaGNuUnpJRDBnVlZKTVVHRnlkSE11Y0dGeWMyVW9jMlZ5ZG1WeUtWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDNW1hWGhRY205MGIyTnZiQ2g0SUQwK0lDaDRJRDA5UFNBbmFIUjBjRG92THljZ1B5QjRJRG9nSjJoMGRIQnpPaTh2SnlrcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0xtWnBlRkJoZEdnb2VDQTlQaUJnSkh0NGZTOW5jbUZ3YUhGc1lDazdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JvZEhSd0lEMGdhSFIwY0ZCaGNuUnpMblJ2VTNSeWFXNW5LQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCM2N5QTlJR2gwZEhCUVlYSjBjMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzVtYVhoUWNtOTBiMk52YkNoNElEMCtJQ2g0SUQwOVBTQW5hSFIwY0Rvdkx5Y2dQeUFuZDNNNkx5OG5JRG9nSjNkemN6b3ZMeWNwS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM1MGIxTjBjbWx1WnlncE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JvZEhSd1ZYSnNPaUJvZEhSd0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIZHpWWEpzT2lCM2N5eGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1aWFJqYURvZ1kyeHBaVzUwVUd4aGRHWnZjbTB1Wm1WMFkyZ3NYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdWMlZpVTI5amEyVjBPaUJqYkdsbGJuUlFiR0YwWm05eWJTNVhaV0pUYjJOclpYUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnWm05eUlDaGpiMjV6ZENCelpYSjJaWElnYjJZZ1kyOXVabWxuTG1SaGRHRXVjMlZ5ZG1WeWN5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWTJ4cFpXNTBRMjl1Wm1sbklEMGdaMlYwUTI5dVptbG5SbTl5VTJWeWRtVnlLSE5sY25abGNpazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMVzVsZUhRdGJHbHVaU0J1YnkxaGQyRnBkQzFwYmkxc2IyOXdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnYm05cGJuTndaV04wYVc5dUlGTndaV3hzUTJobFkydHBibWRKYm5Od1pXTjBhVzl1WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdjbVZrYVhKbFkzUmxaQ0E5SUdGM1lXbDBJSFJvYVhNdVpHVjBaV04wVW1Wa2FYSmxZM1FvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHWmxkR05vTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmdKSHRqYkdsbGJuUkRiMjVtYVdjdWFIUjBjRlZ5YkgwL2NYVmxjbms5SlRkQ2FXNW1ieVUzUW5abGNuTnBiMjRsTjBRbE4wUmdMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tISmxaR2x5WldOMFpXUWdJVDA5SUNjbktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR2gwZEhCUVlYSjBjeUE5SUZWU1RGQmhjblJ6TG5CaGNuTmxLSEpsWkdseVpXTjBaV1FwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F1Wm1sNFVYVmxjbmtvWHlBOVBpQW5KeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnNhV1Z1ZEVOdmJtWnBaeTVvZEhSd1ZYSnNJRDBnYUhSMGNGQmhjblJ6TG5SdlUzUnlhVzVuS0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR05zYVdWdWRFTnZibVpwWnk1M2MxVnliQ0E5SUdoMGRIQlFZWEowYzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTG1acGVGQnliM1J2WTI5c0tIZ2dQVDRnS0hnZ1BUMDlJQ2RvZEhSd09pOHZKeUEvSUNkM2N6b3ZMeWNnT2lBbmQzTnpPaTh2SnlrcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdWRHOVRkSEpwYm1jb0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHTnNhV1Z1ZEVOdmJtWnBaenRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMGdZMkYwWTJnZ0tHVnljbTl5S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWW9ZMjl1Wm1sbkxsOWxjbkpNYjJkV1pYSmliM05sS1NCamIyNXpiMnhsTG14dlp5aGdXMmRsZEVOc2FXVnVkRU52Ym1acFoxMGdabTl5SUhObGNuWmxjaUJjSWlSN2MyVnlkbVZ5ZlZ3aUlHWmhhV3hsWkdBc0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYldWemMyRm5aVG9nWlhKeWIzSXViV1Z6YzJGblpTQjhmQ0JsY25KdmNpNTBiMU4wY21sdVp5Z3BMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhPaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JvZEhSd1gzVnliRG9nWTJ4cFpXNTBRMjl1Wm1sbkxtaDBkSEJWY213c1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCM2MxOTFjbXc2SUdOc2FXVnVkRU52Ym1acFp5NTNjMVZ5YkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWjJWMFEyOXVabWxuUm05eVUyVnlkbVZ5S0dOdmJtWnBaeTVrWVhSaExuTmxjblpsY25OYk1GMHBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUdkbGRGTmxjblpsY2tsdVptOG9jM0JoYmo4NklGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDazZJRkJ5YjIxcGMyVThVMlZ5ZG1WeVNXNW1iejRnZTF4dUlDQWdJQ0FnSUNCaGQyRnBkQ0IwYUdsekxtZHlZWEJvY1d4RGJHbGxiblJTWlhGMWFYSmxaQ2h6Y0dGdUtUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11YzJWeWRtVnlTVzVtYnp0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QnpaWEoyWlhKVWFXMWxSR1ZzZEdFb2MzQmhiajg2SUZOd1lXNGdmQ0JUY0dGdVEyOXVkR1Y0ZENrNklGQnliMjFwYzJVOGJuVnRZbVZ5UGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhObGNuWmxja2x1Wm04Z1BTQmhkMkZwZENCMGFHbHpMbWRsZEZObGNuWmxja2x1Wm04b2MzQmhiaWs3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR05zYVdWdWRFTnZibVpwWnlBOUlIUm9hWE11WjNKaGNHaHhiRU5zYVdWdWRFTnZibVpwWnp0Y2JpQWdJQ0FnSUNBZ2FXWWdLR05zYVdWdWRFTnZibVpwWnlBbUppQnpaWEoyWlhKSmJtWnZMbk4xY0hCdmNuUnpWR2x0WlNBbUppQnpaWEoyWlhKSmJtWnZMblJwYldWRVpXeDBZU0E5UFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0J6ZEdGeWRDQTlJRVJoZEdVdWJtOTNLQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2JtOXBibk53WldOMGFXOXVJRk53Wld4c1EyaGxZMnRwYm1kSmJuTndaV04wYVc5dVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnY21WemNHOXVjMlVnUFNCaGQyRnBkQ0JqYkdsbGJuUkRiMjVtYVdjdVptVjBZMmdvWUNSN1kyeHBaVzUwUTI5dVptbG5MbWgwZEhCVmNteDlQM0YxWlhKNVBTVTNRbWx1Wm04bE4wSjBhVzFsSlRkRUpUZEVZQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdaVzVrSUQwZ1JHRjBaUzV1YjNjb0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCeVpYTndiMjV6WlVSaGRHRWdQU0JoZDJGcGRDQnlaWE53YjI1elpTNXFjMjl1S0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnYzJWeWRtVnlWR2x0WlNBOUlISmxjM0J2Ym5ObFJHRjBZUzVrWVhSaExtbHVabTh1ZEdsdFpUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnpaWEoyWlhKSmJtWnZMblJwYldWRVpXeDBZU0E5SUUxaGRHZ3VjbTkxYm1Rb2MyVnlkbVZ5VkdsdFpTQXRJQ2h6ZEdGeWRDQXJJQ2hsYm1RZ0xTQnpkR0Z5ZENrZ0x5QXlLU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlJR05oZEdOb0lDaGxjbkp2Y2lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1LR052Ym1acFp5NWZaWEp5VEc5blZtVnlZbTl6WlNrZ1kyOXVjMjlzWlM1c2IyY29KejQrUGljc0lHVnljbTl5S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYzJWeWRtVnlTVzVtYnk1MGFXMWxSR1ZzZEdFZ2ZId2dNRHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCelpYSjJaWEpPYjNjb2MzQmhiajg2SUZOd1lXNGdmQ0JUY0dGdVEyOXVkR1Y0ZENrNklGQnliMjFwYzJVOGJuVnRZbVZ5UGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhScGJXVkVaV3gwWVNBOUlHRjNZV2wwSUhSb2FYTXVjMlZ5ZG1WeVZHbHRaVVJsYkhSaEtITndZVzRwTzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnUkdGMFpTNXViM2NvS1NBcklIUnBiV1ZFWld4MFlUdGNiaUFnSUNCOVhHNWNiaUFnSUNCa2NtOXdVMlZ5ZG1WeVZHbHRaVVJsYkhSaEtDa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2RHaHBjeTV6WlhKMlpYSkpibVp2S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxuTmxjblpsY2tsdVptOHVkR2x0WlVSbGJIUmhJRDBnYm5Wc2JEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lHZGxibVZ5WVhSbFQzQmxjbUYwYVc5dVNXUW9LVG9nYzNSeWFXNW5JSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXZjR1Z5WVhScGIyNUpaRk4xWm1acGVDQXJQU0F4TzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWUNSN2RHaHBjeTV2Y0dWeVlYUnBiMjVKWkZCeVpXWnBlSDBrZTNSb2FYTXViM0JsY21GMGFXOXVTV1JUZFdabWFYZ3VkRzlUZEhKcGJtY29NVFlwZldBN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdabWx1YVhOb1QzQmxjbUYwYVc5dWN5aHZjR1Z5WVhScGIyNUpaSE02SUhOMGNtbHVaMXRkS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2h2Y0dWeVlYUnBiMjVKWkhNdWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200N1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdhV1lnS0NFb1lYZGhhWFFnZEdocGN5NW5aWFJUWlhKMlpYSkpibVp2S0NrcExuTjFjSEJ2Y25SelQzQmxjbUYwYVc5dVNXUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQmhkMkZwZENCMGFHbHpMbWR5WVhCb2NXeE5kWFJoZEdsdmJpaGdiWFYwWVhScGIyNGdabWx1YVhOb1QzQmxjbUYwYVc5dWN5Z2tiM0JsY21GMGFXOXVTV1J6T2lCYlUzUnlhVzVuWFNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHWnBibWx6YUU5d1pYSmhkR2x2Ym5Nb2IzQmxjbUYwYVc5dVNXUnpPaUFrYjNCbGNtRjBhVzl1U1dSektWeHVJQ0FnSUNBZ0lDQWdJQ0FnZldBc0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUc5d1pYSmhkR2x2Ymtsa2N5eGNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ1oyVjBRV05qYjNWdWRITkRiM1Z1ZENod1lYSmxiblJUY0dGdVB6b2dLRk53WVc0Z2ZDQlRjR0Z1UTI5dWRHVjRkQ2twT2lCUWNtOXRhWE5sUEc1MWJXSmxjajRnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0J5WlhOMWJIUWdQU0JoZDJGcGRDQjBhR2x6TG5GMVpYSjVLQ2R4ZFdWeWVYdG5aWFJCWTJOdmRXNTBjME52ZFc1MGZTY3NJSFZ1WkdWbWFXNWxaQ3dnY0dGeVpXNTBVM0JoYmlrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCeVpYTjFiSFF1WkdGMFlTNW5aWFJCWTJOdmRXNTBjME52ZFc1ME8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJR2RsZEZSeVlXNXpZV04wYVc5dWMwTnZkVzUwS0hCaGNtVnVkRk53WVc0L09pQW9VM0JoYmlCOElGTndZVzVEYjI1MFpYaDBLU2s2SUZCeWIyMXBjMlU4Ym5WdFltVnlQaUI3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSEpsYzNWc2RDQTlJR0YzWVdsMElIUm9hWE11Y1hWbGNua29KM0YxWlhKNWUyZGxkRlJ5WVc1ellXTjBhVzl1YzBOdmRXNTBmU2NzSUhWdVpHVm1hVzVsWkN3Z2NHRnlaVzUwVTNCaGJpazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnlaWE4xYkhRdVpHRjBZUzVuWlhSVWNtRnVjMkZqZEdsdmJuTkRiM1Z1ZER0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5Qm5aWFJCWTJOdmRXNTBjMVJ2ZEdGc1FtRnNZVzVqWlNod1lYSmxiblJUY0dGdVB6b2dLRk53WVc0Z2ZDQlRjR0Z1UTI5dWRHVjRkQ2twT2lCUWNtOXRhWE5sUEhOMGNtbHVaejRnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0J5WlhOMWJIUWdQU0JoZDJGcGRDQjBhR2x6TG5GMVpYSjVLQ2R4ZFdWeWVYdG5aWFJCWTJOdmRXNTBjMVJ2ZEdGc1FtRnNZVzVqWlgwbkxDQjFibVJsWm1sdVpXUXNJSEJoY21WdWRGTndZVzRwTzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnY21WemRXeDBMbVJoZEdFdVoyVjBRV05qYjNWdWRITlViM1JoYkVKaGJHRnVZMlU3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ2NHOXpkRkpsY1hWbGMzUnpLSEpsY1hWbGMzUnpPaUJTWlhGMVpYTjBXMTBzSUhCaGNtVnVkRk53WVc0L09pQW9VM0JoYmlCOElGTndZVzVEYjI1MFpYaDBLU2s2SUZCeWIyMXBjMlU4WVc1NVBpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1OdmJuUmxlSFF1ZEhKaFkyVW9KM0YxWlhKcFpYTXVjRzl6ZEZKbGNYVmxjM1J6Snl3Z1lYTjVibU1nS0hOd1lXNHBJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1keVlYQm9jV3hOZFhSaGRHbHZiaWhnYlhWMFlYUnBiMjRnY0c5emRGSmxjWFZsYzNSektDUnlaWEYxWlhOMGN6b2dXMUpsY1hWbGMzUmRLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY0c5emRGSmxjWFZsYzNSektISmxjWFZsYzNSek9pQWtjbVZ4ZFdWemRITXBYRzRnSUNBZ0lDQWdJQ0FnSUNCOVlDd2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsY1hWbGMzUnpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTd2djM0JoYmlrN1hHNGdJQ0FnSUNBZ0lIMHNJSEJoY21WdWRGTndZVzRwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0Z6ZVc1aklHMTFkR0YwYVc5dUtGeHVJQ0FnSUNBZ0lDQnhiRG9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0IyWVhKcFlXSnNaWE02SUhzZ1czTjBjbWx1WjEwNklHRnVlU0I5SUQwZ2UzMHNYRzRnSUNBZ0lDQWdJSEJoY21WdWRGTndZVzQvT2lBb1UzQmhiaUI4SUZOd1lXNURiMjUwWlhoMEtTeGNiaUFnSUNBcE9pQlFjbTl0YVhObFBHRnVlVDRnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NWpiMjUwWlhoMExuUnlZV05sS0NkeGRXVnlhV1Z6TG0xMWRHRjBhVzl1Snl3Z1lYTjVibU1nS0hOd1lXNDZJRk53WVc0cElEMCtJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lITndZVzR1YzJWMFZHRm5LQ2R3WVhKaGJYTW5MQ0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlhWMFlYUnBiMjQ2SUhGc0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjbWxoWW14bGN5eGNiaUFnSUNBZ0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdVozSmhjR2h4YkUxMWRHRjBhVzl1S0hGc0xDQjJZWEpwWVdKc1pYTXNJSE53WVc0cE8xeHVJQ0FnSUNBZ0lDQjlMQ0J3WVhKbGJuUlRjR0Z1S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QnhkV1Z5ZVNoY2JpQWdJQ0FnSUNBZ2NXdzZJSE4wY21sdVp5eGNiaUFnSUNBZ0lDQWdkbUZ5YVdGaWJHVnpPaUI3SUZ0emRISnBibWRkT2lCaGJua2dmU0E5SUh0OUxGeHVJQ0FnSUNBZ0lDQndZWEpsYm5SVGNHRnVQem9nS0ZOd1lXNGdmQ0JUY0dGdVEyOXVkR1Y0ZENrc1hHNGdJQ0FnSUNBZ0lIUnBiV1Z2ZFhRL09pQnVkVzFpWlhJc1hHNGdJQ0FnS1RvZ1VISnZiV2x6WlR4aGJuaytJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdVkyOXVkR1Y0ZEM1MGNtRmpaU2duY1hWbGNtbGxjeTV4ZFdWeWVTY3NJR0Z6ZVc1aklDaHpjR0Z1T2lCVGNHRnVLU0E5UGlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J6Y0dGdUxuTmxkRlJoWnlnbmNHRnlZVzF6Snl3Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIRjFaWEo1T2lCeGJDeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjJZWEpwWVdKc1pYTXNYRzRnSUNBZ0lDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxtZHlZWEJvY1d4UmRXVnllU2h4YkN3Z2RtRnlhV0ZpYkdWekxDQnpjR0Z1TENCMGFXMWxiM1YwS1R0Y2JpQWdJQ0FnSUNBZ2ZTd2djR0Z5Wlc1MFUzQmhiaWs3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZWE41Ym1NZ1ozSmhjR2h4YkUxMWRHRjBhVzl1S0hGc09pQnpkSEpwYm1jc0lIWmhjbWxoWW14bGN6b2dleUJiYzNSeWFXNW5YVG9nWVc1NUlIMGdQU0I3ZlN3Z2MzQmhiam9nVTNCaGJpazZJRkJ5YjIxcGMyVThZVzU1UGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUcxMWRHRjBhVzl1SUQwZ1ozRnNLRnR4YkYwcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTVuY21Gd2FGRnNLQ2hqYkdsbGJuUXBJRDArSUdOc2FXVnVkQzV0ZFhSaGRHVW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JYVjBZWFJwYjI0c1hHNGdJQ0FnSUNBZ0lDQWdJQ0IyWVhKcFlXSnNaWE1zWEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjUwWlhoME9pQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkSEpoWTJWVGNHRnVPaUJ6Y0dGdUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ2ZTa3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lITjBZWFJwWXlCcGMwNWxkSGR2Y210RmNuSnZjaWhsY25KdmNqb2dZVzU1S1RvZ1ltOXZiR1ZoYmlCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hsY25KdmNpNWpiMlJsSUQwOVBTQlVUMDVGY25KdmNrTnZaR1V1VVZWRlVsbGZSazlTUTBsQ1RGbGZRVUpQVWxSRlJDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSeWRXVTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdibVYwZDI5eWEwVnljbTl5SUQwZ1pYSnliM0l1Ym1WMGQyOXlhMFZ5Y205eU8xeHVJQ0FnSUNBZ0lDQnBaaUFvSVc1bGRIZHZjbXRGY25KdmNpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUdsbUlDZ25aWEp5Ym04bklHbHVJRzVsZEhkdmNtdEZjbkp2Y2lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlDRW9KM0psYzNCdmJuTmxKeUJwYmlCdVpYUjNiM0pyUlhKeWIzSWdmSHdnSjNKbGMzVnNkQ2NnYVc0Z2JtVjBkMjl5YTBWeWNtOXlLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCbmNtRndhSEZzVVhWbGNua29YRzRnSUNBZ0lDQWdJSEZzT2lCemRISnBibWNzWEc0Z0lDQWdJQ0FnSUhaaGNtbGhZbXhsY3pvZ2V5QmJjM1J5YVc1blhUb2dZVzU1SUgwZ1BTQjdmU3hjYmlBZ0lDQWdJQ0FnYzNCaGJqb2dVM0JoYml4Y2JpQWdJQ0FnSUNBZ2RHbHRaVzkxZEQ4NklHNTFiV0psY2l4Y2JpQWdJQ0FwT2lCUWNtOXRhWE5sUEdGdWVUNGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQnhkV1Z5ZVNBOUlHZHhiQ2hiY1d4ZEtUdGNiaUFnSUNBZ0lDQWdiR1YwSUc1bGVIUlVhVzFsYjNWMElEMGdNVEF3TzF4dUlDQWdJQ0FnSUNCamIyNXpkQ0J6ZEdGeWRGUnBiV1VnUFNCRVlYUmxMbTV2ZHlncE8xeHVJQ0FnSUNBZ0lDQnNaWFFnWm05eVkyVlVaWEp0YVc1aGRHVkZlSFJ5WVZScGJXVnZkWFFnUFNBMU1EQXdPMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQm1iM0pqWlZSbGNtMXBibUYwWlZScGJXVnZkWFFnUFNCMGFXMWxiM1YwSUh4OElIUm9hWE11WTI5dVptbG5MbmRoYVhSR2IzSlVhVzFsYjNWMEtDazdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBjblZsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdOc2FXVnVkQ0E5SUdGM1lXbDBJSFJvYVhNdVozSmhjR2h4YkVOc2FXVnVkRkpsY1hWcGNtVmtLSE53WVc0cE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdOdmJuUmxlSFE2SUdGdWVTQTlJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RISmhZMlZUY0dGdU9pQnpjR0Z1TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1aWFJqYUU5d2RHbHZibk02SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhGMVpYSjVWR2x0Wlc5MWREb2dUV0YwYUM1dGFXNG9YRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWm05eVkyVlVaWEp0YVc1aGRHVlVhVzFsYjNWMElDc2dabTl5WTJWVVpYSnRhVzVoZEdWRmVIUnlZVlJwYldWdmRYUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnVFVGWVgxUkpUVVZQVlZRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBcExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdGM1lXbDBJRzVsZHlCUWNtOXRhWE5sS0NoeVpYTnZiSFpsTENCeVpXcGxZM1FwSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS0dGemVXNWpJQ2dwSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHeGxkQ0JwYzBGamRIVmhiQ0E5SUhSeWRXVTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCa2IxSmxjMjlzZG1VZ1BTQW9jbVZ6ZFd4MEtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR2x6UVdOMGRXRnNLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2x6UVdOMGRXRnNJRDBnWm1Gc2MyVTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjMjlzZG1Vb2NtVnpkV3gwS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCa2IxSmxhbVZqZENBOUlDaGxjbkp2Y2lrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaHBjMEZqZEhWaGJDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBjMEZqZEhWaGJDQTlJR1poYkhObE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpXcGxZM1FvWlhKeWIzSXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVjbVZuYVhOMFpYSlJkV1Z5ZVZKbGFtVmpkQ2hrYjFKbGFtVmpkQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1J2VW1WemIyeDJaU2hoZDJGcGRDQmpiR2xsYm5RdWNYVmxjbmtvZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J4ZFdWeWVTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RtRnlhV0ZpYkdWekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNTBaWGgwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMHBLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1Z5Y205eUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWkc5U1pXcGxZM1FvWlhKeWIzSXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmU0JtYVc1aGJHeDVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMblZ1Y21WbmFYTjBaWEpSZFdWeWVWSmxhbVZqZENoa2IxSmxhbVZqZENrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBwS0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOUlHTmhkR05vSUNobGNuSnZjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJSEpsYzI5c2RtVmtSWEp5YjNJZ1BTQmhkMkZwZENCMGFHbHpMbkpsYzI5c2RtVkhjbUZ3YUZGTVJYSnliM0lvWlhKeWIzSXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoVVQwNVJkV1Z5YVdWelRXOWtkV3hsTG1selRtVjBkMjl5YTBWeWNtOXlLSEpsYzI5c2RtVmtSWEp5YjNJcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ1ltSUNGMGFHbHpMbU52Ym1acFp5NXBjMDVsZEhkdmNtdFVhVzFsYjNWMFJYaHdhWEpsWkZOcGJtTmxLSE4wWVhKMFZHbHRaU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1amIyNW1hV2N1Ykc5bktISmxjMjlzZG1Wa1JYSnliM0lwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCeVpYUnllVVJsYkdGNVZHbHRaVzkxZENBOUlHNWxlSFJVYVcxbGIzVjBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaGQyRnBkQ0J1WlhjZ1VISnZiV2x6WlNoeVpYTnZiSFpsSUQwK0lITmxkRlJwYldWdmRYUW9jbVZ6YjJ4MlpTd2djbVYwY25sRVpXeGhlVlJwYldWdmRYUXBLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLRzVsZUhSVWFXMWxiM1YwSUR3Z016SXdNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYm1WNGRGUnBiV1Z2ZFhRZ0tqMGdNanRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1ptOXlZMlZVWlhKdGFXNWhkR1ZGZUhSeVlWUnBiV1Z2ZFhRZ1BDQjBhR2x6TG1OdmJtWnBaeTUzWVdsMFJtOXlWR2x0Wlc5MWRDZ3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYjNKalpWUmxjbTFwYm1GMFpVVjRkSEpoVkdsdFpXOTFkQ0FyUFNBMU1EQXdPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ2NtVnpiMngyWldSRmNuSnZjanRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCeVpYTnZiSFpsUjNKaGNHaFJURVZ5Y205eUtHVnljbTl5T2lCaGJua3BJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdaM0ZzUlhKeUlEMGdaWEp5YjNJdVozSmhjR2hSVEVWeWNtOXljeUFtSmlCbGNuSnZjaTVuY21Gd2FGRk1SWEp5YjNKeld6QmRPMXh1SUNBZ0lDQWdJQ0JwWmlBb1ozRnNSWEp5S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmpiR2xsYm5SRmNuSWdQU0J1WlhjZ1JYSnliM0lvWjNGc1JYSnlMbTFsYzNOaFoyVXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWjNGc1JYaGpJRDBnS0dkeGJFVnljaTVsZUhSbGJuTnBiMjV6SUNZbUlHZHhiRVZ5Y2k1bGVIUmxibk5wYjI1ekxtVjRZMlZ3ZEdsdmJpa2dmSHdnZTMwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FvWTJ4cFpXNTBSWEp5T2lCaGJua3BMbTUxYldKbGNpQTlJR2R4YkVWNFl5NWpiMlJsSUh4OElEQTdYRzRnSUNBZ0lDQWdJQ0FnSUNBb1kyeHBaVzUwUlhKeU9pQmhibmtwTG1OdlpHVWdQU0JuY1d4RmVHTXVZMjlrWlNCOGZDQXdPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0tHTnNhV1Z1ZEVWeWNqb2dZVzU1S1M1emIzVnlZMlVnUFNCbmNXeEZlR011YzI5MWNtTmxJSHg4SUNkamJHbGxiblFuTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHTnNhV1Z1ZEVWeWNqdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JqYjI1emRDQmxjbkp2Y25NZ1BTQmxjbkp2Y2x4dUlDQWdJQ0FnSUNBZ0lDQWdKaVlnWlhKeWIzSXVibVYwZDI5eWEwVnljbTl5WEc0Z0lDQWdJQ0FnSUNBZ0lDQW1KaUJsY25KdmNpNXVaWFIzYjNKclJYSnliM0l1Y21WemRXeDBYRzRnSUNBZ0lDQWdJQ0FnSUNBbUppQmxjbkp2Y2k1dVpYUjNiM0pyUlhKeWIzSXVjbVZ6ZFd4MExtVnljbTl5Y3p0Y2JpQWdJQ0FnSUNBZ2FXWWdLR1Z5Y205eWN5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUZSUFRrTnNhV1Z1ZEVWeWNtOXlMbkYxWlhKNVJtRnBiR1ZrS0dWeWNtOXljeXdnWVhkaGFYUWdkR2hwY3k1amIyMXdiR1YwWlVWeWNtOXlSR0YwWVNncEtUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdaWEp5YjNJN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWVhONWJtTWdaM0poY0doUmJDaHlaWEYxWlhOME9pQW9ZMnhwWlc1ME9pQkJjRzlzYkc5RGJHbGxiblFwSUQwK0lGQnliMjFwYzJVOFlXNTVQaXdnYzNCaGJqb2dVM0JoYmlrNklGQnliMjFwYzJVOFlXNTVQaUI3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR05zYVdWdWRDQTlJR0YzWVdsMElIUm9hWE11WjNKaGNHaHhiRU5zYVdWdWRGSmxjWFZwY21Wa0tITndZVzRwTzF4dUlDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdGM1lXbDBJSEpsY1hWbGMzUW9ZMnhwWlc1MEtUdGNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDQW9aWEp5YjNJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJR0YzWVdsMElIUm9hWE11Y21WemIyeDJaVWR5WVhCb1VVeEZjbkp2Y2lobGNuSnZjaWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5Qm5jbUZ3YUhGc1EyeHBaVzUwVW1WeGRXbHlaV1FvY0dGeVpXNTBVM0JoYmo4NklGTndZVzRnZkNCVGNHRnVRMjl1ZEdWNGRDazZJRkJ5YjIxcGMyVThRWEJ2Ykd4dlEyeHBaVzUwUGlCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxtZHlZWEJvY1d4RGJHbGxiblFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1keVlYQm9jV3hEYkdsbGJuUTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnYVdZZ0tIUm9hWE11WjNKaGNHaHhiRU5zYVdWdWRFTnlaV0YwYVc5dUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaGQyRnBkQ0IwYUdsekxtZHlZWEJvY1d4RGJHbGxiblJEY21WaGRHbHZiaTVzYVhOMFpXNG9LVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdOeVpXRjBhVzl1SUQwZ2JtVjNJRTExYkhScFkyRnpkRkJ5YjIxcGMyVW9LVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WjNKaGNHaHhiRU5zYVdWdWRFTnlaV0YwYVc5dUlEMGdZM0psWVhScGIyNDdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0YzWVdsMElIUm9hWE11WTI5dWRHVjRkQzUwY21GalpTZ25jMlYwZFhBZ1kyeHBaVzUwSnl3Z0tITndZVzRwSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdVkzSmxZWFJsUjNKaGNHaHhiRU5zYVdWdWRDaHpjR0Z1S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUxDQndZWEpsYm5SVGNHRnVLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxtZHlZWEJvY1d4RGJHbGxiblJEY21WaGRHbHZiaUE5SUc1MWJHdzdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZM0psWVhScGIyNHVjbVZ6YjJ4MlpTaDBhR2x6TG1keVlYQm9jV3hEYkdsbGJuUXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTQmpZWFJqYUNBb1pYSnliM0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbWR5WVhCb2NXeERiR2xsYm5SRGNtVmhkR2x2YmlBOUlHNTFiR3c3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTNKbFlYUnBiMjR1Y21WcVpXTjBLR1Z5Y205eUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCbGNuSnZjanRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1bmNtRndhSEZzUTJ4cFpXNTBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUdOeVpXRjBaVWR5WVhCb2NXeERiR2xsYm5Rb2MzQmhiam9nVTNCaGJpQjhJRk53WVc1RGIyNTBaWGgwS1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhWelpVaDBkSEFnUFNBaGRHaHBjeTVqYjI1bWFXY3VaR0YwWVM1MWMyVlhaV0pUYjJOclpYUkdiM0pSZFdWeWFXVnpPMXh1SUNBZ0lDQWdJQ0JzWlhRZ1kyeHBaVzUwUTI5dVptbG5JRDBnWVhkaGFYUWdkR2hwY3k1blpYUkRiR2xsYm5SRGIyNW1hV2NvS1R0Y2JseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCemRXSnpUM0IwYVc5dWN5QTlJSFJvYVhNdVkyOXVabWxuTG5SeVlXTmxjaTVwYm1wbFkzUW9jM0JoYml3Z1JrOVNUVUZVWDFSRldGUmZUVUZRTENCN2ZTazdYRzRnSUNBZ0lDQWdJR052Ym5OMElITjFZbk5qY21sd2RHbHZia05zYVdWdWREb2dVM1ZpYzJOeWFYQjBhVzl1UTJ4cFpXNTBJQ1lnZXlCMWNtdzZJSE4wY21sdVp5QjlJRDBnYm1WM0lGTjFZbk5qY21sd2RHbHZia05zYVdWdWRDaGNiaUFnSUNBZ0lDQWdJQ0FnSUdOc2FXVnVkRU52Ym1acFp5NTNjMVZ5YkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYVcxbGIzVjBPaUJMUlVWUVgwRk1TVlpGWDFSSlRVVlBWVlFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WamIyNXVaV04wT2lCMGNuVmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym01bFkzUnBiMjVRWVhKaGJYTTZJQ2dwSUQwK0lDaDdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdGalkyVnpjMHRsZVRvZ2RHaHBjeTVqYjI1bWFXY3VaR0YwWVNBbUppQjBhR2x6TG1OdmJtWnBaeTVrWVhSaExtRmpZMlZ6YzB0bGVTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYUdWaFpHVnljem9nYzNWaWMwOXdkR2x2Ym5Nc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTa3NYRzRnSUNBZ0lDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWTJ4cFpXNTBRMjl1Wm1sbkxsZGxZbE52WTJ0bGRDeGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnYzNWaWMyTnlhWEIwYVc5dVEyeHBaVzUwTG05dVVtVmpiMjV1WldOMFpXUW9LQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZb2RHaHBjeTVqYjI1bWFXY3VYMlZ5Y2t4dloxWmxjbUp2YzJVcElHTnZibk52YkdVdWJHOW5LQ2RiVkU5T1EyeHBaVzUwTG5GMVpYSnBaWE5kSnl3Z0oxZGxZbE52WTJ0bGRDQlNaV052Ym01bFkzUmxaQ2NwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1eVpXcGxZM1JCWTNScGRtVlJkV1Z5YVdWektDazdYRzRnSUNBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnSUNCamIyNXpkQ0JuZFdGeVpDQTlJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHUmxkR1ZqZEdsdVoxSmxaR2x5WldOMGFXOXVPaUJtWVd4elpTeGNiaUFnSUNBZ0lDQWdmVHRjYmlBZ0lDQWdJQ0FnYzNWaWMyTnlhWEIwYVc5dVEyeHBaVzUwTG05dVJYSnliM0lvS0NrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWW9kR2hwY3k1amIyNW1hV2N1WDJWeWNreHZaMVpsY21KdmMyVXBJR052Ym5OdmJHVXViRzluS0NkYlZFOU9RMnhwWlc1MExuRjFaWEpwWlhOZEp5d2dKMWRsWWxOdlkydGxkQ0JHWVdsc1pXUW5LVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2huZFdGeVpDNWtaWFJsWTNScGJtZFNaV1JwY21WamRHbHZiaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnlianRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUNoaGMzbHVZeUFvS1NBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdaM1ZoY21RdVpHVjBaV04wYVc1blVtVmthWEpsWTNScGIyNGdQU0IwY25WbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUc1bGQwTnZibVpwWnlBOUlHRjNZV2wwSUhSb2FYTXVaMlYwUTJ4cFpXNTBRMjl1Wm1sbktDazdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR052Ym1acFowbHpRMmhoYm1kbFpDQTlJRzVsZDBOdmJtWnBaeTVvZEhSd1ZYSnNJQ0U5UFNCamJHbGxiblJEYjI1bWFXY3VhSFIwY0ZWeWJGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZId2dibVYzUTI5dVptbG5MbmR6VlhKc0lDRTlQU0JqYkdsbGJuUkRiMjVtYVdjdWQzTlZjbXc3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hqYjI1bWFXZEpjME5vWVc1blpXUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtS0hSb2FYTXVZMjl1Wm1sbkxsOXNiMmRXWlhKaWIzTmxLU0JqYjI1emIyeGxMbXh2WnlnblcxUlBUa05zYVdWdWRDNXhkV1Z5YVdWelhTY3NJQ2REYkdsbGJuUWdZMjl1Wm1sbklHTm9ZVzVuWldRbktUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnNhV1Z1ZEVOdmJtWnBaeUE5SUc1bGQwTnZibVpwWnp0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVaM0poY0doeGJFTnNhV1Z1ZEVOdmJtWnBaeUE5SUdOc2FXVnVkRU52Ym1acFp6dGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lITjFZbk5qY21sd2RHbHZia05zYVdWdWRDNTFjbXdnUFNCdVpYZERiMjVtYVdjdWQzTlZjbXc3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2RHaHBjeTUzYzB4cGJtc3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbmR6VEdsdWF5NTFjbXdnUFNCdVpYZERiMjVtYVdjdWQzTlZjbXc3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2RHaHBjeTVvZEhSd1RHbHVheWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11YUhSMGNFeHBibXN1ZFhKcElEMGdibVYzUTI5dVptbG5MbWgwZEhCVmNtdzdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUlHTmhkR05vSUNobGNuSXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWW9kR2hwY3k1amIyNW1hV2N1WDJWeWNreHZaMVpsY21KdmMyVXBJR052Ym5OdmJHVXViRzluS0NkYlZFOU9RMnhwWlc1MExuRjFaWEpwWlhOZElISmxaR2x5WldOMGFXOXVJR1JsZEdWamRHOXlJR1poYVd4bFpDY3NJR1Z5Y2lrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHZDFZWEprTG1SbGRHVmpkR2x1WjFKbFpHbHlaV04wYVc5dUlEMGdabUZzYzJVN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1NncE8xeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnYzNWaWMyTnlhWEIwYVc5dVEyeHBaVzUwTG0xaGVFTnZibTVsWTNSVWFXMWxSMlZ1WlhKaGRHOXlMbVIxY21GMGFXOXVJRDBnS0NrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhOMVluTmpjbWx3ZEdsdmJrTnNhV1Z1ZEM1dFlYaERiMjV1WldOMFZHbHRaVWRsYm1WeVlYUnZjaTV0WVhnN1hHNGdJQ0FnSUNBZ0lIMDdYRzVjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkSEpoWTJWeVRHbHVheUE5SUdGM1lXbDBJSE5sZEVOdmJuUmxlSFFvS0Y4c0lISmxjU2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdjbVZ6YjJ4MlpXUlRjR0Z1SUQwZ0tISmxjU0FtSmlCeVpYRXVkSEpoWTJWVGNHRnVLU0I4ZkNCemNHRnVPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVnhMbWhsWVdSbGNuTWdQU0I3ZlR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVkyOXVabWxuTG5SeVlXTmxjaTVwYm1wbFkzUW9jbVZ6YjJ4MlpXUlRjR0Z1TENCR1QxSk5RVlJmVkVWWVZGOU5RVkFzSUhKbGNTNW9aV0ZrWlhKektUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR0ZqWTJWemMwdGxlU0E5SUhSb2FYTXVZMjl1Wm1sbkxtUmhkR0VnSmlZZ2RHaHBjeTVqYjI1bWFXY3VaR0YwWVM1aFkyTmxjM05MWlhrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1lXTmpaWE56UzJWNUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVZ4TG1obFlXUmxjbk11WVdOalpYTnpTMlY1SUQwZ1lXTmpaWE56UzJWNU8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm9aV0ZrWlhKek9pQnlaWEV1YUdWaFpHVnljeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lIMDdYRzRnSUNBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnSUNCamIyNXpkQ0IzY21Gd1RHbHVheUE5SUNoc2FXNXJPaUJCY0c5c2JHOU1hVzVyS1RvZ1FYQnZiR3h2VEdsdWF5QTlQaUIwY21GalpYSk1hVzVyTG1OdmJtTmhkQ2hzYVc1cktUdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2FYTlRkV0p6WTNKcGNIUnBiMjRnUFNBb2V5QnhkV1Z5ZVNCOUtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCa1pXWnBibWwwYVc5dUlEMGdaMlYwVFdGcGJrUmxabWx1YVhScGIyNG9jWFZsY25rcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQ2hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1TG10cGJtUWdQVDA5SUNkUGNHVnlZWFJwYjI1RVpXWnBibWwwYVc5dUoxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDWW1JR1JsWm1sdWFYUnBiMjR1YjNCbGNtRjBhVzl1SUQwOVBTQW5jM1ZpYzJOeWFYQjBhVzl1SjF4dUlDQWdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnZlR0Y2JseHVJQ0FnSUNBZ0lDQjBhR2x6TG5kelRHbHVheUE5SUc1bGR5QlhaV0pUYjJOclpYUk1hVzVyS0hOMVluTmpjbWx3ZEdsdmJrTnNhV1Z1ZENrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11YUhSMGNFeHBibXNnUFNCMWMyVklkSFJ3WEc0Z0lDQWdJQ0FnSUNBZ0lDQS9JRzVsZHlCSWRIUndUR2x1YXloN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RYSnBPaUJqYkdsbGJuUkRiMjVtYVdjdWFIUjBjRlZ5YkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbVpYUmphRG9nWVdKdmNuUmhZbXhsUm1WMFkyZ29ZMnhwWlc1MFEyOXVabWxuTG1abGRHTm9LU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIMHBYRzRnSUNBZ0lDQWdJQ0FnSUNBNklHNTFiR3c3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR3hwYm1zZ1BTQjBhR2x6TG1oMGRIQk1hVzVyWEc0Z0lDQWdJQ0FnSUNBZ0lDQS9JSE53YkdsMEtHbHpVM1ZpYzJOeWFYQjBhVzl1TENCM2NtRndUR2x1YXloMGFHbHpMbmR6VEdsdWF5a3NJSGR5WVhCTWFXNXJLSFJvYVhNdWFIUjBjRXhwYm1zcEtWeHVJQ0FnSUNBZ0lDQWdJQ0FnT2lCM2NtRndUR2x1YXloMGFHbHpMbmR6VEdsdWF5azdYRzRnSUNBZ0lDQWdJSFJvYVhNdVozSmhjR2h4YkVOc2FXVnVkRU52Ym1acFp5QTlJR05zYVdWdWRFTnZibVpwWnp0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVuY21Gd2FIRnNRMnhwWlc1MElEMGdibVYzSUVGd2IyeHNiME5zYVdWdWRDaDdYRzRnSUNBZ0lDQWdJQ0FnSUNCallXTm9aVG9nYm1WM0lFbHVUV1Z0YjNKNVEyRmphR1VvZTMwcExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYkdsdWF5eGNiaUFnSUNBZ0lDQWdJQ0FnSUdSbFptRjFiSFJQY0hScGIyNXpPaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZDJGMFkyaFJkV1Z5ZVRvZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtWlhSamFGQnZiR2xqZVRvZ0oyNXZMV05oWTJobEp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEYxWlhKNU9pQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdabGRHTm9VRzlzYVdONU9pQW5ibTh0WTJGamFHVW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlMRnh1SUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5QmpiRzl6WlNncElIdGNiaUFnSUNBZ0lDQWdhV1lnS0hSb2FYTXVaM0poY0doeGJFTnNhV1Z1ZENrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdZMnhwWlc1MElEMGdkR2hwY3k1bmNtRndhSEZzUTJ4cFpXNTBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVuY21Gd2FIRnNRMnhwWlc1MElEMGdiblZzYkR0Y2JpQWdJQ0FnSUNBZ0lDQWdJR05zYVdWdWRDNXpkRzl3S0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoZDJGcGRDQmpiR2xsYm5RdVkyeGxZWEpUZEc5eVpTZ3BPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdmVnh1ZlZ4dVhHNWNibU5zWVhOeklGUlBUbEYxWlhKcFpYTk5iMlIxYkdWRGIyeHNaV04wYVc5dUlHbHRjR3hsYldWdWRITWdWRTlPVVVOdmJHeGxZM1JwYjI0Z2UxeHVJQ0FnSUcxdlpIVnNaVG9nVkU5T1VYVmxjbWxsYzAxdlpIVnNaVHRjYmx4dUlDQWdJR052Ykd4bFkzUnBiMjVPWVcxbE9pQnpkSEpwYm1jN1hHNWNiaUFnSUNCMGVYQmxUbUZ0WlRvZ2MzUnlhVzVuTzF4dVhHNGdJQ0FnWTI5dWMzUnlkV04wYjNJb1hHNGdJQ0FnSUNBZ0lHMXZaSFZzWlRvZ1ZFOU9VWFZsY21sbGMwMXZaSFZzWlN4Y2JpQWdJQ0FnSUNBZ1kyOXNiR1ZqZEdsdmJrNWhiV1U2SUhOMGNtbHVaeXhjYmlBZ0lDQWdJQ0FnZEhsd1pVNWhiV1U2SUhOMGNtbHVaeXhjYmlBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXRiMlIxYkdVZ1BTQnRiMlIxYkdVN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WTI5c2JHVmpkR2x2Yms1aGJXVWdQU0JqYjJ4c1pXTjBhVzl1VG1GdFpUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1MGVYQmxUbUZ0WlNBOUlIUjVjR1ZPWVcxbE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJSEYxWlhKNUtGeHVJQ0FnSUNBZ0lDQXVMaTVoY21kelhHNGdJQ0FnSUNBZ0lDOHFYRzRnSUNBZ0lDQWdJQ0FnSUNCbWFXeDBaWEpQY2xCaGNtRnRjem9nWVc1NUlId2dWRTlPVVhWbGNubFFZWEpoYlhNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUTZJSE4wY21sdVp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUc5eVpHVnlRbmsvT2lCUGNtUmxja0o1VzEwc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JzYVcxcGREODZJRzUxYldKbGNpeGNiaUFnSUNBZ0lDQWdJQ0FnSUhScGJXVnZkWFEvT2lCdWRXMWlaWElzWEc0Z0lDQWdJQ0FnSUNBZ0lDQndZWEpsYm5SVGNHRnVQem9nS0ZOd1lXNGdmQ0JUY0dGdVEyOXVkR1Y0ZENsY2JpQWdJQ0FnSUNBZ0lDb3ZYRzRnSUNBZ0tUb2dVSEp2YldselpUeGhibmsrSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdabWxzZEdWeUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2IzSmtaWEpDZVN4Y2JpQWdJQ0FnSUNBZ0lDQWdJR3hwYldsMExGeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdsdFpXOTFkQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHOXdaWEpoZEdsdmJrbGtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NHRnlaVzUwVTNCaGJpeGNiaUFnSUNBZ0lDQWdmU0E5SUhKbGMyOXNkbVZRWVhKaGJYTThWRTlPVVhWbGNubFFZWEpoYlhNK0tHRnlaM01zSUNkbWFXeDBaWEluTENBb0tTQTlQaUFvZTF4dUlDQWdJQ0FnSUNBZ0lDQWdabWxzZEdWeU9pQmhjbWR6V3pCZExGeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBPaUFvWVhKbmMxc3hYVG9nWVc1NUtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUc5eVpHVnlRbms2SUNoaGNtZHpXekpkT2lCaGJua3BMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2JHbHRhWFE2SUNoaGNtZHpXek5kT2lCaGJua3BMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2RHbHRaVzkxZERvZ0tHRnlaM05iTkYwNklHRnVlU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQndZWEpsYm5SVGNHRnVPaUJoY21keld6VmRMRnh1SUNBZ0lDQWdJQ0I5S1NrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbTF2WkhWc1pTNWpiMjUwWlhoMExuUnlZV05sS0dBa2UzUm9hWE11WTI5c2JHVmpkR2x2Yms1aGJXVjlMbkYxWlhKNVlDd2dZWE41Ym1NZ0tITndZVzRwSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhOd1lXNHVjMlYwVkdGbktDZHdZWEpoYlhNbkxDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdabWxzZEdWeUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZEN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdmNtUmxja0o1TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4cGJXbDBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJwYldWdmRYUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiM0JsY21GMGFXOXVTV1FzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhWelpVOXdaWEpoZEdsdmJrbGtJRDBnYjNCbGNtRjBhVzl1U1dSY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBbUppQW9ZWGRoYVhRZ2RHaHBjeTV0YjJSMWJHVXVaMlYwVTJWeWRtVnlTVzVtYnloemNHRnVLU2t1YzNWd2NHOXlkSE5QY0dWeVlYUnBiMjVKWkR0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHTWdQU0IwYUdsekxtTnZiR3hsWTNScGIyNU9ZVzFsTzF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2RDQTlJSFJvYVhNdWRIbHdaVTVoYldVN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnhiQ0E5SUdCY2JpQWdJQ0FnSUNBZ0lDQWdJSEYxWlhKNUlDUjdZMzBvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSkdacGJIUmxjam9nSkh0MGZVWnBiSFJsY2l4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBa2IzSmtaWEpDZVRvZ1cxRjFaWEo1VDNKa1pYSkNlVjBzSUZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNSc2FXMXBkRG9nU1c1MExDQmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWtkR2x0Wlc5MWREb2dSbXh2WVhSY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBa2UzVnpaVTl3WlhKaGRHbHZia2xrSUQ4Z0p5d2dKRzl3WlhKaGRHbHZia2xrT2lCVGRISnBibWNuSURvZ0p5ZDlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdKSHRqZlNoY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdabWxzZEdWeU9pQWtabWxzZEdWeUxDQmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYjNKa1pYSkNlVG9nSkc5eVpHVnlRbmtzSUZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnNhVzFwZERvZ0pHeHBiV2wwTENCY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2x0Wlc5MWREb2dKSFJwYldWdmRYUmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSkh0MWMyVlBjR1Z5WVhScGIyNUpaQ0EvSUNjc0lHOXdaWEpoZEdsdmJrbGtPaUFrYjNCbGNtRjBhVzl1U1dRbklEb2dKeWQ5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS1NCN0lDUjdjbVZ6ZFd4MGZTQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVlEdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJSFpoY21saFlteGxjem9nZXlCYmMzUnlhVzVuWFRvZ1lXNTVJSDBnUFNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1ptbHNkR1Z5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUc5eVpHVnlRbmtzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkdsdGFYUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIVnpaVTl3WlhKaGRHbHZia2xrS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RtRnlhV0ZpYkdWekxtOXdaWEpoZEdsdmJrbGtJRDBnYjNCbGNtRjBhVzl1U1dRN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEdsdFpXOTFkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhaaGNtbGhZbXhsY3k1MGFXMWxiM1YwSUQwZ1RXRjBhQzV0YVc0b1RVRllYMVJKVFVWUFZWUXNJSFJwYldWdmRYUXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQ2hoZDJGcGRDQjBhR2x6TG0xdlpIVnNaUzVuY21Gd2FIRnNVWFZsY25rb2NXd3NJSFpoY21saFlteGxjeXdnYzNCaGJpd2dkR2x0Wlc5MWRDa3BMbVJoZEdGYlkxMDdYRzRnSUNBZ0lDQWdJSDBzSUhCaGNtVnVkRk53WVc0cE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdGemVXNWpJR0ZuWjNKbFoyRjBaU2hjYmlBZ0lDQWdJQ0FnY0dGeVlXMXpPaUJVVDA1UmRXVnllVUZuWjNKbFoyRjBaVkJoY21GdGN5eGNiaUFnSUNBcE9pQlFjbTl0YVhObFBITjBjbWx1WjF0ZFBpQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG0xdlpIVnNaUzVqYjI1MFpYaDBMblJ5WVdObEtHQWtlM1JvYVhNdVkyOXNiR1ZqZEdsdmJrNWhiV1Y5TG1GblozSmxaMkYwWldBc0lHRnplVzVqSUNoemNHRnVLU0E5UGlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J6Y0dGdUxuTmxkRlJoWnlnbmNHRnlZVzF6Snl3Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHWnBiSFJsY2pvZ2NHRnlZVzF6TG1acGJIUmxjaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYVdWc1pITTZJSEJoY21GdGN5NW1hV1ZzWkhNc1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaEtHRjNZV2wwSUhSb2FYTXViVzlrZFd4bExtZGxkRk5sY25abGNrbHVabThvYzNCaGJpa3BMbk4xY0hCdmNuUnpRV2RuY21WbllYUnBiMjV6S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnVkU5T1EyeHBaVzUwUlhKeWIzSXVjMlZ5ZG1WeVJHOWxjMjUwVTNWd2NHOXlkRUZuWjNKbFoyRjBhVzl1Y3loY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWGRoYVhRZ2RHaHBjeTV0YjJSMWJHVXVZMjl0Y0d4bGRHVkZjbkp2Y2tSaGRHRW9LU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnZENBOUlIUm9hWE11ZEhsd1pVNWhiV1U3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCeElEMGdkR2hwY3k1MGVYQmxUbUZ0WlM1bGJtUnpWMmwwYUNnbmN5Y3BJRDhnWUdGblozSmxaMkYwWlNSN2RIMWdJRG9nWUdGblozSmxaMkYwWlNSN2RIMXpZRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhGc0lEMGdZRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NYVmxjbmtnSkh0eGZTaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWtabWxzZEdWeU9pQWtlM1I5Um1sc2RHVnlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ1JtYVdWc1pITTZJRnRHYVdWc1pFRm5aM0psWjJGMGFXOXVYU0JjYmlBZ0lDQWdJQ0FnSUNBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FrZTNGOUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYVd4MFpYSTZJQ1JtYVd4MFpYSXNJRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbWFXVnNaSE02SUNSbWFXVnNaSE1nWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdmV0E3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCMllYSnBZV0pzWlhNNklIc2dXM04wY21sdVoxMDZJR0Z1ZVNCOUlEMGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1pwYkhSbGNqb2djR0Z5WVcxekxtWnBiSFJsY2l4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbWFXVnNaSE02SUhCaGNtRnRjeTVtYVdWc1pITXNYRzRnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQ2hoZDJGcGRDQjBhR2x6TG0xdlpIVnNaUzVuY21Gd2FIRnNVWFZsY25rb2NXd3NJSFpoY21saFlteGxjeXdnYzNCaGJpa3BMbVJoZEdGYmNWMDdYRzRnSUNBZ0lDQWdJSDBzSUhCaGNtRnRjeTV3WVhKbGJuUlRjR0Z1S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J6ZFdKelkzSnBZbVVvWEc0Z0lDQWdJQ0FnSUM0dUxtRnlaM05jYmlBZ0lDQWdJQ0FnTHlwY2JpQWdJQ0FnSUNBZ1ptbHNkR1Z5VDNKUVlYSmhiWE02SUdGdWVTQjhJRlJQVGxOMVluTmpjbWxpWlZCaGNtRnRjeXhjYmlBZ0lDQWdJQ0FnY21WemRXeDBQem9nYzNSeWFXNW5MRnh1SUNBZ0lDQWdJQ0J2YmtSdlkwVjJaVzUwUHpvZ1JHOWpSWFpsYm5Rc1hHNGdJQ0FnSUNBZ0lHOXVSWEp5YjNJL09pQW9aWEp5T2lCRmNuSnZjaWtnUFQ0Z2RtOXBaRnh1SUNBZ0lDQWdJQ0FnS2k5Y2JpQWdJQ0FwT2lCVGRXSnpZM0pwY0hScGIyNGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCbWFXeDBaWElzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J2YmtSdlkwVjJaVzUwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdiMjVGY25KdmNpeGNiaUFnSUNBZ0lDQWdmU0E5SUhKbGMyOXNkbVZRWVhKaGJYTThWRTlPVTNWaWMyTnlhV0psVUdGeVlXMXpQaWhoY21kekxDQW5abWxzZEdWeUp5d2dLQ2tnUFQ0Z0tIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdacGJIUmxjam9nWVhKbmMxc3dYU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxjM1ZzZERvZ0tHRnlaM05iTVYwNklHRnVlU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnZia1J2WTBWMlpXNTBPaUFvWVhKbmMxc3lYVG9nWVc1NUtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUc5dVJYSnliM0k2SUNoaGNtZHpXek5kT2lCaGJua3BMRnh1SUNBZ0lDQWdJQ0I5S1NrN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhOd1lXNGdQU0IwYUdsekxtMXZaSFZzWlM1amIyNW1hV2N1ZEhKaFkyVnlMbk4wWVhKMFUzQmhiaWduVkU5T1VYVmxjbWxsYzAxdlpIVnNaUzVxY3pwemRXSnpZM0pwWW1VZ0p5azdYRzRnSUNBZ0lDQWdJSE53WVc0dWMyVjBWR0ZuS0ZSaFozTXVVMUJCVGw5TFNVNUVMQ0FuWTJ4cFpXNTBKeWs3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSFJsZUhRZ1BTQmdjM1ZpYzJOeWFYQjBhVzl1SUNSN2RHaHBjeTVqYjJ4c1pXTjBhVzl1VG1GdFpYMG9KR1pwYkhSbGNqb2dKSHQwYUdsekxuUjVjR1ZPWVcxbGZVWnBiSFJsY2lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSkh0MGFHbHpMbU52Ykd4bFkzUnBiMjVPWVcxbGZTaG1hV3gwWlhJNklDUm1hV3gwWlhJcElIc2dKSHR5WlhOMWJIUjlJSDFjYmlBZ0lDQWdJQ0FnZldBN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUhGMVpYSjVJRDBnWjNGc0tGdDBaWGgwWFNrN1hHNGdJQ0FnSUNBZ0lHeGxkQ0J6ZFdKelkzSnBjSFJwYjI0Z1BTQnVkV3hzTzF4dUlDQWdJQ0FnSUNBb1lYTjVibU1nS0NrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmpiR2xsYm5RZ1BTQmhkMkZwZENCMGFHbHpMbTF2WkhWc1pTNW5jbUZ3YUhGc1EyeHBaVzUwVW1WeGRXbHlaV1FvYzNCaGJpazdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2IySnpaWEoyWVdKc1pTQTlJR05zYVdWdWRDNXpkV0p6WTNKcFltVW9lMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeGRXVnllU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RtRnlhV0ZpYkdWek9pQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1hV3gwWlhJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MzVmljMk55YVhCMGFXOXVJRDBnYjJKelpYSjJZV0pzWlM1emRXSnpZM0pwWW1Vb0tHMWxjM05oWjJVcElEMCtJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2IyNUViMk5GZG1WdWRDZ25hVzV6WlhKMEwzVndaR0YwWlNjc0lHMWxjM05oWjJVdVpHRjBZVnQwYUdsekxtTnZiR3hsWTNScGIyNU9ZVzFsWFNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOUlHTmhkR05vSUNobGNuSnZjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhOd1lXNHViRzluS0h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdaWFpsYm5RNklDZG1ZV2xzWldRbkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J3WVhsc2IyRmtPaUJsY25KdmNpeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2IyNUZjbkp2Y2lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J2YmtWeWNtOXlLR1Z5Y205eUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmloamIyNW1hV2N1WDJWeWNreHZaMVpsY21KdmMyVXBJR052Ym5OdmJHVXViRzluS0NkVVQwNGdRMnhwWlc1MElITjFZbk5qY21sd2RHbHZiaUJsY25KdmNpY3NJR1Z5Y205eUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMHBLQ2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjFibk4xWW5OamNtbGlaVG9nS0NrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoemRXSnpZM0pwY0hScGIyNHBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MzVmljMk55YVhCMGFXOXVMblZ1YzNWaWMyTnlhV0psS0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSE53WVc0dVptbHVhWE5vS0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNCOVhHNWNiaUFnSUNCaGMzbHVZeUIzWVdsMFJtOXlLRnh1SUNBZ0lDQWdJQ0F1TGk1aGNtZHpYRzRnSUNBZ0lDQWdJQzhxWEc0Z0lDQWdJQ0FnSUdacGJIUmxjazl5VUdGeVlXMXpPaUJoYm5rZ2ZDQlVUMDVYWVdsMFJtOXlVR0Z5WVcxekxGeHVJQ0FnSUNBZ0lDQnlaWE4xYkhRNklITjBjbWx1Wnl4Y2JpQWdJQ0FnSUNBZ2RHbHRaVzkxZEQ4NklHNTFiV0psY2l4Y2JpQWdJQ0FnSUNBZ2NHRnlaVzUwVTNCaGJqODZJQ2hUY0dGdUlId2dVM0JoYmtOdmJuUmxlSFFwWEc0Z0lDQWdJQ0FnSUNBcUwxeHVJQ0FnSUNrNklGQnliMjFwYzJVOFlXNTVQaUI3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHWnBiSFJsY2l4Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RDeGNiaUFnSUNBZ0lDQWdJQ0FnSUhScGJXVnZkWFE2SUhCaGNtRnRjMVJwYldWdmRYUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCd1lYSmxiblJUY0dGdUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnYjNCbGNtRjBhVzl1U1dRc1hHNGdJQ0FnSUNBZ0lIMGdQU0J5WlhOdmJIWmxVR0Z5WVcxelBGUlBUbGRoYVhSR2IzSlFZWEpoYlhNK0tHRnlaM01zSUNkbWFXeDBaWEluTENBb0tTQTlQaUFvZTF4dUlDQWdJQ0FnSUNBZ0lDQWdabWxzZEdWeU9pQmhjbWR6V3pCZExGeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBPaUFvWVhKbmMxc3hYVG9nWVc1NUtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUhScGJXVnZkWFE2SUNoaGNtZHpXekpkT2lCaGJua3BMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NHRnlaVzUwVTNCaGJqb2dZWEpuYzFzelhTeGNiaUFnSUNBZ0lDQWdmU2twTzF4dUlDQWdJQ0FnSUNCamIyNXpkQ0IwYVcxbGIzVjBJRDBnY0dGeVlXMXpWR2x0Wlc5MWRDQjhmQ0IwYUdsekxtMXZaSFZzWlM1amIyNW1hV2N1ZDJGcGRFWnZjbFJwYldWdmRYUW9LVHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdaRzlqY3lBOUlHRjNZV2wwSUhSb2FYTXVjWFZsY25rb2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWm1sc2RHVnlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVnpkV3gwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdkR2x0Wlc5MWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUhCaGNtVnVkRk53WVc0c1hHNGdJQ0FnSUNBZ0lDQWdJQ0J2Y0dWeVlYUnBiMjVKWkN4Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQWdJR2xtSUNoa2IyTnpMbXhsYm1kMGFDQStJREFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQmtiMk56V3pCZE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSFJvY205M0lGUlBUa05zYVdWdWRFVnljbTl5TG5kaGFYUkdiM0pVYVcxbGIzVjBLR0YzWVdsMElIUm9hWE11Ylc5a2RXeGxMbU52YlhCc1pYUmxSWEp5YjNKRVlYUmhLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZiR3hsWTNScGIyNDZJSFJvYVhNdVkyOXNiR1ZqZEdsdmJrNWhiV1VzWEc0Z0lDQWdJQ0FnSUgwcEtUdGNiaUFnSUNCOVhHNTlYRzVjYmxSUFRsRjFaWEpwWlhOTmIyUjFiR1V1Ylc5a2RXeGxUbUZ0WlNBOUlDZFVUMDVSZFdWeWFXVnpUVzlrZFd4bEp6dGNiaUpkZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWNvZGVNZXNzYWdlID0gZGVjb2RlTWVzc2FnZTtcbmV4cG9ydHMuZW5jb2RlT3V0cHV0ID0gZW5jb2RlT3V0cHV0O1xuZXhwb3J0cy5Db3JlQ3J5cHRvQm94ID0gZXhwb3J0cy5ERUZBVUxUX0hEX1BBVEggPSBleHBvcnRzLkRFRkFVTFRfTU5FTU9OSUNfV09SRF9DT1VOVCA9IGV4cG9ydHMuREVGQVVMVF9NTkVNT05JQ19ESUNUSU9OQVJZID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBkZWNvZGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2UuYmFzZTY0KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG1lc3NhZ2UuYmFzZTY0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBpZiAobWVzc2FnZS5oZXgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obWVzc2FnZS5oZXgsICdoZXgnKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShtZXNzYWdlLnRleHQgfHwgJycsICd1dGY4Jyk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZU91dHB1dChidWZmZXIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdCYXNlNjQnOlxuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgICBjYXNlICdIZXgnOlxuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG5cbiAgICBjYXNlICdIZXhVcHBlcmNhc2UnOlxuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cbn1cblxudmFyIG5vdEltcGxlbWVudGVkID0gbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblxudmFyIENvcmVTaWduaW5nQm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29yZVNpZ25pbmdCb3goY3J5cHRvQm94LCBoZFBhdGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29yZVNpZ25pbmdCb3gpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY3J5cHRvQm94XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZFBhdGhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInB1YmxpY0tleVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jcnlwdG9Cb3ggPSBjcnlwdG9Cb3g7XG4gICAgdGhpcy5oZFBhdGggPSBoZFBhdGg7XG4gICAgdGhpcy5wdWJsaWNLZXkgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvcmVTaWduaW5nQm94LCBbe1xuICAgIGtleTogXCJnZXRQdWJsaWNLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRQdWJsaWNLZXkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9Cb3guZ2V0U2lnbktleXModGhpcy5oZFBhdGgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IF9jb250ZXh0LnNlbnRbXCJwdWJsaWNcIl07XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5wdWJsaWNLZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gX2dldFB1YmxpY0tleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0UHVibGljS2V5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInNpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zaWduID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIobWVzc2FnZSwgb3V0cHV0RW5jb2RpbmcpIHtcbiAgICAgICAgdmFyIGtleXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9Cb3guZ2V0U2lnbktleXModGhpcy5oZFBhdGgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBrZXlzID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5jcnlwdG9Cb3guY3J5cHRvLm5hY2xTaWduRGV0YWNoZWQobWVzc2FnZSwgXCJcIi5jb25jYXQoa2V5cy5zZWNyZXQpLmNvbmNhdChrZXlzW1wicHVibGljXCJdKSwgb3V0cHV0RW5jb2RpbmcpKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2lnbihfeCwgX3gyKSB7XG4gICAgICAgIHJldHVybiBfc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2lnbjtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBDb3JlU2lnbmluZ0JveDtcbn0oKTtcblxudmFyIENvcmVFbmNyeXB0aW9uQm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29yZUVuY3J5cHRpb25Cb3goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvcmVFbmNyeXB0aW9uQm94KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb3JlRW5jcnlwdGlvbkJveCwgW3tcbiAgICBrZXk6IFwiZ2V0UHVibGljS2V5XCIsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHVibGljS2V5KCkge1xuICAgICAgdGhyb3cgbm90SW1wbGVtZW50ZWQ7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyxuby11bnVzZWQtdmFyc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5jcnlwdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNyeXB0KG1lc3NhZ2UsIG91dHB1dEVuY29kaW5nKSB7XG4gICAgICB0aHJvdyBub3RJbXBsZW1lbnRlZDtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLG5vLXVudXNlZC12YXJzXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWNyeXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHQobWVzc2FnZSwgb3V0cHV0RW5jb2RpbmcpIHtcbiAgICAgIHRocm93IG5vdEltcGxlbWVudGVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb3JlRW5jcnlwdGlvbkJveDtcbn0oKTtcblxudmFyIERFRkFVTFRfTU5FTU9OSUNfRElDVElPTkFSWSA9IDE7XG5leHBvcnRzLkRFRkFVTFRfTU5FTU9OSUNfRElDVElPTkFSWSA9IERFRkFVTFRfTU5FTU9OSUNfRElDVElPTkFSWTtcbnZhciBERUZBVUxUX01ORU1PTklDX1dPUkRfQ09VTlQgPSAxMjtcbmV4cG9ydHMuREVGQVVMVF9NTkVNT05JQ19XT1JEX0NPVU5UID0gREVGQVVMVF9NTkVNT05JQ19XT1JEX0NPVU5UO1xudmFyIERFRkFVTFRfSERfUEFUSCA9ICdtLzQ0XFwnLzM5NlxcJy8wXFwnLzAvMCc7XG5leHBvcnRzLkRFRkFVTFRfSERfUEFUSCA9IERFRkFVTFRfSERfUEFUSDtcblxuZnVuY3Rpb24gcmVzb2x2ZUhEUGF0aChwYXRoKSB7XG4gIGlmIChwYXRoID09PSBudWxsIHx8IHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBERUZBVUxUX0hEX1BBVEg7XG4gIH1cblxuICByZXR1cm4gcGF0aCB8fCAnbSc7XG59XG5cbnZhciBDb3JlQ3J5cHRvQm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29yZUNyeXB0b0JveChjcnlwdG8sIHBhcmFtcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3JlQ3J5cHRvQm94KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNyeXB0b1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jcnlwdGVkU2VlZFBocmFzZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2VlZFBocmFzZUVuY3J5cHRpb25Cb3hcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlZWRQaHJhc2VEaWN0aW9uYXJ5XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWVkUGhyYXNlV29yZENvdW50XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduaW5nQm94ZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY3J5cHRpb25Cb3hlc1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jcnlwdG8gPSBjcnlwdG87XG4gICAgdGhpcy5lbmNyeXB0ZWRTZWVkUGhyYXNlID0gcGFyYW1zLmVuY3J5cHRlZFNlZWRQaHJhc2U7XG4gICAgdGhpcy5zZWVkUGhyYXNlRW5jcnlwdGlvbkJveCA9IHBhcmFtcy5zZWVkUGhyYXNlRW5jcnlwdGlvbkJveDtcbiAgICB0aGlzLnNlZWRQaHJhc2VEaWN0aW9uYXJ5ID0gcGFyYW1zLnNlZWRQaHJhc2VEaWN0aW9uYXJ5IHx8IERFRkFVTFRfTU5FTU9OSUNfRElDVElPTkFSWTtcbiAgICB0aGlzLnNlZWRQaHJhc2VXb3JkQ291bnQgPSBwYXJhbXMuc2VlZFBocmFzZVdvcmRDb3VudCB8fCBERUZBVUxUX01ORU1PTklDX1dPUkRfQ09VTlQ7XG4gICAgdGhpcy5zaWduaW5nQm94ZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5lbmNyeXB0aW9uQm94ZXMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29yZUNyeXB0b0JveCwgW3tcbiAgICBrZXk6IFwiZ2V0U2lnbmluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFNpZ25pbmdCb3ggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIGhkUGF0aCwgc2lnbmluZ0JveDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaGRQYXRoID0gcmVzb2x2ZUhEUGF0aChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuaGRQYXRoKTtcbiAgICAgICAgICAgICAgICBzaWduaW5nQm94ID0gdGhpcy5zaWduaW5nQm94ZXMuZ2V0KGhkUGF0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNpZ25pbmdCb3gpIHtcbiAgICAgICAgICAgICAgICAgIHNpZ25pbmdCb3ggPSBuZXcgQ29yZVNpZ25pbmdCb3godGhpcywgaGRQYXRoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmluZ0JveGVzLnNldChoZFBhdGgsIHNpZ25pbmdCb3gpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHNpZ25pbmdCb3gpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRTaWduaW5nQm94KF94Mykge1xuICAgICAgICByZXR1cm4gX2dldFNpZ25pbmdCb3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFNpZ25pbmdCb3g7XG4gICAgfSgpIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLG5vLXVudXNlZC12YXJzXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbmNyeXB0aW9uQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVuY3J5cHRpb25Cb3gocGFyYW1zKSB7XG4gICAgICB0aHJvdyBub3RJbXBsZW1lbnRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0aGlzLnNpZ25pbmdCb3hlcy5jbGVhcigpO1xuICAgICAgdGhpcy5lbmNyeXB0aW9uQm94ZXMuY2xlYXIoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IC8vIEludGVybmFsc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2lnbktleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTaWduS2V5cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGhkUGF0aCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSB0aGlzLmNyeXB0bztcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VlZFBocmFzZUVuY3J5cHRpb25Cb3guZGVjcnlwdCh0aGlzLmVuY3J5cHRlZFNlZWRQaHJhc2UsICdUZXh0Jyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC50MSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC50MiA9IGhkUGF0aDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQudDMgPSB0aGlzLnNlZWRQaHJhc2VEaWN0aW9uYXJ5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC50NCA9IHRoaXMuc2VlZFBocmFzZVdvcmRDb3VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQudDUgPSB7XG4gICAgICAgICAgICAgICAgICBwaHJhc2U6IF9jb250ZXh0NC50MSxcbiAgICAgICAgICAgICAgICAgIHBhdGg6IF9jb250ZXh0NC50MixcbiAgICAgICAgICAgICAgICAgIGRpY3Rpb25hcnk6IF9jb250ZXh0NC50MyxcbiAgICAgICAgICAgICAgICAgIHdvcmRDb3VudDogX2NvbnRleHQ0LnQ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDQudDAubW5lbW9uaWNEZXJpdmVTaWduS2V5cy5jYWxsKF9jb250ZXh0NC50MCwgX2NvbnRleHQ0LnQ1KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNpZ25LZXlzKF94NCkge1xuICAgICAgICByZXR1cm4gX2dldFNpZ25LZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRTaWduS2V5cztcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBDb3JlQ3J5cHRvQm94O1xufSgpO1xuXG5leHBvcnRzLkNvcmVDcnlwdG9Cb3ggPSBDb3JlQ3J5cHRvQm94O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5dGIyUjFiR1Z6TDJOeWVYQjBieTFpYjNndWFuTWlYU3dpYm1GdFpYTWlPbHNpWkdWamIyUmxUV1Z6YzJGblpTSXNJbTFsYzNOaFoyVWlMQ0ppWVhObE5qUWlMQ0pDZFdabVpYSWlMQ0ptY205dElpd2lhR1Y0SWl3aWRHVjRkQ0lzSW1WdVkyOWtaVTkxZEhCMWRDSXNJbUoxWm1abGNpSXNJbVZ1WTI5a2FXNW5JaXdpZEc5VGRISnBibWNpTENKMGIxVndjR1Z5UTJGelpTSXNJbTV2ZEVsdGNHeGxiV1Z1ZEdWa0lpd2lSWEp5YjNJaUxDSkRiM0psVTJsbmJtbHVaMEp2ZUNJc0ltTnllWEIwYjBKdmVDSXNJbWhrVUdGMGFDSXNJbkIxWW14cFkwdGxlU0lzSW1kbGRGTnBaMjVMWlhseklpd2liM1YwY0hWMFJXNWpiMlJwYm1jaUxDSnJaWGx6SWl3aVkzSjVjSFJ2SWl3aWJtRmpiRk5wWjI1RVpYUmhZMmhsWkNJc0luTmxZM0psZENJc0lrTnZjbVZGYm1OeWVYQjBhVzl1UW05NElpd2lSRVZHUVZWTVZGOU5Ua1ZOVDA1SlExOUVTVU5VU1U5T1FWSlpJaXdpUkVWR1FWVk1WRjlOVGtWTlQwNUpRMTlYVDFKRVgwTlBWVTVVSWl3aVJFVkdRVlZNVkY5SVJGOVFRVlJJSWl3aWNtVnpiMngyWlVoRVVHRjBhQ0lzSW5CaGRHZ2lMQ0pEYjNKbFEzSjVjSFJ2UW05NElpd2ljR0Z5WVcxeklpd2laVzVqY25sd2RHVmtVMlZsWkZCb2NtRnpaU0lzSW5ObFpXUlFhSEpoYzJWRmJtTnllWEIwYVc5dVFtOTRJaXdpYzJWbFpGQm9jbUZ6WlVScFkzUnBiMjVoY25raUxDSnpaV1ZrVUdoeVlYTmxWMjl5WkVOdmRXNTBJaXdpYzJsbmJtbHVaMEp2ZUdWeklpd2lUV0Z3SWl3aVpXNWpjbmx3ZEdsdmJrSnZlR1Z6SWl3aWMybG5ibWx1WjBKdmVDSXNJbWRsZENJc0luTmxkQ0lzSW1Oc1pXRnlJaXdpVUhKdmJXbHpaU0lzSW5KbGMyOXNkbVVpTENKa1pXTnllWEIwSWl3aWNHaHlZWE5sSWl3aVpHbGpkR2x2Ym1GeWVTSXNJbmR2Y21SRGIzVnVkQ0lzSW0xdVpXMXZibWxqUkdWeWFYWmxVMmxuYmt0bGVYTWlYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGblFrOHNVMEZCVTBFc1lVRkJWQ3hEUVVGMVFrTXNUMEZCZGtJc1JVRkJlVVE3UVVGRE5VUXNUVUZCU1VFc1QwRkJUeXhEUVVGRFF5eE5RVUZhTEVWQlFXOUNPMEZCUTJoQ0xGZEJRVTlETEUxQlFVMHNRMEZCUTBNc1NVRkJVQ3hEUVVGWlNDeFBRVUZQTEVOQlFVTkRMRTFCUVhCQ0xFVkJRVFJDTEZGQlFUVkNMRU5CUVZBN1FVRkRTRHM3UVVGRFJDeE5RVUZKUkN4UFFVRlBMRU5CUVVOSkxFZEJRVm9zUlVGQmFVSTdRVUZEWWl4WFFVRlBSaXhOUVVGTkxFTkJRVU5ETEVsQlFWQXNRMEZCV1Vnc1QwRkJUeXhEUVVGRFNTeEhRVUZ3UWl4RlFVRjVRaXhMUVVGNlFpeERRVUZRTzBGQlEwZzdPMEZCUTBRc1UwRkJUMFlzVFVGQlRTeERRVUZEUXl4SlFVRlFMRU5CUVZsSUxFOUJRVThzUTBGQlEwc3NTVUZCVWl4SlFVRm5RaXhGUVVFMVFpeEZRVUZuUXl4TlFVRm9ReXhEUVVGUU8wRkJRMGc3TzBGQlIwMHNVMEZCVTBNc1dVRkJWQ3hEUVVGelFrTXNUVUZCZEVJc1JVRkJjME5ETEZGQlFYUkRMRVZCUVN0Rk8wRkJRMnhHTEZWQlFWRkJMRkZCUVZJN1FVRkRRU3hUUVVGTExGRkJRVXc3UVVGRFNTeGhRVUZQUkN4TlFVRk5MRU5CUVVORkxGRkJRVkFzUTBGQlowSXNVVUZCYUVJc1EwRkJVRHM3UVVGRFNpeFRRVUZMTEV0QlFVdzdRVUZEU1N4aFFVRlBSaXhOUVVGTkxFTkJRVU5GTEZGQlFWQXNRMEZCWjBJc1MwRkJhRUlzUTBGQlVEczdRVUZEU2l4VFFVRkxMR05CUVV3N1FVRkRTU3hoUVVGUFJpeE5RVUZOTEVOQlFVTkZMRkZCUVZBc1EwRkJaMElzUzBGQmFFSXNSVUZCZFVKRExGZEJRWFpDTEVWQlFWQTdPMEZCUTBvN1FVRkRTU3hoUVVGUFNDeE5RVUZOTEVOQlFVTkZMRkZCUVZBc1EwRkJaMElzVFVGQmFFSXNRMEZCVUR0QlFWSktPMEZCVlVnN08wRkJSVVFzU1VGQlRVVXNZMEZCWXl4SFFVRkhMRWxCUVVsRExFdEJRVW9zUTBGQlZTeHBRa0ZCVml4RFFVRjJRanM3U1VGSFRVTXNZenRCUVV0R0xEQkNRVUZaUXl4VFFVRmFMRVZCUVhORFF5eE5RVUYwUXl4RlFVRnpSRHRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVGQk96dEJRVU5zUkN4VFFVRkxSQ3hUUVVGTUxFZEJRV2xDUVN4VFFVRnFRanRCUVVOQkxGTkJRVXRETEUxQlFVd3NSMEZCWTBFc1RVRkJaRHRCUVVOQkxGTkJRVXRETEZOQlFVd3NSMEZCYVVJc1NVRkJha0k3UVVGRFNEczdPenM3T3pzN096dHZRa0ZIVVN4TFFVRkxRU3hUT3pzN096czdkVUpCUTJ0Q0xFdEJRVXRHTEZOQlFVd3NRMEZCWlVjc1YwRkJaaXhEUVVFeVFpeExRVUZMUml4TlFVRm9ReXhET3pzN1FVRkJlRUlzY1VKQlFVdERMRk03T3p0cFJFRkZSaXhMUVVGTFFTeFRPenM3T3pzN096czdPenM3T3pzN096czdPMmxIUVVkTWFFSXNUeXhGUVVFd1FtdENMR003T3pzN096czdkVUpCUTJRc1MwRkJTMG9zVTBGQlRDeERRVUZsUnl4WFFVRm1MRU5CUVRKQ0xFdEJRVXRHTEUxQlFXaERMRU03T3p0QlFVRmlTU3huUWtGQlFVRXNTVHRyUkVGRFF5eExRVUZMVEN4VFFVRk1MRU5CUVdWTkxFMUJRV1lzUTBGQmMwSkRMR2RDUVVGMFFpeERRVUYxUTNKQ0xFOUJRWFpETEZsQlFXMUViVUlzU1VGQlNTeERRVUZEUnl4TlFVRjRSQ3hUUVVGcFJVZ3NTVUZCU1N4VlFVRnlSU3hIUVVGblJrUXNZMEZCYUVZc1F6czdPenM3T3pzN096czdPenM3T3pzN096czdPMGxCUzFSTExHbENPenM3T3pzN08wRkJRMFk3YlVOQlEyZERPMEZCUXpWQ0xGbEJRVTFhTEdOQlFVNDdRVUZEU0N4TExFTkJSVVE3T3pzN05FSkJRMUZZTEU4c1JVRkJNRUpyUWl4akxFVkJRWGRFTzBGQlEzUkdMRmxCUVUxUUxHTkJRVTQ3UVVGRFNDeExMRU5CUlVRN096czdORUpCUTFGWUxFOHNSVUZCTUVKclFpeGpMRVZCUVhkRU8wRkJRM1JHTEZsQlFVMVFMR05CUVU0N1FVRkRTRHM3T3pzN08wRkJTVVVzU1VGQlRXRXNNa0pCUVRKQ0xFZEJRVWNzUTBGQmNFTTdPMEZCUTBFc1NVRkJUVU1zTWtKQlFUSkNMRWRCUVVjc1JVRkJjRU03TzBGQlEwRXNTVUZCVFVNc1pVRkJaU3hIUVVGSExITkNRVUY0UWpzN08wRkJSVkFzVTBGQlUwTXNZVUZCVkN4RFFVRjFRa01zU1VGQmRrSXNSVUZCT0VNN1FVRkRNVU1zVFVGQlNVRXNTVUZCU1N4TFFVRkxMRWxCUVZRc1NVRkJhVUlzVDBGQlQwRXNTVUZCVUN4TFFVRm5RaXhYUVVGeVF5eEZRVUZyUkR0QlFVTTVReXhYUVVGUFJpeGxRVUZRTzBGQlEwZzdPMEZCUTBRc1UwRkJUMFVzU1VGQlNTeEpRVUZKTEVkQlFXWTdRVUZEU0RzN1NVRkZXVU1zWVR0QlFWVlVMSGxDUVVGWlZDeE5RVUZhTEVWQlFTdENWU3hOUVVFdlFpeEZRVUV5UkR0QlFVRkJPenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVGQk96dEJRVUZCT3p0QlFVRkJPenRCUVVGQk96dEJRVU4yUkN4VFFVRkxWaXhOUVVGTUxFZEJRV05CTEUxQlFXUTdRVUZEUVN4VFFVRkxWeXh0UWtGQlRDeEhRVUV5UWtRc1RVRkJUU3hEUVVGRFF5eHRRa0ZCYkVNN1FVRkRRU3hUUVVGTFF5eDFRa0ZCVEN4SFFVRXJRa1lzVFVGQlRTeERRVUZEUlN4MVFrRkJkRU03UVVGRFFTeFRRVUZMUXl4dlFrRkJUQ3hIUVVFMFFrZ3NUVUZCVFN4RFFVRkRSeXh2UWtGQlVDeEpRVUVyUWxRc01rSkJRVE5FTzBGQlEwRXNVMEZCUzFVc2JVSkJRVXdzUjBGQk1rSktMRTFCUVUwc1EwRkJRMGtzYlVKQlFWQXNTVUZCT0VKVUxESkNRVUY2UkR0QlFVTkJMRk5CUVV0VkxGbEJRVXdzUjBGQmIwSXNTVUZCU1VNc1IwRkJTaXhGUVVGd1FqdEJRVU5CTEZOQlFVdERMR1ZCUVV3c1IwRkJkVUlzU1VGQlNVUXNSMEZCU2l4RlFVRjJRanRCUVVOSU96czdPenN3UjBGRmJVSk9MRTA3T3pzN096dEJRVU5XWml4blFrRkJRVUVzVFN4SFFVRlRXU3hoUVVGaExFTkJRVU5ITEUxQlFVUXNZVUZCUTBFc1RVRkJSQ3gxUWtGQlEwRXNUVUZCVFN4RFFVRkZaaXhOUVVGVUxFTTdRVUZEZUVKMVFpeG5Ra0ZCUVVFc1ZTeEhRVUZoTEV0QlFVdElMRmxCUVV3c1EwRkJhMEpKTEVkQlFXeENMRU5CUVhOQ2VFSXNUVUZCZEVJc1F6czdRVUZEYWtJc2IwSkJRVWtzUTBGQlEzVkNMRlZCUVV3c1JVRkJhVUk3UVVGRFlrRXNhMEpCUVVGQkxGVkJRVlVzUjBGQlJ5eEpRVUZKZWtJc1kwRkJTaXhEUVVGdFFpeEpRVUZ1UWl4RlFVRjVRa1VzVFVGQmVrSXNRMEZCWWp0QlFVTkJMSFZDUVVGTGIwSXNXVUZCVEN4RFFVRnJRa3NzUjBGQmJFSXNRMEZCYzBKNlFpeE5RVUYwUWl4RlFVRTRRblZDTEZWQlFUbENPMEZCUTBnN08ydEVRVU5OUVN4Vk96czdPenM3T3pzN096czdPenM3VVVGSFdEczdPenR4UTBGRGFVSlNMRTBzUlVGSllUdEJRVU14UWl4WlFVRk5ia0lzWTBGQlRqdEJRVU5JT3pzN05FSkJSWE5DTzBGQlEyNUNMRmRCUVV0M1FpeFpRVUZNTEVOQlFXdENUU3hMUVVGc1FqdEJRVU5CTEZkQlFVdEtMR1ZCUVV3c1EwRkJjVUpKTEV0QlFYSkNPMEZCUTBFc1lVRkJUME1zVDBGQlR5eERRVUZEUXl4UFFVRlNMRVZCUVZBN1FVRkRTQ3hMTEVOQlJVUTdPenM3TzNkSFFVVnJRalZDTEUwN096czdPeXRDUVVOUUxFdEJRVXRMTEUwN08zVkNRVU5OTEV0QlFVdFpMSFZDUVVGTUxFTkJRVFpDV1N4UFFVRTNRaXhEUVVGeFF5eExRVUZMWWl4dFFrRkJNVU1zUlVGQkswUXNUVUZCTDBRc1F6czdPenNyUWtGRFVtaENMRTA3SzBKQlEwMHNTMEZCUzJ0Q0xHOUNPeXRDUVVOT0xFdEJRVXRETEcxQ096dEJRVWhvUWxjc2EwSkJRVUZCTEUwN1FVRkRRV3BDTEd0Q1FVRkJRU3hKTzBGQlEwRnJRaXhyUWtGQlFVRXNWVHRCUVVOQlF5eHJRa0ZCUVVFc1V6czdLMFJCU21WRExITkNJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHk4Z1FHWnNiM2RjYmx4dWFXMXdiM0owSUhSNWNHVWdlMXh1SUNBZ0lGUlBUa055ZVhCMGJ5eGNiaUFnSUNCVVQwNURjbmx3ZEc5Q2IzZ3NYRzRnSUNBZ1ZFOU9RM0o1Y0hSdlFtOTRVR0Z5WVcxekxGeHVJQ0FnSUZSUFRrVnVZM0o1Y0hScGIyNUJiR2R2Y21sMGFHMHNYRzRnSUNBZ1ZFOU9SVzVqY25sd2RHbHZia0p2ZUN4Y2JpQWdJQ0JVVDA1SmJuQjFkRTFsYzNOaFoyVXNYRzRnSUNBZ1ZFOU9TMlY1VUdGcGNrUmhkR0VzWEc0Z0lDQWdWRTlPVFc1bGJXOXVhV05FYVdOMGFXOXVZWEo1Vkhsd1pTeGNiaUFnSUNCVVQwNU5ibVZ0YjI1cFkxZHZjbVJEYjNWdWRGUjVjR1VzWEc0Z0lDQWdWRTlPVDNWMGNIVjBSVzVqYjJScGJtZFVlWEJsTEZ4dUlDQWdJRlJQVGxOcFoyNXBibWRDYjNnc1hHNTlJR1p5YjIwZ0p5NHVMeTR1TDNSNWNHVnpKenRjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdSbFkyOWtaVTFsYzNOaFoyVW9iV1Z6YzJGblpUb2dWRTlPU1c1d2RYUk5aWE56WVdkbEtUb2dRblZtWm1WeUlIdGNiaUFnSUNCcFppQW9iV1Z6YzJGblpTNWlZWE5sTmpRcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlFSjFabVpsY2k1bWNtOXRLRzFsYzNOaFoyVXVZbUZ6WlRZMExDQW5ZbUZ6WlRZMEp5azdYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUlDaHRaWE56WVdkbExtaGxlQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnUW5WbVptVnlMbVp5YjIwb2JXVnpjMkZuWlM1b1pYZ3NJQ2RvWlhnbktUdGNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJRUoxWm1abGNpNW1jbTl0S0cxbGMzTmhaMlV1ZEdWNGRDQjhmQ0FuSnl3Z0ozVjBaamduS1R0Y2JuMWNibHh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWlc1amIyUmxUM1YwY0hWMEtHSjFabVpsY2pvZ1FuVm1abVZ5TENCbGJtTnZaR2x1WnpvZ1ZFOU9UM1YwY0hWMFJXNWpiMlJwYm1kVWVYQmxLVG9nYzNSeWFXNW5JSHRjYmlBZ0lDQnpkMmwwWTJnZ0tHVnVZMjlrYVc1bktTQjdYRzRnSUNBZ1kyRnpaU0FuUW1GelpUWTBKenBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR0oxWm1abGNpNTBiMU4wY21sdVp5Z25ZbUZ6WlRZMEp5azdYRzRnSUNBZ1kyRnpaU0FuU0dWNEp6cGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHSjFabVpsY2k1MGIxTjBjbWx1WnlnbmFHVjRKeWs3WEc0Z0lDQWdZMkZ6WlNBblNHVjRWWEJ3WlhKallYTmxKenBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR0oxWm1abGNpNTBiMU4wY21sdVp5Z25hR1Y0SnlrdWRHOVZjSEJsY2tOaGMyVW9LVHRjYmlBZ0lDQmtaV1poZFd4ME9seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1luVm1abVZ5TG5SdlUzUnlhVzVuS0NkMWRHWTRKeWs3WEc0Z0lDQWdmVnh1ZlZ4dVhHNWpiMjV6ZENCdWIzUkpiWEJzWlcxbGJuUmxaQ0E5SUc1bGR5QkZjbkp2Y2lnblRtOTBJR2x0Y0d4bGJXVnVkR1ZrSnlrN1hHNWNibHh1WTJ4aGMzTWdRMjl5WlZOcFoyNXBibWRDYjNnZ2FXMXdiR1Z0Wlc1MGN5QlVUMDVUYVdkdWFXNW5RbTk0SUh0Y2JpQWdJQ0JqY25sd2RHOUNiM2c2SUVOdmNtVkRjbmx3ZEc5Q2IzZzdYRzRnSUNBZ2FHUlFZWFJvT2lCemRISnBibWM3WEc0Z0lDQWdjSFZpYkdsalMyVjVPaUEvYzNSeWFXNW5PMXh1WEc0Z0lDQWdZMjl1YzNSeWRXTjBiM0lvWTNKNWNIUnZRbTk0T2lCRGIzSmxRM0o1Y0hSdlFtOTRMQ0JvWkZCaGRHZzZJSE4wY21sdVp5a2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtTnllWEIwYjBKdmVDQTlJR055ZVhCMGIwSnZlRHRjYmlBZ0lDQWdJQ0FnZEdocGN5NW9aRkJoZEdnZ1BTQm9aRkJoZEdnN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y0hWaWJHbGpTMlY1SUQwZ2JuVnNiRHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmhjM2x1WXlCblpYUlFkV0pzYVdOTFpYa29LVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRjBhR2x6TG5CMVlteHBZMHRsZVNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXdkV0pzYVdOTFpYa2dQU0FvWVhkaGFYUWdkR2hwY3k1amNubHdkRzlDYjNndVoyVjBVMmxuYmt0bGVYTW9kR2hwY3k1b1pGQmhkR2dwS1M1d2RXSnNhV003WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjSFZpYkdsalMyVjVPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRnplVzVqSUhOcFoyNG9iV1Z6YzJGblpUb2dWRTlPU1c1d2RYUk5aWE56WVdkbExDQnZkWFJ3ZFhSRmJtTnZaR2x1WnpvZ1ZFOU9UM1YwY0hWMFJXNWpiMlJwYm1kVWVYQmxLVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdhMlY1Y3lBOUlHRjNZV2wwSUhSb2FYTXVZM0o1Y0hSdlFtOTRMbWRsZEZOcFoyNUxaWGx6S0hSb2FYTXVhR1JRWVhSb0tUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11WTNKNWNIUnZRbTk0TG1OeWVYQjBieTV1WVdOc1UybG5ia1JsZEdGamFHVmtLRzFsYzNOaFoyVXNJR0FrZTJ0bGVYTXVjMlZqY21WMGZTUjdhMlY1Y3k1d2RXSnNhV045WUN3Z2IzVjBjSFYwUlc1amIyUnBibWNwTzF4dUlDQWdJSDFjYm4xY2JseHVYRzVqYkdGemN5QkRiM0psUlc1amNubHdkR2x2YmtKdmVDQnBiWEJzWlcxbGJuUnpJRlJQVGtWdVkzSjVjSFJwYjI1Q2IzZ2dlMXh1SUNBZ0lDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXNWxlSFF0YkdsdVpTQmpiR0Z6Y3kxdFpYUm9iMlJ6TFhWelpTMTBhR2x6WEc0Z0lDQWdaMlYwVUhWaWJHbGpTMlY1S0NrNklGQnliMjFwYzJVOGMzUnlhVzVuUGlCN1hHNGdJQ0FnSUNBZ0lIUm9jbTkzSUc1dmRFbHRjR3hsYldWdWRHVmtPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXNWxlSFF0YkdsdVpTQmpiR0Z6Y3kxdFpYUm9iMlJ6TFhWelpTMTBhR2x6TEc1dkxYVnVkWE5sWkMxMllYSnpYRzRnSUNBZ1pXNWpjbmx3ZENodFpYTnpZV2RsT2lCVVQwNUpibkIxZEUxbGMzTmhaMlVzSUc5MWRIQjFkRVZ1WTI5a2FXNW5PaUJVVDA1UGRYUndkWFJGYm1OdlpHbHVaMVI1Y0dVcE9pQlFjbTl0YVhObFBITjBjbWx1Wno0Z2UxeHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdWIzUkpiWEJzWlcxbGJuUmxaRHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJsYzJ4cGJuUXRaR2x6WVdKc1pTMXVaWGgwTFd4cGJtVWdZMnhoYzNNdGJXVjBhRzlrY3kxMWMyVXRkR2hwY3l4dWJ5MTFiblZ6WldRdGRtRnljMXh1SUNBZ0lHUmxZM0o1Y0hRb2JXVnpjMkZuWlRvZ1ZFOU9TVzV3ZFhSTlpYTnpZV2RsTENCdmRYUndkWFJGYm1OdlpHbHVaem9nVkU5T1QzVjBjSFYwUlc1amIyUnBibWRVZVhCbEtUb2dVSEp2YldselpUeHpkSEpwYm1jK0lIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ2JtOTBTVzF3YkdWdFpXNTBaV1E3WEc0Z0lDQWdmVnh1ZlZ4dVhHNWNibVY0Y0c5eWRDQmpiMjV6ZENCRVJVWkJWVXhVWDAxT1JVMVBUa2xEWDBSSlExUkpUMDVCVWxrZ1BTQXhPMXh1Wlhod2IzSjBJR052Ym5OMElFUkZSa0ZWVEZSZlRVNUZUVTlPU1VOZlYwOVNSRjlEVDFWT1ZDQTlJREV5TzF4dVpYaHdiM0owSUdOdmJuTjBJRVJGUmtGVlRGUmZTRVJmVUVGVVNDQTlJQ2R0THpRMFhGd25Mek01Tmx4Y0p5OHdYRnduTHpBdk1DYzdYRzVjYm1aMWJtTjBhVzl1SUhKbGMyOXNkbVZJUkZCaGRHZ29jR0YwYUQ4NklITjBjbWx1WnlrNklITjBjbWx1WnlCN1hHNGdJQ0FnYVdZZ0tIQmhkR2dnUFQwOUlHNTFiR3dnZkh3Z2RIbHdaVzltSUhCaGRHZ2dQVDA5SUNkMWJtUmxabWx1WldRbktTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQkVSVVpCVlV4VVgwaEVYMUJCVkVnN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQndZWFJvSUh4OElDZHRKenRjYm4xY2JseHVaWGh3YjNKMElHTnNZWE56SUVOdmNtVkRjbmx3ZEc5Q2IzZ2dhVzF3YkdWdFpXNTBjeUJVVDA1RGNubHdkRzlDYjNnZ2UxeHVJQ0FnSUdOeWVYQjBiem9nVkU5T1EzSjVjSFJ2TzF4dUlDQWdJR1Z1WTNKNWNIUmxaRk5sWldSUWFISmhjMlU2SUZSUFRrbHVjSFYwVFdWemMyRm5aVHRjYmlBZ0lDQnpaV1ZrVUdoeVlYTmxSVzVqY25sd2RHbHZia0p2ZURvZ1ZFOU9SVzVqY25sd2RHbHZia0p2ZUR0Y2JpQWdJQ0J6WldWa1VHaHlZWE5sUkdsamRHbHZibUZ5ZVRvZ1ZFOU9UVzVsYlc5dWFXTkVhV04wYVc5dVlYSjVWSGx3WlR0Y2JpQWdJQ0J6WldWa1VHaHlZWE5sVjI5eVpFTnZkVzUwT2lCVVQwNU5ibVZ0YjI1cFkxZHZjbVJEYjNWdWRGUjVjR1U3WEc1Y2JpQWdJQ0J6YVdkdWFXNW5RbTk0WlhNNklFMWhjRHh6ZEhKcGJtY3NJRU52Y21WVGFXZHVhVzVuUW05NFBqdGNiaUFnSUNCbGJtTnllWEIwYVc5dVFtOTRaWE02SUUxaGNEeHpkSEpwYm1jc0lFTnZjbVZGYm1OeWVYQjBhVzl1UW05NFBqdGNibHh1SUNBZ0lHTnZibk4wY25WamRHOXlLR055ZVhCMGJ6b2dWRTlPUTNKNWNIUnZMQ0J3WVhKaGJYTTZJRlJQVGtOeWVYQjBiMEp2ZUZCaGNtRnRjeWtnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbU55ZVhCMGJ5QTlJR055ZVhCMGJ6dGNiaUFnSUNBZ0lDQWdkR2hwY3k1bGJtTnllWEIwWldSVFpXVmtVR2h5WVhObElEMGdjR0Z5WVcxekxtVnVZM0o1Y0hSbFpGTmxaV1JRYUhKaGMyVTdYRzRnSUNBZ0lDQWdJSFJvYVhNdWMyVmxaRkJvY21GelpVVnVZM0o1Y0hScGIyNUNiM2dnUFNCd1lYSmhiWE11YzJWbFpGQm9jbUZ6WlVWdVkzSjVjSFJwYjI1Q2IzZzdYRzRnSUNBZ0lDQWdJSFJvYVhNdWMyVmxaRkJvY21GelpVUnBZM1JwYjI1aGNua2dQU0J3WVhKaGJYTXVjMlZsWkZCb2NtRnpaVVJwWTNScGIyNWhjbmtnZkh3Z1JFVkdRVlZNVkY5TlRrVk5UMDVKUTE5RVNVTlVTVTlPUVZKWk8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5ObFpXUlFhSEpoYzJWWGIzSmtRMjkxYm5RZ1BTQndZWEpoYlhNdWMyVmxaRkJvY21GelpWZHZjbVJEYjNWdWRDQjhmQ0JFUlVaQlZVeFVYMDFPUlUxUFRrbERYMWRQVWtSZlEwOVZUbFE3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjMmxuYm1sdVowSnZlR1Z6SUQwZ2JtVjNJRTFoY0NncE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1WdVkzSjVjSFJwYjI1Q2IzaGxjeUE5SUc1bGR5Qk5ZWEFvS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JoYzNsdVl5Qm5aWFJUYVdkdWFXNW5RbTk0S0hCaGNtRnRjejg2SUhzZ2FHUlFZWFJvUHpvZ2MzUnlhVzVuSUgwcE9pQlFjbTl0YVhObFBGUlBUbE5wWjI1cGJtZENiM2crSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYUdSUVlYUm9JRDBnY21WemIyeDJaVWhFVUdGMGFDaHdZWEpoYlhNL0xtaGtVR0YwYUNrN1hHNGdJQ0FnSUNBZ0lHeGxkQ0J6YVdkdWFXNW5RbTk0SUQwZ2RHaHBjeTV6YVdkdWFXNW5RbTk0WlhNdVoyVjBLR2hrVUdGMGFDazdYRzRnSUNBZ0lDQWdJR2xtSUNnaGMybG5ibWx1WjBKdmVDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2MybG5ibWx1WjBKdmVDQTlJRzVsZHlCRGIzSmxVMmxuYm1sdVowSnZlQ2gwYUdsekxDQm9aRkJoZEdncE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXphV2R1YVc1blFtOTRaWE11YzJWMEtHaGtVR0YwYUN3Z2MybG5ibWx1WjBKdmVDazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSE5wWjI1cGJtZENiM2c3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnWlhOc2FXNTBMV1JwYzJGaWJHVXRibVY0ZEMxc2FXNWxJR05zWVhOekxXMWxkR2h2WkhNdGRYTmxMWFJvYVhNc2JtOHRkVzUxYzJWa0xYWmhjbk5jYmlBZ0lDQm5aWFJGYm1OeWVYQjBhVzl1UW05NEtIQmhjbUZ0Y3pvZ2UxeHVJQ0FnSUNBZ0lDQm9aRkJoZEdnL09pQnpkSEpwYm1jc1hHNGdJQ0FnSUNBZ0lHRnNaMjl5YVhSb2JUb2dWRTlPUlc1amNubHdkR2x2YmtGc1oyOXlhWFJvYlN4Y2JpQWdJQ0FnSUNBZ1lXeG5iM0pwZEdodFQzQjBhVzl1Y3pvZ2V5QmJjM1J5YVc1blhUb2dZVzU1SUgwc1hHNGdJQ0FnZlNrNklGQnliMjFwYzJVOFZFOU9SVzVqY25sd2RHbHZia0p2ZUQ0Z2UxeHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdWIzUkpiWEJzWlcxbGJuUmxaRHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmpiRzl6WlNncE9pQlFjbTl0YVhObFBIWnZhV1ErSUh0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTV6YVdkdWFXNW5RbTk0WlhNdVkyeGxZWElvS1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVsYm1OeWVYQjBhVzl1UW05NFpYTXVZMnhsWVhJb0tUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlGQnliMjFwYzJVdWNtVnpiMngyWlNncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklFbHVkR1Z5Ym1Gc2MxeHVYRzRnSUNBZ1lYTjVibU1nWjJWMFUybG5ia3RsZVhNb2FHUlFZWFJvT2lCemRISnBibWNwT2lCUWNtOXRhWE5sUEZSUFRrdGxlVkJoYVhKRVlYUmhQaUI3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxtTnllWEIwYnk1dGJtVnRiMjVwWTBSbGNtbDJaVk5wWjI1TFpYbHpLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIQm9jbUZ6WlRvZ1lYZGhhWFFnZEdocGN5NXpaV1ZrVUdoeVlYTmxSVzVqY25sd2RHbHZia0p2ZUM1a1pXTnllWEIwS0hSb2FYTXVaVzVqY25sd2RHVmtVMlZsWkZCb2NtRnpaU3dnSjFSbGVIUW5LU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIQmhkR2c2SUdoa1VHRjBhQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHUnBZM1JwYjI1aGNuazZJSFJvYVhNdWMyVmxaRkJvY21GelpVUnBZM1JwYjI1aGNua3NYRzRnSUNBZ0lDQWdJQ0FnSUNCM2IzSmtRMjkxYm5RNklIUm9hWE11YzJWbFpGQm9jbUZ6WlZkdmNtUkRiM1Z1ZEN4Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ2ZWeHVmVnh1SWwxOSIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIwIFRPTiBERVYgU09MVVRJT05TIExURC5cbiAqL1xuXG5jb25zdCB7IFRPTkNsaWVudCB9ID0gcmVxdWlyZSgnLi9kaXN0L1RPTkNsaWVudCcpO1xuY29uc3Qge1xuICAgIFRPTkFkZHJlc3NTdHJpbmdWYXJpYW50LFxuICAgIFRPTkNsaWVudFRyYW5zYWN0aW9uUGhhc2UsXG4gICAgVE9OQ2xpZW50Q29tcHV0ZVNraXBwZWRTdGF0dXMsXG4gICAgVE9OQ2xpZW50U3RvcmFnZVN0YXR1cyxcbiAgICBRSW5Nc2dUeXBlLFxuICAgIFFPdXRNc2dUeXBlLFxuICAgIFFNZXNzYWdlVHlwZSxcbiAgICBRTWVzc2FnZVByb2Nlc3NpbmdTdGF0dXMsXG4gICAgUUJsb2NrUHJvY2Vzc2luZ1N0YXR1cyxcbiAgICBRU3BsaXRUeXBlLFxuICAgIFFBY2NvdW50VHlwZSxcbiAgICBRVHJhbnNhY3Rpb25UeXBlLFxuICAgIFFUcmFuc2FjdGlvblByb2Nlc3NpbmdTdGF0dXMsXG4gICAgUUFjY291bnRTdGF0dXMsXG4gICAgUUFjY291bnRTdGF0dXNDaGFuZ2UsXG4gICAgUUNvbXB1dGVUeXBlLFxuICAgIFFTa2lwUmVhc29uLFxuICAgIFFCb3VuY2VUeXBlLFxufSA9IHJlcXVpcmUoJy4vZGlzdC9tb2R1bGVzL1RPTkNvbnRyYWN0c01vZHVsZScpO1xuXG5jb25zdCB7XG4gICAgVE9OT3V0cHV0RW5jb2RpbmcsXG4gICAgVE9OTW5lbW9uaWNEaWN0aW9uYXJ5LFxufSA9IHJlcXVpcmUoJy4vZGlzdC9tb2R1bGVzL1RPTkNyeXB0b01vZHVsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBUT05DbGllbnQsXG4gICAgVE9OQWRkcmVzc1N0cmluZ1ZhcmlhbnQsXG4gICAgVE9OQ2xpZW50VHJhbnNhY3Rpb25QaGFzZSxcbiAgICBUT05DbGllbnRDb21wdXRlU2tpcHBlZFN0YXR1cyxcbiAgICBUT05DbGllbnRTdG9yYWdlU3RhdHVzLFxuICAgIFFJbk1zZ1R5cGUsXG4gICAgUU91dE1zZ1R5cGUsXG4gICAgUU1lc3NhZ2VUeXBlLFxuICAgIFFNZXNzYWdlUHJvY2Vzc2luZ1N0YXR1cyxcbiAgICBRQmxvY2tQcm9jZXNzaW5nU3RhdHVzLFxuICAgIFFTcGxpdFR5cGUsXG4gICAgUUFjY291bnRUeXBlLFxuICAgIFFUcmFuc2FjdGlvblR5cGUsXG4gICAgUVRyYW5zYWN0aW9uUHJvY2Vzc2luZ1N0YXR1cyxcbiAgICBRQWNjb3VudFN0YXR1cyxcbiAgICBRQWNjb3VudFN0YXR1c0NoYW5nZSxcbiAgICBRQ29tcHV0ZVR5cGUsXG4gICAgUVNraXBSZWFzb24sXG4gICAgUUJvdW5jZVR5cGUsXG5cbiAgICBUT05PdXRwdXRFbmNvZGluZyxcbiAgICBUT05NbmVtb25pY0RpY3Rpb25hcnksXG59O1xuIiwiaW1wb3J0IHsgVE9OQ2xpZW50IH0gZnJvbSAndG9uLWNsaWVudC1qcyc7XG5jb25zdCB3b3JrZXJTY3JpcHQgPSBgXG5cbmNvbnN0IHdhc21XcmFwcGVyID0gKGZ1bmN0aW9uKCkge1xubGV0IHdhc20gPSBudWxsO1xuY29uc3QgcmVzdWx0ID0ge1xuICAgIHNldHVwOiAobmV3V2FzbSkgPT4ge1xuICAgICAgICB3YXNtID0gbmV3V2FzbTtcbiAgICB9LFxufTtcblxuXG5jb25zdCBoZWFwID0gbmV3IEFycmF5KDMyKS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMzYpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5sZXQgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pO1xuXG5jYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcblxubGV0IGNhY2hlZ2V0VWludDhNZW1vcnkwID0gbnVsbDtcbmZ1bmN0aW9uIGdldFVpbnQ4TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVnZXRVaW50OE1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVnZXRVaW50OE1lbW9yeTAuYnVmZmVyICE9PSB3YXNtLm1lbW9yeS5idWZmZXIpIHtcbiAgICAgICAgY2FjaGVnZXRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVnZXRVaW50OE1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBsZW4pKTtcbn1cbi8qKlxuKiBAcmV0dXJucyB7bnVtYmVyfVxuKi9cbnJlc3VsdC5jb3JlX2NyZWF0ZV9jb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHdhc20uY29yZV9jcmVhdGVfY29udGV4dCgpO1xuICAgIHJldHVybiByZXQgPj4+IDA7XG59XG5cbi8qKlxuKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFxuKi9cbnJlc3VsdC5jb3JlX2Rlc3Ryb3lfY29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB3YXNtLmNvcmVfZGVzdHJveV9jb250ZXh0KGNvbnRleHQpO1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxubGV0IGNhY2hlZFRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG5jb25zdCBlbmNvZGVTdHJpbmcgPSAodHlwZW9mIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8gPT09ICdmdW5jdGlvbidcbiAgICA/IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhhcmcsIHZpZXcpO1xufVxuICAgIDogZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgIHZpZXcuc2V0KGJ1Zik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhZDogYXJnLmxlbmd0aCxcbiAgICAgICAgd3JpdHRlbjogYnVmLmxlbmd0aFxuICAgIH07XG59KTtcblxuZnVuY3Rpb24gcGFzc1N0cmluZ1RvV2FzbTAoYXJnLCBtYWxsb2MsIHJlYWxsb2MpIHtcblxuICAgIGlmIChyZWFsbG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhidWYubGVuZ3RoKTtcbiAgICAgICAgZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBidWYubGVuZ3RoKS5zZXQoYnVmKTtcbiAgICAgICAgV0FTTV9WRUNUT1JfTEVOID0gYnVmLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBsZXQgcHRyID0gbWFsbG9jKGxlbik7XG5cbiAgICBjb25zdCBtZW0gPSBnZXRVaW50OE1lbW9yeTAoKTtcblxuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICg7IG9mZnNldCA8IGxlbjsgb2Zmc2V0KyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGFyZy5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgIGlmIChjb2RlID4gMHg3RikgYnJlYWs7XG4gICAgICAgIG1lbVtwdHIgKyBvZmZzZXRdID0gY29kZTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ICE9PSBsZW4pIHtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgbGVuID0gb2Zmc2V0ICsgYXJnLmxlbmd0aCAqIDMpO1xuICAgICAgICBjb25zdCB2aWV3ID0gZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyICsgb2Zmc2V0LCBwdHIgKyBsZW4pO1xuICAgICAgICBjb25zdCByZXQgPSBlbmNvZGVTdHJpbmcoYXJnLCB2aWV3KTtcblxuICAgICAgICBvZmZzZXQgKz0gcmV0LndyaXR0ZW47XG4gICAgfVxuXG4gICAgV0FTTV9WRUNUT1JfTEVOID0gb2Zmc2V0O1xuICAgIHJldHVybiBwdHI7XG59XG5cbmxldCBjYWNoZWdldEludDMyTWVtb3J5MCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJbnQzMk1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZ2V0SW50MzJNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZ2V0SW50MzJNZW1vcnkwLmJ1ZmZlciAhPT0gd2FzbS5tZW1vcnkuYnVmZmVyKSB7XG4gICAgICAgIGNhY2hlZ2V0SW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZ2V0SW50MzJNZW1vcnkwO1xufVxuLyoqXG4qIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0XG4qIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtc19qc29uXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xucmVzdWx0LmNvcmVfanNvbl9yZXF1ZXN0ID0gZnVuY3Rpb24oY29udGV4dCwgbWV0aG9kLCBwYXJhbXNfanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobWV0aG9kLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHBhcmFtc19qc29uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmNvcmVfanNvbl9yZXF1ZXN0KDgsIGNvbnRleHQsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVs4IC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVs4IC8gNCArIDFdO1xuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZEhlYXBPYmplY3Qob2JqKSB7XG4gICAgaWYgKGhlYXBfbmV4dCA9PT0gaGVhcC5sZW5ndGgpIGhlYXAucHVzaChoZWFwLmxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGlkeCA9IGhlYXBfbmV4dDtcbiAgICBoZWFwX25leHQgPSBoZWFwW2lkeF07XG5cbiAgICBoZWFwW2lkeF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leG5fc3RvcmUoYWRkSGVhcE9iamVjdChlKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVU4RnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcmV0dXJuIGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDEsIHB0ciAvIDEgKyBsZW4pO1xufVxuICAgIHJlc3VsdC53YmcgPSB7fTtcbiAgICByZXN1bHQud2JnLl9fd2JnX25ldzBfOGQ4MTc5MTVjZDg5MGJkOCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIHJlc3VsdC53YmcuX193YmdfZ2V0VGltZV84ZTdhMDU3ODU5OGU1MDM5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIHJlc3VsdC53YmcuX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHRha2VPYmplY3QoYXJnMCk7XG4gICAgfTtcbiAgICByZXN1bHQud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9NT0RVTEVfYWJmNWFlMjg0YmZmZGY0NSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0ID0gbW9kdWxlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgcmVzdWx0LndiZy5fX3diZ19zZWxmXzFjODNlYjQ0NzFkOWViOWIgPSBoYW5kbGVFcnJvcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJldCA9IHNlbGYuc2VsZjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9KTtcbiAgICByZXN1bHQud2JnLl9fd2JnX3JlcXVpcmVfNWIyYjViNTk0ZDgwOWQ5ZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgdmFyIHJldCA9IGdldE9iamVjdChhcmcwKS5yZXF1aXJlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICByZXN1bHQud2JnLl9fd2JnX2NyeXB0b19jMTJmMTRlODEwZWRjYWEyID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIHJlc3VsdC53YmcuX193YmdfbXNDcnlwdG9fNjc5YmU3NjUxMTFiYTc3NSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgdmFyIHJldCA9IGdldE9iamVjdChhcmcwKS5tc0NyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIHJlc3VsdC53YmcuX193YmluZGdlbl9pc191bmRlZmluZWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHZhciByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIHJlc3VsdC53YmcuX193YmdfZ2V0UmFuZG9tVmFsdWVzXzA1YTYwYmYxNzFiZmMyYmUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHZhciByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgcmVzdWx0LndiZy5fX3diZ19nZXRSYW5kb21WYWx1ZXNfM2FjMWIzM2M5MGI1MjU5NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmdldFJhbmRvbVZhbHVlcyhnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9O1xuICAgIHJlc3VsdC53YmcuX193YmdfcmFuZG9tRmlsbFN5bmNfNmY5NTYwMjk2NTg2NjJlYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJhbmRvbUZpbGxTeW5jKGdldEFycmF5VThGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIH07XG4gICAgcmVzdWx0LndiZy5fX3diaW5kZ2VuX3Rocm93ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICB9O1xuICAgcmV0dXJuIHJlc3VsdDtcbn0pKClcblxuXG5zZWxmLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICBjb25zdCBzZXR1cCA9IG1lc3NhZ2Uuc2V0dXA7XG4gICAgaWYgKHNldHVwKSB7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShzZXR1cC53YXNtTW9kdWxlLCB7XG4gICAgICAgICAgICAgICAgd2JnOiB3YXNtV3JhcHBlci53YmdcbiAgICAgICAgICAgIH0pKS5leHBvcnRzO1xuICAgICAgICAgICAgd2FzbVdyYXBwZXIuc2V0dXAoaW5zdGFuY2UpO1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHNldHVwOiB7fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbWVzc2FnZS5yZXF1ZXN0O1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdjb250ZXh0LmNyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gd2FzbVdyYXBwZXIuY29yZV9jcmVhdGVfY29udGV4dCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHtyZXN1bHRfanNvbjogSlNPTi5zdHJpbmdpZnkoY29udGV4dCksIGVycm9yX2pzb246ICcnfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnY29udGV4dC5kZXN0cm95Jykge1xuICAgICAgICAgICAgICAgIHdhc21XcmFwcGVyLmNvcmVfZGVzdHJveV9jb250ZXh0KHJlcXVlc3QuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoe3Jlc3VsdF9qc29uOiAnJywgZXJyb3JfanNvbjogJyd9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gd2FzbVdyYXBwZXIuY29yZV9qc29uX3JlcXVlc3QocmVxdWVzdC5jb250ZXh0LCByZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHJlc3VsdF9qc29uOiAnJyxcbiAgICAgICAgICAgICAgICBlcnJvcl9qc29uOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDYsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5gO1xuXG5cbmNvbnN0IHdhc21PcHRpb25zID0ge1xuICAgIGRlYnVnTG9nOiBudWxsLFxuICAgIGJpbmFyeVVSTDogJy90b25jbGllbnQud2FzbScsXG59O1xuXG5mdW5jdGlvbiBkZWJ1Z0xvZyhtZXNzYWdlKSB7XG4gICAgaWYgKHdhc21PcHRpb25zLmRlYnVnTG9nKSB7XG4gICAgICAgIHdhc21PcHRpb25zLmRlYnVnTG9nKG1lc3NhZ2UpO1xuICAgIH1cbn1cblxuY29uc3QgY3JlYXRlTGlicmFyeSA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB3b3JrZXJCbG9iID0gbmV3IEJsb2IoXG4gICAgICAgIFt3b3JrZXJTY3JpcHRdLFxuICAgICAgICB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9XG4gICAgKTtcbiAgICBjb25zdCB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsKTtcblxuICAgIGNvbnN0IGFjdGl2ZVJlcXVlc3RzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gRGVmZXJyZWQgcmVxdWVzdHMgYXJlIGFjY3VtdWxhdGVkIGJlZm9yZSBXQVNNIG1vZHVsZSBoYXZlIGJlZW4gbG9hZGVkXG4gICAgbGV0IGRlZmVycmVkUmVxdWVzdHMgPSBbXTtcblxuICAgIGxldCBuZXh0QWN0aXZlUmVxdWVzdElkID0gMTtcblxuICAgIHdvcmtlci5vbmVycm9yID0gKGV2dCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgZnJvbSBXZWIgV29ya2VyOiAke2V2dC5tZXNzYWdlfWApO1xuICAgIH07XG5cbiAgICBjb25zdCBjb3JlUmVxdWVzdCA9IChjb250ZXh0LCBtZXRob2QsIHBhcmFtcywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBuZXh0QWN0aXZlUmVxdWVzdElkO1xuICAgICAgICBuZXh0QWN0aXZlUmVxdWVzdElkICs9IDE7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlzRGVmZXJyZWRTZXR1cCA9IChtZXRob2QgPT09ICdzZXR1cCcpICYmIChkZWZlcnJlZFJlcXVlc3RzICE9PSBudWxsKTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdHMuc2V0KGlkLCB7XG4gICAgICAgICAgICBjYWxsYmFjazogaXNEZWZlcnJlZFNldHVwID8gKCkgPT4ge1xuICAgICAgICAgICAgfSA6IGNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVmZXJyZWRSZXF1ZXN0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmZXJyZWRSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgcmVxdWVzdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWZlcnJlZFNldHVwKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygnJywgJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGxlZ2FjeUNvcmVDb250ZXh0ID0gbnVsbDtcbiAgICBjb25zdCBsaWJyYXJ5ID0ge1xuICAgICAgICBjb3JlQ3JlYXRlQ29udGV4dDogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb3JlUmVxdWVzdCgwLCAnY29udGV4dC5jcmVhdGUnLCAnJywgKHJlc3VsdEpzb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IEpTT04ucGFyc2UocmVzdWx0SnNvbik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb3JlRGVzdHJveUNvbnRleHQ6IChjb250ZXh0LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY29yZVJlcXVlc3QoY29udGV4dCwgJ2NvbnRleHQuZGVzdHJveScsICcnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvcmVSZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0OiAobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAobGVnYWN5Q29yZUNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaWJyYXJ5LmNvcmVDcmVhdGVDb250ZXh0KChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeUNvcmVDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgY29yZVJlcXVlc3QobGVnYWN5Q29yZUNvbnRleHQsIG1ldGhvZCwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcmVSZXF1ZXN0KGxlZ2FjeUNvcmVDb250ZXh0LCBtZXRob2QsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICB3b3JrZXIub25tZXNzYWdlID0gKGV2dCkgPT4ge1xuICAgICAgICBjb25zdCBzZXR1cCA9IGV2dC5kYXRhLnNldHVwO1xuICAgICAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiBkZWZlcnJlZFJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgcmVxdWVzdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkUmVxdWVzdHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBldnQuZGF0YS5yZXNwb25zZTtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVSZXF1ZXN0ID0gYWN0aXZlUmVxdWVzdHMuZ2V0KHJlc3BvbnNlLmlkKTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3RzLmRlbGV0ZShyZXNwb25zZS5pZCk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlUmVxdWVzdC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGxldCB7IHJlc3VsdCB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIEJPTSBmcm9tIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYgPyByZXN1bHQuc3Vic3RyKDEpIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0X2pzb24sIGVycm9yX2pzb24gfSA9IEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBhY3RpdmVSZXF1ZXN0LmNhbGxiYWNrKHJlc3VsdF9qc29uLCBlcnJvcl9qc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IHdhc21Nb2R1bGU7XG4gICAgICAgIGNvbnN0IGZldGNoZWQgPSBmZXRjaCh3YXNtT3B0aW9ucy5iaW5hcnlVUkwpO1xuICAgICAgICBpZiAoV2ViQXNzZW1ibHkuY29tcGlsZVN0cmVhbWluZykge1xuICAgICAgICAgICAgZGVidWdMb2coJ2NvbXBpbGVTdHJlYW1pbmcgYmluYXJ5Jyk7XG4gICAgICAgICAgICB3YXNtTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZVN0cmVhbWluZyhmZXRjaGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnTG9nKCdjb21waWxlIGJpbmFyeScpO1xuICAgICAgICAgICAgd2FzbU1vZHVsZSA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoYXdhaXQgKGF3YWl0IGZldGNoZWQpLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzZXR1cDoge1xuICAgICAgICAgICAgICAgIHdhc21Nb2R1bGUsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1Z0xvZyhgY29tcGlsZSB0aW1lICR7RGF0ZS5ub3coKSAtIGV9YCk7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGlicmFyeSk7XG59O1xuXG5mdW5jdGlvbiBzZXRXYXNtT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbih3YXNtT3B0aW9ucywgb3B0aW9ucyk7XG59XG5cbmNvbnN0IGNsaWVudFBsYXRmb3JtID0ge1xuICAgIGZldGNoOiB3aW5kb3cgPyB3aW5kb3cuZmV0Y2guYmluZCh3aW5kb3cpIDogZmV0Y2gsXG4gICAgV2ViU29ja2V0LFxuICAgIGNyZWF0ZUxpYnJhcnksXG59O1xuXG5mdW5jdGlvbiBpbml0VE9OQ2xpZW50KHRvbkNsaWVudENsYXNzKSB7XG4gICAgdG9uQ2xpZW50Q2xhc3Muc2V0TGlicmFyeShjbGllbnRQbGF0Zm9ybSk7XG59XG5cbmluaXRUT05DbGllbnQoVE9OQ2xpZW50KTtcblxuZXhwb3J0IHtcbiAgICBjcmVhdGVMaWJyYXJ5LFxuICAgIHNldFdhc21PcHRpb25zLFxuICAgIGNsaWVudFBsYXRmb3JtLFxuICAgIGluaXRUT05DbGllbnQsXG4gICAgVE9OQ2xpZW50XG59O1xuIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSAndHNsaWInO1xuXG52YXIgZ2VuZXJpY01lc3NhZ2UgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIjtcclxudmFyIF9hID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLCBzZXRQcm90b3R5cGVPZiA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAob2JqLCBwcm90bykge1xyXG4gICAgb2JqLl9fcHJvdG9fXyA9IHByb3RvO1xyXG4gICAgcmV0dXJuIG9iajtcclxufSA6IF9hO1xyXG52YXIgSW52YXJpYW50RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW52YXJpYW50RXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnZhcmlhbnRFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gZ2VuZXJpY01lc3NhZ2U7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJudW1iZXJcIlxyXG4gICAgICAgICAgICA/IGdlbmVyaWNNZXNzYWdlICsgXCI6IFwiICsgbWVzc2FnZSArIFwiIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvaW52YXJpYW50LXBhY2thZ2VzKVwiXHJcbiAgICAgICAgICAgIDogbWVzc2FnZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5mcmFtZXNUb1BvcCA9IDE7XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IGdlbmVyaWNNZXNzYWdlO1xyXG4gICAgICAgIHNldFByb3RvdHlwZU9mKF90aGlzLCBJbnZhcmlhbnRFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBJbnZhcmlhbnRFcnJvcjtcclxufShFcnJvcikpO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cmFwQ29uc29sZU1ldGhvZChtZXRob2QpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnNvbGVbbWV0aG9kXS5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufVxyXG4oZnVuY3Rpb24gKGludmFyaWFudCkge1xyXG4gICAgaW52YXJpYW50Lndhcm4gPSB3cmFwQ29uc29sZU1ldGhvZChcIndhcm5cIik7XHJcbiAgICBpbnZhcmlhbnQuZXJyb3IgPSB3cmFwQ29uc29sZU1ldGhvZChcImVycm9yXCIpO1xyXG59KShpbnZhcmlhbnQgfHwgKGludmFyaWFudCA9IHt9KSk7XHJcbi8vIENvZGUgdGhhdCB1c2VzIHRzLWludmFyaWFudCB3aXRoIHJvbGx1cC1wbHVnaW4taW52YXJpYW50IG1heSB3YW50IHRvXHJcbi8vIGltcG9ydCB0aGlzIHByb2Nlc3Mgc3R1YiB0byBhdm9pZCBlcnJvcnMgZXZhbHVhdGluZyBwcm9jZXNzLmVudi5OT0RFX0VOVi5cclxuLy8gSG93ZXZlciwgYmVjYXVzZSBtb3N0IEVTTS10by1DSlMgY29tcGlsZXJzIHdpbGwgcmV3cml0ZSB0aGUgcHJvY2VzcyBpbXBvcnRcclxuLy8gYXMgdHNJbnZhcmlhbnQucHJvY2Vzcywgd2hpY2ggcHJldmVudHMgcHJvcGVyIHJlcGxhY2VtZW50IGJ5IG1pbmlmaWVycywgd2VcclxuLy8gYWxzbyBhdHRlbXB0IHRvIGRlZmluZSB0aGUgc3R1YiBnbG9iYWxseSB3aGVuIGl0IGlzIG5vdCBhbHJlYWR5IGRlZmluZWQuXHJcbnZhciBwcm9jZXNzU3R1YiA9IHsgZW52OiB7fSB9O1xyXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIHByb2Nlc3NTdHViID0gcHJvY2VzcztcclxufVxyXG5lbHNlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIFVzaW5nIEZ1bmN0aW9uIHRvIGV2YWx1YXRlIHRoaXMgYXNzaWdubWVudCBpbiBnbG9iYWwgc2NvcGUgYWxzbyBlc2NhcGVzXHJcbiAgICAgICAgLy8gdGhlIHN0cmljdCBtb2RlIG9mIHRoZSBjdXJyZW50IG1vZHVsZSwgdGhlcmVieSBhbGxvd2luZyB0aGUgYXNzaWdubWVudC5cclxuICAgICAgICAvLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvcHVsbC8zNjkuXHJcbiAgICAgICAgRnVuY3Rpb24oXCJzdHViXCIsIFwicHJvY2VzcyA9IHN0dWJcIikocHJvY2Vzc1N0dWIpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGF0TGVhc3RXZVRyaWVkKSB7XHJcbiAgICAgICAgLy8gVGhlIGFzc2lnbm1lbnQgY2FuIGZhaWwgaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBoZWF2eS1oYW5kZWRseVxyXG4gICAgICAgIC8vIGZvcmJpZHMgRnVuY3Rpb24gdXNhZ2UuIEluIHRob3NlIGVudmlyb25tZW50cywgZGV2ZWxvcGVycyBzaG91bGQgdGFrZVxyXG4gICAgICAgIC8vIGV4dHJhIGNhcmUgdG8gcmVwbGFjZSBwcm9jZXNzLmVudi5OT0RFX0VOViBpbiB0aGVpciBwcm9kdWN0aW9uIGJ1aWxkcyxcclxuICAgICAgICAvLyBvciBkZWZpbmUgYW4gYXBwcm9wcmlhdGUgZ2xvYmFsLnByb2Nlc3MgcG9seWZpbGwuXHJcbiAgICB9XHJcbnZhciBpbnZhcmlhbnQkMSA9IGludmFyaWFudDtcblxuZXhwb3J0IGRlZmF1bHQgaW52YXJpYW50JDE7XG5leHBvcnQgeyBJbnZhcmlhbnRFcnJvciwgaW52YXJpYW50LCBwcm9jZXNzU3R1YiBhcyBwcm9jZXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhcmlhbnQuZXNtLmpzLm1hcFxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiaW1wb3J0IHplbk9ic2VydmFibGUgZnJvbSAnemVuLW9ic2VydmFibGUnO1xuXG52YXIgT2JzZXJ2YWJsZSA9IHplbk9ic2VydmFibGU7XG5cbmV4cG9ydCBkZWZhdWx0IE9ic2VydmFibGU7XG5leHBvcnQgeyBPYnNlcnZhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuZXNtLmpzLm1hcFxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9PYnNlcnZhYmxlLmpzJykuT2JzZXJ2YWJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vID09PSBTeW1ib2wgU3VwcG9ydCA9PT1cbnZhciBoYXNTeW1ib2xzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBoYXNTeW1ib2wgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaGFzU3ltYm9scygpICYmIEJvb2xlYW4oU3ltYm9sW25hbWVdKTtcbn07XG5cbnZhciBnZXRTeW1ib2wgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaGFzU3ltYm9sKG5hbWUpID8gU3ltYm9sW25hbWVdIDogJ0BAJyArIG5hbWU7XG59O1xuXG5pZiAoaGFzU3ltYm9scygpICYmICFoYXNTeW1ib2woJ29ic2VydmFibGUnKSkge1xuICBTeW1ib2wub2JzZXJ2YWJsZSA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xufVxuXG52YXIgU3ltYm9sSXRlcmF0b3IgPSBnZXRTeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xudmFyIFN5bWJvbFNwZWNpZXMgPSBnZXRTeW1ib2woJ3NwZWNpZXMnKTsgLy8gPT09IEFic3RyYWN0IE9wZXJhdGlvbnMgPT09XG5cbmZ1bmN0aW9uIGdldE1ldGhvZChvYmosIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BlY2llcyhvYmopIHtcbiAgdmFyIGN0b3IgPSBvYmouY29uc3RydWN0b3I7XG5cbiAgaWYgKGN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGN0b3IgPSBjdG9yW1N5bWJvbFNwZWNpZXNdO1xuXG4gICAgaWYgKGN0b3IgPT09IG51bGwpIHtcbiAgICAgIGN0b3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN0b3IgIT09IHVuZGVmaW5lZCA/IGN0b3IgOiBPYnNlcnZhYmxlO1xufVxuXG5mdW5jdGlvbiBpc09ic2VydmFibGUoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIE9ic2VydmFibGU7IC8vIFNQRUM6IEJyYW5kIGNoZWNrXG59XG5cbmZ1bmN0aW9uIGhvc3RSZXBvcnRFcnJvcihlKSB7XG4gIGlmIChob3N0UmVwb3J0RXJyb3IubG9nKSB7XG4gICAgaG9zdFJlcG9ydEVycm9yLmxvZyhlKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZShmbikge1xuICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgZm4oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2NsZWFudXA7XG4gIGlmIChjbGVhbnVwID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgc3Vic2NyaXB0aW9uLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuXG4gIGlmICghY2xlYW51cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1bnN1YnNjcmliZSA9IGdldE1ldGhvZChjbGVhbnVwLCAndW5zdWJzY3JpYmUnKTtcblxuICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlLmNhbGwoY2xlYW51cCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaG9zdFJlcG9ydEVycm9yKGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICBzdWJzY3JpcHRpb24uX29ic2VydmVyID0gdW5kZWZpbmVkO1xuICBzdWJzY3JpcHRpb24uX3F1ZXVlID0gdW5kZWZpbmVkO1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ2Nsb3NlZCc7XG59XG5cbmZ1bmN0aW9uIGZsdXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICB2YXIgcXVldWUgPSBzdWJzY3JpcHRpb24uX3F1ZXVlO1xuXG4gIGlmICghcXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdWJzY3JpcHRpb24uX3F1ZXVlID0gdW5kZWZpbmVkO1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ3JlYWR5JztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgcXVldWVbaV0udHlwZSwgcXVldWVbaV0udmFsdWUpO1xuICAgIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpIHtcbiAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdydW5uaW5nJztcbiAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vYnNlcnZlcjtcblxuICB0cnkge1xuICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLCB0eXBlKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgIGlmIChtKSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO2Vsc2UgdGhyb3cgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGlmIChtKSBtLmNhbGwob2JzZXJ2ZXIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gIH1cblxuICBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtlbHNlIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAncnVubmluZycpIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAncmVhZHknO1xufVxuXG5mdW5jdGlvbiBvbk5vdGlmeShzdWJzY3JpcHRpb24sIHR5cGUsIHZhbHVlKSB7XG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgcmV0dXJuO1xuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnYnVmZmVyaW5nJykge1xuICAgIHN1YnNjcmlwdGlvbi5fcXVldWUucHVzaCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSAhPT0gJ3JlYWR5Jykge1xuICAgIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAnYnVmZmVyaW5nJztcbiAgICBzdWJzY3JpcHRpb24uX3F1ZXVlID0gW3tcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9XTtcbiAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbHVzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG5vdGlmeVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24sIHR5cGUsIHZhbHVlKTtcbn1cblxudmFyIFN1YnNjcmlwdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzY3JpcHRpb24pO1xuXG4gICAgLy8gQVNTRVJUOiBvYnNlcnZlciBpcyBhbiBvYmplY3RcbiAgICAvLyBBU1NFUlQ6IHN1YnNjcmliZXIgaXMgY2FsbGFibGVcbiAgICB0aGlzLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhdGUgPSAnaW5pdGlhbGl6aW5nJztcbiAgICB2YXIgc3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY2xlYW51cCA9IHN1YnNjcmliZXIuY2FsbCh1bmRlZmluZWQsIHN1YnNjcmlwdGlvbk9ic2VydmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWJzY3JpcHRpb25PYnNlcnZlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdpbml0aWFsaXppbmcnKSB0aGlzLl9zdGF0ZSA9ICdyZWFkeSc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3Vic2NyaXB0aW9uLCBbe1xuICAgIGtleTogXCJ1bnN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb25PYnNlcnZlcihzdWJzY3JpcHRpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIpO1xuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN1YnNjcmlwdGlvbk9ic2VydmVyLCBbe1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQodmFsdWUpIHtcbiAgICAgIG9uTm90aWZ5KHRoaXMuX3N1YnNjcmlwdGlvbiwgJ25leHQnLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgICBvbk5vdGlmeSh0aGlzLl9zdWJzY3JpcHRpb24sICdlcnJvcicsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICBvbk5vdGlmeSh0aGlzLl9zdWJzY3JpcHRpb24sICdjb21wbGV0ZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uT2JzZXJ2ZXI7XG59KCk7XG5cbnZhciBPYnNlcnZhYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9ic2VydmFibGUpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9ic2VydmFibGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYnNlcnZhYmxlIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbicpO1xuICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JzZXJ2YWJsZSBpbml0aWFsaXplciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB0aGlzLl9zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPYnNlcnZhYmxlLCBbe1xuICAgIGtleTogXCJzdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0JyB8fCBvYnNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICBuZXh0OiBvYnNlcnZlcixcbiAgICAgICAgICBlcnJvcjogYXJndW1lbnRzWzFdLFxuICAgICAgICAgIGNvbXBsZXRlOiBhcmd1bWVudHNbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX3N1YnNjcmliZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZuKHZhbHVlLCBkb25lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChmbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihmbikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghZm4odmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWR1Y2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkdWNlKGZuKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICAgIHZhciBoYXNTZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgIHZhciBzZWVkID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGFjYyA9IHNlZWQ7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9ICFoYXNWYWx1ZTtcbiAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFmaXJzdCB8fCBoYXNTZWVkKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWNjID0gZm4oYWNjLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFjYyA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1ZhbHVlICYmICFoYXNTZWVkKSByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IobmV3IFR5cGVFcnJvcignQ2Fubm90IHJlZHVjZSBhbiBlbXB0eSBzZXF1ZW5jZScpKTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoYWNjKTtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb247XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnROZXh0KG5leHQpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXh0LnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnROZXh0KEMuZnJvbShzb3VyY2VzW2luZGV4KytdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0TmV4dChfdGhpczUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbGF0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsYXRNYXAoZm4pIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IFtdO1xuXG4gICAgICAgIHZhciBvdXRlciA9IF90aGlzNi5zdWJzY3JpYmUoe1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlubmVyID0gQy5mcm9tKHZhbHVlKS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBzdWJzY3JpcHRpb25zLmluZGV4T2YoaW5uZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpID49IDApIHN1YnNjcmlwdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlSWZEb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGlubmVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29tcGxldGVJZkRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlSWZEb25lKCkge1xuICAgICAgICAgIGlmIChvdXRlci5jbG9zZWQgJiYgc3Vic2NyaXB0aW9ucy5sZW5ndGggPT09IDApIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvdXRlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2xPYnNlcnZhYmxlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBPYnNlcnZhYmxlO1xuICAgICAgaWYgKHggPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKHgsIFN5bWJvbE9ic2VydmFibGUpO1xuXG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbWV0aG9kLmNhbGwoeCk7XG4gICAgICAgIGlmIChPYmplY3Qob2JzZXJ2YWJsZSkgIT09IG9ic2VydmFibGUpIHRocm93IG5ldyBUeXBlRXJyb3Iob2JzZXJ2YWJsZSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKG9ic2VydmFibGUpICYmIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMpIHJldHVybiBvYnNlcnZhYmxlO1xuICAgICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTeW1ib2woJ2l0ZXJhdG9yJykpIHtcbiAgICAgICAgbWV0aG9kID0gZ2V0TWV0aG9kKHgsIFN5bWJvbEl0ZXJhdG9yKTtcblxuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbWV0aG9kLmNhbGwoeClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2l0ZW0gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoX2l0ZW0pO1xuICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHhbaV0pO1xuICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIG5vdCBvYnNlcnZhYmxlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6IE9ic2VydmFibGU7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbaV0pO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2xTcGVjaWVzLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KCk7XG5cbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG5cbmlmIChoYXNTeW1ib2xzKCkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGUsIFN5bWJvbCgnZXh0ZW5zaW9ucycpLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHN5bWJvbDogU3ltYm9sT2JzZXJ2YWJsZSxcbiAgICAgIGhvc3RSZXBvcnRFcnJvcjogaG9zdFJlcG9ydEVycm9yXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG1vZHVsZSk7XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRzZXQ6ICgpID0+IHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRVMgTW9kdWxlcyBtYXkgbm90IGFzc2lnbiBtb2R1bGUuZXhwb3J0cyBvciBleHBvcnRzLiosIFVzZSBFU00gZXhwb3J0IHN5bnRheCwgaW5zdGVhZDogJyArIG1vZHVsZS5pZCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImNvbnN0IHsgVE9OQ2xpZW50LCBzZXRXYXNtT3B0aW9ucyB9ID0gcmVxdWlyZSgndG9uLWNsaWVudC13ZWItanMnKTtcblxuZGVjbGFyZSBnbG9iYWwge1xuXHRpbnRlcmZhY2UgV2luZG93IHtcblx0XHRUT05DbGllbnRGYWNhZGU6IFRPTkNsaWVudEZhY2FkZUNvbnN0cnVjdG9yO1xuXHR9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3VudEluZm8ge1xuXHRyZWFkb25seSBiYWxhbmNlOiBzdHJpbmc7XG5cdHJlYWRvbmx5IGNvZGVIYXNoOiBzdHJpbmc7XG59XG5leHBvcnQgaW50ZXJmYWNlIEtleVBhaXIge1xuXHRyZWFkb25seSBwdWJsaWM6IHN0cmluZztcblx0cmVhZG9ubHkgc2VjcmV0OiBzdHJpbmc7XG59XG5cbm5hbWVzcGFjZSBUT05DbGllbnQge1xuXHRleHBvcnQgaW50ZXJmYWNlIERlcGxveURhdGEge1xuXHRcdHJlYWRvbmx5IGFjY291bnRJZDogc3RyaW5nO1xuXHRcdHJlYWRvbmx5IGFkZHJlc3M6IHN0cmluZztcblx0XHRyZWFkb25seSBkYXRhQmFzZTY0OiBzdHJpbmc7XG5cdFx0cmVhZG9ubHkgaW1hZ2VCYXNlNjQ6IHN0cmluZztcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVG9uQ2xpZW50RmFjYWRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdHB1YmxpYyByZWFkb25seSBpbm5lckV4Y2VwdGlvbjogYW55O1xuXHRjb25zdHJ1Y3Rvcihtc2c6IHN0cmluZywgaW5uZXJFeGNlcHRpb246IGFueSA9IHVuZGVmaW5lZCkge1xuXHRcdHN1cGVyKG1zZyk7XG5cdFx0dGhpcy5pbm5lckV4Y2VwdGlvbiA9IGlubmVyRXhjZXB0aW9uO1xuXHR9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVE9OQ2xpZW50RmFjYWRlQ29uc3RydWN0b3Ige1xuXHRuZXcoKTogVE9OQ2xpZW50RmFjYWRlO1xufVxuXG5leHBvcnQgY2xhc3MgVE9OQ2xpZW50RmFjYWRlIHtcblx0cHJpdmF0ZSBfX3RvbkNsaWVudEluaXRpYWxpemVyOiBudWxsIHwgUHJvbWlzZTxVbmRlcmxheWluZ1RPTkNsaWVudD4gfCBVbmRlcmxheWluZ1RPTkNsaWVudDtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fX3RvbkNsaWVudEluaXRpYWxpemVyID0gbnVsbDtcblx0fVxuXG5cdGFzeW5jIGluaXQoKSB7XG5cdFx0aWYgKHRoaXMuX190b25DbGllbnRJbml0aWFsaXplciA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJUT04gQ2xpZW50IGluaXRpYWxpemluZy4uLlwiKTtcblx0XHRcdHRoaXMuX190b25DbGllbnRJbml0aWFsaXplciA9IFRPTkNsaWVudEZhY2FkZS5fY3JlYXRlVE9OQ2xpZW50KCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fdG9uQ2xpZW50SW5pdGlhbGl6ZXIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9fdG9uQ2xpZW50SW5pdGlhbGl6ZXJcblx0XHRcdFx0LnRoZW4odG9uQ2xpZW50ID0+IHtcblx0XHRcdFx0XHR0aGlzLl9fdG9uQ2xpZW50SW5pdGlhbGl6ZXIgPSB0b25DbGllbnQ7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJUT04gQ2xpZW50IHdhcyBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkuXCIpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBnZW5lcmF0ZU1uZW1vbmljUGhyYXNlU2VlZCh3b3Jkc0NvdW50OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdGNvbnN0IFNFRURfUEhSQVNFX0RJQ1RJT05BUllfRU5HTElTSDogbnVtYmVyID0gMTtcblx0XHRjb25zdCBzZWVkOiBzdHJpbmcgPSBhd2FpdCB0aGlzLl90b25DbGllbnQuY3J5cHRvLm1uZW1vbmljRnJvbVJhbmRvbSh7XG5cdFx0XHRkaWN0aW9uYXJ5OiBTRUVEX1BIUkFTRV9ESUNUSU9OQVJZX0VOR0xJU0gsXG5cdFx0XHR3b3JkQ291bnQ6IHdvcmRzQ291bnRcblx0XHR9KTtcblx0XHRyZXR1cm4gc2VlZDtcblx0fVxuXG5cdGFzeW5jIGRlcml2ZUtleVBhaXIoc2VlZE1uZW1vbmljUGhyYXNlOiBzdHJpbmcsIHdvcmRzQ291bnQ6IG51bWJlcikge1xuXHRcdGNvbnNvbGUuZXJyb3Ioc2VlZE1uZW1vbmljUGhyYXNlKTtcblx0XHRjb25zdCBTRUVEX1BIUkFTRV9ESUNUSU9OQVJZX0VOR0xJU0g6IG51bWJlciA9IDE7XG5cdFx0Y29uc3Qga2V5UGFpcjogS2V5UGFpciA9IGF3YWl0IHRoaXMuX3RvbkNsaWVudC5jcnlwdG8ubW5lbW9uaWNEZXJpdmVTaWduS2V5cyh7XG5cdFx0XHRkaWN0aW9uYXJ5OiBTRUVEX1BIUkFTRV9ESUNUSU9OQVJZX0VOR0xJU0gsXG5cdFx0XHR3b3JkQ291bnQ6IHdvcmRzQ291bnQsXG5cdFx0XHRwaHJhc2U6IHNlZWRNbmVtb25pY1BocmFzZSxcblx0XHRcdHBhdGg6IFwibS80NCcvMzk2Jy8wJy8wLzBcIlxuXHRcdH0pO1xuXHRcdHJldHVybiBrZXlQYWlyO1xuXHR9XG5cblx0YXN5bmMgZ2V0RGVwbG95RGF0YShcblx0XHRwdWJsaWNLZXk6IHN0cmluZyxcblx0XHRzbWFydENvbnRyYWN0QUJJOiBzdHJpbmcsXG5cdFx0c21hcnRDb250cmFjdFRWQ0Jhc2U2NDogc3RyaW5nXG5cdCk6IFByb21pc2U8c3RyaW5nPiB7XG5cblx0XHRjb25zdCBmcmllbmRseVNtYXJ0Q29udHJhY3RBQkk6IGFueSA9IEpTT04ucGFyc2Uoc21hcnRDb250cmFjdEFCSSk7XG5cblx0XHRjb25zdCBwYXJhbSA9IHtcblx0XHRcdGFiaTogZnJpZW5kbHlTbWFydENvbnRyYWN0QUJJLFxuXHRcdFx0aW1hZ2VCYXNlNjQ6IHNtYXJ0Q29udHJhY3RUVkNCYXNlNjQsXG5cdFx0XHRpbml0UGFyYW1zOiB7fSxcblx0XHRcdHB1YmxpY0tleUhleDogcHVibGljS2V5LFxuXHRcdFx0d29ya2NoYWluSWQ6IDAsXG5cdFx0fTtcblx0XHRjb25zdCByZXN1bHQ6IFRPTkNsaWVudC5EZXBsb3lEYXRhID0gYXdhaXQgdGhpcy5fdG9uQ2xpZW50LmNvbnRyYWN0cy5nZXREZXBsb3lEYXRhKHBhcmFtKTtcblx0XHRjb25zb2xlLmVycm9yKHJlc3VsdCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRyZXNzO1xuXHR9XG5cblx0Ly8gYXN5bmMgY2FsY0RlcGxveUZlZXMoa2V5OiBLZXlQYWlyKSB7XG5cdC8vIFx0aWYgKCEoXCJwdWJsaWNcIiBpbiBrZXkgJiYgdHlwZW9mIGtleS5wdWJsaWMgPT09IFwic3RyaW5nXCIpKSB7XG5cdC8vIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQdWJsaWMga2V5IGVycm9yXCIpO1xuXHQvLyBcdH1cblx0Ly8gXHRjb25zdCBwa2cgPSB7IGFiaTogU21hcnRDb250cmFjdC5hYmksIGltYWdlQmFzZTY0OiBTbWFydENvbnRyYWN0LmltYWdlIH07XG5cdC8vIFx0Y29uc3QgY29uc3RydWN0b3JQYXJhbXMgPSB7IG93bmVyczogW2AweCR7a2V5LnB1YmxpY31gXSwgcmVxQ29uZmlybXM6IDEgfTtcblx0Ly8gXHRjb25zdCBwYXJhbSA9IHtcblx0Ly8gXHRcdHBhY2thZ2U6IHBrZyxcblx0Ly8gXHRcdGNvbnN0cnVjdG9yUGFyYW1zLFxuXHQvLyBcdFx0aW5pdFBhcmFtczoge30sXG5cdC8vIFx0XHRrZXlQYWlyOiB7XG5cdC8vIFx0XHRcdFwicHVibGljXCI6IGtleS5wdWJsaWMsXG5cdC8vIFx0XHRcdFwic2VjcmV0XCI6IGtleS5zZWNyZXRcblx0Ly8gXHRcdH0sXG5cdC8vIFx0XHRlbXVsYXRlQmFsYW5jZTogdHJ1ZSxcblx0Ly8gXHRcdG5ld2FjY291bnQ6IHRydWVcblx0Ly8gXHR9O1xuXHQvLyBcdHJldHVybiBhd2FpdCB0aGlzLl90b25DbGllbnQuY29udHJhY3RzLmNhbGNEZXBsb3lGZWVzKHBhcmFtKTtcblx0Ly8gfVxuXG5cdC8vIGFzeW5jIGRlcGxveUNvbnRyYWN0KGtleTogS2V5UGFpcikge1xuXHQvLyBcdGNvbnN0IHBrZyA9IHsgYWJpOiBTbWFydENvbnRyYWN0LmFiaSwgaW1hZ2VCYXNlNjQ6IFNtYXJ0Q29udHJhY3QuaW1hZ2UgfTtcblx0Ly8gXHRjb25zdCBjb25zdHJ1Y3RvclBhcmFtcyA9IHsgb3duZXJzOiBbYDB4JHtrZXkucHVibGljfWBdLCByZXFDb25maXJtczogMSB9O1xuXHQvLyBcdGNvbnN0IHBhcmFtID0ge1xuXHQvLyBcdFx0cGFja2FnZTogcGtnLFxuXHQvLyBcdFx0Y29uc3RydWN0b3JQYXJhbXMsXG5cdC8vIFx0XHRpbml0UGFyYW1zOiB7fSxcblx0Ly8gXHRcdGtleVBhaXI6IHtcblx0Ly8gXHRcdFx0XCJwdWJsaWNcIjoga2V5LnB1YmxpYyxcblx0Ly8gXHRcdFx0XCJzZWNyZXRcIjoga2V5LnNlY3JldFxuXHQvLyBcdFx0fVxuXHQvLyBcdH07XG5cdC8vIFx0Y29uc3QgZGVwbG95TWVzc2FnZSA9IGF3YWl0IHRoaXMuX3RvbkNsaWVudC5jb250cmFjdHMuY3JlYXRlRGVwbG95TWVzc2FnZShwYXJhbSk7XG5cdC8vIFx0Y29uc3QgcHJvY2Vzc2luZ1N0YXRlID0gYXdhaXQgdGhpcy5fdG9uQ2xpZW50LmNvbnRyYWN0cy5zZW5kTWVzc2FnZShkZXBsb3lNZXNzYWdlLm1lc3NhZ2UpO1xuXHQvLyBcdHJldHVybiBcIjEyM1wiOy8vYXdhaXQgdGhpcy5fdG9uQ2xpZW50LmNvbnRyYWN0cy53YWl0Rm9yRGVwbG95VHJhbnNhY3Rpb24oZGVwbG95TWVzc2FnZSwgcHJvY2Vzc2luZ1N0YXRlKTtcblx0Ly8gfTtcblxuXHRhc3luYyBmZXRjaEFjY291bnRJbmZvcm1hdGlvbihhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPEFjY291bnRJbmZvIHwgbnVsbD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fdG9uQ2xpZW50LnF1ZXJpZXMuYWNjb3VudHNcblx0XHRcdFx0LnF1ZXJ5KHsgaWQ6IHsgaW46IGFkZHJlc3MgfSB9LCAnaWQsIGJhbGFuY2UoZm9ybWF0OiBERUMpLCBjb2RlX2hhc2gnKTtcblxuXHRcdFx0Y29uc29sZS5sb2coXCJmZXRjaEFjY291bnRJbmZvcm1hdGlvblwiLCBhZGRyZXNzLCBkYXRhKTtcblxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBiYWxhbmNlOiBzdHJpbmcgPSBkYXRhWzBdLmJhbGFuY2U7XG5cdFx0XHRjb25zdCBjb2RlX2hhc2g6IHN0cmluZyA9IGRhdGFbMF0uY29kZV9oYXNoO1xuXG5cdFx0XHRjb25zdCByZXN1bHQ6IEFjY291bnRJbmZvID0ge1xuXHRcdFx0XHRiYWxhbmNlLFxuXHRcdFx0XHRjb2RlSGFzaDogY29kZV9oYXNoXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fTtcblxuXHRnZXQgX3RvbkNsaWVudCgpIHtcblx0XHRpZiAodGhpcy5fX3RvbkNsaWVudEluaXRpYWxpemVyID09PSBudWxsIHx8IHRoaXMuX190b25DbGllbnRJbml0aWFsaXplciBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3BlcmF0aW9uLiBEaWQgeW91IGluaXQoKT8uXCIpXG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9fdG9uQ2xpZW50SW5pdGlhbGl6ZXI7XG5cdH1cblxuXHRzdGF0aWMgYXN5bmMgX2NyZWF0ZVRPTkNsaWVudCgpIHtcblx0XHRhd2FpdCBuZXcgUHJvbWlzZSgocmx2LCByZWopID0+IHNldFRpbWVvdXQocmx2LCAyNTApKTsgLy8gRmFrZSBpbml0IGRlcGxheVxuXHRcdHJldHVybiBhd2FpdCBUT05DbGllbnQuY3JlYXRlKHtcblx0XHRcdHNlcnZlcnM6IFsnbmV0LnRvbi5kZXYnXVxuXHRcdH0pO1xuXHR9XG59XG4vL3NldFdhc21PcHRpb25zKCk7XG5cbnR5cGUgVW5kZXJsYXlpbmdUT05DbGllbnQgPSBhbnk7XG5cbihmdW5jdGlvbiAoKSB7XG5cdGlmICh3aW5kb3cuVE9OQ2xpZW50RmFjYWRlID09PSB1bmRlZmluZWQpIHtcblx0XHR3aW5kb3cuVE9OQ2xpZW50RmFjYWRlID0gVE9OQ2xpZW50RmFjYWRlO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsdXJlLiBUT05DbGllbnRGYWNhZGUgYWxyZWFkeSBwcmVzZW50ZWQgb24gd2luZG93IG9iamVjdC5cIik7XG5cdH1cbn0pKCk7XG5cblxuLy8gLy8gQWRkaW5nIGFuIEhUTUwgdXBkYXRlIGZ1bmN0aW9uXG4vLyBzZXRXYXNtT3B0aW9ucyh7XG4vLyBcdGFkZEhUTUwsXG4vLyB9KTtcbi8vIGxldCBjcmVhdGVTdGFydCA9IERhdGUubm93KCk7XG4vLyAvLyBjcmVhdGluZyBhIFRPTkNsaWVudCB3aXQgYSBuZXQudG9uLmRldiBjb25uZWN0aW9uXG4vLyBjb25zdCBjbGllbnQgPSBhd2FpdCBUT05DbGllbnQuY3JlYXRlKHtcbi8vIFx0c2VydmVyczogWyduZXQudG9uLmRldiddXG4vLyB9KTtcbi8vIC8vIHJlcXVlc3RpbmcgVE9OQ2xpZW50IGNyZWF0aW9uIHRpbWUgc3RhbXBcbi8vIGFkZEhUTUwoYENsaWVudCBjcmVhdGlvbiB0aW1lOiAkeyhEYXRlLm5vdygpIC0gY3JlYXRlU3RhcnQpfWApO1xuLy8gLy8gZGlzcGxheWluZyB0aGUgY3VycmVudCBjbGllbnQgdmVyc2lvblxuLy8gYWRkSFRNTChgQ2xpZW50IHZlcnNpb246ICR7YXdhaXQgY2xpZW50LmNvbmZpZy5nZXRWZXJzaW9uKCl9YCk7XG4vLyBhZGRIVE1MKGBDbGllbnQgY29ubmVjdGVkIHRvOiAke2F3YWl0IGNsaWVudC5jb25maWcuZGF0YS5zZXJ2ZXJzfWApO1xuLy8gY29uc3QgcXVlcnlTdGFydCA9IERhdGUubm93KCk7XG4vLyAvLyByZXF1ZXN0aW5nIHRvcCAxMCBhY2NvdW50cyBzb3J0ZWQgYnkgYmFsYW5jZSBmcm9tIG5ldC50b24uZGV2L2dyYXBocWxcbi8vIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY2xpZW50LnF1ZXJpZXMuYWNjb3VudHMucXVlcnkoe30sICdpZCBiYWxhbmNlJywgW3sgcGF0aDogJ2JhbGFuY2UnLCBkaXJlY3Rpb246ICdERVNDJyB9XSwgMTApO1xuLy8gYWRkSFRNTChgUXVlcnkgdGltZTogJHsoRGF0ZS5ub3coKSAtIHF1ZXJ5U3RhcnQpfWApO1xuLy8gLy8gZGlzcGxheWluZyB0aGUgZGF0YVxuLy8gYWRkSFRNTChgPHRhYmxlPiR7YWNjb3VudHMubWFwKHggPT4gYDx0cj48dGQ+JHt4LmlkfTwvdGQ+PHRkPiR7QmlnSW50KHguYmFsYW5jZSl9PC90ZD48L3RyPmApLmpvaW4oJycpfTwvdGFibGU+YCk7XG4vLyAvLyBkaXNwbGF5aW5nIHRoZSBkYXRhIHJlY2VpdmVkIHRpbWUgc3RhbXBcbi8vIGFkZEhUTUwoYE5vdyBpczogJHtuZXcgRGF0ZSgpfWApO1xuXG4vLyBjb25zdCBTRUVEX1BIUkFTRV9XT1JEX0NPVU5UID0gMTI7XG4vLyBjb25zdCBTRUVEX1BIUkFTRV9ESUNUSU9OQVJZX0VOR0xJU0ggPSAxO1xuLy8gY29uc3QgcGhyYXNlID0gYXdhaXQgY2xpZW50LmNyeXB0by5tbmVtb25pY0Zyb21SYW5kb20oe1xuLy8gXHRkaWN0aW9uYXJ5OiBTRUVEX1BIUkFTRV9ESUNUSU9OQVJZX0VOR0xJU0gsXG4vLyBcdHdvcmRDb3VudDogU0VFRF9QSFJBU0VfV09SRF9DT1VOVFxuLy8gfSk7XG4vLyBhZGRIVE1MKGBNZW5tb25pYyBwaHJhc2U6ICR7cGhyYXNlfWApO1xuLy8gcmV0dXJuIHBocmFzZTsiXSwic291cmNlUm9vdCI6IiJ9